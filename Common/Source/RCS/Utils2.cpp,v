head	8.31;
access;
symbols
	beta8:8.1;
locks
	root:8.31; strict;
comment	@// @;


8.31
date	2010.12.13.00.55.29;	author root;	state Exp;
branches;
next	8.30;

8.30
date	2010.09.11.18.53.51;	author root;	state Exp;
branches;
next	8.29;

8.29
date	2010.02.16.01.21.34;	author root;	state Exp;
branches;
next	8.28;

8.28
date	2010.02.02.23.41.17;	author root;	state Exp;
branches;
next	8.27;

8.27
date	2009.11.27.01.11.59;	author root;	state Exp;
branches;
next	8.26;

8.26
date	2009.11.25.18.09.25;	author root;	state Exp;
branches;
next	8.25;

8.25
date	2009.11.09.00.17.12;	author root;	state Exp;
branches;
next	8.24;

8.24
date	2009.11.04.12.36.07;	author root;	state Exp;
branches;
next	8.23;

8.23
date	2009.11.01.19.54.50;	author root;	state Exp;
branches;
next	8.22;

8.22
date	2009.10.23.11.28.46;	author root;	state Exp;
branches;
next	8.21;

8.21
date	2009.10.19.16.28.21;	author root;	state Exp;
branches;
next	8.20;

8.20
date	2009.10.12.13.25.20;	author root;	state Exp;
branches;
next	8.19;

8.19
date	2009.10.01.15.06.06;	author root;	state Exp;
branches;
next	8.18;

8.18
date	2009.09.30.16.13.55;	author root;	state Exp;
branches;
next	8.17;

8.17
date	2009.09.20.20.29.00;	author root;	state Exp;
branches;
next	8.16;

8.16
date	2009.09.16.19.03.02;	author root;	state Exp;
branches;
next	8.15;

8.15
date	2009.09.16.10.57.50;	author root;	state Exp;
branches;
next	8.14;

8.14
date	2009.09.09.22.59.44;	author root;	state Exp;
branches;
next	8.13;

8.13
date	2009.09.07.19.08.30;	author root;	state Exp;
branches;
next	8.12;

8.12
date	2009.09.02.20.29.45;	author root;	state Exp;
branches;
next	8.11;

8.11
date	2009.07.30.13.38.15;	author root;	state Exp;
branches;
next	8.10;

8.10
date	2009.07.24.14.31.52;	author root;	state Exp;
branches;
next	8.9;

8.9
date	2009.07.24.10.00.00;	author root;	state Exp;
branches;
next	8.8;

8.8
date	2009.07.22.10.53.48;	author root;	state Exp;
branches;
next	8.7;

8.7
date	2009.07.17.15.26.15;	author root;	state Exp;
branches;
next	8.6;

8.6
date	2009.07.14.19.52.03;	author root;	state Exp;
branches;
next	8.5;

8.5
date	2009.07.11.12.23.47;	author root;	state Exp;
branches;
next	8.4;

8.4
date	2009.07.05.22.58.13;	author root;	state Exp;
branches;
next	8.3;

8.3
date	2009.07.01.22.25.49;	author root;	state Exp;
branches;
next	8.2;

8.2
date	2009.06.27.17.18.12;	author root;	state Exp;
branches;
next	8.1;

8.1
date	2009.06.19.20.28.25;	author venta;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.17.01.49.09;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.16.14.07.26;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.15.09.32.29;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.14.11.29.03;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.11.19.50.22;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.01.21.17.16;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.12.50.16;	author root;	state Exp;
branches;
next	;


desc
@funzionante
@

8.31
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: Utils2.cpp,v 8.30 2010/09/11 18:53:51 root Exp root $
*/

#include "StdAfx.h"
#include <stdio.h>
#ifndef __MINGW32__
#if defined(CECORE)
#include "winbase.h"
#endif
#if (WINDOWSPC<1)
#include "projects.h"
#endif
#endif
#include "options.h"
#include "externs.h"
#include "XCSoar.h"
#include "InfoBoxLayout.h"
#include "Utils2.h"
#include "Cpustats.h"
#include "device.h"
#include "Logger.h"
#include "Parser.h"
#include "WaveThread.h"
#include "GaugeFLARM.h"
#include "LKUtils.h"
#include "Message.h"
#include "McReady.h"
#include "InputEvents.h"
#include "MapWindow.h"

extern void NextMapSpace();
extern void PreviousMapSpace();
extern void ShowMenu();

void BottomSounds();

#define CURTYPE	ModeType[ModeIndex]
#define ISPARAGLIDER (AircraftCategory == (AircraftCategory_t)umParaglider)

bool InitLDRotary(ldrotary_s *buf) {
short i, bsize;
#ifdef DEBUG_ROTARY
char ventabuffer[200];
FILE *fp;
#endif

	switch (AverEffTime) {
		case ae15seconds:
			bsize=15;	// useless, LDinst already there
			break;
		case ae30seconds:
			bsize=30;	// limited useful
			break;
		case ae60seconds:
			bsize=60;	// starting to be valuable
			break;
		case ae90seconds:
			bsize=90;	// good interval
			break;
		case ae2minutes:
			bsize=120;	// other software's interval
			break;
		case ae3minutes:
			bsize=180;	// probably too long interval
			break;
		default:
			bsize=3; // make it evident 
			break;
	}
	//if (bsize <3 || bsize>MAXLDROTARYSIZE) return false;
	for (i=0; i<MAXLDROTARYSIZE; i++) {
		buf->distance[i]=0;
		buf->altitude[i]=0;
		#if EQMC
		buf->ias[i]=0;
		#endif
	}
	buf->totaldistance=0;
	#if EQMC
	buf->totalias=0;
	#endif
	buf->start=-1;
	buf->size=bsize;
	buf->valid=false;
#ifdef DEBUG_ROTARY
	sprintf(ventabuffer,"InitLdRotary size=%d\r\n",buf->size);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
                    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
  return false; 
}

void InsertLDRotary(ldrotary_s *buf, int distance, int altitude) {
static short errs=0;
#ifdef DEBUG_ROTARY
char ventabuffer[200];
FILE *fp;
#endif
	if (CALCULATED_INFO.OnGround == TRUE) {
#ifdef DEBUG_ROTARY
		sprintf(ventabuffer,"OnGround, ignore LDrotary\r\n");
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
			    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
		return;
	}
	
	if (CALCULATED_INFO.Circling == TRUE) {
#ifdef DEBUG_ROTARY
		sprintf(ventabuffer,"Circling, ignore LDrotary\r\n");
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
			    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
		return;
	}


	//CALCULATED_INFO.Odometer += distance;
	if (distance<3 || distance>150) { // just ignore, no need to reset rotary
		if (errs>2) {
#ifdef DEBUG_ROTARY
			sprintf(ventabuffer,"Rotary reset after exceeding errors\r\n");
			if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
				    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
			InitLDRotary(&rotaryLD);
			errs=0;
			return;

		}
		errs++;
#ifdef DEBUG_ROTARY
		sprintf(ventabuffer,"(errs=%d) IGNORE INVALID distance=%d altitude=%d\r\n",errs,distance,altitude);
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
			    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
		return;
	}
	errs=0;

	if (++buf->start >=buf->size) { 
#ifdef DEBUG_ROTARY
		sprintf(ventabuffer,"*** rotary reset and VALID=TRUE ++bufstart=%d >=bufsize=%d\r\n",buf->start, buf->size);
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
			    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
		buf->start=0;
		buf->valid=true; // flag for a full usable buffer 
	}
	// need to fill up buffer before starting to empty it
	if ( buf->valid == true) {
		buf->totaldistance-=buf->distance[buf->start];
		#if EQMC
		buf->totalias-=buf->ias[buf->start];
		#endif
	}
	buf->totaldistance+=distance;
	buf->distance[buf->start]=distance;
	#if EQMC
	// insert IAS in the rotary buffer, either real or estimated
	if (GPS_INFO.AirspeedAvailable) {
                buf->totalias += (int)GPS_INFO.IndicatedAirspeed;
                buf->ias[buf->start] = (int)GPS_INFO.IndicatedAirspeed;
	} else {
                buf->totalias += (int)CALCULATED_INFO.IndicatedAirspeedEstimated;
                buf->ias[buf->start] = (int)CALCULATED_INFO.IndicatedAirspeedEstimated;
	}
	#endif
	buf->altitude[buf->start]=altitude;
#ifdef DEBUG_ROTARY
	sprintf(ventabuffer,"insert buf[%d/%d], distance=%d totdist=%d\r\n",buf->start, buf->size-1, distance,buf->totaldistance);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
		    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
}

/*
 * returns 0 if invalid, 999 if too high
 * EqMc is negative when no value is available, because recalculated and buffer still not usable
 */
#if EQMC
double CalculateLDRotary(ldrotary_s *buf, DERIVED_INFO *Calculated ) {
#else
int CalculateLDRotary(ldrotary_s *buf ) {
#endif

	int altdiff;
	double eff;
	short bcold;
#ifdef DEBUG_ROTARY
	char ventabuffer[200];
	FILE *fp;
#endif
	#if EQMC
	double averias;
	double avertas;
	#endif

	if ( CALCULATED_INFO.Circling == TRUE || CALCULATED_INFO.OnGround == TRUE) {
#ifdef DEBUG_ROTARY
		sprintf(ventabuffer,"Not Calculating, on ground or circling\r\n");
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
			    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
		#if EQMC
		// StartupStore(_T("... Circling or grounded, EqMc -2 (---)\n"));
		Calculated->EqMc = -1;
		#endif
		return(0);
	}

	if ( buf->start <0) {
#ifdef DEBUG_ROTARY
		sprintf(ventabuffer,"Calculate: invalid buf start<0\r\n");
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
			    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif
		#if EQMC
		// StartupStore(_T("... Invalid buf start, EqMc -2 (---)\n"));
		Calculated->EqMc = -1;
		#endif
		return(0);
	}

	ldrotary_s bc;
  	memcpy(&bc, buf, sizeof(ldrotary_s));

	if (bc.valid == false ) {
		if (bc.start==0) {
			#if EQMC
			// StartupStore(_T("... bc.valid is false, EqMc -2 (---)\n"));
			Calculated->EqMc = -1;
			#endif
			return(0); // unavailable
		}
		bcold=0;
	} else {

		if (bc.start < (bc.size-1))
			bcold=bc.start+1;
		else
			bcold=0;
	}

	altdiff= bc.altitude[bcold] - bc.altitude[bc.start];

	#if EQMC
	// StartupStore(_T("... bcold=%d bcstart=%d  old-start=%d\n"), bcold, bc.start, bcold-bc.start); // REMOVE
	// if ( bc.valid == true ) {
	// bcsize<=0  should NOT happen, but we check it for safety
	if ( (bc.valid == true) && bc.size>0 ) {
		averias = bc.totalias/bc.size;
		// According to Welch & Irving, suggested by Dave..
		// MC = Vso*[ (V/Vo)^3 - (Vo/V)]
		// Vso: sink at best L/D
		// Vo : speed at best L/D
		// V  : TAS

		avertas=averias*AirDensityRatio(Calculated->NavAltitude);

		double dtmp= avertas/GlidePolar::Vbestld;

		Calculated->EqMc = -1*GlidePolar::sinkratecache[GlidePolar::Vbestld] * ( (dtmp*dtmp*dtmp) - ( GlidePolar::Vbestld/avertas));
		//StartupStore(_T(".. eMC=%.2f (=%.1f)  Averias=%f Avertas=%f kmh, sinktas=%.1f ms  sinkmc0=%.1f ms Vbestld=%.1f\n"),
		//Calculated->EqMc, Calculated->EqMc, averias*TOKPH, avertas*TOKPH,-1*GlidePolar::sinkratecache[(int)avertas], 
		//GlidePolar::sinkratecache[GlidePolar::Vbestld], GlidePolar::Vbestld*TOKPH);

	}
	#endif

	if (altdiff == 0 ) {
		return(INVALID_GR); // infinitum
	}
	eff= (double)bc.totaldistance / (double)altdiff;

#ifdef DEBUG_ROTARY
	sprintf(ventabuffer,"bcstart=%d bcold=%d altnew=%d altold=%d altdiff=%d totaldistance=%d eff=%d\r\n",
		bc.start, bcold,
		bc.altitude[bc.start], bc.altitude[bcold], altdiff, bc.totaldistance, eff);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
                    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
#endif

	if (eff>MAXEFFICIENCYSHOW) eff=INVALID_GR;

	return(eff);

}

#if 0
bool InitFilterBuffer(ifilter_s *buf, short bsize) {
short i;
	if (bsize <3 || bsize>RASIZE) return false;
	for (i=0; i<RASIZE; i++) buf->array[i]=0;
	buf->start=-1;
	buf->size=bsize;
	return true;
}

void InsertRotaryBuffer(ifilter_s *buf, int value) {
	if (++buf->start >=buf->size) { 
		buf->start=0;
	}
	buf->array[buf->start]=value;
}

int FilterFast(ifilter_s *buf, int minvalue, int maxvalue) {

  ifilter_s bc;
  memcpy(&bc, buf, sizeof(ifilter_s));

  short i,nc,iter;
  int s, *val;
  float aver=0.0, oldaver, low=minvalue, high=maxvalue, cutoff;

  for (iter=0; iter<MAXITERFILTER; iter++) {
 	 for (i=0, nc=0, s=0; i<bc.size; i++) {
		val=&bc.array[i];
		if (*val >=low && *val <=high) { s+=*val; nc++; }
	  }
	  if (nc==0) { aver=0.0; break; }
	  oldaver=aver; aver=((float)s/nc);
 	  //printf("Sum=%d count=%d Aver=%0.3f (old=%0.3f)\n",s,nc,aver,oldaver);
	  if (oldaver==aver) break;
	  cutoff=aver/50; // 2%
 	  low=aver-cutoff;
 	  high=aver+cutoff;
  }
  //printf("Found: aver=%d (%0.3f) after %d iterations\n",(int)aver, aver, iter);
  return ((int)aver);

}

int FilterRotary(ifilter_s *buf, int minvalue, int maxvalue) {

  ifilter_s bc;
  memcpy(&bc, buf, sizeof(ifilter_s));

  short i,curs,nc,iter;
  int s, val;
  float aver, low, high, cutoff;

  low  = minvalue;
  high = maxvalue;

  for (iter=0; iter<MAXITERFILTER; iter++) {
 	 for (i=0, nc=0, s=0,curs=bc.start; i<bc.size; i++) {

		val=bc.array[curs];
		if (val >=low && val <=high) {
			s+=val;
			nc++;
		}
		if (++curs >= bc.size ) curs=0;
	  }
	  if (nc==0) {
		aver=0.0;
		break;
	  }
	  aver=((float)s/nc);
 	  //printf("Sum=%d count=%d Aver=%0.3f\n",s,nc,aver);

	  cutoff=aver/50; // 2%
 	  low=aver-cutoff;
 	  high=aver+cutoff;
  }

  //printf("final: aver=%d\n",(int)aver);
  return ((int)aver);

}
#endif
/*
main(int argc, char *argv[])
{
  short i;
  ifilter_s buf;
  InitFilterBuffer(&buf,20);
  int values[20] = { 140,121,134,119,116,118,121,122,120,124,119,117,116,130,122,119,110,118,120,121 };
  for (i=0; i<20; i++) InsertRotaryBuffer(&buf, values[i]);
  FilterFast(&buf, 70,200 );
  buf.start=10; 
  for (i=0; i<20; i++) InsertRotaryBuffer(&buf, values[i]);
  FilterFast(&buf, 70,200 );
}
*/

/*
	Virtual Key Manager by Paolo Ventafridda

	Returns 0 if invalid virtual scan code, otherwise a valid transcoded keycode.

 */

// vkmode 0=normal 1=gesture up 2=gesture down
// however we consider a down as up, and viceversa
int ProcessVirtualKey(int X, int Y, long keytime, short vkmode) {

#define VKTIMELONG 1500
#if LKPMODE
#define DONTDRAWTHEMAP NewMap&&Look8000&&!MapWindow::EnablePan&&MapSpaceMode!=1
#else
#define DONTDRAWTHEMAP MapWindow::IsMapFullScreen()&&NewMap&&Look8000&&!MapWindow::EnablePan&&MapSpaceMode!=1
#endif

	#if 100228
	static int AIRCRAFTMENUSIZE=0;
	#else
	#define AIRCRAFTMENUSIZE	NIBLSCALE(28)
	#endif
	short yup, ydown;
	short sizeup;
	short i, j;
	short numpages=0;

	static short s_sizeright=0, s_xright=0, s_xleft=0;
	static short s_bottomY=0;
	static bool doinit=true;

	bool dontdrawthemap=(DONTDRAWTHEMAP);

	#ifdef DEBUG_PROCVK
	TCHAR buf[100];
	wsprintf(buf,_T("R=%d,%d,%d,%d, X=%d Y=%d kt=%ld"),MapWindow::MapRect.left, MapWindow::MapRect.top, 
	MapWindow::MapRect.right, MapWindow::MapRect.bottom,X,Y,keytime);
	DoStatusMessage(buf);
	#endif

	if (doinit) {

		// bottomline does not exist when infoboxes are painted, so we can make it static
		s_sizeright=MapWindow::MapRect.right-MapWindow::MapRect.left;

		// calculate left and right starting from center
		s_xleft=(s_sizeright/2)-(s_sizeright/6);
		s_xright=(s_sizeright/2)+(s_sizeright/6);

		// same for bottom navboxes: they do not exist in infobox mode
		s_bottomY=(MapWindow::MapRect.bottom-MapWindow::MapRect.top)-BottomSize-NIBLSCALE(2); // bugfix era 15, troppo 090731

		#if 100228
		#define _NOCOMPASSINCLUDE
		#include "./LKinclude_menusize.cpp"
		#endif

		doinit=false;
	}
	
	sizeup=MapWindow::MapRect.bottom-MapWindow::MapRect.top;
	// do not consider navboxes, they are processed separately
	// These are coordinates for up down center VKs
	if (NewMap&&DrawBottom&&MapWindow::IsMapFullScreen()) {
		yup=(short)((sizeup-BottomSize-TopSize)/2.7)+MapWindow::MapRect.top+TopSize;
		ydown=(short)(MapWindow::MapRect.bottom-BottomSize-((sizeup-BottomSize)/2.7));
	} else {
		yup=(short)(sizeup/2.7)+MapWindow::MapRect.top;
		ydown=(short)(MapWindow::MapRect.bottom-(sizeup/2.7));
	}
//	TCHAR buf[100];  VENTA REMOVE
//	wsprintf(buf,_T("sizeup=%d BottomSize=%d yup=%d ydown=%d"),
//		sizeup, BottomSize, yup, ydown);
//	DoStatusMessage(buf);

	#ifdef DEBUG_PROCVK
	TCHAR buf[100];
	#endif

	// Handle fullscreen 8000 mode 
	// sound clicks require some attention here
	if (NewMap &&  DrawBottom && !MapWindow::EnablePan && vkmode==LKGESTURE_NONE) { 
		//
		// CLICKS on NAVBOXES, any MapSpaceMode ok
		//
		if (Y>= s_bottomY ) { // TESTFIX 090930

			if ( UseMapLock ) {
				if (MapLock==false) {
					if (!MapWindow::EnablePan ) LockMap();
					MapWindow::RefreshMap();
					return 0;
				}
			}
			if ( X>s_xright ) {
				// standard configurable mode
				if (keytime >=CustomKeyTime) {
					// 2 is right key
					if (CustomKeyHandler(CKI_BOTTOMRIGHT)) return 0;
				}
				#ifdef DEBUG_PROCVK
				wsprintf(buf,_T("RIGHT in limit=%d"),sizeup-BottomSize-NIBLSCALE(20));
				DoStatusMessage(buf);
				#endif
				if (  (BottomMode+1) >BM_LAST ) {
					if ( DisplayMode == dmCircling)
						BottomMode=BM_TRM;
					else
						BottomMode=BM_FIRST;
					BottomSounds();
					MapWindow::RefreshMap();
					return 0;
				} else ++BottomMode;
				BottomSounds(); // 100402
/*
				#ifndef DISABLEAUDIO
			        if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
				#endif
*/
				MapWindow::RefreshMap();
				return 0;
			}
			if ( X<s_xleft ) { // following is ugly
				if (keytime >=CustomKeyTime) {
					// 1 is left key
					if (CustomKeyHandler(CKI_BOTTOMLEFT)) return 0;
				}

				#ifdef DEBUG_PROCVK
				wsprintf(buf,_T("LEFT in limit=%d"),sizeup-BottomSize-NIBLSCALE(20));
				DoStatusMessage(buf);
				#endif
				if ((BottomMode-1) == BM_TRM) {
					if (DisplayMode != dmCircling) BottomMode=BM_LAST;
					else {
						BottomMode=BM_TRM;
						/*
						#ifndef DISABLEAUDIO
                                        	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
						#endif
						*/
						BottomSounds();
						MapWindow::RefreshMap();
						return 0;
					}
				}
				else if ((BottomMode-1)<0) {
					BottomMode=BM_LAST;
				} else if ( ((BottomMode-1)==BM_FIRST)&& (DisplayMode!=dmCircling)) {
					/*
					#ifndef DISABLEAUDIO
                                       	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
					#endif
					*/
					BottomMode--;
					BottomSounds();
					MapWindow::RefreshMap();
					return 0;
				} else BottomMode--;
				BottomSounds(); // 100402
/*
				#ifndef DISABLEAUDIO
			        if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
				#endif
*/
				MapWindow::RefreshMap();
				return 0;
			}
			#ifdef DEBUG_PROCVK
			wsprintf(buf,_T("CENTER in limit=%d"),sizeup-BottomSize-NIBLSCALE(20));
			DoStatusMessage(buf);
			#endif

			//
			// VIRTUAL CENTER KEY HANDLING
			//
			// long press on center navbox currently used only for test purposes
#if (0)
			// Output NMEA to device
			if (keytime>1000) {
				#ifndef DISABLEAUDIO
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
				#endif
				devWriteNMEAString(devA(),_T("$PGRMCE"));
				Message::AddMessage(1000, 3, _T("NMEA out $PGRMCE"));
				return 0;
			}
#endif
#if (0)
			// Simulate incoming NMEA string
			if (keytime>1000) {
				static TCHAR mbuf[200];
				wsprintf(mbuf,_T("$VARIO,1010.18,0.0,0.00,2.34,2,000.0,000.0*51\n"));
				NMEAParser::ParseNMEAString(0, (TCHAR *) mbuf, &GPS_INFO);
				return 0;
			}
#endif
#if (0)	// TESTKEY
			#if (LK_CACHECALC && LK_CACHECALC_MCA_STAT)
			// Print a message on the screen for debugging purposes
			TCHAR mbuf[100];
			if (keytime>1000) {
				_stprintf(mbuf,_T("Cache MCA %d/%d F=%d"), 
				Cache_Hits_MCA, Cache_Calls_MCA, Cache_False_MCA );
				Message::Lock();
				Message::AddMessage(20000, 3, mbuf);
				Message::Unlock();
				return 0;
			}
			#endif
#endif

#if (0)
			if (keytime>=CustomKeyTime) {
				if (OvertargetMode==OVT_MAXMODE) OvertargetMode=0;
				else OvertargetMode++;
				#ifndef DISABLEAUDIO
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
				#endif
				return 0;
			}
#endif
			// REAL USAGE, ALWAYS ACTIVATE 
			#if (1)
			// standard configurable mode
			if (keytime >=CustomKeyTime) {
				// 0 is center key
				if (CustomKeyHandler(CKI_BOTTOMCENTER)) return 0;
			}
			#endif

			// normally, we fall down here.
			// If CustomKeyHandler returned false, back as well here (nothing configured in custom).
			NextModeIndex();
			MapWindow::RefreshMap();
			SoundModeIndex();

			return 0;
		// End click on navboxes 
		} else 
		// CLICK ON SORTBOX line at the top, only with no map and only for nearest
		if ( (MapSpaceMode == MSM_LANDABLE || MapSpaceMode==MSM_AIRPORTS || 
			MapSpaceMode==MSM_NEARTPS || MapSpaceMode==MSM_TRAFFIC) && Y<=SortBoxY ) {

			// only search for 1-3, otherwise it's the fourth (fifth really)
			// we don't use 0 now
			for (i=0, j=4; i<4; i++) { // i=1 original 090925 FIX
				if (X <SortBoxX[i]) {
					j=i;
					break;
				}
			}
			switch(MapSpaceMode) {
				case MSM_LANDABLE:
				case MSM_AIRPORTS:
							SortedMode[MapSpaceMode]=j;
							LKForceDoNearest=true;
							#ifndef DISABLEAUDIO
							if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
							#endif
							break;
				case MSM_NEARTPS:
							SortedMode[MapSpaceMode]=j;
							LKForceDoNearestTurnpoint=true;
							#ifndef DISABLEAUDIO
							if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
							#endif
							break;
				case MSM_TRAFFIC:
							SortedMode[MapSpaceMode]=j;
							// force immediate resorting
							LastDoTraffic=0;
							#ifndef DISABLEAUDIO
							if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
							#endif
							break;
				default:
							DoStatusMessage(_T("ERR-022 UNKNOWN MSM in VK"));
							break;
			}
			SelectedPage[MapSpaceMode]=0;
			SelectedRaw[MapSpaceMode]=0;
			MapWindow::RefreshMap();

			return 0;
		// end sortbox
		}  
	// end newmap  with no gestures
	}

	// REAL virtual keys
	// Emulate real keypresses with wParam

	// UP gesture
	if (vkmode>LKGESTURE_NONE) {
		// do not handle gestures outside mapspacemode
		if (!dontdrawthemap) {
			// DoStatusMessage(_T("DBG-033 gesture not used here"));
			return 0;
		}
		switch(MapSpaceMode) {
			case MSM_LANDABLE:
			case MSM_AIRPORTS:
						LKForceDoNearest=true;
						numpages=Numpages; // TODO adopt Numpages[MapSpaceMode]
						break;
			case MSM_COMMON:
						LKForceDoCommon=true;
						// warning. Commons and Recents share the same variable!
						numpages=CommonNumpages;
						break;
			case MSM_RECENT:
						LKForceDoRecent=true;
						numpages=CommonNumpages;
						break;
			case MSM_NEARTPS:
						LKForceDoNearestTurnpoint=true;
						numpages=TurnpointNumpages;
						break;
			case MSM_TRAFFIC:
						numpages=TrafficNumpages;
						break;
			default:
						break;
		}
		SelectedRaw[MapSpaceMode]=0;

		switch(vkmode) {
			// SCROLL DOWN
			case LKGESTURE_DOWN:
				// careful, selectedpage starts from 0
				if (++SelectedPage[MapSpaceMode] >=numpages) {
					#ifndef DISABLEAUDIO
					if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
					#endif
					SelectedPage[MapSpaceMode]=0;
				} else {
					#ifndef DISABLEAUDIO
					if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
					#endif
				}
				LKevent=LKEVENT_NEWPAGE;
				MapWindow::RefreshMap();
				return 0;
			// SCROLL UP
			case LKGESTURE_UP:
				if (--SelectedPage[MapSpaceMode] <0) {
					#ifndef DISABLEAUDIO
					if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
					#endif
					SelectedPage[MapSpaceMode]=(numpages-1);
				} else {
					if (SelectedPage[MapSpaceMode]==0) {
						#ifndef DISABLEAUDIO
						if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
						#endif
					} else {
						#ifndef DISABLEAUDIO
						if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
						#endif
					}
				}
				LKevent=LKEVENT_NEWPAGE;
				MapWindow::RefreshMap();
				return 0;
			case LKGESTURE_RIGHT:
				NextModeType();
				MapWindow::RefreshMap();
				#ifndef DISABLEAUDIO
				if (EnableSoundModes) {
					if (CURTYPE == 0)
						PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
					else
						PlayResource(TEXT("IDR_WAV_CLICK"));
				}
				#endif
				return 0;

				break;

			case LKGESTURE_LEFT:
				PreviousModeType();
				MapWindow::RefreshMap();
				#ifndef DISABLEAUDIO
				if (EnableSoundModes) {
					if (CURTYPE == 0)
						PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
					else
						PlayResource(TEXT("IDR_WAV_CLICK"));
				}
				#endif
				return 0;

				break;
			default:
				return 0;
		}

		return 0;
	}

	if (Y<yup) {
		// we are processing up/down in mapspacemode i.e. browsing waypoints on the page
		if (dontdrawthemap) {
			if (MapSpaceMode<=MSM_MAP) {
				// DoStatusMessage(_T("DBG-032-A event up not used here"));
				return 0;
			}
			#ifndef DISABLEAUDIO
	        	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
			//if (--SelectedRaw[MapSpaceMode] <0) SelectedRaw[MapSpaceMode]=Numraws-1;
			LKevent=LKEVENT_UP;
			MapWindow::RefreshMap();
			// DoStatusMessage(_T("DBG-032-B event up used here"));
			return 0;
		}
		#ifndef DISABLEAUDIO
	        if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		if (keytime>=VKTIMELONG)
			return 0xc1;
		else
			return 38;
	}
	if (Y>ydown) {
		if (dontdrawthemap) {
			if (MapSpaceMode<=MSM_MAP) return 0;
			#ifndef DISABLEAUDIO
	        	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
			//if (++SelectedRaw[MapSpaceMode] >=Numraws) SelectedRaw[MapSpaceMode]=0;
			LKevent=LKEVENT_DOWN;
			MapWindow::RefreshMap();
			return 0;
		}
		#ifndef DISABLEAUDIO
	        if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		if (keytime>=VKTIMELONG)
			return 0xc2;
		else
			return 40;
	}
	// no click for already clicked events

	//  Swap white and black colours on LK8000 
	if (keytime>=VKTIMELONG && !dontdrawthemap) {
		if (NewMap&&Look8000) {
			static short oldOutline=OutlinedTp;
			if (OutlinedTp>(OutlinedTp_t)otDisabled) OutlinedTp=(OutlinedTp_t)otDisabled;
			else
				OutlinedTp=oldOutline;
			// TODO CHECK EXPERIMENTAL
			Appearance.InverseInfoBox = !Appearance.InverseInfoBox;
			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
			MapWindow::RefreshMap();
		}
		return 0;

		// return 27; virtual ESC 
	} else {
		// If in mapspacemode process ENTER 
		if ( (keytime>=(VKSHORTCLICK*2)) && dontdrawthemap) {
			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_BELL"));
			#endif
			LKevent=LKEVENT_ENTER;
			MapWindow::RefreshMap();
			return 0;
		}
		// do not process enter in panmode, unused
/*
		if ( !MapWindow::EnablePan ) {
	             DoStatusMessage(_T("Virtual ENTER")); 
		     return 13;
		}
*/

#if NOSIM
		if (SIMMODE) {
			if ( MapWindow::EnablePan  && ISPARAGLIDER) return 99; // 091221 return impossible value
			else return 0;
		} else {
			return 0;
		}
#else
#if _SIM_
		if ( MapWindow::EnablePan  && ISPARAGLIDER) return 99; // 091221 return impossible value
			else return 0;
#else
		// if we want to emulate a return key, return 13;
		return 0;
#endif
#endif
	}
	DoStatusMessage(_T("VirtualKey Error")); 
	return 0;
}

void InitNewMap()
{

  StartupStore(_T(". InitNewMap%s"),NEWLINE); // 091213

  LOGFONT logfontTarget;	// StatisticsWindow
  LOGFONT logfontBig;		// InfoWindow
  LOGFONT logfontTitle;		// MapWindow
  LOGFONT logfontTitleNavbox;
  LOGFONT logfontMap;		// MapWindow compatible, safe to user changed with edit fonts
  LOGFONT logfontValue;		// StatisticsWindow
  LOGFONT logfontUnit;		// TitleSmallWindow
  LOGFONT logfontSmall;
  LOGFONT logfontMedium;
  LOGFONT logfontSymbol;
  LOGFONT logfontInfoBig;
  LOGFONT logfontInfoBigItalic;
  LOGFONT logfontInfoNormal;
  LOGFONT logfontInfoSmall;
  LOGFONT logfontPanelBig;
  LOGFONT logfontPanelMedium;
  LOGFONT logfontPanelSmall;
  LOGFONT logfontPanelUnit;


  memset ((char *)&logfontTarget, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontBig, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontTitle, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontTitleNavbox, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontMap, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontValue, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontUnit, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontSmall, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontMedium, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontSymbol, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontInfoBig, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontInfoBigItalic, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontInfoNormal, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontInfoSmall, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontPanelBig, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontPanelMedium, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontPanelSmall, 0, sizeof (LOGFONT) );
  memset ((char *)&logfontPanelUnit, 0, sizeof (LOGFONT) );


  // ALL THESE VALUES HAVE BEEN TESTED ONE BY ONE AGAINST EACH DEVICE RESOLUTION
  // AND IT WAS A LONG WORK, SO DO NOT CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING
  // > ALSO UNUSED SPLITTER VALUES ARE FINE TUNED!
 
  switch (ScreenSize) { 

	// Landscape

	// remember: changing values here may need cosmetic changes in InfoBoxLayout where
	// BottomSize is set manually... *UPDATE> apparently no more since december 09
	case (ScreenSize_t)ss800x480:		// PASSED DEV-1 090701 VENTA
		splitter=6;
		propGetFontSettingsFromString(TEXT("72,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);	// 64 600
		propGetFontSettingsFromString(TEXT("48,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("41,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);	// 40 600
		propGetFontSettingsFromString(TEXT("18,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);

	 	propGetFontSettingsFromString(TEXT("36,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
	 	propGetFontSettingsFromString(TEXT("34,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
	 	propGetFontSettingsFromString(TEXT("32,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap); // was 36
		// propGetFontSettingsFromString(TEXT("50,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);	// 46 600
		propGetFontSettingsFromString(TEXT("54,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget); // 100914
		propGetFontSettingsFromString(TEXT("48,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("18,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);

		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); 
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); 
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); 
		propGetFontSettingsFromString(TEXT("30,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);

		propGetFontSettingsFromString(TEXT("64,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  
		propGetFontSettingsFromString(TEXT("48,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium); 
		propGetFontSettingsFromString(TEXT("32,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); 
		propGetFontSettingsFromString(TEXT("22,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		BottomSize=80; // Title+Value-4
		break;
	case (ScreenSize_t)ss400x240:		// 091204
		splitter=6;
		propGetFontSettingsFromString(TEXT("36,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);	// 64 600
		propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("21,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);	// 40 600
		propGetFontSettingsFromString(TEXT("9,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);

	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
	 	propGetFontSettingsFromString(TEXT("17,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
	 	propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap); // was 36
		propGetFontSettingsFromString(TEXT("25,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);	// 46 600
		propGetFontSettingsFromString(TEXT("24,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("9,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);

		propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); 
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); 
		propGetFontSettingsFromString(TEXT("17,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); 
		propGetFontSettingsFromString(TEXT("15,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);

		propGetFontSettingsFromString(TEXT("32,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  
		propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium); 
		propGetFontSettingsFromString(TEXT("16,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); 
		propGetFontSettingsFromString(TEXT("11,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		BottomSize=40; // Title+Value-4
		break;
	case (ScreenSize_t)ss480x272:		// PASSED SIM-1 090701 VENTA
		splitter=5;
		#if (WINDOWSPC>0)
		// propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		propGetFontSettingsFromString(TEXT("48,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		// propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig); changed 100910
		propGetFontSettingsFromString(TEXT("48,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#endif
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("26,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		#if 0
		if (splitter==6) {
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("24,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=36; // Title+Value-4
		} else {
		#endif
			propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			// propGetFontSettingsFromString(TEXT("30,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget); 100914
			propGetFontSettingsFromString(TEXT("32,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("30,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("14,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=48; // Title+Value-4 plus something more
		// }
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); 
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); 
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("38,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig); 
		#else
		// propGetFontSettingsFromString(TEXT("38,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig); changed 100910
		propGetFontSettingsFromString(TEXT("38,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig); 
		#endif
		propGetFontSettingsFromString(TEXT("26,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("14,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		break;
	case (ScreenSize_t)ss720x408:
		splitter=5;
		propGetFontSettingsFromString(TEXT("72,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		propGetFontSettingsFromString(TEXT("33,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("39,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("15,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		propGetFontSettingsFromString(TEXT("30,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
		propGetFontSettingsFromString(TEXT("30,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
		propGetFontSettingsFromString(TEXT("30,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
		propGetFontSettingsFromString(TEXT("48,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
		propGetFontSettingsFromString(TEXT("45,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("21,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
		BottomSize=72; // Title+Value-4 plus something more

		propGetFontSettingsFromString(TEXT("42,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); 
		propGetFontSettingsFromString(TEXT("42,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); 
		propGetFontSettingsFromString(TEXT("33,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		propGetFontSettingsFromString(TEXT("57,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig); 
		propGetFontSettingsFromString(TEXT("39,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("27,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("21,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		break;
	case (ScreenSize_t)ss480x234:		// PASSED SIM-1 090701 VENTA
		splitter=5;
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("38,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		propGetFontSettingsFromString(TEXT("38,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		#endif
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("24,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		#if 0
		if (splitter==6) {
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=36; // Title+Value-4
		} else {
		#endif
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("28,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("26,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=41; // Title+Value-4
		// }
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig);
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("34,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);
		#else
		propGetFontSettingsFromString(TEXT("34,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig);
		#endif
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("16,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		break;

	// Units are too big, tahoma is not enough. Units are disabled by default.
	// This is also used by 640x480 devices actually, if SE_VGA is not disabled

	case (ScreenSize_t)ss320x240:		// PASSED DEV-1 090701 VENTA
		splitter=5;
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("32,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		propGetFontSettingsFromString(TEXT("34,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#endif
		propGetFontSettingsFromString(TEXT("16,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("16,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("8,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		#if 0
		if (splitter==6) {
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("20,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("16,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("8,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=24; // Title+Value-4

		} else {
		#endif
			propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("24,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("22,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("8,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=38; // 100914
		//}
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig);
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		break;

	case (ScreenSize_t)ss640x480:		// PASSED DEV-1 090701 VENTA
		splitter=5;
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("64,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		propGetFontSettingsFromString(TEXT("64,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		#endif
		propGetFontSettingsFromString(TEXT("32,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("32,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("14,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		#if 0
		if (splitter==6) {
			propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("46,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("32,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue); 
			propGetFontSettingsFromString(TEXT("16,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=56; // Title+Value-4

		} else {		
		#endif
			propGetFontSettingsFromString(TEXT("32,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("32,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("32,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("46,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("44,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("16,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=72; // Title+Value-4
		// }
		propGetFontSettingsFromString(TEXT("38,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig);
		propGetFontSettingsFromString(TEXT("38,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("22,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		propGetFontSettingsFromString(TEXT("56,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);
		propGetFontSettingsFromString(TEXT("44,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("28,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("20,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		break;

	case (ScreenSize_t)ss896x672:		//  091204
		splitter=6;
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("89,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		propGetFontSettingsFromString(TEXT("89,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		#endif
		propGetFontSettingsFromString(TEXT("45,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("44,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("20,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		if (splitter==6) {
			propGetFontSettingsFromString(TEXT("38,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("38,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("38,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("62,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("44,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue); 
			propGetFontSettingsFromString(TEXT("22,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=78; // Title+Value-4

		} 
		#if 0
		else {		
			propGetFontSettingsFromString(TEXT("44,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("44,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("44,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("64,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("61,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("22,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=100; // Title+Value-4
		}
		#endif
		propGetFontSettingsFromString(TEXT("53,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig);
		propGetFontSettingsFromString(TEXT("53,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("47,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("30,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		propGetFontSettingsFromString(TEXT("78,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);
		propGetFontSettingsFromString(TEXT("61,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("39,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("28,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		break;

	///////////////       Portrait  mode        ////////////////

	case (ScreenSize_t)ss240x320:		// PASSED DEV-1 090701  DEV-2 101005
		#if NEWPNAV
		splitter=3;
		#else
		splitter=5;
		#endif
			#if (WINDOWSPC>0)
			propGetFontSettingsFromString(TEXT("30,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig); // 29 600 101005
			#else
			propGetFontSettingsFromString(TEXT("30,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
			#endif
			propGetFontSettingsFromString(TEXT("11,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
			propGetFontSettingsFromString(TEXT("16,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
			propGetFontSettingsFromString(TEXT("6,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);

		if (splitter==3) {
			// Splitter = 3 on two rows
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("22,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("23,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("9,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=68; 
		}
		#if 0
		if (splitter==6) {
			propGetFontSettingsFromString(TEXT("9,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("9,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("9,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("11,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("6,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=20; // Title+Value-4  a bit bigger here
		}
		#endif
		if (splitter==5) {
			// very small, only a sample of what can be seen under landscape mode
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("22,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("17,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("6,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=27; // Title+Value-4  a bit bigger here
		} 
		#if 0
		else {
			// Splitter 4
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("22,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			#if (WINDOWSPC>0)
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			#else
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), &logfontValue);
			#endif
			propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=40; // Title+Value-4  a bit bigger here
		}
		#endif
		propGetFontSettingsFromString(TEXT("17,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig);
		propGetFontSettingsFromString(TEXT("17,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("15,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("22,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig); // 24 101005
		#else
		propGetFontSettingsFromString(TEXT("22,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig);
		#endif
		propGetFontSettingsFromString(TEXT("17,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("8,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit);  // 10 101005
		break;

	case (ScreenSize_t)ss272x480:
		#if NEWPNAV
		splitter=3;
		propGetFontSettingsFromString(TEXT("36,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		splitter=5;
		propGetFontSettingsFromString(TEXT("34,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#endif
			propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
			propGetFontSettingsFromString(TEXT("20,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
			propGetFontSettingsFromString(TEXT("8,0,0,0,200,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		if (splitter==3) {
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("28,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("26,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontValue);
			propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=80; // Title+Value-4  a bit bigger here
		}
		if (splitter==5) {
			// very small, only a sample of what can be seen under landscape mode
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("26,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("8,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=40; // Title+Value-4  a bit bigger here
		} 
		#if 0
		else {
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("26,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontValue);
			propGetFontSettingsFromString(TEXT("8,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=50; // Title+Value-4  a bit bigger here
		}
		#endif
		propGetFontSettingsFromString(TEXT("18,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig);
		propGetFontSettingsFromString(TEXT("18,0,0,0,600,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("18,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		propGetFontSettingsFromString(TEXT("28,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);
		propGetFontSettingsFromString(TEXT("18,0,0,0,200,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("14,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		break;
// BigFont      LK8000 welcome
// FontMedium   Tactical Flight Computer welcome
// InfoNormal:  Dist Eff ReqE top line

	case (ScreenSize_t)ss480x640:		// PASSED DEV-1 090701 VENTA
		#if NEWPNAV
		splitter=3;
		#else
		splitter=5;
		#endif
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("60,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		propGetFontSettingsFromString(TEXT("60,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		#endif
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("32,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);

		if (splitter==3) { 
			/* ----------------------------
			// Splitter = 6 , all-in-a-line  unused being too small,  otherwise ok
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("44,2,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=44; // Title+Value-4 a bit bigger here
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("40,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=75; // Title+Value-4  a bit bigger here
			   ----------------------------- */
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("46,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget); // 44 101005
			propGetFontSettingsFromString(TEXT("46,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("18,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=135; 
		} else {	
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget); // 600
			propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=62; // Title+Value-4 a bit bigger here
		}
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); 
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("30,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // 101004: 49 800
		#else
		propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig); 
		#endif
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("16,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit);  // 101004 18
		break;

	case (ScreenSize_t)ss480x800:		// 100410
		#if NEWPNAV
		splitter=3;
		#else
		splitter=5;
		#endif
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("62,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		propGetFontSettingsFromString(TEXT("62,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		#endif
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontSymbol);
		propGetFontSettingsFromString(TEXT("32,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);

		if (splitter==3) {
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("46,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("46,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("18,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=135; 
		}
		#if 0
		if (splitter==6) { // unused
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("44,2,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=44; // Title+Value-4 a bit bigger here

		}
		else {		
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
			propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
			propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget); // 600
			propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=62; // Title+Value-4 a bit bigger here
		}
		#endif
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); 
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("30,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("48,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // 101004 49 800
		#else
		propGetFontSettingsFromString(TEXT("48,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig); 
		#endif
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("20,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		break;
	// Default assumes a portrait 240x320 so all text will fit and users will report too small

	default:
		splitter=5;
	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMap);
	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitleNavbox);
		propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
		#if (WINDOWSPC>0)
		propGetFontSettingsFromString(TEXT("28,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
		#else
		propGetFontSettingsFromString(TEXT("28,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		#endif
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("16,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
		propGetFontSettingsFromString(TEXT("11,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("6,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig);
		propGetFontSettingsFromString(TEXT("12,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic);
		propGetFontSettingsFromString(TEXT("9,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal);
		propGetFontSettingsFromString(TEXT("8,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
		propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
		BottomSize=38; // Title+Value-4
		break;
  }

  logfontTarget.lfQuality = ANTIALIASED_QUALITY; 
  logfontBig.lfQuality = ANTIALIASED_QUALITY; 
  logfontValue.lfQuality = ANTIALIASED_QUALITY; 
  logfontTitle.lfQuality = ANTIALIASED_QUALITY; 
  logfontMap.lfQuality = ANTIALIASED_QUALITY; 
  logfontTitleNavbox.lfQuality = ANTIALIASED_QUALITY; 
  logfontUnit.lfQuality = ANTIALIASED_QUALITY; 
  logfontMedium.lfQuality = ANTIALIASED_QUALITY; 
  logfontSmall.lfQuality = ANTIALIASED_QUALITY; 
  logfontInfoBig.lfQuality = ANTIALIASED_QUALITY; 
  logfontInfoBigItalic.lfQuality = ANTIALIASED_QUALITY; 
  logfontInfoNormal.lfQuality = ANTIALIASED_QUALITY; 
  logfontInfoSmall.lfQuality = ANTIALIASED_QUALITY; 
  logfontSymbol.lfQuality = ANTIALIASED_QUALITY; 
  logfontSymbol.lfCharSet = SYMBOL_CHARSET; // careful
  logfontPanelBig.lfQuality= ANTIALIASED_QUALITY;
  logfontPanelMedium.lfQuality= ANTIALIASED_QUALITY;
  logfontPanelSmall.lfQuality= ANTIALIASED_QUALITY;
  logfontPanelUnit.lfQuality= ANTIALIASED_QUALITY;

  LK8TargetFont	= CreateFontIndirect (&logfontTarget); 
  LK8BigFont	= CreateFontIndirect (&logfontBig);
  LK8ValueFont	= CreateFontIndirect (&logfontValue);
  LK8TitleFont	= CreateFontIndirect (&logfontTitle);
  LK8MapFont	= CreateFontIndirect (&logfontMap);
  LK8TitleNavboxFont	= CreateFontIndirect (&logfontTitleNavbox);
  LK8UnitFont	= CreateFontIndirect (&logfontUnit);
  LK8SymbolFont	= CreateFontIndirect (&logfontSymbol);
  LK8MediumFont	= CreateFontIndirect (&logfontMedium);
  LK8SmallFont	= CreateFontIndirect (&logfontSmall);
  LK8InfoBigFont	= CreateFontIndirect (&logfontInfoBig);
  LK8InfoBigItalicFont	= CreateFontIndirect (&logfontInfoBigItalic);
  LK8InfoNormalFont	= CreateFontIndirect (&logfontInfoNormal);
  LK8InfoSmallFont	= CreateFontIndirect (&logfontInfoSmall);
  LK8PanelBigFont	= CreateFontIndirect (&logfontPanelBig);
  LK8PanelMediumFont	= CreateFontIndirect (&logfontPanelMedium);
  LK8PanelSmallFont	= CreateFontIndirect (&logfontPanelSmall);
  LK8PanelUnitFont	= CreateFontIndirect (&logfontPanelUnit);

/* Old try
  LONG mastersize=800/22; // should be equivalent to PNA best MapWindowFont 36
   _tcscpy(logfontTarget.lfFaceName, _T("Tahoma"));
  logfontTarget.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE  ;
  logfontTarget.lfCharSet = ANSI_CHARSET;
  logfontTarget.lfQuality = ANTIALIASED_QUALITY; 
  logfontTarget.lfHeight = int (ceil(mastersize*1.33)); // eq Statistics 48
  logfontTarget.lfWidth =  0;
  logfontTarget.lfWeight = FW_NORMAL;
  logfontTarget.lfItalic = FALSE;
  LK8TargetFont = CreateFontIndirect (&logfontTarget); 
  BottomSize= int (ceil(mastersize*1.77 + mastersize));
*/


}


void InitScreenSize() {

#if (WINDOWSPC>0)
  int iWidth=SCREENWIDTH;
  int iHeight=SCREENHEIGHT;
#else
  int iWidth=GetSystemMetrics(SM_CXSCREEN);
  int iHeight=GetSystemMetrics(SM_CYSCREEN);
#endif

  ScreenSizeX=iWidth;
  ScreenSizeY=iHeight;
  ScreenSizeR.top=0;
  ScreenSizeR.bottom=iHeight-1;
  ScreenSizeR.left=0;
  ScreenSizeR.right=iWidth-1;

  ScreenSize=0;

  if (iWidth == 240 && iHeight == 320) ScreenSize=(ScreenSize_t)ss240x320; // QVGA      portrait
  if (iWidth == 272 && iHeight == 480) ScreenSize=(ScreenSize_t)ss272x480;
  if (iWidth == 480 && iHeight == 640) ScreenSize=(ScreenSize_t)ss480x640; //  VGA
  if (iWidth == 640 && iHeight == 480) ScreenSize=(ScreenSize_t)ss640x480; //   VGA
  if (iWidth == 320 && iHeight == 240) ScreenSize=(ScreenSize_t)ss320x240; //  QVGA
  if (iWidth == 720 && iHeight == 408) ScreenSize=(ScreenSize_t)ss720x408;
  if (iWidth == 480 && iHeight == 800) ScreenSize=(ScreenSize_t)ss480x800;
  if (iWidth == 400 && iHeight == 240) ScreenSize=(ScreenSize_t)ss400x240; // landscape
  if (iWidth == 480 && iHeight == 272) ScreenSize=(ScreenSize_t)ss480x272; // WQVGA     landscape
  if (iWidth == 480 && iHeight == 234) ScreenSize=(ScreenSize_t)ss480x234; //   iGo
  if (iWidth == 800 && iHeight == 480) ScreenSize=(ScreenSize_t)ss800x480; //  WVGA
  if (iWidth == 896 && iHeight == 672) ScreenSize=(ScreenSize_t)ss896x672; //  PC version only

  TCHAR tbuf[80];
  if (ScreenSize==0) {
        wsprintf(tbuf,_T(". InitScreenSize: ++++++ ERROR UNKNOWN RESOLUTION %dx%d !%s"),iWidth,iHeight,NEWLINE); // 091119
        StartupStore(tbuf);
  } else {
        wsprintf(tbuf,_T(". InitScreenSize: %dx%d%s"),iWidth,iHeight,NEWLINE); // 091213
        StartupStore(tbuf);
  }

  if (ScreenSize > (ScreenSize_t)sslandscape) 
	ScreenLandscape=true;
  else
	ScreenLandscape=false;

}

void InitAircraftCategory()
{

 switch (AircraftCategory) {

	case (AircraftCategory_t)umGlider:
	case (AircraftCategory_t)umGAaircraft:
	case (AircraftCategory_t)umCar:

		MapWindow::RequestMapScale = 5; 
		MapWindow::MapScale = 5;
		MapWindow::MapScaleOverDistanceModify = 5/DISTANCEMODIFY;
		break;

	case (AircraftCategory_t)umParaglider:
		TCHAR buf[100];
		wsprintf(buf,_T(". PGCruiseZoom set to %d%s"),PGCruiseZoom,NEWLINE); // 091119
		StartupStore(buf);
		switch(PGCruiseZoom) { // 091108
			case 0:
				MapWindow::RequestMapScale = 0.10;  // 088
				MapWindow::MapScale = 0.10;
				break;
			case 1:
				MapWindow::RequestMapScale = 0.12;  // 117
				MapWindow::MapScale = 0.12;
				break;
			case 2:
				MapWindow::RequestMapScale = 0.14;  // 205
				MapWindow::MapScale = 0.14;
				break;
			case 3:
				MapWindow::RequestMapScale = 0.16;  // 293
				MapWindow::MapScale = 0.16;
				break;
			case 4:
				MapWindow::RequestMapScale = 0.18; 
				MapWindow::MapScale = 0.18;
				break;
			case 5:
				MapWindow::RequestMapScale = 0.20; 
				MapWindow::MapScale = 0.20;
				break;
			case 6:
				MapWindow::RequestMapScale = 0.23; 
				MapWindow::MapScale = 0.23;
				break;
			case 7:
				MapWindow::RequestMapScale = 0.25; 
				MapWindow::MapScale = 0.25;
				break;
			case 8:
			default:
				MapWindow::RequestMapScale = 0.3; 
				MapWindow::MapScale = 0.3;
				break;
		}
		MapWindow::MapScaleOverDistanceModify = MapWindow::RequestMapScale/DISTANCEMODIFY;
				
		break;

	default:
		// make it an evident problem
		MapWindow::RequestMapScale = 50;
		MapWindow::MapScale = 50;
		MapWindow::MapScaleOverDistanceModify = 50/DISTANCEMODIFY;
		break;
 }


}

// Requires restart if activated from config menu
void InitLK8000() 
{
	StartupStore(_T(". Init LK8000%s"),NEWLINE);
	LoadRecentList();

	InitModeTable();
	if ( AircraftCategory != (AircraftCategory_t)umParaglider ) {
		// Normal alternates forced on for LK8000. In MapWindow3 if not valid they WERE reset off
		// Currently in lk8000 they should be all the times on, calculation time is irrelevant
		OnAlternate1=true;
		OnAlternate2=true;
		OnBestAlternate=true;
	}

	// By default, h=v=size/6 and here we set it better
	switch (ScreenSize) { 
		case (ScreenSize_t)ss800x480:
			GestureSize=50;
			LKVarioSize=50;
			// dscale=480/240=2  800/dscale=400 -(70+2+2)=  326 x dscale = 652
			LKwdlgConfig=652;
			break;
		case (ScreenSize_t)ss400x240:
			GestureSize=50;
			LKVarioSize=25;
			// dscale=240/240=1  400/dscale=400 -(70+2+2)=  326 x dscale = 326
			LKwdlgConfig=326;
			break;
		case (ScreenSize_t)ss640x480:
			GestureSize=50;
			LKVarioSize=40;
			// dscale=480/240=2  640/dscale=320 -(70+2+2)=  246 x dscale = 492
			LKwdlgConfig=492;
			break;
		case (ScreenSize_t)ss896x672:
			GestureSize=50;
			LKVarioSize=56;
			// dscale=672/240=2.8  896/dscale=320 -(70+2+2)=  246 x dscale = 689
			LKwdlgConfig=689;
			break;
		case (ScreenSize_t)ss480x272:
			GestureSize=50;
			LKVarioSize=30;
			// dscale=272/240=1.133  480/dscale=424 -(70+2+2)=  350 x dscale = 397
			LKwdlgConfig=395;
			break;
		case (ScreenSize_t)ss720x408:
			GestureSize=50;
			LKVarioSize=45;
			// dscale=408/240=1.133  720/dscale=423 -(70+2+2)=  350 x dscale = 594
			LKwdlgConfig=594;
			break;
		case (ScreenSize_t)ss480x234:
			GestureSize=50;
			LKVarioSize=30;
			// dscale=234/240=0.975  480/dscale=492 -(70+2+2)=  418 x dscale = 407
			LKwdlgConfig=405;
			break;
		case (ScreenSize_t)ss320x240:
			GestureSize=50;
			LKVarioSize=20;
			// dscale=240/240=1  320/dscale=320 -(70+2+2)=  246 x dscale = 246
                        // but 246 is too long..
			LKwdlgConfig=244;
			break;
		// PORTRAIT MODES
		case (ScreenSize_t)ss480x640:
			GestureSize=50;
			LKVarioSize=30;
			break;
		case (ScreenSize_t)ss480x800:
			GestureSize=50;
			LKVarioSize=30;
			// dscale=240/240=1  400/dscale=400 -(70+2+2)=  326 x dscale = 326
			LKwdlgConfig=324;
			break;
		case (ScreenSize_t)ss240x320:
			GestureSize=50;
			LKVarioSize=15;
			break;
		default:
			GestureSize=50;
			LKVarioSize=30;
			break;
	}

}

void LockMap(){
	if (MapLock==false) {
		// DoStatusMessage(_T("MAP LOCKED"));
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) 
		        PlayResource(TEXT("IDR_WAV_GREEN"));
		#endif
		DefocusInfoBox();
	}
	MapLock=true;
}

void UnlockMap(){
	if (MapLock) {
		// DoStatusMessage(_T("MAP UNLOCKED")); // annoying
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) 
		        LKSound(_T("UNLOCKMAP.WAV"));
		#endif
	}

	MapLock=false;
}

// colorcode is taken from a 5 bit AsInt union
void MapWindow::TextColor(HDC hDC, short colorcode) {

	switch (colorcode) {
	case TEXTBLACK: 
		if (BlackScreen) // 091109
		  SetTextColor(hDC,RGB_WHITE);  // black 
		else
		  SetTextColor(hDC,RGB_BLACK);  // black 
	  break;
	case TEXTWHITE: 
		if (BlackScreen) // 091109
		  SetTextColor(hDC,RGB_LIGHTYELLOW);  // white
		else
		  SetTextColor(hDC,RGB_WHITE);  // white
	  break;
	case TEXTGREEN: 
	  SetTextColor(hDC,RGB_GREEN);  // green
	  break;
	case TEXTRED:
	  SetTextColor(hDC,RGB_RED);  // red
	  break;
	case TEXTBLUE:
	  SetTextColor(hDC,RGB_BLUE);  // blue
	  break;
	case TEXTYELLOW:
	  SetTextColor(hDC,RGB_YELLOW);  // yellow
	  break;
	case TEXTCYAN:
	  SetTextColor(hDC,RGB_CYAN);  // cyan
	  break;
	case TEXTMAGENTA:
	  SetTextColor(hDC,RGB_MAGENTA);  // magenta
	  break;
	case TEXTLIGHTGREY: 
	  SetTextColor(hDC,RGB_LIGHTGREY);  // light grey
	  break;
	case TEXTGREY: 
	  SetTextColor(hDC,RGB_GREY);  // grey
	  break;
	case TEXTLIGHTGREEN:
	  SetTextColor(hDC,RGB_LIGHTGREEN);  //  light green
	  break;
	case TEXTLIGHTRED:
	  SetTextColor(hDC,RGB_LIGHTRED);  // light red
	  break;
	case TEXTLIGHTYELLOW:
	  SetTextColor(hDC,RGB_LIGHTYELLOW);  // light yellow
	  break;
	case TEXTLIGHTCYAN:
	  SetTextColor(hDC,RGB_LIGHTCYAN);  // light cyan
	  break;
	case TEXTORANGE:
	  SetTextColor(hDC,RGB_ORANGE);  // orange
	  break;
	case TEXTLIGHTORANGE:
	  SetTextColor(hDC,RGB_LIGHTORANGE);  // light orange
	  break;
	case TEXTLIGHTBLUE:
	  SetTextColor(hDC,RGB_LIGHTBLUE);  // light blue
	  break;
	default:
	  SetTextColor(hDC,RGB_MAGENTA);  // magenta so we know it's wrong: nobody use magenta..
	  break;
	}

}


#ifdef PNA
// VENTA-ADDON MODELTYPE

//
//	Check if the model type is encoded in the executable file name
//
//  GlobalModelName is a global variable, shown during startup and used for printouts only.
//  In order to know what model you are using, GlobalModelType is used.
// 
//  This "smartname" facility is used to override the registry/config Model setup to force
//  a model type to be used, just in case. The model types may not follow strictly those in
//  config menu, nor be updated. Does'nt hurt though.
//
void SmartGlobalModelType() {

	GlobalModelType=MODELTYPE_PNA;	// default for ifdef PNA by now!

	if ( GetGlobalModelName() ) 
	{
		ConvToUpper(GlobalModelName);
	
		if ( !_tcscmp(GlobalModelName,_T("PNA"))) {
					GlobalModelType=MODELTYPE_PNA_PNA;
					_tcscpy(GlobalModelName,_T("GENERIC") );
		}
		else 
			if ( !_tcscmp(GlobalModelName,_T("HP31X")))	{
					GlobalModelType=MODELTYPE_PNA_HP31X;
			}
		else	
			if ( !_tcscmp(GlobalModelName,_T("PN6000"))) {
					GlobalModelType=MODELTYPE_PNA_PN6000;
			}
		else	
			if ( !_tcscmp(GlobalModelName,_T("MIO"))) {
					GlobalModelType=MODELTYPE_PNA_MIO;
			}
		else
			_tcscpy(GlobalModelName,_T("UNKNOWN") );
	} else	
		_tcscpy(GlobalModelName, _T("UNKNOWN") );
}


bool SetModelType() {

  TCHAR sTmp[100];
  TCHAR szRegistryInfoBoxModel[]= TEXT("AppInfoBoxModel");
  DWORD Temp=0;

  GetFromRegistry(szRegistryInfoBoxModel, &Temp);
  
  if ( SetModelName(Temp) != true ) {
	_stprintf(sTmp,_T(". SetModelType failed: probably no registry entry%s"), NEWLINE);
	StartupStore(sTmp);
	GlobalModelType=MODELTYPE_PNA_PNA;
	_tcscpy(GlobalModelName,_T("GENERIC"));  // 100820
	return false;
  } else {
	GlobalModelType = Temp;
  }
  
  _stprintf(sTmp,_T(". SetModelType: Name=<%s> Type=%d%s"),GlobalModelName, GlobalModelType,NEWLINE);
  StartupStore(sTmp);
  return true;
}

// Parse a MODELTYPE value and set the equivalent model name. 
// If the modeltype is invalid or not yet handled, assume that
// the user changed it in the registry or in the profile, and 
// correct the error returning false: this will force a Generic Type.

bool SetModelName(DWORD Temp) {
  switch (Temp) {
  case MODELTYPE_PNA_PNA:
    _tcscpy(GlobalModelName,_T("GENERIC")); 
    return true;
    break;
  case MODELTYPE_PNA_HP31X:
    _tcscpy(GlobalModelName,_T("HP31X"));
    return true;
    break;
  case MODELTYPE_PNA_PN6000:
    _tcscpy(GlobalModelName,_T("PN6000"));
    return true;
  case MODELTYPE_PNA_MIO:
    _tcscpy(GlobalModelName,_T("MIO"));
    return true;
  case  MODELTYPE_PNA_MEDION_P5:
    _tcscpy(GlobalModelName,_T("MEDION P5"));
    return true;
  case MODELTYPE_PNA_NOKIA_500:
    _tcscpy(GlobalModelName,_T("NOKIA500"));
    return true;
  case MODELTYPE_PNA_NAVIGON:
    _tcscpy(GlobalModelName,_T("NAVIGON"));
    return true;
  default:
    _tcscpy(GlobalModelName,_T("UNKNOWN"));
    return false;
  }

}

#endif


#if defined(PNA) || defined(FIVV)  // VENTA-ADDON gmfpathname & C.

/* 
	Paolo Ventafridda 1 feb 08 
	Get pathname & c. from GetModuleFilename (gmf)
	In case of problems, always return \ERRORxx\  as path name
	It will be displayed at startup and users will know that
	something is wrong reporting the error code to us.
	Approach not followed: It works but we don't know why
	Approach followed: It doesn't work and we DO know why

	These are temporary solutions to be improved
 */

#define MAXPATHBASENAME MAX_PATH

/*
 * gmfpathname returns the pathname of the current executed program, with leading and trailing slash
 * example:  \sdmmc\   \SD CARD\
 * In case of double slash, it is assumed currently as a single "\" .
 */
TCHAR * gmfpathname ()
{
  static TCHAR gmfpathname_buffer[MAXPATHBASENAME];
  TCHAR  *p; 
  
  if (GetModuleFileName(NULL, gmfpathname_buffer, MAXPATHBASENAME) <= 0) {
//    StartupStore(TEXT("CRITIC- gmfpathname returned null GetModuleFileName\n")); // rob bughunt
    return(_T("\\ERROR_01\\") );
  }
  if (gmfpathname_buffer[0] != '\\' ) {
//   StartupStore(TEXT("CRITIC- gmfpathname starting without a leading backslash\n"));
    return(_T("\\ERROR_02\\"));
  }
  gmfpathname_buffer[MAXPATHBASENAME-1] = '\0';	// truncate for safety
  
  for (p=gmfpathname_buffer+1; *p != '\0'; p++)
    if ( *p == '\\' ) break;	// search for the very first "\"
  
  if ( *p == '\0') {
//    StartupStore(TEXT("CRITIC- gmfpathname no backslash found\n"));
    return(_T("\\ERROR_03\\"));
  }
  *++p = '\0';
  
  return (TCHAR *) gmfpathname_buffer;
}

/*
 * gmfbasename returns the filename of the current executed program, without leading path.
 * Example:  xcsoar.exe 
 */
TCHAR * gmfbasename ()
{
  static TCHAR gmfbasename_buffer[MAXPATHBASENAME];
  TCHAR *p, *lp;
  
  if (GetModuleFileName(NULL, gmfbasename_buffer, MAXPATHBASENAME) <= 0) {
    StartupStore(TEXT("++++++ CRITIC- gmfbasename returned null GetModuleFileName%s"),NEWLINE); // 091119
    return(_T("ERROR_04") );
  }
  if (gmfbasename_buffer[0] != '\\' ) {
    StartupStore(TEXT("++++++ CRITIC- gmfbasename starting without a leading backslash%s"),NEWLINE); // 091119
    return(_T("ERROR_05"));
  }
  for (p=gmfbasename_buffer+1, lp=NULL; *p != '\0'; p++)
    {
      if ( *p == '\\' ) {
	lp=++p;
	continue;
      }
    }
  return  lp;
}

/*
 *	A little hack in the executable filename: if it contains an
 *	underscore, then the following chars up to the .exe is
 *	considered a modelname
 *  Returns 0 if failed, 1 if name found
 */
int GetGlobalModelName ()
{
  TCHAR modelname_buffer[MAXPATHBASENAME];
  TCHAR *p, *lp, *np;
  
  _tcscpy(GlobalModelName, _T(""));
  
  if (GetModuleFileName(NULL, modelname_buffer, MAXPATHBASENAME) <= 0) {
    StartupStore(TEXT("++++++ CRITIC- GetGlobalFileName returned NULL%s"),NEWLINE); // 091119
    return 0;
  }
  if (modelname_buffer[0] != '\\' ) {
    StartupStore(TEXT("++++++ CRITIC- GetGlobalFileName starting without a leading backslash%s"),NEWLINE); // 091119
    return 0;
  }
  for (p=modelname_buffer+1, lp=NULL; *p != '\0'; p++) 
    {
      if ( *p == '\\' ) {
	lp=++p;
	continue;
      }
    } // assuming \sd\path\xcsoar_pna.exe  we are now at \xcsoar..
  
  for (p=lp, np=NULL; *p != '\0'; p++)
    {
      if (*p == '_' ) {
	np=++p;
	break;
      }
    } // assuming xcsoar_pna.exe we are now at _pna..
  
  if ( np == NULL ) {
    return 0;	// VENTA2-bugfix , null deleted
  }
  
  for ( p=np, lp=NULL; *p != '\0'; p++) 
    {
      if (*p == '.' ) {
	lp=p;
	break;
      }
    } // we found the . in pna.exe
  
  if (lp == NULL) return 0; // VENTA2-bugfix null return
  *lp='\0'; // we cut .exe
  
  _tcscpy(GlobalModelName, np);
  
  return 1;  // we say ok
  
}

#endif   // PNA

/*
 * Convert to uppercase a TCHAR array
 */
void ConvToUpper( TCHAR *str )
{
	if ( str )
	{
		for ( ; *str; ++str )
		*str = towupper(*str);

	}

	return ;
}

#ifdef FIVV
BOOL DelRegistryKey(const TCHAR *szDelKey)
{
   HKEY tKey;
   RegOpenKeyEx(HKEY_CURRENT_USER, _T(REGKEYNAME),0,0,&tKey);
   if ( RegDeleteValue(tKey, szDelKey) != ERROR_SUCCESS ) {
	return false;
   }
   RegCloseKey(tKey);
   return true;
}
#endif

#ifdef PNA
void CleanRegistry()
{
   HKEY tKey;
   RegOpenKeyEx(HKEY_CURRENT_USER, szRegistryKey ,0,0,&tKey);

	RegDeleteValue(tKey,_T("CDIWindowFont"));
	RegDeleteValue(tKey,_T("InfoWindowFont"));
	RegDeleteValue(tKey,_T("MapLabelFont"));
	RegDeleteValue(tKey,_T("MapWindowBoldFont"));
	RegDeleteValue(tKey,_T("MapWindowFont"));
	RegDeleteValue(tKey,_T("StatisticsFont"));
	RegDeleteValue(tKey,_T("TitleSmallWindowFont"));
	RegDeleteValue(tKey,_T("TitleWindowFont"));
	RegDeleteValue(tKey,_T("BugsBallastFont"));
	RegDeleteValue(tKey,_T("TeamCodeFont"));

   RegCloseKey(tKey);
}
#endif

#ifdef PNA 	
/* Paolo Ventafridda Apr 23th 2009 VENTA4
 * SetBacklight for PNA devices. There is no standard way of managing backlight on CE,
 * and every device may have different value names and settings. Microsoft did not set 
 * a standard and thus we need a custom solution for each device.
 * But the approach is always the same: change a value and call an event.
 * We do this in XCSoar.cpp at the beginning, no need to make these settings configurable:
 * max brightness and no timeout if on power is the rule. Otherwise, do it manually..
 */
bool SetBacklight() // VENTA4
{
  HKEY    hKey;
  DWORD   Disp=0;
  HRESULT hRes;
  bool doevent=false;

  if (EnableAutoBacklight == false ) return false;

  hRes = RegOpenKeyEx(HKEY_CURRENT_USER, _T("ControlPanel\\Backlight"), 0,  0, &hKey);
  if (hRes != ERROR_SUCCESS) return false;

  switch (GlobalModelType)
  {
	case MODELTYPE_PNA_HP31X:

		Disp=20; // max backlight
		// currently we ignore hres, if registry entries are spoiled out user is already in deep troubles
		hRes = RegSetValueEx(hKey, _T("BackLightCurrentACLevel"),0,REG_DWORD, (LPBYTE)&Disp, sizeof(DWORD));
		hRes = RegSetValueEx(hKey, _T("BackLightCurrentBatteryLevel"),0,REG_DWORD, (LPBYTE)&Disp, sizeof(DWORD));
		hRes = RegSetValueEx(hKey, _T("TotalLevels"),0,REG_DWORD, (LPBYTE)&Disp, sizeof(DWORD));
		Disp=0;
		hRes = RegSetValueEx(hKey, _T("UseExt"),0,REG_DWORD, (LPBYTE)&Disp, sizeof(DWORD));
		RegDeleteValue(hKey,_T("ACTimeout"));
		doevent=true;
		break;

	default:
		doevent=false;
		break;
  }

  RegCloseKey(hKey); if (doevent==false) return false;

  HANDLE BLEvent = CreateEvent(NULL, FALSE, FALSE, TEXT("BacklightChangeEvent")); 
  if ( SetEvent(BLEvent) == 0) doevent=false;
  	else CloseHandle(BLEvent);
  return doevent;
}

bool SetSoundVolume() // VENTA4
{

  if (EnableAutoSoundVolume == false ) return false;

/*
 * This does not work, dunno why
 *
  HKEY    hKey;
  DWORD   Disp=0;
  HRESULT hRes;

  hRes = RegOpenKeyEx(HKEY_CURRENT_USER, _T("ControlPanel\\Volume"), 0,  0, &hKey);
  if (hRes != ERROR_SUCCESS) return false;
  switch (GlobalModelType)
  {
	case MODELTYPE_PNA_HP31X:
		Disp=0xFFFFFFFF; // max volume
		hRes = RegSetValueEx(hKey, _T("Volume"),0,REG_DWORD, (LPBYTE)&Disp, sizeof(DWORD));
		Disp=65538;
		hRes = RegSetValueEx(hKey, _T("Screen"),0,REG_DWORD, (LPBYTE)&Disp, sizeof(DWORD));
		Disp=0;
		hRes = RegSetValueEx(hKey, _T("Key"),0,REG_DWORD, (LPBYTE)&Disp, sizeof(DWORD));
		Disp=7;
		hRes = RegSetValueEx(hKey, _T("Mute"),0,REG_DWORD, (LPBYTE)&Disp, sizeof(DWORD));
		SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0xF2, 0); 
	        RegCloseKey(hKey); 
		break;

	default:
		break;
  }
 */

  // should we enter critical section ?  probably... 
  waveOutSetVolume(0, 0xffff); // this is working for all platforms

  return true;
}


#endif

#if defined(FIVV) || defined(PNA)
// VENTA2-ADDON fonts install
/*
 * Get the localpath, enter XCSoarData/Config, see if there are fonts to copy,
 * check that they have not already been copied in \Windows\Fonts,
 * and eventually copy everything in place.
 *
 * 0 if nothing needed, and all is ok
 * 1 if made action, and all is ok
 * errors if >1
 * 
 * These are currently fonts used by PDA:
 *
	DejaVuSansCondensed2.ttf
	DejaVuSansCondensed-Bold2.ttf
	DejaVuSansCondensed-BoldOblique2.ttf
	DejaVuSansCondensed-Oblique2.ttf
 *
 *
 */

// This will NOT be called from PC versions
short InstallSystem() {

  TCHAR srcdir[MAX_PATH];
  TCHAR dstdir[MAX_PATH];
  TCHAR maindir[MAX_PATH];
  TCHAR fontdir[MAX_PATH];
  TCHAR srcfile[MAX_PATH];
  TCHAR dstfile[MAX_PATH];
  TCHAR tbuf[MAX_PATH*3];
#if (0)
  DWORD attrib;
#endif
  bool failure=false;

  #if ALPHADEBUG
  StartupStore(_T(". Welcome to InstallSystem v1.2%s"),NEWLINE);
  #endif
  LocalPath(srcdir,TEXT(LKD_SYSTEM));

  _stprintf(dstdir,_T(""));

  // search for the main system directory on the real device
  // Remember that SHGetSpecialFolder works differently on CE platforms, and you cannot check for result.
  // We need to verify if directory does really exist.

  SHGetSpecialFolderPath(hWndMainWindow, dstdir, CSIDL_WINDOWS, false);
  if ( wcslen(dstdir) <6) {
	_stprintf(tbuf,_T("------ InstallSystem PROBLEM: cannot locate the Windows folder, got string:<%s>%s"),dstdir,NEWLINE);
	StartupStore(tbuf);
	StartupStore(_T("------ InstallSystem attempting to use default \"\\Windows\" but no warranty!%s"),NEWLINE);
	_stprintf(dstdir,TEXT("\\Windows")); // 091118
  } else {
	StartupStore(_T(". InstallSystem: Windows path reported from device is: <%s>%s"),dstdir,NEWLINE);
  }
  _tcscpy(maindir,dstdir);

  _stprintf(tbuf,_T(". InstallSystem: copy DLL from <%s> to <%s>%s"), srcdir, dstdir,NEWLINE);
  StartupStore(tbuf);

  // We now test for a single file existing inside the directory, called _DIRECTORYNAME
  // because GetFileAttributes can be very slow or hang if checking a directory. In any case testing a file is 
  // much more faster.
#if (0)
  if (  GetFileAttributes(srcdir) != FILE_ATTRIBUTE_DIRECTORY) { // TODO FIX &= 
	StartupStore(_T("------ InstallSystem ERROR could not find source directory <%s> !%s"),srcdir,NEWLINE); // 091104
	failure=true;
#else
  _stprintf(srcfile,TEXT("%s\\_SYSTEM"),srcdir);
  if (  GetFileAttributes(srcfile) == 0xffffffff ) {
	StartupStore(_T("------ InstallSystem ERROR could not find valid system directory <%s>%s"),srcdir,NEWLINE); // 091104
	StartupStore(_T("------ Missing checkfile <%s>%s"),srcfile,NEWLINE);
	failure=true;
#endif
  } else {
	StartupStore(_T(". InstallSystem source directory <%s> is available%s"),srcdir,NEWLINE);
  }

#if (0)
  attrib=GetFileAttributes(dstdir);
  if ( attrib == 0xffffffff ) {
	StartupStore(_T("------ InstallSystem ERROR Directory <%s> does not exist ???%s"),dstdir,NEWLINE);
	failure=true;
  }
  if ( attrib &= FILE_ATTRIBUTE_SYSTEM ) {
	StartupStore(_T(". Directory <%s> is identified as a system folder%s"),dstdir,NEWLINE);
  }
  if ( attrib &= FILE_ATTRIBUTE_COMPRESSED ) {
	StartupStore(_T(". Directory <%s> is a compressed folder%s"),dstdir,NEWLINE);
  }
  if ( attrib &= FILE_ATTRIBUTE_HIDDEN ) {
	StartupStore(_T(". Directory <%s> is a hidden folder%s"),dstdir,NEWLINE);
  }
  /* These attributes are not available
  if ( attrib &= FILE_ATTRIBUTE_INROM ) {
	StartupStore(_T("------ InstallSystem ERROR Directory <%s> is in ROM%s"),dstdir,NEWLINE);
	failure=true;
  }
  if ( attrib &= FILE_ATTRIBUTE_ROMMODULE ) {
	StartupStore(_T("------ InstallSystem ERROR Directory <%s> is a ROM MODULE%s"),dstdir,NEWLINE);
	failure=true;
  }
  */
  if ( attrib &= FILE_ATTRIBUTE_READONLY ) {
	StartupStore(_T("------ InstallSystem ERROR Directory <%s> is READ ONLY%s"),dstdir,NEWLINE);
	failure=true;
  }
#endif

  if (  failure ) {
	StartupStore(_T("------ WARNING: NO DLL install available (and thus NO G-RECORD FOR VALIDATING IGC FILES)%s"),NEWLINE);
	StartupStore(_T("------ WARNING: NO font will be installed on device (and thus wrong text size displayed)%s"),NEWLINE);
	return 5; // 091109
  } else {
#ifdef PPC2002
	_stprintf(srcfile,TEXT("%s\\GRECORD2002.XCS"),srcdir);
#endif
#ifdef PPC2003
	_stprintf(srcfile,TEXT("%s\\GRECORD2003.XCS"),srcdir);
#endif
#ifdef PNA
	_stprintf(srcfile,TEXT("%s\\GRECORDPNA.XCS"),srcdir);
#endif

	_stprintf(dstfile,TEXT("%s\\GRecordDll.dll"),dstdir);

	if (  GetFileAttributes(dstfile) != 0xffffffff ) {
		StartupStore(_T(". GRecordDll.dll already installed in device, very well.%s"),NEWLINE);
	} else {
		if (!CopyFile(srcfile,dstfile,TRUE)) {
			StartupStore(_T("++++++ COULD NOT INSTALL <%s> inside device. BAD!%s"),srcfile,NEWLINE);
			StartupStore(_T("++++++ Error code was: %ld%s"),GetLastError(),NEWLINE);
		} else {
			StartupStore(_T("... GRecordDll.dll installed using <%s>. Great.%s"),srcfile,NEWLINE);
		}
	}

#ifdef PNA
	if (GlobalModelType == MODELTYPE_PNA_HP31X) { // 091109

		StartupStore(_T(". InstallSystem checking desktop links for HP31X%s"),NEWLINE);

		_stprintf(dstdir,TEXT("\\Windows\\Desktop"));
		if (  GetFileAttributes(dstdir) != FILE_ATTRIBUTE_DIRECTORY) { // FIX
			StartupStore(_T("------ Desktop directory <%s> NOT found! Is this REALLY an HP31X?%s"),dstdir,NEWLINE);
		} else {
			_stprintf(srcfile,TEXT("%s\\LK8_HP310.lnk"),srcdir);
			_stprintf(dstfile,TEXT("%s\\LK8000.lnk"),dstdir);
			if (  GetFileAttributes(dstfile) != 0xffffffff ) {
				StartupStore(_T(". Link to LK8000 already found on the desktop, ok.%s"),NEWLINE);
			} else {
				StartupStore(_T(". Installing <%s>%s"),srcfile,NEWLINE);
				if (!CopyFile(srcfile,dstfile,FALSE))  {
					StartupStore(_T("------ Could not install in <%s>. Strange.%s"),dstfile,NEWLINE);
					StartupStore(_T("------ Error code was: %ld%s"),GetLastError(),NEWLINE);
				} else
					StartupStore(_T(". Installed <%s> link.%s"),dstfile,NEWLINE);
			}
			#if 0
			_stprintf(srcfile,TEXT("%s\\LK8SIM_HP310.lnk"),srcdir);
			_stprintf(dstfile,TEXT("%s\\SIM.lnk"),dstdir);
			if (  GetFileAttributes(dstfile) != 0xffffffff ) {
				StartupStore(_T(". Link to SIM LK8000 already found on the desktop, ok.%s"),NEWLINE);
			} else {
				StartupStore(_T(". Installing <%s>%s"),srcfile,NEWLINE);
				if (!CopyFile(srcfile,dstfile,FALSE))  {
					StartupStore(_T("------ Could not install in <%s>. Strange.%s"),dstfile,NEWLINE);
					StartupStore(_T("------ Error code was: %ld%s"),GetLastError(),NEWLINE);
				} else
					StartupStore(_T(". Installed <%s> link.%s"),dstfile,NEWLINE);
			}
			#endif
			_stprintf(srcfile,TEXT("%s\\BT_HP310.lnk"),srcdir);
			_stprintf(dstfile,TEXT("%s\\BlueTooth.lnk"),dstdir);
			if (  GetFileAttributes(dstfile) != 0xffffffff ) {
				StartupStore(_T(". Link to BlueTooth already found on the desktop, ok.%s"),NEWLINE);
			} else {
				StartupStore(_T(". Installing <%s>%s"),srcfile,NEWLINE);
				if (!CopyFile(srcfile,dstfile,FALSE))  {
					StartupStore(_T("------ Could not install in <%s>. Strange.%s"),dstfile,NEWLINE);
					StartupStore(_T("------ Error code was: %ld%s"),GetLastError(),NEWLINE);
				} else
					StartupStore(_T(". Installed <%s> link.%s"),dstfile,NEWLINE);
			}
			_stprintf(srcfile,TEXT("%s\\NAV_HP310.lnk"),srcdir);
			_stprintf(dstfile,TEXT("%s\\CarNav.lnk"),dstdir);
			if (  GetFileAttributes(dstfile) != 0xffffffff ) {
				StartupStore(_T(". Link to Car Navigator already found on the desktop, ok.%s"),NEWLINE);
			} else {
				StartupStore(_T(". Installing <%s>%s"),srcfile,NEWLINE);
				if (!CopyFile(srcfile,dstfile,FALSE))  {
					StartupStore(_T("------ Could not install in <%s>. Strange.%s"),dstfile,NEWLINE);
					StartupStore(_T("------ Error code was: %ld%s"),GetLastError(),NEWLINE);
				} else
					StartupStore(_T(". Installed <%s> link.%s"),dstfile,NEWLINE);
			}
			_stprintf(srcfile,TEXT("%s\\TLOCK_HP310.lnk"),srcdir);
			_stprintf(dstfile,TEXT("%s\\TouchLock.lnk"),dstdir);
			if (  GetFileAttributes(dstfile) != 0xffffffff ) {
				StartupStore(_T(". Link to TouchLock already found on the desktop, ok.%s"),NEWLINE);
			} else {
				StartupStore(_T(". Installing <%s>%s"),srcfile,NEWLINE);
				if (!CopyFile(srcfile,dstfile,FALSE))  {
					StartupStore(_T("------ Could not install in <%s>. Strange.%s"),dstfile,NEWLINE);
					StartupStore(_T("------ Error code was: %ld%s"),GetLastError(),NEWLINE);
				} else
					StartupStore(_T(". Installed <%s> link.%s"),dstfile,NEWLINE);
			}
		}
	}
#endif

  }

  // we are shure that \Windows does exist already.

  _stprintf(fontdir,_T(""));
  _stprintf(dstdir,_T(""));
  #ifdef PNA
  if ( GetFontPath(fontdir) == FALSE ) {
	StartupStore(_T(". Special RegKey for fonts not found on this PNA, using standard folder.%s"), NEWLINE);
	SHGetSpecialFolderPath(hWndMainWindow, dstdir, CSIDL_FONTS, false);
	if ( wcslen(dstdir) <5 ) {
		_stprintf(tbuf,_T("------ PROBLEM: cannot locate the Fonts folder, got string:<%s>%s"),dstdir,NEWLINE);
		StartupStore(tbuf);
		_stprintf(tbuf,_T("------ Attempting to use directory <%s> as a fallback%s"),maindir,NEWLINE);
		StartupStore(tbuf);
		_tcscpy(dstdir,maindir);
	}
  } else {
	StartupStore(_T(". RegKey Font directory is <%s>%s"),fontdir,NEWLINE);
	CreateRecursiveDirectory(fontdir);
	_tcscpy(dstdir,fontdir); 
  }
  #else
  // this is not working correctly on PNA, it is reporting Windows Fonts even with another value in regkey
  SHGetSpecialFolderPath(hWndMainWindow, dstdir, CSIDL_FONTS, false);
  if ( wcslen(dstdir) <5 ) {
	_stprintf(tbuf,_T("------ PROBLEM: cannot locate the Fonts folder, got string:<%s>%s"),dstdir,NEWLINE);
	StartupStore(tbuf);
	_stprintf(tbuf,_T("------ Attempting to use directory <%s> as a fallback%s"),maindir,NEWLINE);
	StartupStore(tbuf);
	_tcscpy(dstdir,maindir);
  }
  #endif


  _stprintf(tbuf,_T(". InstallSystem: Copy Fonts from <%s> to <%s>%s"), srcdir, dstdir,NEWLINE);
  StartupStore(tbuf);
  // on PNAs sometimes FolderPath is reported correctly, but the directory is not existing!
  // this is not needed really on PNA, but doesnt hurt
  CreateDirectory(dstdir, NULL); // 100820


  // we cannot check directory existance without the risk of hanging for many seconds
  // we can only rely on singe real file existance, not on directories

  #if ALPHADEBUG
  StartupStore(_T(". Checking TAHOMA font%s"),NEWLINE);
  #endif
  _stprintf(srcfile,TEXT("%s\\TAHOMA.TTF"),srcdir);
  _stprintf(dstfile,TEXT("%s\\TAHOMA.TTF"),dstdir);
  if (  GetFileAttributes(dstfile) != 0xffffffff ) {
	StartupStore(_T(". Font TAHOMA.TTF is already installed%s"),NEWLINE);
  } else {
	if ( !CopyFile(srcfile,dstfile,TRUE))  {
		StartupStore(_T("------ Could not copy TAHOMA.TTF on device, not good.%s"),NEWLINE);
		StartupStore(_T("------ Error code was: %ld%s"),GetLastError(),NEWLINE);
	} else
		StartupStore(_T("... Font TAHOMA.TTF installed on device%s"),NEWLINE);
  }

  // not needed, cannot overwrite tahoma while in use! Tahoma bold not used for some reason in this case.
  // Problem solved, look at FontPath !!

  #if ALPHADEBUG
  StartupStore(_T(". Checking TAHOMABD font%s"),NEWLINE);
  #endif
  _stprintf(srcfile,TEXT("%s\\TAHOMABD.TTF"),srcdir);
  _stprintf(dstfile,TEXT("%s\\TAHOMABD.TTF"),dstdir);
  if (  GetFileAttributes(dstfile) != 0xffffffff ) {
	StartupStore(_T(". Font TAHOMABD.TTF is already installed%s"),NEWLINE);
  } else {
	if ( !CopyFile(srcfile,dstfile,TRUE))  {
		StartupStore(_T("------ Could not copy TAHOMABD.TTF on device, not good.%s"),NEWLINE);
		StartupStore(_T("------ Error code was: %ld%s"),GetLastError(),NEWLINE);
	} else
		StartupStore(_T("... Font TAHOMABD.TTF installed on device%s"),NEWLINE);
  }

  #if ALPHADEBUG
  StartupStore(_T(". InstallSystem completed OK%s"),NEWLINE);
  #endif

  return 0;

}

bool CheckDataDir() {
  TCHAR srcdir[MAX_PATH];
  TCHAR srcfile[MAX_PATH];
  LocalPath(srcdir,_T(LKD_SYSTEM));
  _stprintf(srcfile,TEXT("%s\\_SYSTEM"),srcdir);
  if (  GetFileAttributes(srcfile) == 0xffffffff ) return false;
  return true;
}

bool CheckLanguageDir() {
  TCHAR srcdir[MAX_PATH];
  TCHAR srcfile[MAX_PATH];
  LocalPath(srcdir, _T(LKD_LANGUAGE));
  _stprintf(srcfile,TEXT("%s\\_LANGUAGE"),srcdir);
  if (  GetFileAttributes(srcfile) == 0xffffffff ) return false;

  LocalPath(srcdir, _T(LKD_LANGUAGE));
  _stprintf(srcfile,TEXT("%s\\ENG_MSG.TXT"),srcdir);
  if (  GetFileAttributes(srcfile) == 0xffffffff ) return false;

  return true;
}

bool CheckRegistryProfile() {
	TCHAR srcpath[MAX_PATH];
	if ( GlobalModelType == MODELTYPE_PNA_HP31X ) return false;
	LocalPath(srcpath,TEXT(LKD_CONF)); // 091101
	_stprintf(srcpath,_T("%s\\%s"),srcpath,XCSPROFILE); // 091101
	if (  GetFileAttributes(srcpath) == 0xffffffff) return false;
	return true;
}
#endif


int roundupdivision(int a, int b) {
   int c=a / b;
   if ( (a%b) >0) return ++c;
   else return c;
}

#ifdef CPUSTATS
// Warning this is called by several concurrent threads, no static variables here
void Cpustats(int *accounting, FILETIME *kernel_old, FILETIME *kernel_new, FILETIME *user_old, FILETIME *user_new) {
   __int64 knew=0, kold=0, unew=0, uold=0;
   int total=2; // show evident problem

   knew = kernel_new->dwHighDateTime;
   knew <<= 32;
   knew += kernel_new->dwLowDateTime;
    
   unew=user_new->dwHighDateTime;
   unew <<=32;
   unew+=user_new->dwLowDateTime;

   kold = kernel_old->dwHighDateTime;
   kold <<= 32;
   kold += kernel_old->dwLowDateTime;
   
   uold=user_old->dwHighDateTime;
   uold <<=32;
   uold+=user_old->dwLowDateTime;

#if (WINDOWSPC>0)   
   total = (int) ((knew+unew-kold-uold)/10.0);
   //if (total==0) return;
#else
   total = (int) ((knew+unew-kold-uold)/10000.0);
#endif
   *accounting=total;

}

#endif


// Conversion between submenus and global mapspace modes 
// Basic initialization of global variables and parameters.
//
void InitModeTable() {

	short i;
	StartupStore(_T(". Init ModeTable for LK8000: "));

	for (i=0; i<=LKMODE_TOP; i++)
		for (short j=0; j<=MSM_TOP; j++)
			ModeTable[i][j]=INVALID_VALUE;


	// this table is for submenus, order is not important
	ModeTable[LKMODE_MAP][MP_WELCOME]	=	MSM_WELCOME;
	ModeTable[LKMODE_MAP][MP_MOVING]	=	MSM_MAP;

	ModeTable[LKMODE_WP][WP_AIRPORTS]	=	MSM_AIRPORTS;
	ModeTable[LKMODE_WP][WP_LANDABLE]	=	MSM_LANDABLE;
	ModeTable[LKMODE_WP][WP_NEARTPS]	=	MSM_NEARTPS;

	ModeTable[LKMODE_INFOMODE][IM_CRUISE]	=	MSM_INFO_CRUISE;
	ModeTable[LKMODE_INFOMODE][IM_THERMAL]	=	MSM_INFO_THERMAL;
	ModeTable[LKMODE_INFOMODE][IM_TASK]	=	MSM_INFO_TASK;
	ModeTable[LKMODE_INFOMODE][IM_AUX]	=	MSM_INFO_AUX;
	ModeTable[LKMODE_INFOMODE][IM_TRI]	=	MSM_INFO_TRI;

	ModeTable[LKMODE_NAV][NV_COMMONS]	=	MSM_COMMON;
	ModeTable[LKMODE_NAV][NV_HISTORY]	=	MSM_RECENT;

	ModeTable[LKMODE_TRF][TF_LIST]		=	MSM_TRAFFIC;
	ModeTable[LKMODE_TRF][IM_TRF]		=	MSM_INFO_TRF;
	ModeTable[LKMODE_TRF][IM_TARGET]	=	MSM_INFO_TARGET;

	// startup mode
	ModeIndex=LKMODE_MAP;
	// startup values for each mode
	ModeType[LKMODE_MAP]	=	MP_WELCOME;
	ModeType[LKMODE_WP]	=	WP_AIRPORTS;
	ModeType[LKMODE_INFOMODE]=	IM_CRUISE;
	ModeType[LKMODE_NAV]	=	NV_COMMONS;
	ModeType[LKMODE_TRF]	=	TF_LIST;

	ModeTableTop[LKMODE_MAP]=MP_TOP;
	ModeTableTop[LKMODE_WP]=WP_TOP;
	ModeTableTop[LKMODE_INFOMODE]=IM_TOP;
	ModeTableTop[LKMODE_NAV]=NV_TOP;
	ModeTableTop[LKMODE_TRF]=TF_TOP;

	// set all sorting type to distance (default) even for unconventional modes just to be sure
	for (i=0; i<=MSM_TOP; i++) SortedMode[i]=1;

	for (i=0; i<MAXNEARTURNPOINT;i++) 
		SortedTurnpointIndex[i]=-1;

	for (i=0; i<MAXNEAREST;i++) {
		SortedLandableIndex[i]=-1;
		SortedAirportIndex[i]=-1;
	}

	for (i=0; i<MAXCOMMON; i++) 
		CommonIndex[i]= -1;


	StartupStore(_T("Ok%s"),NEWLINE);
}


void SetModeType(short modeindex, short modetype) {

	UnselectMapSpace( ModeTable[ModeIndex][CURTYPE] );
	// TODO: make safe checks
	ModeIndex=modeindex;
	CURTYPE=modetype;
	SelectMapSpace( ModeTable[ModeIndex][CURTYPE] );

}

// Advance through types inside current mode
//
void NextModeType() {

	UnselectMapSpace( ModeTable[ModeIndex][CURTYPE] );
	if ( CURTYPE >= ModeTableTop[ModeIndex] ) {
		// point to first
		CURTYPE=0; 
	} else {
		CURTYPE++;
	}
	SelectMapSpace( ModeTable[ModeIndex][CURTYPE] );
}


void PreviousModeType() {
// usare ifcircling per decidere se 0 o 1
	UnselectMapSpace( ModeTable[ModeIndex][CURTYPE] );
	if ( CURTYPE <= 0 ) 
		// point to last
		CURTYPE=ModeTableTop[ModeIndex]; 
	else
		CURTYPE--;
	SelectMapSpace( ModeTable[ModeIndex][CURTYPE] );
}


// Advance inside Mode Table between map, wp, infopages 
// and reselect previous state for that mode
// Notice: does NOT advance inside modes through types
//
void NextModeIndex() {
	UnselectMapSpace(ModeTable[ModeIndex][CURTYPE]);
	if ( GPS_INFO.FLARM_Available ) { // 100325
		if ( (ModeIndex+1)>LKMODE_TOP)
			ModeIndex=LKMODE_MAP;
		else
			ModeIndex++;
	} else {
		if ( (ModeIndex+1)>(LKMODE_TOP-1))
			ModeIndex=LKMODE_MAP;
		else
			ModeIndex++;
	}
	SelectMapSpace(ModeTable[ModeIndex][CURTYPE]);
}

void SoundModeIndex() {
#ifndef DISABLEAUDIO
	if (EnableSoundModes) {
		switch(ModeIndex) {
			case LKMODE_MAP:
				PlayResource(TEXT("IDR_WAV_TONE7"));
				break;
			case LKMODE_INFOMODE:
				PlayResource(TEXT("IDR_WAV_TONE1"));
				break;
			case LKMODE_WP:
				PlayResource(TEXT("IDR_WAV_TONE2"));
				break;
			case LKMODE_NAV:
				PlayResource(TEXT("IDR_WAV_TONE3"));
				break;
			case LKMODE_TRF:
				PlayResource(TEXT("IDR_WAV_TONE4"));
				break;
		}
	}
#endif
}

void BottomSounds() {
#ifndef DISABLEAUDIO
   if (EnableSoundModes) {
	switch(BottomMode) {
		case 1:
			PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
			break;
		case 2:
			PlayResource(TEXT("IDR_WAV_BTONE2"));
			break;
		case 3:
			PlayResource(TEXT("IDR_WAV_BTONE2"));
			break;
		case 4:
			PlayResource(TEXT("IDR_WAV_BTONE4"));
			break;
		case 5:
			PlayResource(TEXT("IDR_WAV_BTONE4"));
			break;
		case 6:
			PlayResource(TEXT("IDR_WAV_BTONE5"));
			break;
		case 7:
			PlayResource(TEXT("IDR_WAV_BTONE5"));
			break;
		case 8:
			PlayResource(TEXT("IDR_WAV_BTONE6"));
			break;
		case 9:
			PlayResource(TEXT("IDR_WAV_BTONE6"));
			break;
		default:
			PlayResource(TEXT("IDR_WAV_CLICK"));
			break;
	}
  }
#endif
}

// This is currently unused.. we need a button!
void PreviousModeIndex() {
  UnselectMapSpace(ModeTable[ModeIndex][CURTYPE]);
  if ( (ModeIndex-1)<0) {
	if ( GPS_INFO.FLARM_Available ) { // 100325
		ModeIndex=LKMODE_TOP;
	} else {
		ModeIndex=LKMODE_TOP-1;
	}
  } else
	ModeIndex--;
  SelectMapSpace(ModeTable[ModeIndex][CURTYPE]);
}

// This will set mapspace directly, and set ModeIndex accordingly. So we can do a "goto" mapspace now.
void SetModeIndex(short i) {
  UnselectMapSpace(ModeTable[ModeIndex][CURTYPE]);
  if (i<0 || i>LKMODE_TOP) {
	DoStatusMessage(_T("ERR-137 INVALID MODEINDEX"));
	return;
  }
  ModeIndex=i;
  SelectMapSpace(ModeTable[ModeIndex][CURTYPE]);

}


// Selecting MapSpaceMode need also ModeIndex and ModeType to be updated!
// Do not use these functions directly..
// Toggling pages will force intermediate activations, so careful here
//
void UnselectMapSpace(short i) {

	return;
}


void SelectMapSpace(short i) {
	
	LKForceDoNearest=false;
	LKForceDoCommon=false;
	LKForceDoRecent=false;
	LKForceDoNearestTurnpoint=false;
	// Particular care not to leave pending events
	LKevent=LKEVENT_NONE;

	switch(i) {
		case MSM_LANDABLE:
		case MSM_AIRPORTS:
			// force DoNearest to run at once
			LKForceDoNearest=true;
			LKevent=LKEVENT_NEWRUN;
			SelectedPage[MapSpaceMode]=0;
			SelectedRaw[MapSpaceMode]=0;
			break;
		case MSM_COMMON:
			LKForceDoCommon=true;
			LKevent=LKEVENT_NEWRUN;
			SelectedPage[MapSpaceMode]=0;
			SelectedRaw[MapSpaceMode]=0;
			break;
		case MSM_RECENT:
			LKForceDoRecent=true;
			LKevent=LKEVENT_NEWRUN;
			SelectedPage[MapSpaceMode]=0;
			SelectedRaw[MapSpaceMode]=0;
			break;
		case MSM_NEARTPS:
			LKForceDoNearestTurnpoint=true;
			LKevent=LKEVENT_NEWRUN;
			SelectedPage[MapSpaceMode]=0;
			SelectedRaw[MapSpaceMode]=0;
			break;
		default:
			LKevent=LKEVENT_NEWRUN;
			break;
	}
	MapSpaceMode=i;
}

// Get the infobox type from configuration, selecting position i
// From 1-8 auxiliaries
//     0-16 dynamic page
//
int GetInfoboxType(int i) {

	int retval = 0;
	if (i<1||i>16) return LK_ERROR;

	// it really starts from 0
	if (i<=8)
		retval = (InfoType[i-1] >> 24) & 0xff; // auxiliary
	else {
		switch ( DisplayMode ) {
			case dmCruise:
				retval = (InfoType[i-9] >> 8) & 0xff;
				break;
			case dmFinalGlide:
				retval = (InfoType[i-9] >> 16) & 0xff;
				break;
			case dmCircling:
				retval = (InfoType[i-9]) & 0xff; 
				break;
			default:
				// impossible case, show twice auxiliaries
				retval = (InfoType[i-9] >> 24) & 0xff;
				break;
		}
	}

	return min(NUMSELECTSTRINGS-1,retval);
}

// Returns the LKProcess index value for configured infobox (0-8) for dmCruise, dmFinalGlide, Auxiliary, dmCircling
// The function name is really stupid...
// dmMode is an enum, we simply use for commodity
int GetInfoboxIndex(int i, short dmMode) {
	int retval = 0;
	if (i<0||i>8) return LK_ERROR;

	switch(dmMode) {
		case dmCruise:
			retval = (InfoType[i-1] >> 8) & 0xff;
			break;
		case dmFinalGlide:
			retval = (InfoType[i-1] >> 16) & 0xff;
			break;
		case dmCircling:
			retval = (InfoType[i-1]) & 0xff; 
			break;
		default:
			// default is auxiliary
			retval = (InfoType[i-1] >> 24) & 0xff; 
			break;
	}
	return min(NUMSELECTSTRINGS-1,retval);
}


double GetMacCready(int wpindex, short wpmode)
{
	if (WayPointCalc[wpindex].IsLandable) {
		if (MACCREADY>GlidePolar::SafetyMacCready) 
			return MACCREADY;
		else
			return GlidePolar::SafetyMacCready;
	}
	return MACCREADY;

}

// UNUSED 091023
void unicodetoascii(TCHAR *utext, int utextsize, char *atext) {

	int i,j;
	if (utextsize==0) {
		atext[0]=0;
		return;
	}

	for (i=0,j=0; i<utextsize; i++) {
		if (utext[i]==0) continue;
		atext[j++]=utext[i];
	}
	atext[j]=0;

}

void InitWindRotary(windrotary_s *buf) {
short i;

	for (i=0; i<WCALC_ROTARYSIZE; i++) {
		buf->speed[i]=0;
		buf->ias[i]=0;
		buf->track[i]=0;
		buf->compass[i]=0;
		buf->altitude[i]=0;
	}
	buf->start=-1;
	// only last x seconds of data are used
	buf->size=WCALC_MAXSIZE;
	return;
}

//#define DEBUG_ROTARY

void InsertWindRotary(windrotary_s *buf, double speed, double track, double altitude ) {
static short errs=0;

#ifdef DEBUG_ROTARY
char ventabuffer[200];
FILE *fp;
#endif
	if (CALCULATED_INFO.OnGround == TRUE) {
		return;
	}
	
	if (CALCULATED_INFO.Circling == TRUE) {
		return;
	}


	// speed is in m/s
	if (speed<1 || speed>100 || altitude <1 || altitude >10000) { 
		if (errs>2) {
			#ifdef DEBUG_ROTARY
			sprintf(ventabuffer,"Wind Rotary reset after exceeding errors\n");
			if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
				    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
			#endif
			InitWindRotary(&rotaryWind);
			errs=0;
			return;

		}
		errs++;
		#ifdef DEBUG_ROTARY
		sprintf(ventabuffer,"(errs=%d) IGNORE INVALID speed=%f track=%f alt=%f\n",errs,speed, track, altitude);
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
			    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
		#endif
		return;
	}
	errs=0;

	if (++buf->start >=buf->size) { 
		#ifdef DEBUG_ROTARY
		sprintf(ventabuffer,"*** rotary reset ++bufstart=%d >=bufsize=%d\n",buf->start, buf->size);
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
			    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
		#endif
		buf->start=0;
	}


	// We store GS in kmh, simply.
	buf->speed[buf->start] = (int)(speed*TOKPH);
	// we use track+180 in order to be always over 0 in range calculations
	// we want track north to be 0, not 360
	if (track==360) track=0;
	buf->track[buf->start]=(int)track+180;
	buf->altitude[buf->start]=(int)altitude;
	// ias is in m/s
	if (GPS_INFO.AirspeedAvailable && GPS_INFO.IndicatedAirspeed>0) {
		buf->ias[buf->start] = (int)GPS_INFO.IndicatedAirspeed;
	}

	#ifdef DEBUG_ROTARY
	sprintf(ventabuffer,"insert buf[%d/%d], track=%d alt=%d GS=%d",
		buf->start, buf->size-1, 
		buf->track[buf->start]-180,
		buf->altitude[buf->start] , 
		buf->speed[buf->start]);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
		    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
}

// The Magic TrueWind returns: (see Utils2.h WCALC return codes) <=0 error values
//
// iaspeed is Indicated Air Speed in m/s. Target track is automatic. (TODO: use digital compass if available)
// IF IAS IS AVAILABLE, we use average IAS, in m/s and we ignore iaspeed
//

#if (WINDOWSPC>0)
//#define DEBUG_WCALC  // REMOVE BEFORE FLIGHT!
//#define STORE_WCALC  // REMOVE BEFORE FLIGHT!
#endif

// wmode  is 0 for NESW , 1 for 3,12,21,30    2 for 6 15 24 33
// For digital compass, wmode is heading degrees + 180 (that is, it starts from 180 degrees..)

#define WCALCTHRESHOLD 0.60
int CalculateWindRotary(windrotary_s *buf, double iaspeed , double *wfrom, double *wspeed, int windcalctime, int wmode) {

  #ifdef DEBUG_WCALC
  char ventabuffer[200];
  FILE *fp;
  #endif

  if (windcalctime<3) {
	StartupStore(_T("------ TrueWind: calctime=%d too low!%s"),windcalctime,NEWLINE);
	return WCALC_INVALID_DATA;
  }

  // make a copy of the working area, and work offline
  windrotary_s bc;
  memcpy(&bc, buf, sizeof(windrotary_s));

  short i,curs,nc,iter;
  int s, alt;
  int low, high;
  float averspeed, averias, avertrack, cutoff;
  double averaltitude=0;
  bool haveias=false;
  short gsquality=0, trackquality=0, iasquality=0;

  averspeed=0; averias=0; avertrack=0; cutoff=0;

  if (iaspeed<2||iaspeed>180) {
	StartupStore(_T("------ TrueWind: Invalid target speed=%f in Wind Calculation%s"),iaspeed,NEWLINE);
	return WCALC_INVALID_DATA;
  } else {
	// kmh range for GS 
	low = 10;
	high = 300;
  }

  #ifdef DEBUG_WCALC
  if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {
	fprintf(fp,"-------------------------------------------\n");
  	if (GPS_INFO.AirspeedAvailable) {
		fprintf(fp,"TAS/IAS are available, preconfig iaspeed=%.3f not used \n",iaspeed);
		fprintf(fp,"*** DUMP BUFFER, rotary size=%d (max buffer:%d) start=%d\n",bc.size, WCALC_ROTARYSIZE,bc.start);
		for (i=0; i< bc.size; i+=5) {
			sprintf(ventabuffer,"  [%02d] sp=%03d trk=%03d ias=%03d  ",i,bc.speed[i],bc.track[i]-180, (int)(bc.ias[i]*3.6));
			fprintf(fp,ventabuffer);
			sprintf(ventabuffer,"[%02d] sp=%03d trk=%03d ias=%03d  ",i+1,bc.speed[i+1],bc.track[i+1]-180, (int)(bc.ias[i]*3.6));
			fprintf(fp,ventabuffer);
			sprintf(ventabuffer,"[%02d] sp=%03d trk=%03d ias=%03d  ",i+2,bc.speed[i+2],bc.track[i+2]-180, (int)(bc.ias[i]*3.6));
			fprintf(fp,ventabuffer);
			sprintf(ventabuffer,"[%02d] sp=%03d trk=%03d ias=%03d  ",i+3,bc.speed[i+3],bc.track[i+3]-180, (int)(bc.ias[i]*3.6));
			fprintf(fp,ventabuffer);
			sprintf(ventabuffer,"[%02d] sp=%03d trk=%03d ias=%03d\n",i+4,bc.speed[i+4],bc.track[i+4]-180, (int)(bc.ias[i]*3.6));
			fprintf(fp,ventabuffer);
		}
		fclose(fp);

	} else {
		fprintf(fp,"Preconfigured iaspeed=%.3f \n",iaspeed);
		fprintf(fp,"*** DUMP BUFFER, rotary size=%d (max buffer:%d) start=%d\n",bc.size, WCALC_ROTARYSIZE,bc.start);
		for (i=0; i< bc.size; i+=5) {
			sprintf(ventabuffer,"  [%02d] sp=%03d trk=%03d  ",i,bc.speed[i],bc.track[i]-180);
			fprintf(fp,ventabuffer);
			sprintf(ventabuffer,"[%02d] sp=%03d trk=%03d  ",i+1,bc.speed[i+1],bc.track[i+1]-180);
			fprintf(fp,ventabuffer);
			sprintf(ventabuffer,"[%02d] sp=%03d trk=%03d  ",i+2,bc.speed[i+2],bc.track[i+2]-180);
			fprintf(fp,ventabuffer);
			sprintf(ventabuffer,"[%02d] sp=%03d trk=%03d  ",i+3,bc.speed[i+3],bc.track[i+3]-180);
			fprintf(fp,ventabuffer);
			sprintf(ventabuffer,"[%02d] sp=%03d trk=%03d\n",i+4,bc.speed[i+4],bc.track[i+4]-180);
			fprintf(fp,ventabuffer);
		}
		fclose(fp);

	}
  }
  #endif


  // search for a GS convergent value between these two margins. 

  for (iter=0; iter<MAXITERFILTER; iter++) {
	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"(speed iter=%d) low=%d high=%d",iter,low,high);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
	// skip last 2 seconds and go backwards to last 40
	if (bc.start<WCALC_TIMESKIP) curs=bc.size-1; else curs=bc.start-WCALC_TIMESKIP;

	//for (i=0, nc=0, s=0; i<WCALC_TIMEBACK; i++) {
	for (i=0, nc=0, s=0; i<windcalctime; i++) {
		if (bc.speed[curs] >=low && bc.speed[curs] <=high) {
			s+=bc.speed[curs];
			nc++;
		}
		if (--curs <0 ) curs=bc.size-1;
	}
	// do not accept a valid result if we don't have at least (TIMEBACK/2)+1 valid samples
	// do not accept a valid result if we don't have at least 75% +1 valid samples
	//if (nc<((WCALC_TIMEBACK/2)+1)) {
	if (nc<((windcalctime*WCALCTHRESHOLD)+1)) {
		#ifdef DEBUG_WCALC
		sprintf(ventabuffer,"(speed iter=%d) nc=%d <%d : no valid GS averspeed",iter,nc,(int)(windcalctime*WCALCTHRESHOLD)+1);
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
		{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
		#endif
		averspeed=0.0;
		break;
	}
	// ground speed quality is an absolute value: the valid fixes accounted
	gsquality=nc;
	averspeed=((float)s/nc);
	cutoff=averspeed/(float)(10.0*(iter+1)); // era 50
	if (cutoff<1) cutoff=1;
	low=(int)(averspeed-cutoff);
	high=(int)(averspeed+cutoff);
	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"(speed iter=%d) nc=%d  averspeed=%.3f >> new: cutoff=%.3f >> low=%d high=%d",
		iter,nc,averspeed,cutoff,low,high);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif

  }

  #ifdef DEBUG_WCALC
  if (averspeed>0) {
  	sprintf(ventabuffer,"GPS GS averspeed is %d kmh", (int)averspeed);
  	if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
  }
  #endif
  
  // track search, and also altitude average
  // Track is stored + 180, so 359 is now 539. There is NO 360, it is 0 + 180

  low=145;
  high=540;
  for (iter=0; iter<MAXITERFILTER; iter++) {
	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"(track iter=%d) low=%d high=%d",iter,low,high);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
	// skip last seconds and go backwards to last 40 or whatever
	if (bc.start<WCALC_TIMESKIP) curs=bc.size-1; else curs=bc.start-WCALC_TIMESKIP;

	for (i=0,nc=0,s=0,alt=0; i<windcalctime; i++) {

		// Track over 325 (505) should appear as x-180 (145)  100316 ?? it was a bug
		int track=bc.track[curs];
		if (track >=low && track <=high) {
			//s+=bc.track[curs];
			s+=track;
			alt+=bc.altitude[curs];
			nc++;
		}
		if (--curs <0 ) curs=bc.size-1;
	}
	// do not accept a valid result if we don't have at least (TIMEBACK/2)+1 valid samples
	// do not accept a valid result if we don't have at least 75%+1 valid samples
	if (nc<((windcalctime*WCALCTHRESHOLD)+1)) {
		#ifdef DEBUG_WCALC
		sprintf(ventabuffer,"(track iter=%d) nc=%d <%d : no valid avertrack",iter,nc,(int)(windcalctime*WCALCTHRESHOLD)+1);
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
		{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
		#endif
		avertrack=-1; // negative avertrack means invalid
		break;
	}
	// track quality is number of valid fixes found
	trackquality=nc;
	avertrack=((float)s/nc);
	averaltitude=alt/nc;

	cutoff=avertrack/(float)(10.0*(iter+1)); 
	if (cutoff<1) cutoff=1;
	low=(int)(avertrack-cutoff);
	high=(int)(avertrack+cutoff);

	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"(track iter=%d) nc=%d  avertrack=%.3f >> new: cutoff=%.3f >> low=%d high=%d",
		iter,nc,avertrack,cutoff,low,high);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
  }

  #ifdef DEBUG_WCALC
  if (avertrack>-1) {
  	sprintf(ventabuffer,"GPS TRACK avertrack is %d", (int)avertrack-180);
  	if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
  } else {
  	sprintf(ventabuffer,"GPS TRACK avertrack is -1 : NO average track found)");
  	if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
  }
  #endif

  // If Airspeed is available, use it  (ias is in m/s) but not if using Condor
  #if TESTIASWITHCONDOR
  if (!GPS_INFO.AirspeedAvailable ) goto goto_NoAirspeed;
  #else
  if (!GPS_INFO.AirspeedAvailable || devIsCondor(devA()) ) goto goto_NoAirspeed;
  #endif
  low=2;
  high=60;
  for (iter=0; iter<MAXITERFILTER; iter++) {
	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"(IAS iter=%d) low=%d high=%d",iter,low,high);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
	// skip last 2 seconds and go backwards to last 40
	if (bc.start<WCALC_TIMESKIP) curs=bc.size-1; else curs=bc.start-WCALC_TIMESKIP;

	for (i=0, nc=0, s=0; i<windcalctime; i++) {
		if (bc.ias[curs] >=low && bc.ias[curs] <=high) {
			s+=bc.ias[curs];
			nc++;
		}
		if (--curs <0 ) curs=bc.size-1;
	}
	// do not accept a valid result if we don't have at least 75% +1 valid samples
	if (nc<((windcalctime*WCALCTHRESHOLD)+1)) {
		#ifdef DEBUG_WCALC
		sprintf(ventabuffer,"(IAS iter=%d) nc=%d <%d : no valid average IAS",iter,nc,(int)(windcalctime*WCALCTHRESHOLD)+1);
		if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
		{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
		#endif
		averias=0.0;
		if (nc>0) return WCALC_INVALID_IAS;
		else return WCALC_INVALID_NOIAS;
		// otherwise, try to use eIAS
	}
	// iasquality is number of valid fixes found
	iasquality=nc;
	haveias=true; 
	averias=((float)s/nc);
	cutoff=averias/(float)(10.0*(iter+1));
	if (cutoff<1) cutoff=1;
	low=(int)(averias-cutoff);
	high=(int)(averias+cutoff);
	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"(IAS iter=%d) nc=%d  averias=%.3f >> new: cutoff=%.3f >> low=%d high=%d",
		iter,nc,averias,cutoff,low,high);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif

  }

  // Assuming 10 seconds, GS is calculated on ground moving in this time. We want in 10 seconds at least 50m made
  // averias is >0 , but must be >18kmh, >5ms ?
  // NO, by now we keep 2ms minimum, for paragliders mainly
  #ifdef DEBUG_WCALC
  sprintf(ventabuffer,"REAL IAS averias is %d", (int)averias);
  if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
  #endif
  if (averias<=2) {
	#ifdef STORE_WCALC
	StartupStore(_T("... TrueWind: REAL average IAS =%d TOO LOW%s"),(int)averias, NEWLINE);
	#endif
	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"REAL IAS averias is %d TOO LOW", (int)averias);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
	return WCALC_INVALID_NOIAS;
  }

  goto_NoAirspeed:
  // track is inserted with +180 
  // a negative heading to 325 is 145, so 145-180 would be -35 . 360-35=325 correct
  if (avertrack>-1) { // if valid avertrack found
	avertrack-=180;
	if (avertrack<0) avertrack=360-avertrack;
  }
  #ifdef DEBUG_WCALC
  if (averspeed>0 && avertrack>=0) {
	#if TESTIASWITHCONDOR
	if (GPS_INFO.AirspeedAvailable ) {
	#else
	if (GPS_INFO.AirspeedAvailable && !devIsCondor(devA()) ) {
	#endif
		if (averias>0)
			sprintf(ventabuffer,"*** Averages found (AIRSPEED AVAILABLE): averIAS=%d speed=%d track=%d altitude=%d\n", 
				(int)(averias*TOKPH), (int)averspeed, (int)avertrack, (int)averaltitude);
		else
			sprintf(ventabuffer,"*** Averages found (AIRSPEED AVAILABLE): INVALID averIAS=%dm/s speed=%d track=%d altitude=%d\n", 
				(int)averias, (int)averspeed, (int)avertrack, (int)averaltitude);
	} else {
		sprintf(ventabuffer,"*** Averages found: speed=%d track=%d altitude=%d\n", 
			(int)averspeed, (int)avertrack, (int)averaltitude);
	}

	if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
  }
  #endif
  #ifdef STORE_WCALC
  #if TESTIASWITHCONDOR
  if (GPS_INFO.AirspeedAvailable && averias>0 )
  #else
  if (GPS_INFO.AirspeedAvailable && averias>0 && !devIsCondor(devA()) )
  #endif
	StartupStore(_T("... TrueWind: REAL average IAS =%d Average GS=%d Track=%d Altitude=%d%s"),
		(int)(averias*TOKPH),(int)averspeed,(int)avertrack,(int)averaltitude, NEWLINE);
  else
	StartupStore(_T("... TrueWind: IAS =%d Average GS=%d Track=%d Altitude=%d%s"),
		(int)(iaspeed*TOKPH),(int)averspeed,(int)avertrack,(int)averaltitude, NEWLINE);
  #endif

  if (averspeed<=0 && avertrack<0){
  	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"Fail: GPS averspeed<=0 && avertrack<0 INVALID ALL \n");
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
	return WCALC_INVALID_ALL;
  }
  if (averspeed<=0) {
  	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"Fail: GPS averspeed<=0 INVALID SPEED \n");
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
	return WCALC_INVALID_SPEED;
  }
  if (avertrack<0) {
  	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"Fail: GPS avertrack<0 INVALID TRACK \n");
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
	return WCALC_INVALID_TRACK;
  }


  // p_heading is presumed heading , NSEW .. in degrees (understood from avertrack)
  // iaspeed is presumed IAS , as configured . in km/h (passed as parameter)

  // TODO If we have a digital compass, use wmode for it
#if 100215
  double p_heading=999;
  switch(wmode) {
	case 0:
		// wmode==0:  0 90  180  270   (N E S W)
		if (avertrack >=325.0 || avertrack<=35.0 ) p_heading=0;
		if (avertrack >=55.0 && avertrack<=125.0 ) p_heading=90;
		if (avertrack >=145.0 && avertrack<=215.0 ) p_heading=180;
		if (avertrack >=235.0 && avertrack<=305.0 ) p_heading=270;
		break;
	case 1:
		// wmode==1:  30 120 210 300
		if (avertrack >=355.0 || avertrack<=65.0 ) p_heading=30;
		if (avertrack >=85.0 && avertrack<=155.0 ) p_heading=120;
		if (avertrack >=175.0 && avertrack<=245.0 ) p_heading=210;
		if (avertrack >=265.0 && avertrack<=335.0 ) p_heading=300;
		break;
	case 2:
		// wmode==2:  60 150 240 330
		if (avertrack >=25.0 && avertrack<=95.0 ) p_heading=60;
		if (avertrack >=115.0 && avertrack<=185.0 ) p_heading=150;
		if (avertrack >=205.0 && avertrack<=275.0 ) p_heading=240;
		if (avertrack >=295.0 || avertrack<=5.0 ) p_heading=330;
		break;
	default:
		FailStore(_T("INVALID WMODE WINDCALC: %d%s"),wmode,NEWLINE);
		return WCALC_INVALID_DATA;
		break;
   }


#else
  double p_heading=999;
  if (avertrack >=325.0 || avertrack<=35.0 ) p_heading=0;
  if (avertrack >=55.0 && avertrack<=125.0 ) p_heading=90;
  if (avertrack >=145.0 && avertrack<=215.0 ) p_heading=180;
  if (avertrack >=235.0 && avertrack<=305.0 ) p_heading=270;
#endif

  if (p_heading==999) {
  	#ifdef DEBUG_WCALC
	sprintf(ventabuffer,"Fail: GPS avertrack=%d INVALID HEADING \n",(int)avertrack);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
	#endif
	return WCALC_INVALID_HEADING;
  } 
  #ifdef DEBUG_WCALC
  else {
	sprintf(ventabuffer,"*** avertrack=%d presumed HEADING is %d \n",(int)avertrack,(int)p_heading);
	if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
	{;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
  }
  #endif
  #ifdef STORE_WCALC
  StartupStore(_T("... TrueWind: average track=%d , presumed heading to %d%s"),(int)avertrack,(int)p_heading, NEWLINE);
  #endif

  // Condor has its own wind precalculated: TrueWind will not cheat using read IAS
  #if TESTIASWITHCONDOR
  if (GPS_INFO.AirspeedAvailable && averias>0 ) iaspeed=averias;
  #else
  if (GPS_INFO.AirspeedAvailable && averias>0 && !devIsCondor(devA()) ) iaspeed=averias;
  #endif

  double tas=(iaspeed*TOKPH)*(1+0.02*(averaltitude/0.328/1000));

  double tasns=tas*cos( p_heading / RAD_TO_DEG );
  double tasew=tas*sin( p_heading / RAD_TO_DEG );

  double gsns=averspeed * cos(avertrack/ RAD_TO_DEG);
  double gsew=averspeed * sin(avertrack/ RAD_TO_DEG);

  double windns=gsns-tasns;
  double windew=gsew-tasew;

  double windsp=sqrt(pow(windns,2)+pow(windew,2));

  double windtmp=0;

  if (windns==0) windtmp=M_PI/2; else windtmp=atan(windew/windns);

  double q1=windtmp*RAD_TO_DEG;
  double q2=180+q1;
  double q3=q2;
  double q4=360+q1;
  double windto=0;
  if (windns>=0) {
	if ( windew>=0 )
		windto=q1;
	else
		windto=q4;
  }
  if (windns<0) {
	if ( windew>=0 )
		windto=q2;
	else
		windto=q3;
  }

  double windfrom=(windto-180)>0?windto-180:windto+180;
  if (windfrom==360) windfrom=0;

  #ifdef DEBUG_WCALC
  sprintf(ventabuffer,"ias=%.3f tas=%.3f tasns=%.3f tasew=%.3f gsns=%.3f gsew=%.3f\n windns=%.3f\
	windew=%.3f windsp=%.3f tmp=%.3f q1=%.3f q2=%.3f q3=%.3f q4=%.3f windto=%.3f windfrom=%.3f\n",
	iaspeed*TOKPH,tas, tasns, tasew, gsns, gsew, windns, windew, windsp, windtmp, q1, q2, q3,q4,windto, windfrom);
  if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
  #endif

  *wfrom=windfrom;
  *wspeed=windsp;

  #ifdef DEBUG_WCALC
  sprintf(ventabuffer,"*** Wind from %.0f deg/ %.0f kmh\n", windfrom, windsp);
  if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
  #endif
  #ifdef STORE_WCALC
  StartupStore(_T("... TrueWind: calculated wind from %.0f deg, %.0f km/h%s"), windfrom, windsp,NEWLINE);
  #endif

  // StartupStore(_T(".......gsq=%d tq=%d wcalc=%d  qual=%d\n"),gsquality,trackquality, windcalctime,
  // 						((gsquality+trackquality)*100) / (windcalctime*2)  );
  // return quality percentage: part/total *100 
  if (haveias) 
	return ( ((gsquality+trackquality+iasquality)*100) / (windcalctime*3) );
  else
	return ( ((gsquality+trackquality)*100) / (windcalctime*2) );


}


void SetOverColorRef() {
  switch(OverColor) {
	case OcWhite:
		OverColorRef=RGB_WHITE;
		break;
	case OcBlack:
		OverColorRef=RGB_SBLACK;
		break;
	case OcBlue:
		OverColorRef=RGB_DARKBLUE;
		break;
	case OcGreen:
		OverColorRef=RGB_GREEN;
		break;
	case OcYellow:
		OverColorRef=RGB_YELLOW;
		break;
	case OcCyan:
		OverColorRef=RGB_CYAN;
		break;
	case OcOrange:
		OverColorRef=RGB_ORANGE;
		break;
	case OcGrey:
		OverColorRef=RGB_GREY;
		break;
	case OcDarkGrey:
		OverColorRef=RGB_DARKGREY;
		break;
	case OcDarkWhite:
		OverColorRef=RGB_DARKWHITE;
		break;
	case OcAmber:
		OverColorRef=RGB_AMBER;
		break;
	case OcLightGreen:
		OverColorRef=RGB_LIGHTGREEN;
		break;
	case OcPetrol:
		OverColorRef=RGB_PETROL;
		break;
	default:
		OverColorRef=RGB_MAGENTA;
		break;
  }
}

// handle custom keys. Input: key pressed (center, left etc.)
// Returns true if handled successfully, false if not
bool CustomKeyHandler(const int key) {

  int ckeymode;
  static bool doinit=true;
  static int oldModeIndex;

  if (doinit) {
	oldModeIndex=LKMODE_INFOMODE;;
	doinit=false;
  }

  switch(key) {
	case CKI_BOTTOMCENTER:
		ckeymode=CustomKeyModeCenter;
		break;
	case CKI_BOTTOMLEFT:	
		ckeymode=CustomKeyModeLeft;
		break;
	case CKI_BOTTOMRIGHT:	
		ckeymode=CustomKeyModeRight;
		break;
	case CKI_BOTTOMICON:	
		ckeymode=CustomKeyModeAircraftIcon;
		break;
	case CKI_TOPLEFT:
		ckeymode=CustomKeyModeLeftUpCorner;
		break;
	case CKI_TOPRIGHT:
		ckeymode=CustomKeyModeRightUpCorner;
		break;
	default:
		DoStatusMessage(_T("ERR-725 UNKNWOWN CUSTOMKEY"));
		return false;
		break;
  }

  switch(ckeymode) {
	case ckDisabled:
		break;
	case ckMenu:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		ShowMenu();
		return true;
	case ckBackMode:
		PreviousModeIndex();
		MapWindow::RefreshMap();
		SoundModeIndex();
		return true;
	case ckToggleMap: //TODO
		if (ModeIndex==LKMODE_MAP)
			SetModeIndex(oldModeIndex);
		else {
			oldModeIndex=ModeIndex;
			SetModeIndex(LKMODE_MAP);
		}
		MapWindow::RefreshMap();
		SoundModeIndex();
		return true;

	case ckTrueWind:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		InputEvents::setMode(_T("TrueWind"));
//		MenuTimeOut = 0;
//		DisplayTimeOut = 0;
		return true;

	case ckTeamCode:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		InputEvents::eventSetup(_T("Teamcode"));
		return true;

	case ckToggleOverlays:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		ToggleOverlays();
		return true;

	case ckToggleMapLandable:
		if (ModeIndex==LKMODE_MAP)
			SetModeIndex(LKMODE_WP);
		else
			SetModeIndex(LKMODE_MAP);
		MapWindow::RefreshMap();
		SoundModeIndex();
		return true;
	case ckLandables:
		SetModeIndex(LKMODE_WP);
		MapWindow::RefreshMap();
		SoundModeIndex();
		return true;
	case ckToggleMapCommons:
		if (ModeIndex==LKMODE_MAP)
			SetModeIndex(LKMODE_NAV);
		else
			SetModeIndex(LKMODE_MAP);
		MapWindow::RefreshMap();
		SoundModeIndex();
		return true;
	case ckCommons:
		SetModeIndex(LKMODE_NAV);
		MapWindow::RefreshMap();
		SoundModeIndex();
		return true;
	case ckToggleMapTraffic:
		if (ModeIndex==LKMODE_MAP)
			SetModeIndex(LKMODE_TRF);
		else
			SetModeIndex(LKMODE_MAP);
		MapWindow::RefreshMap();
		SoundModeIndex();
		return true;
	case ckTraffic:
		SetModeIndex(LKMODE_TRF);
		MapWindow::RefreshMap();
		SoundModeIndex();
		return true;
	case ckInvertColors:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		InputEvents::eventInvertColor(NULL);
		return true;
	// Only used for aircraft icon
	case ckToggleInfobox:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_BELL"));
		#endif
		MapWindow::RequestToggleFullScreen();
		return true;
	case ckTimeGates:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		InputEvents::eventTimeGates(NULL);
		return true;
	case ckMarkLocation:
		InputEvents::eventMarkLocation(_T(""));
		return true;
	case ckAutoZoom:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		InputEvents::eventZoom(_T("auto toggle"));
		InputEvents::eventZoom(_T("auto show"));
		return true;
	case ckActiveMap:
		InputEvents::eventActiveMap(_T("toggle"));
		InputEvents::eventActiveMap(_T("show"));
		return true;
	case ckBooster:
		DoStatusMessage(_T("FEEL THE THERMAL"));
		if (EnableSoundModes) LKSound(_T("LK_BOOSTER.WAV"));
		return true;
	case ckGoHome:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		if (ValidWayPoint(HomeWaypoint)) {
			if ( (ValidTaskPoint(ActiveWayPoint)) && (Task[ActiveWayPoint].Index == HomeWaypoint )) {
				DoStatusMessage(gettext(TEXT("Already going home")));
			} else {
				GotoWaypoint(HomeWaypoint);
			}
		} else
			DoStatusMessage(gettext(TEXT("No Home to go!")));
		return true;
	case ckPanorama:
		if (PGZoomTrigger==false)
			PGZoomTrigger=true;
		else
			LastZoomTrigger=0;
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		return true;

	case ckMultitargetRotate:
		RotateOvertarget();
		return true;

	case ckMultitargetMenu:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		InputEvents::setMode(_T("MTarget"));
		return true;
	case ckBaroToggle:
		ToggleBaroAltitude();
		return true;
	case ckBasicSetup:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		InputEvents::eventSetup(_T("Basic"));
		return true;
	case ckSimMenu:
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		InputEvents::setMode(_T("SIMMENU"));
		return true;
	default:
		DoStatusMessage(_T("ERR-726 INVALID CUSTOMKEY"));
		FailStore(_T("ERR-726 INVALID CUSTOMKEY=%d"),ckeymode);
		break;
  }

  return false;

}

// set Climb and Cruis MapScale accordingly to PGClimbZoom, everytime it changes.
// Needed to avoid software restart to bypass doinit in MapWindow
void SetMapScales() {

  if (ISPARAGLIDER) {
	CruiseMapScale = MapWindow::RequestMapScale;

	switch(PGClimbZoom) {
		case 0:
			ClimbMapScale = 0.05;
			break;
		case 1:
			ClimbMapScale = 0.07;
			break;
		case 2:
			ClimbMapScale = 0.09;
			break;
		case 3:
			ClimbMapScale = 0.14;
			break;
		case 4:
		default:
			ClimbMapScale = 0.03;
			break;
	}
  } else {
	CruiseMapScale = MapWindow::RequestMapScale*2;
	ClimbMapScale = MapWindow::RequestMapScale/20;
  }

}

#ifdef PNA
bool LoadModelFromProfile()
{

  TCHAR tmpTbuf[MAX_PATH*2];
  char  tmpbuf[MAX_PATH*2];

  LocalPath(tmpTbuf,_T(LKD_CONF));
  _tcscat(tmpTbuf,_T("\\"));
  _tcscat(tmpTbuf,_T(XCSPROFILE));

  StartupStore(_T(". Searching modeltype inside default profile <%s>%s"),tmpTbuf,NEWLINE);

  FILE *fp=NULL;
  sprintf(tmpbuf,"%S",tmpTbuf);
  fp = fopen(tmpbuf, "rb");
  if(fp == NULL) {
	StartupStore(_T("... No default profile found%s"),NEWLINE);
	return false;
  }

  while (fgets(tmpbuf, (MAX_PATH*2)-1, fp) != NULL ) {

	if (strlen(tmpbuf)<21) continue;

	if (strncmp(tmpbuf,"AppInfoBoxModel",15) == 0) {
		int val=atoi(&tmpbuf[16]);
		GlobalModelType=val;
		SetModelName(val);
		StartupStore(_T("... ModelType found: <%s> val=%d%s"),GlobalModelName,GlobalModelType,NEWLINE);
		fclose(fp);
		return true;
	}
  }

  StartupStore(_T(". Modeltype not found in profile, probably Generic PNA is used.\n"));
  fclose(fp);
  return false;
}
#endif

#ifdef PNA
void CreateRecursiveDirectory(TCHAR *fullpath)
{
  TCHAR tmpbuf[MAX_PATH];
  TCHAR *p;
  TCHAR *lastslash;
  bool found;
  
  if ( _tcslen(fullpath) <10 || _tcslen(fullpath)>=MAX_PATH) {
	StartupStore(_T("... FontPath too short or too long, cannot create folders%s"),NEWLINE);
	return;
  }

  if (*fullpath != '\\' ) {
	StartupStore(TEXT("... FontPath <%s> has no leading backslash, cannot create folders on a relative path.%s"),fullpath,NEWLINE);
	return;
  }

  lastslash=tmpbuf;

  do {
	// we copy the full path in tmpbuf as a working copy 
	_tcscpy(tmpbuf,fullpath);
	found=false;
	// we are looking after a slash. like in /Disk/
	// special case: a simple / remaining which we ignore, because either it is the first and only (like in \)
	// or it is a trailing slash with a null following
	if (*(lastslash+1)=='\0') {
		break;
	}
	
	// no eol, so lets look for another slash, starting from the char after last
	for (p=lastslash+1; *p != '\0'; p++) {
		if ( *p == '\\' ) {
			*p='\0';
			found=true;
			lastslash=p;
			break;
		}
	}
	if (_tcscmp(tmpbuf,_T("\\Windows"))==0) {
		continue;
	}
	CreateDirectory(tmpbuf, NULL);
  } while (found);
			
  return;
}
#endif


#if OVERTARGET
// return current overtarget waypoint index, or -1 if not available
int GetOvertargetIndex(void) {
  int index;
  switch (OvertargetMode) {
	case OVT_TASK: // task 
		if ( ValidTaskPoint(ActiveWayPoint) != false ) {
			index = Task[ActiveWayPoint].Index;
			if ( index >=0 ) return index;
		}
		return -1;
		break;
	case OVT_ALT1: // alternate 1
		if ( ValidWayPoint(Alternate1) != false ) {
			index = Alternate1;
			if ( index >=0 ) return index;
		}
		return -1;
		break;
	case OVT_ALT2: // alternate 2
		if ( ValidWayPoint(Alternate2) != false ) {
			index = Alternate2;
			if ( index >=0 ) return index;
		}
		return -1;
		break;
	case OVT_BALT: // bestalternate
		if ( ValidWayPoint(BestAlternate) != false ) {
			index = BestAlternate;
			if ( index >=0 ) return index;
		}
		return -1;
		break;
	case OVT_HOME: // home waypoint
		if (ValidNotResWayPoint(HomeWaypoint)) {
			index = HomeWaypoint;
			if ( index >=0 ) return index;
		}
		return -1;
		break;

	case OVT_THER:
		index=RESWP_LASTTHERMAL;
		if (ValidResWayPoint(index)) return index;
		return -1;
		break;

	case OVT_MATE:
		index=RESWP_TEAMMATE;
		if (ValidResWayPoint(index)) return index;
		return -1;
		break;

	case OVT_FLARM:
		index=RESWP_FLARMTARGET;
		if (ValidResWayPoint(index)) return index;
		return -1;
		break;

	// 4: home, 5: traffic, 6: mountain pass, last thermal, etc.
	default:
		return -1;
		break;
  }
}

// return current overtarget waypoint name with leading identifier, even if empty
// exception for TEAM MATE: always report OWN CODE if available
void GetOvertargetName(TCHAR *overtargetname) {
  int index;
  if (OvertargetMode == OVT_MATE) {
	if (ValidWayPoint(TeamCodeRefWaypoint)) {
		if (TeammateCodeValid)
			_stprintf(overtargetname,_T("%s> %s"), GetOvertargetHeader(),CALCULATED_INFO.OwnTeamCode);
		else
			_stprintf(overtargetname,_T("%s: %s"), GetOvertargetHeader(),CALCULATED_INFO.OwnTeamCode);
	} else
		_stprintf(overtargetname,_T("%s ---"),GetOvertargetHeader());
	return;
  }
  index=GetOvertargetIndex();
  if (index<0)
	_stprintf(overtargetname,_T("%s ---"),GetOvertargetHeader());
  else 
	_stprintf(overtargetname,_T("%s%s"), GetOvertargetHeader(),WayPointList[index].Name);
}

// return current overtarget header name
TCHAR *GetOvertargetHeader(void) {
  static bool doinit=true;
  // Maxmode + 1 because maxmode does not account pos 0
  static TCHAR targetheader[OVT_MAXMODE+1][4];

  if (doinit) {
	_tcscpy(targetheader[OVT_TASK],_T("T>"));
	_tcscpy(targetheader[OVT_BALT],_T("B>"));
	_tcscpy(targetheader[OVT_ALT1],_T("1>"));
	_tcscpy(targetheader[OVT_ALT2],_T("2>"));
	_tcscpy(targetheader[OVT_HOME],_T("H>"));
	_tcscpy(targetheader[OVT_THER],_T("L>"));
	_tcscpy(targetheader[OVT_MATE],_T("M"));
	_tcscpy(targetheader[OVT_FLARM],_T("F>"));

	doinit=false;
  }

  return(targetheader[OvertargetMode]);
}

void RotateOvertarget(void) {

  OvertargetMode++;
  if (ISPARAGLIDER) {
	if (OvertargetMode==OVT_BALT) OvertargetMode++;
  }

  if (OvertargetMode==OVT_FLARM) {
	if (!GPS_INFO.FLARM_Available) OvertargetMode++;
  }

  if (OvertargetMode>OVT_ROTATE) {
	OvertargetMode=OVT_TASK;
  }
  #ifndef DISABLEAUDIO
  if (EnableSoundModes) {
	switch(OvertargetMode) {
		case 0:
			PlayResource(TEXT("IDR_WAV_OVERTONE7"));
			break;
		case 1:
			PlayResource(TEXT("IDR_WAV_OVERTONE0"));
			break;
		case 2:
			PlayResource(TEXT("IDR_WAV_OVERTONE1"));
			break;
		case 3:
			PlayResource(TEXT("IDR_WAV_OVERTONE2"));
			break;
		case 4:
			PlayResource(TEXT("IDR_WAV_OVERTONE3"));
			break;
		case 5:
			PlayResource(TEXT("IDR_WAV_OVERTONE4"));
			break;
		case 6:
			PlayResource(TEXT("IDR_WAV_OVERTONE5"));
			break;
		case 7:
			PlayResource(TEXT("IDR_WAV_OVERTONE6"));
			break;
		case 8:
			PlayResource(TEXT("IDR_WAV_OVERTONE7"));
			break;
		default:
			PlayResource(TEXT("IDR_WAV_OVERTONE5"));
			break;
	}
  }
  #endif
  return;

}

#endif

//
void ToggleOverlays() {
  static int oldLook8000;
  static bool doinit=true;

  if (doinit) {
	if (Look8000 == (Look8000_t)lxcNoOverlay)
		oldLook8000=(Look8000_t)lxcAdvanced;
	else
		oldLook8000=Look8000;
	doinit=false;
  }

  if (Look8000>lxcNoOverlay)
	Look8000=lxcNoOverlay;
  else
	Look8000=oldLook8000;

}
@


8.30
log
@*** empty log message ***
@
text
@d2 3
a4 1
Copyright_License {
d6 1
a6 32
  XCSoar Glide Computer - http://xcsoar.sourceforge.net/
  Copyright (C) 2000 - 2008  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  $Id: Utils2.cpp,v 8.29 2010/02/16 01:21:34 root Exp root $
}
a8 3
/*
#include <string.h>
*/
d165 1
a165 1
	///: 100908 insert IAS in the rotary buffer, either real or estimated
d187 1
a187 1
int CalculateLDRotary(ldrotary_s *buf, DERIVED_INFO *Calculated ) {
d192 2
a193 1
	int altdiff, eff;
d200 2
a201 2
	double sinkias, sinkmc0;
	int averias;
d211 1
a211 1
		///: StartupStore(_T("... Circling or grounded, EqMc -2 (---)\n"));
d224 1
a224 1
		///: StartupStore(_T("... Invalid buf start, EqMc -2 (---)\n"));
d236 1
a236 1
			///: StartupStore(_T("... bc.valid is false, EqMc -2 (---)\n"));
d253 20
a272 39
	///: StartupStore(_T("... bcold=%d bcstart=%d  old-start=%d\n"), bcold, bc.start, bcold-bc.start); // REMOVE
	if ( bc.valid == true ) {
			///: it should NOT happen, but we check it for safety
			if (bc.size>0) {
				averias = (int)(bc.totalias/bc.size);
				///:  No, rough air is too low.
				///: if (averias >(int)SAFTEYSPEED) averias=(int)SAFTEYSPEED; 

				///: this is the expected sink for this IAS, not the MC.. we still need to
				///: subtract the MC0 sink rate. This value is negative, m/s and we want it positive
				sinkias=-1*(GlidePolar::sinkratecache[averias]);
				sinkmc0=GlidePolar::sinkratecache[GlidePolar::Vbestld];
				///: sinkmc0 is negative, since we want to subtract it from sinkias it is ok to add it as negative
				///:LockTaskData();
				if (sinkias+sinkmc0 <0.07)
					Calculated->EqMc = 0.0;
				else
					Calculated->EqMc = sinkias+sinkmc0;
				///: UnlockTaskData();
				///: REMOVE TODO 100908
				///: StartupStore(_T(".. eMC=%.2f =%.1f  Averias=%d kmh, sinkias=%.1f ms  sinkmc0=%.1f ms SAFTEY=%.1f\n"),
				///:	Calculated->EqMc, Calculated->EqMc, (int)(averias*TOKPH),sinkias, sinkmc0, SAFTEYSPEED);

				///: -------------------------
				///: UNUSED REMOVE
				///: realsink=(double)altdiff / (double)bc.size;
				///: //sinkmin is negative
				///: sinkmin=GlidePolar::sinkratecache[GlidePolar::Vminsink];
				///: StartupStore(_T("... realsink=%.1f sinkmin=%.1f \n"),realsink, sinkmin );
				///: StartupStore(_T("........... eMC=%.1f rMC=%.1f\n\n"),sinkias, realsink+sinkmin);
				///:if ( (realsink+sinkmin)<0) {
				///:	CALCULATED_INFO.EqMc = -1;
				///:	StartupStore(_T("... eMC= OO POSITIVE AIRMASS\n"));
				///:} else {
				///:	CALCULATED_INFO.EqMc = realsink+sinkmin;
				///:	StartupStore(_T("... eMC=%.1f\n"), realsink + sinkmin);
				///:}
				///: -------------------------
			}
d279 1
a279 1
	eff= bc.totaldistance / altdiff;
a316 1
  ///: short i,curs,nc,iter; 091007 REMOVE unused curs
d400 2
a401 2
///: vkmode 0=normal 1=gesture up 2=gesture down
///: however we consider a down as up, and viceversa
d436 1
a436 1
		///: bottomline does not exist when infoboxes are painted, so we can make it static
d439 1
a439 1
		///: 090930 calculate left and right starting from center
a441 2
		///: s_xleft=(s_sizeright-AIRCRAFTMENUSIZE)/3-IBLSCALE(6); // 3 was original, 15 was too much
		///: s_xright=s_sizeright-AIRCRAFTMENUSIZE-s_xleft; 
d443 1
a443 1
		///: same for bottom navboxes: they do not exist in infobox mode
d455 2
a456 2
	///: do not consider navboxes, they are processed separately
	///: These are coordinates for up down center VKs
d473 2
a474 3
	///: Handle fullscreen 8000 mode 
	///: sound clicks require some attention here
	///: if (NewMap &&  DrawBottom && vkmode==LKGESTURE_NONE) { // 100320 BUGFIX
d476 3
a478 4
		///:
		///: CLICKS on NAVBOXES, any MapSpaceMode ok
		///:
		//if (Y>= (sizeup-BottomSize-IBLSCALE(2)) ) { // bugfix era 15, troppo 
a487 3

			///: We might in the future handle long presses also here to gain 3 more buttons
			///: 100511 WE DO, now!
d489 1
a489 1
				///: 100511 standard configurable mode
d491 2
a492 2
					///: 2 is right key
					if (CustomKeyHandler(2)) return 0;
a516 1
				///: 100511 standard configurable mode
d518 2
a519 2
					///: 1 is left key
					if (CustomKeyHandler(1)) return 0;
d567 4
a570 20
			///:
			///: VIRTUAL CENTER KEY HANDLING
			///:

			///: long press on center navbox currently used only for test purposes
#if (0)
			///: Force immediate recall of moving map page
			if (keytime>600) { // VNT10 090909 300>600ms timing
				///: reset default page
				MapSpaceMode=MSM_MAP; // TODO FIX HERE!!!!
				#ifndef DISABLEAUDIO
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
				#endif
				MapWindow::RefreshMap();
				return 0;
			}
#endif



d572 1
a572 1
			///: Output NMEA to device
d583 1
a583 1
			///: Simulate incoming NMEA string, with correct checksum
a586 1
				//wsprintf(mbuf,_T("$GPGLL,4050.04704,N,00836.45176,W,113015.00,A,A*76\n")); NONVA
d593 1
a593 1
			///: Print a message on the screen for debugging purposes
d606 4
a609 6
#if (1)
			///: 100511 standard configurable mode
			if (keytime >=CustomKeyTime) {
				///: 0 is center key
				if (CustomKeyHandler(0)) return 0;
/* REMOVE 100511
d611 2
a612 3
	                        if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
	                        #endif
				ShowMenu();
a613 1
*/
d616 8
d625 2
a626 2
			///: normally, we fall down here.
			///: If CustomKeyHandler returned false, back as well here (nothing configured in custom).
d632 1
a632 1
		///: End click on navboxes 
d634 1
a634 1
		///: CLICK ON SORTBOX line at the top, only with no map and only for nearest
d638 2
a639 2
			///: only search for 1-3, otherwise it's the fourth (fifth really)
			///: we don't use 0 now
d664 1
a664 1
							///: 100404 force immediate resorting
d679 1
a679 1
		///: end sortbox
d681 1
a681 1
	///: end newmap  with no gestures
d684 2
a685 2
	///: REAL virtual keys
	///: Emulate real keypresses with wParam
d687 1
a687 1
	///: UP gesture
d689 1
a689 1
		///: do not handle gestures outside mapspacemode
d691 1
a691 1
			///: DoStatusMessage(_T("DBG-033 gesture not used here"));
d702 2
a703 2
						///: warning. Commons and Recents share the same variable!
						numpages=CommonNumpages;	// BUGFIX 090915
d722 1
a722 1
			///: SCROLL DOWN
d724 1
a724 1
				///: careful, selectedpage starts from 0
d738 1
a738 1
			///: SCROLL UP
d796 1
a796 1
		///: we are processing up/down in mapspacemode i.e. browsing waypoints on the page
d799 1
a799 1
				///: DoStatusMessage(_T("DBG-032-A event up not used here"));
d808 1
a808 1
			///: DoStatusMessage(_T("DBG-032-B event up used here"));
d838 1
a838 1
	///: no click for already clicked events
d840 1
a840 1
	///:  Swap white and black colours on LK8000 
d847 1
a847 1
			///: TODO CHECK EXPERIMENTAL
a848 10
/*
			if (EnableLogNMEA==true) {
				DoStatusMessage(_T("NMEA LOG DISABLED"));
				EnableLogNMEA=false;
			} else {
				DoStatusMessage(_T("NMEA LOG ENABLED"));
				EnableLogNMEA=true;
			}
*/

d858 1
a858 1
		///: If in mapspacemode process ENTER 
d867 1
a867 1
		///: do not process enter in panmode, unused
d874 6
a879 14
///: 031009 disabled, moved to MapWindow
#if 0	
		///: If in in moving map and paraglider, trap virtual enter screen on map and zoom 5km 091111
#if _SIM_
		///: 091221 in Pan mode, SIM mode, paragliders do not have this function as the vk is used for centering on map
		if ( (keytime>=(VKSHORTCLICK*2)) && ISPARAGLIDER && !MapWindow::EnablePan) {
#else
		if ( (keytime>=(VKSHORTCLICK*2)) && ISPARAGLIDER) {
#endif
			PGZoomTrigger=true;
			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
			MapWindow::RefreshMap();
d882 1
a882 2
#endif // zoomout for paragliders

d887 1
a887 1
		///: if we want to emulate a return key, return 13;
d890 1
d949 2
a950 2
	///: 091117 remember: changing values here may need cosmetic changes in InfoBoxLayout where
	///: BottomSize is set manually... *UPDATE> apparently no more since december 09
d961 2
a962 1
		propGetFontSettingsFromString(TEXT("50,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);	// 46 600
d1005 2
a1006 1
		propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
d1008 1
a1008 1
		///: propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig); changed 100910
d1014 1
d1024 1
d1028 2
a1029 1
			propGetFontSettingsFromString(TEXT("30,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
d1033 1
a1033 1
		}
d1041 1
a1041 1
		///: propGetFontSettingsFromString(TEXT("38,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig); changed 100910
d1048 23
d1081 1
d1091 1
d1099 1
a1099 1
		}
d1114 2
a1115 2
	///: Units are too big, tahoma is not enough. Units are disabled by default.
	///: This is also used by 640x480 devices actually, if SE_VGA is not disabled
d1122 1
a1122 2
		///: propGetFontSettingsFromString(TEXT("31,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig); 122b
		propGetFontSettingsFromString(TEXT("32,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
d1127 1
d1138 1
a1141 1
			///: propGetFontSettingsFromString(TEXT("23,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget); 100824
d1145 2
a1146 2
			BottomSize=34; // Title+Value-4
		}
d1167 1
d1178 1
d1186 1
a1186 1
		}
d1216 3
a1218 1
		} else {		
d1227 1
d1238 1
a1238 3
	///://////////////////////////////////////////////////////////
	///://///////////       Portrait  mode        ////////////////
	///://////////////////////////////////////////////////////////
d1240 4
a1243 1
	case (ScreenSize_t)ss240x320:		// PASSED DEV-1 090701 VENTA
d1245 1
d1247 1
a1247 1
			propGetFontSettingsFromString(TEXT("29,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
d1249 1
a1249 1
			propGetFontSettingsFromString(TEXT("29,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
d1254 12
d1275 1
d1285 4
a1288 2
		} else {
			///: Splitter 4
d1301 1
d1307 1
a1307 1
		propGetFontSettingsFromString(TEXT("24,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);
d1309 1
a1309 1
		propGetFontSettingsFromString(TEXT("24,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig);
d1313 52
a1364 1
		propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
d1366 3
d1371 3
d1375 1
d1385 3
a1387 1
		if (splitter==6) { // unused
d1395 16
a1410 2

		} else {		
d1424 1
a1424 1
		propGetFontSettingsFromString(TEXT("49,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig); 
d1426 1
a1426 1
		propGetFontSettingsFromString(TEXT("49,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig); 
d1430 1
a1430 1
		propGetFontSettingsFromString(TEXT("20,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelUnit); 
d1434 3
d1438 1
d1440 1
a1440 1
		propGetFontSettingsFromString(TEXT("60,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontBig);
d1442 1
a1442 1
		propGetFontSettingsFromString(TEXT("60,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
d1448 10
d1467 2
a1468 1
		} else {		
d1477 1
d1483 1
a1483 1
		propGetFontSettingsFromString(TEXT("49,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig); 
d1485 1
a1485 1
		propGetFontSettingsFromString(TEXT("49,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig); 
a1519 2
  //logfontTarget.lfQuality = CLEARTYPE_COMPAT_QUALITY; ///  TEST FIX
  //logfontBig.lfQuality = CLEARTYPE_COMPAT_QUALITY; 
a1578 11
/*
  HDC dc;
  dc = ::GetDC(NULL);
  int dpix = ::GetDeviceCaps(dc,LOGPIXELSX);
  int dpiy = ::GetDeviceCaps(dc,LOGPIXELSY);
  char ventabuffer[200];
  FILE *fp;
  sprintf(ventabuffer,"screensize get =%d %d dpix=%d dpiy=%d\r\n",iWidth,iHeight,dpix,dpiy);
  if ((fp=fopen("DEBUG.TXT","a"))!= NULL) {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
*/

a1586 1
  ///: 100425
d1597 1
d1601 1
a1601 1
#if ( (WINDOWSPC==0) || ((WINDOWSPC>0)&&_REALTHING_))  // 091205
a1606 1
#endif
a1624 1
///: VNT need some different initialisations for para, delta, etc.
d1631 2
a1681 1
		///: MapWindow::MapScaleOverDistanceModify = 0.2/DISTANCEMODIFY;
a1683 5
/* 091108
		MapWindow::RequestMapScale = 0.17;  // 091108 was 0.3
		MapWindow::MapScale = 0.17;	// ditto
		MapWindow::MapScaleOverDistanceModify = 0.2/DISTANCEMODIFY;
*/
d1697 1
a1697 1
///: Requires restart if activated from config menu!
a1701 1
///:	if ( !(NewMap&&Look8000)) return; 100513 always on!
d1705 2
a1706 2
		///: Normal alternates forced on for LK8000. In MapWindow3 if not valid they WERE reset off
		///: Currently in lk8000 they should be all the times on, calculation time is irrelevant
d1712 1
a1712 2
	///: By default, h=v=size/6 and here we set it better
	///: 100513 wdlgConfig
d1717 1
a1717 1
			///: dscale=480/240=2  800/dscale=400 -(70+2+2)=  326 x dscale = 652
d1723 1
a1723 1
			///: dscale=240/240=1  400/dscale=400 -(70+2+2)=  326 x dscale = 326
d1729 1
a1729 1
			///: dscale=480/240=2  640/dscale=320 -(70+2+2)=  246 x dscale = 492
d1735 1
a1735 1
			///: dscale=672/240=2.8  896/dscale=320 -(70+2+2)=  246 x dscale = 689
d1741 1
a1741 1
			///: dscale=272/240=1.133  480/dscale=424 -(70+2+2)=  350 x dscale = 397
d1743 6
a1748 1
			///:LKwdlgConfig=390;  when X=80
d1753 1
a1753 1
			///: dscale=234/240=0.975  480/dscale=492 -(70+2+2)=  418 x dscale = 407
d1759 2
a1760 2
			///: dscale=240/240=1  320/dscale=320 -(70+2+2)=  246 x dscale = 246
                        ///: but 246 is too long..
d1763 1
a1763 1
		///: PORTRAIT MODES
d1771 1
a1771 1
			///: dscale=240/240=1  400/dscale=400 -(70+2+2)=  326 x dscale = 326
a1783 4
       // GaugeFLARM::ForceVisible=true;

	//wsprintf(NearestAirspaceName,_T(""));

d1803 1
a1803 1
		        PlayResource(TEXT("IDR_WAV_BEEPBWEEP"));
d1810 1
a1810 3
///:
///: colorcode is taken from a 5 bit AsInt union
///:
a1922 4
///: Retrieve from the registry the previous set model type
///: This value is defined in xcsoar.h , example> MODELTYPE_PNA_HP31X
///: is equivalent to a value=10201 (defined in the header file)
///:
d1932 1
a1932 1
	_stprintf(sTmp,_T("... SetModelType failed: probably no registry entry%s"), NEWLINE);
d2283 1
a2283 3
///:
///: This will NOT be called from PC versions
///:
d2289 1
d2298 3
a2300 2
  StartupStore(_T(". Welcome to InstallSystem v1.1%s"),NEWLINE);
  //_stprintf(srcdir,TEXT("%s%S\\Fonts"),gmfpathname(), XCSDATADIR ); // TESTFIX 091001 REMOVE
a2302 2
  // _stprintf(dstdir,TEXT("\\Windows")); 091118 REMOVE

d2305 3
a2307 3
  ///: 091118 search for the main system directory on the real device
  ///: Remember that SHGetSpecialFolder works differently on CE platforms, and you cannot check for result.
  ///: We need to verify if directory does really exist.
a2319 1

d2323 3
a2325 3
  ///: We now test for a single file existing inside the directory, called _DIRECTORYNAME
  ///: because GetFileAttributes can be very slow or hang if checking a directory. In any case testing a file is 
  ///: much more faster.
d2333 2
a2334 2
	StartupStore(_T("------ InstallSystem ERROR could not find valid source directory <%s>%s"),srcdir,NEWLINE); // 091104
	StartupStore(_T("------ Missing file <%s>%s"),srcfile,NEWLINE);
a2340 3
  ///:
  ///: 091119 the GetFileAttributes hangs on some devices testing a directory, maybe a mingw problem
  ///: 
a2371 2
  /// if (  GetFileAttributes(dstdir) != FILE_ATTRIBUTE_DIRECTORY) { BUGFIX 091118 REMOVE

d2396 1
a2396 1
			StartupStore(_T("...... GRecordDll.dll installed using <%s>. Great.%s"),srcfile,NEWLINE);
d2410 1
a2410 1
			_stprintf(dstfile,TEXT("%s\\FLY.lnk"),dstdir);
d2421 1
d2434 1
d2477 1
a2477 2
  ///: 091109 we are shure that \Windows does exist already.
  // _stprintf(dstdir,TEXT("\\Windows\\Fonts"));  091118 not really!!
d2479 1
d2481 18
d2507 1
d2512 2
a2513 1
  ///: 100820 on PNAs sometimes FolderPath is reported correctly, but the directory is not existing!
a2515 22
/* ******* 091119 this does not work correctly due to GetFileAttributes problems *****

  /// if (  GetFileAttributes(dstdir) != FILE_ATTRIBUTE_DIRECTORY) { 091118
  if (  GetFileAttributes(dstdir) == 0xffffffff ) {
	StartupStore(_T("------ InstallSystem cannot find target directory <%s>%s"),dstdir,NEWLINE);
	StartupStore(_T("------ InstallSystem will try to create it%s"),NEWLINE);
	///CreateDirectoryIfAbsent(TEXT("\\Windows\\Fonts")); // 091109
	CreateDirectory(dstdir); // 091118    this is actually missing NULL param

	// if (  GetFileAttributes(dstdir) != FILE_ATTRIBUTE_DIRECTORY) { 091118
	if (  GetFileAttributes(dstdir) == 0xffffffff ) {
		StartupStore(_T("++++++ CRITIC: InstallSystem could not create Fonts directory%s"),NEWLINE);
		StartupStore(_T("++++++ Error code was: %ld%s"),GetLastError(),NEWLINE);
		StartupStore(_T("++++++ Fonts will NOT be installed, NOT good!%s"),NEWLINE);
		return 5; // 091109
	} else {
		StartupStore(_T("------ InstallSystem created Fonts directory, OK\n"));
	}
  } else {
	StartupStore(_T(". InstallSystem: Font directory <%s> is valid%s"),dstdir,NEWLINE);
  }
 *************************** */
d2517 2
a2518 5
  ///: 091119 we cannot check directory existance without the risk of hanging for many seconds
  ///: we can only rely on singe real file existance, not on directories


  ///: #ifdef PNA		091104 copy TAHOMA fonts also for PDAS (but not for PC)
d2520 1
d2522 1
d2535 2
a2536 8
  ///: 100825 not needed, cannot overwrite tahoma while in use! Tahoma bold not used for some reason in this case.
  #if 0
  #ifdef PNA // 100824
  ///: 100824 On PNAs copy fonts also inside Windows
  _tcscpy(dstdir,maindir);
  CopyFile(srcfile,dstfile,TRUE);
  #endif
  #endif
d2538 1
d2540 1
d2553 2
a2554 6
  #if 0
  #ifdef PNA // 100824
  ///: 100824 On PNAs copy fonts also inside Windows
  _tcscpy(dstdir,maindir);
  CopyFile(srcfile,dstfile,TRUE);
  #endif
a2556 35
  ///: #endif

#if 0 // 100909 do not copy DejaVu fonts anymore
  _stprintf(srcfile,TEXT("%s\\DejaVuSansCondensed2.ttf"),srcdir);
  _stprintf(dstfile,TEXT("%s\\DejaVuSansCondensed2.ttf"),dstdir);

  //if (  GetFileAttributes(srcfile) != FILE_ATTRIBUTE_NORMAL) return 3;

  if (  GetFileAttributes(dstfile) != 0xffffffff ) {
	StartupStore(_T(". DejaVu fonts already installed on device%s"),NEWLINE);
	return 0;
  }
  if ( !CopyFile(srcfile, dstfile, TRUE)) {
	StartupStore(_T("--- Could not copy DejaVu fonts for some reason%s"),NEWLINE);
	StartupStore(_T("--- Error code was: %ld%s"),GetLastError(),NEWLINE);
	return 5;
  }

  // From now on we attempt to copy without overwriting
  _stprintf(srcfile,TEXT("%s\\DejaVuSansCondensed-Bold2.ttf"),srcdir);
  _stprintf(dstfile,TEXT("%s\\DejaVuSansCondensed-Bold2.ttf"),dstdir);
  CopyFile(srcfile,dstfile,TRUE);

  _stprintf(srcfile,TEXT("%s\\DejaVuSansCondensed-BoldOblique2.ttf"),srcdir);
  _stprintf(dstfile,TEXT("%s\\DejaVuSansCondensed-BoldOblique2.ttf"),dstdir);
  CopyFile(srcfile,dstfile,TRUE);

  _stprintf(srcfile,TEXT("%s\\DejaVuSansCondensed-Oblique2.ttf"),srcdir);
  _stprintf(dstfile,TEXT("%s\\DejaVuSansCondensed-Oblique2.ttf"),dstdir);
  CopyFile(srcfile,dstfile,TRUE);
#endif


  StartupStore(_T(". InstallSystem completed OK%s"),NEWLINE);

a2560 4
/*
 * Check that XCSoarData exist where it should be
 * Return false if error, true if Ok
 */
d2562 7
a2568 1
	TCHAR srcdir[MAX_PATH];
d2570 12
a2581 6
//	_stprintf(srcdir,TEXT("%s%S"),gmfpathname(), XCSDATADIR ); // TESTFIX 091001 REMOVE
	LocalPath(srcdir);
	StartupStore(_T(". CheckDataDir <%s>%s"),srcdir,NEWLINE); // 091109
	///: TODO 091118 use file existance, not directory existance
	if (  GetFileAttributes(srcdir) != FILE_ATTRIBUTE_DIRECTORY) return false;
	return true;
a2583 8
/*
 * Check for xcsoar-registry.prf  existance
 * Should really check if geometry has changed.. in 5.2.3!
 * Currently we disable it for HP31X which is the only PNA with different settings
 * for different geometries
 * 5.2.3 BOOL changed to bool
 * TODO: VENTA4 now that Rob fonts is used, should return false all the way
 */
a2586 2
//	_stprintf(srcpath,TEXT("%s%S\\%S"),gmfpathname(), XCSDATADIR , XCSPROFILE); // TESTFIX 091001 REMOVE
	///: LocalPath(srcpath,TEXT(XCSPROFILE)); // TESTFIX 091101 REMOVE
d2636 3
a2638 4
///:
///: Conversion between submenus and global mapspace modes 
///: Basic initialization of global variables and parameters.
///:
d2649 1
a2649 1
	///: this table is for submenus, order is not important
d2670 1
a2670 1
	///: startup mode
d2672 1
a2672 1
	///: startup values for each mode
d2685 1
a2685 1
	///: set all sorting type to distance (default) even for unconventional modes just to be sure
d2707 1
a2707 1
	///: TODO: make safe checks
d2714 2
a2715 3
///:
///: Advance through types inside current mode
///:
d2720 1
a2720 1
		///: point to first
d2733 1
a2733 1
		///: point to last
d2741 4
a2744 5
///:
///: Advance inside Mode Table between map, wp, infopages 
///: and reselect previous state for that mode
///: Notice: does NOT advance inside modes through types
///:
d2824 1
a2824 1
///: This is currently unused.. we need a button!
d2838 1
a2838 1
///: 100511 This will set mapspace directly, and set ModeIndex accordingly. So we can do a "goto" mapspace now.
d2851 4
a2854 5
///:
///: Selecting MapSpaceMode need also ModeIndex and ModeType to be updated!
///: Do not use these functions directly..
///: Toggling pages will force intermediate activations, so careful here
///:
d2867 1
a2867 1
	///: Particular care not to leave pending events
d2873 1
a2873 1
			///: force DoNearest to run at once
d2904 4
a2907 5
///:
///: Get the infobox type from configuration, selecting position i
///: From 1-8 auxiliaries
///:     0-16 dynamic page
///:
d2913 1
a2913 1
	///: it really starts from 0
d2928 1
a2928 1
				///: impossible case, show twice auxiliaries
d2937 3
a2939 3
///: Returns the LKProcess index value for configured infobox (0-8) for dmCruise, dmFinalGlide, Auxiliary, dmCircling
///: The function name is really stupid...
///: dmMode is an enum, we simply use for commodity
d2955 1
a2955 1
			///: default is auxiliary
a2962 1
///: 091016  revised 091220 wpmode unused TODO remove wpmode
a2972 36
/* 091220 obsoleted
	switch(wpmode) {
		case GMC_DEFAULT:
			if (WayPointCalc[wpindex].IsLandable) 
				return GlidePolar::SafetyMacCready;
			else
				return MACCREADY;
			break;

		default:
			return MACCREADY;
			break;
	}
*/
/*
if (0)
  if (AbortSafetyUseCurrent) {
    return MACCREADY;
  } else {
    return SafetyMacCready;
  }
#else
        switch(AltArrivMode) {
                case ALTA_MC:
                        return MACCREADY;
                case ALTA_MC0:
                        return 0;
                case ALTA_SMC:
                        return SafetyMacCready;
                default:
                        return 9; // something to notice!
        }
#endif
*/


a2991 1
///: 100103
d3003 1
a3003 1
	///: only last x seconds of data are used
a3009 1
///: 100103
d3026 1
a3026 1
	///: speed is in m/s
a3057 2
	///: we convert it to kmh corrected for altitude pressure with 200m error margin
	///: buf->speed[buf->start]=(int) (  (speed*TOKPH) / AirDensityRatio(altitude>200?altitude-200:altitude));
d3059 1
a3059 1
	///: NO! We store GS in kmh, simply.
d3061 2
a3062 2
	///: we use track+180 in order to be always over 0 in range calculations
	///: we want track north to be 0, not 360
d3066 1
a3066 1
	///: ias is in m/s
d3082 5
a3086 6
///: 100103 The Magic TrueWind returns: (see Utils2.h WCALC return codes) <=0 error values
///:
///: iaspeed is Indicated Air Speed in m/s. Target track is automatic. (TODO: use digital compass if available)
///: IF IAS IS AVAILABLE, we use average IAS, in m/s and we ignore iaspeed
///:
///: 100202 added mode
d3093 2
a3094 2
///: 100215 wmode  is 0 for NESW , 1 for 3,12,21,30    2 for 6 15 24 33
///: For digital compass, wmode is heading degrees + 180 (that is, it starts from 180 degrees..)
d3109 1
a3109 1
  ///: make a copy of the working area, and work offline
d3127 1
a3127 1
	///: kmh range for GS 
d3174 1
a3174 1
  ///: search for a GS convergent value between these two margins. 
d3182 1
a3182 1
	///: skip last 2 seconds and go backwards to last 40
d3193 2
a3194 2
	///: do not accept a valid result if we don't have at least (TIMEBACK/2)+1 valid samples
	///: do not accept a valid result if we don't have at least 75% +1 valid samples
d3205 1
a3205 1
	///: 100202 ground speed quality is an absolute value: the valid fixes accounted
d3228 2
a3229 2
  ///: track search, and also altitude average
  ///: Track is stored + 180, so 359 is now 539. There is NO 360, it is 0 + 180
d3239 1
a3239 1
	///: skip last seconds and go backwards to last 40 or whatever
d3244 1
a3244 1
		///: Track over 325 (505) should appear as x-180 (145)  100316 ?? it was a bug
a3245 2
		///: if ( track>=505 ) track-=360; BUGFIX 100316
		//if (bc.track[curs] >=low && bc.track[curs] <=high) {
d3254 2
a3255 3
	///: do not accept a valid result if we don't have at least (TIMEBACK/2)+1 valid samples
	///: do not accept a valid result if we don't have at least 75%+1 valid samples
	//if (nc<((WCALC_TIMEBACK/2)+1)) {
d3265 1
a3265 1
	///: 100202 track quality is number of valid fixes found
d3293 1
a3293 1
  ///: If Airspeed is available, use it  (ias is in m/s) but not if using Condor
d3307 1
a3307 1
	///: skip last 2 seconds and go backwards to last 40
d3317 1
a3317 1
	///: do not accept a valid result if we don't have at least 75% +1 valid samples
d3327 1
a3327 2
		///: otherwise, try to use eIAS
		///: break;
d3329 1
a3329 1
	///: iasquality is number of valid fixes found
d3345 3
a3347 3
  ///: Assuming 10 seconds, GS is calculated on ground moving in this time. We want in 10 seconds at least 50m made
  ///: averias is >0 , but must be >18kmh, >5ms ?
  ///: NO, by now we keep 2ms minimum, for paragliders mainly
d3364 2
a3365 2
  ///: track is inserted with +180 
  ///: a negative heading to 325 is 145, so 145-180 would be -35 . 360-35=325 correct
d3430 2
a3431 2
  ///: p_heading is presumed heading , NSEW .. in degrees (understood from avertrack)
  ///: iaspeed is presumed IAS , as configured . in km/h (passed as parameter)
d3433 1
a3433 1
  ///: TODO If we have a digital compass, use wmode for it
d3438 1
a3438 1
		///: wmode==0:  0 90  180  270   (N E S W)
d3445 1
a3445 1
		///: wmode==1:  30 120 210 300
d3452 1
a3452 1
		///: wmode==2:  60 150 240 330
d3492 1
a3492 1
  ///: Condor has its own wind precalculated: TrueWind will not cheat using read IAS
d3557 3
a3559 3
  ///: StartupStore(_T(".......gsq=%d tq=%d wcalc=%d  qual=%d\n"),gsquality,trackquality, windcalctime,
  ///: 						((gsquality+trackquality)*100) / (windcalctime*2)  );
  ///: return quality percentage: part/total *100 
a3568 1
///: 100413
d3592 18
d3616 2
a3617 2
///: 100511 handle custom keys. Input: key pressed (center, left etc.)
///: Returns true if handled successfully, false if not
a3621 1
  static int oldLook8000;
a3624 1
	oldLook8000=Look8000;
d3630 1
a3630 1
	case 0:
d3633 1
a3633 1
	case 1:	
d3636 1
a3636 1
	case 2:	
d3639 1
a3639 1
	case 3:	
d3642 6
d3688 7
d3699 1
a3699 4
		if (Look8000>lxcNoOverlay)
			Look8000=lxcNoOverlay;
		else
			Look8000=oldLook8000;
d3747 1
a3747 1
	///: Only used for aircraft icon
d3784 1
a3784 1
				DoStatusMessage(_T("Already going home"));
d3789 14
a3802 1
			DoStatusMessage(_T("No Home to go!"));
d3805 21
d3836 2
a3837 2
///: 100512 set Climb and Cruis MapScale accordingly to PGClimbZoom, everytime it changes.
///: Needed to avoid software restart to bypass doinit in MapWindow
a3841 2
	///: ClimbMapScale = MapWindow::RequestMapScale/40; // 091023 TESTFIX
	///: ClimbMapScale = 0.07; // 091108 changed from 0.05
a3868 2
///: 100527
///: #include "wcecompat/ts_string.h"
d3879 1
a3879 1
  StartupStore(_T("... Searching modeltype inside default profile <%s>%s"),tmpTbuf,NEWLINE);
a3892 3
///:	ascii2unicode(tmpbuf,tmpTbuf);
///:	StartupStore(_T(" READ: <%s>\n"),tmpTbuf);

d3903 1
a3903 1
  StartupStore(_T("... Modeltype not found in profile\n"));
d3909 235
@


8.29
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.28 2010/02/02 23:41:17 root Exp root $
d66 1
d70 3
d111 3
d116 3
d188 6
a193 1
	if ( buf->valid == true) buf->totaldistance-=buf->distance[buf->start];
d196 10
d216 1
d218 3
d222 1
d230 4
d241 4
d254 4
d265 7
a271 1
		if (bc.start==0) return(0); // unavailable
d282 47
a328 1
	if (altdiff == 0 ) return(INVALID_GR); // infinitum
d456 3
d460 1
a460 1
#define AIRCRAFTMENUSIZE	IBLSCALE(28)
d462 5
d493 2
a494 2
		//s_xleft=(s_sizeright-AIRCRAFTMENUSIZE)/3-IBLSCALE(6); // 3 was original, 15 was too much
		//s_xright=s_sizeright-AIRCRAFTMENUSIZE-s_xleft; 
d497 7
a503 1
		s_bottomY=(MapWindow::MapRect.bottom-MapWindow::MapRect.top)-BottomSize-IBLSCALE(2); // bugfix era 15, troppo 090731
d528 2
a529 1
	if (NewMap &&  DrawBottom && vkmode==LKGESTURE_NONE) {
d545 1
d547 5
d553 1
a553 1
				wsprintf(buf,_T("RIGHT in limit=%d"),sizeup-BottomSize-IBLSCALE(20));
a556 3
						#ifndef DISABLEAUDIO
                                                if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
						#endif
d561 1
d565 2
d570 1
d575 6
d582 1
a582 1
				wsprintf(buf,_T("LEFT in limit=%d"),sizeup-BottomSize-IBLSCALE(20));
d589 1
d593 2
d602 1
d606 1
d608 1
d612 2
d617 1
d622 1
a622 1
			wsprintf(buf,_T("CENTER in limit=%d"),sizeup-BottomSize-IBLSCALE(20));
d643 3
a657 8
			if (keytime>1000) {
				TCHAR mbuf[200];
				_stprintf(mbuf,_T("TaskTemp=%d"),TaskIsTemporary());
				DoStatusMessage(mbuf);
				return 0;
			}
#endif
#if (0)
d667 1
a667 1
#if (1)	// TESTKEY
d682 17
a698 1
			///: normally, we fall down here
d707 2
a708 1
		if ( (MapSpaceMode == MSM_LANDABLE || MapSpaceMode==MSM_AIRPORTS || MapSpaceMode==MSM_NEARTPS) && Y<=SortBoxY ) {
d734 8
d785 3
d956 2
d972 2
d1040 1
a1040 1
	///: BottomSize is set manually...
d1093 6
a1098 1
		propGetFontSettingsFromString(TEXT("44,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
d1123 6
a1128 1
		propGetFontSettingsFromString(TEXT("38,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontPanelBig); 
d1135 3
d1139 1
d1164 3
d1168 1
d1179 6
a1184 1
		propGetFontSettingsFromString(TEXT("31,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
d1201 2
a1202 1
			propGetFontSettingsFromString(TEXT("23,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
d1219 3
d1223 1
d1257 3
d1261 1
d1299 3
d1303 1
d1315 2
a1316 1
		} else {
d1325 13
d1343 3
d1347 1
d1355 3
d1359 1
d1386 3
d1390 1
d1396 42
d1446 3
d1450 1
d1547 8
d1579 5
d1668 1
a1668 1
	if ( !(NewMap&&Look8000)) return;
d1680 1
d1685 2
d1691 2
d1697 2
d1703 2
d1709 3
d1716 2
d1722 3
d1726 1
d1731 6
a1776 16
#ifdef CIDCONTEST
void CidContest(){

 #include "/v/xcsoar/fivv/cidcontest.h" 

	// work in progress

}

void CidInit() {

	// load handicap values per class

}
#endif

d1892 5
a1896 6
//
// Retrieve from the registry the previous set model type
// This value is defined in xcsoar.h , example> MODELTYPE_PNA_HP31X
// is equivalent to a value=10201 (defined in the header file)
//
void SetModelType() {
d1905 5
a1909 5
    
    _stprintf(sTmp,_T("+++ SetModelType ERROR! ModelName returned invalid value <%d> from Registry!%s"), Temp,NEWLINE);
    StartupStore(sTmp);
    GlobalModelType=MODELTYPE_PNA_PNA;
    
d1911 1
a1911 2
    
    GlobalModelType = Temp;
d1916 1
d1946 3
d2472 2
d2482 1
a2482 1
	CreateDirectory(dstdir); // 091118
d2517 8
d2539 8
d2549 1
d2577 1
d2694 4
d2705 1
d2711 1
d2777 11
a2787 4
	if ( (ModeIndex+1)>LKMODE_TOP)
		ModeIndex=LKMODE_MAP;
	else
		ModeIndex++;
d2807 3
d2815 40
d2856 3
a2858 2
	UnselectMapSpace(ModeTable[ModeIndex][CURTYPE]);
	if ( (ModeIndex-1)<0)
d2860 18
a2877 3
	else
		ModeIndex--;
	SelectMapSpace(ModeTable[ModeIndex][CURTYPE]);
d3155 1
a3155 1
///: 100103 The Magic TrueWind returns: (see Utils2.h WCALC return codes)
d3163 2
a3164 1
// #define DEBUG_WCALC  // REMOVE BEFORE FLIGHT!
d3166 3
a3168 1
///: #define STORE_WCALC // REMOVE BEFORE FLIGHT!
d3171 1
a3171 1
int CalculateWindRotary(windrotary_s *buf, double iaspeed , double *wfrom, double *wspeed, int windcalctime) {
d3318 1
a3318 1
		///: Track over 325 (505) should appear as x-180 (145)
d3320 1
a3320 1
		if ( track>=505 ) track-=360;
d3511 33
a3543 2
  ///: TODO If we have a digital compass, use those averaged values 
#if 1
a3548 2
#else
	use digital compass averaged inside buffer
d3647 288
@


8.28
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*only last x seconds of data are used
d34 1
a34 1
  $Id: Utils2.cpp,v 8.27 2009/11/27 01:11:59 root Exp root $
d513 1
a523 1
			///: Rotate background empty map colors
d525 3
a527 22
				if (BgMapColor>=(LKMAXBACKGROUNDS-1)) BgMapColor=0;
				else BgMapColor++;

				//InputEvents::setMode(_T("MC"));
				//MenuTimeout=0;
				//DisplayTimeout=0;

				//DoStatusMessage(_T("The Quick Brown Fox Jumps Over The Lazy Dog Back"));
				//StartupStore(_T("....   test StartMaxSpeed=%d\n"),StartMaxSpeed); 
				//StartupStore(_T("....   test StartMaxSpeedMargin=%d\n"),StartMaxSpeedMargin);
				//StartupStore(_T("....   test SAFTEYSPEED=%f\n"),SAFTEYSPEED);
/*
	StartupStore(_T("... Dist=%.2f Height=%.2f NavAlt=%f \n"), 
			CALCULATED_INFO.ObstacleDistance,
			CALCULATED_INFO.ObstacleHeight,
			CALCULATED_INFO.NavAltitude);
	StartupStore(_T("... Reqd=%.2f AltArriv=%f \n"), 
			CALCULATED_INFO.ObstacleAltReqd,
			CALCULATED_INFO.ObstacleAltArriv);
*/


d532 1
d541 1
a541 52
#if (0)
			if (keytime>1000) {
				double wfrom=0, wspeed=0;
				int resw=0;
				static TCHAR mbuf[200];
				resw=CalculateWindRotary(&rotaryWind,100, &wfrom, &wspeed);

				if (resw>0 ) {
					_stprintf(mbuf,_T("WIND:  %.0f")TEXT(DEG)_T(" / %.0f%s"), 
						wfrom, wspeed/3.6*SPEEDMODIFY, Units::GetHorizontalSpeedName());
					Message::AddMessage(30000, 3, mbuf);
				} else {
					switch(resw) {
						case WCALC_INVALID_SPEED:
							_stprintf(mbuf,_T("KEEP SPEED LONGER PLEASE"));
							break;
						case WCALC_INVALID_TRACK:
							_stprintf(mbuf,_T("KEEP HEADING LONGER PLEASE"));
							break;
						case WCALC_INVALID_ALL:
							_stprintf(mbuf,_T("KEEP SPEED AND HEADING LONGER PLEASE"));
							break;
						case WCALC_INVALID_HEADING:
							_stprintf(mbuf,_T("INACCURATE HEADING OR TOO STRONG WIND"));
							break;
						default:
							_stprintf(mbuf,_T("INVALID DATA CALCULATING WIND"));
							break;
					}
					Message::AddMessage(30000, 3, mbuf);
				}
				return 0;
			}
#endif
#if (0)
			///: TEST MODE 091015
			if (keytime>1000) {
				static TCHAR mbuf[200];
				wsprintf(mbuf,_T("$PDSXT,Direzione Gara,ATTENZIONE - gara sospesa per incipiente mal tempo*14\n"));
				//wsprintf(mbuf,_T("$PDSXT,,ATTENZIONE - gara sospesa per incipiente mal tempo*14"));
				NMEAParser::ParseNMEAString(0, (TCHAR *) mbuf, &GPS_INFO);
/*
				wsprintf(mbuf,_T("INCOMING SMS FROM <SenderName> : Text Message"));
				Message::AddMessage(30000, 3, mbuf);
				#ifndef DISABLEAUDIO
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_TONEUP"));
				#endif
*/
				return 0;
			}
#endif
#if (1)
d2774 1
a2774 5
///: 100103 The Magic Wind returns:
///: -3 	no valid track and speed
///: -2		no valid track
///: -1 	no valid speed
///: 0		no valid data 
d2777 3
a2779 1
///: IF IAS IS AVAILABLE, we use average IAS, in m/s
d2782 1
a2782 1
///: #define DEBUG_WCALC  // REMOVE BEFORE FLIGHT!
d2784 1
a2784 1
#define STORE_WCALC // REMOVE 100113
d2786 2
a2787 1
int CalculateWindRotary(windrotary_s *buf, double iaspeed , double *wfrom, double *wspeed) {
d2794 5
d2808 2
d2814 1
a2814 1
	StartupStore(_T("------ TrueWind: Invalid target speed in Wind Calculation%s"),NEWLINE);
d2876 1
a2876 1
	for (i=0, nc=0, s=0; i<WindCalcTime; i++) {
d2886 1
a2886 1
	if (nc<((WindCalcTime*0.75)+1)) {
d2888 1
a2888 1
		sprintf(ventabuffer,"(speed iter=%d) nc=%d <%d : no valid GS averspeed",iter,nc,(int)(WindCalcTime*0.75)+1);
d2895 2
d2932 1
a2932 1
	for (i=0,nc=0,s=0,alt=0; i<WindCalcTime; i++) {
d2949 1
a2949 1
	if (nc<((WindCalcTime*0.75)+1)) {
d2951 1
a2951 1
		sprintf(ventabuffer,"(track iter=%d) nc=%d <%d : no valid avertrack",iter,nc,(int)(WindCalcTime*0.75)+1);
d2958 2
d3003 1
a3003 1
	for (i=0, nc=0, s=0; i<WindCalcTime; i++) {
d3011 1
a3011 1
	if (nc<((WindCalcTime*0.75)+1)) {
d3013 1
a3013 1
		sprintf(ventabuffer,"(IAS iter=%d) nc=%d <%d : no valid average IAS",iter,nc,(int)(WindCalcTime*0.75)+1);
d3023 3
d3222 9
a3230 2
  ///: higher values should mean better precision
  return 1;
@


8.27
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*
d34 1
a34 1
  $Id: Utils2.cpp,v 8.26 2009/11/25 18:09:25 root Exp root $
d65 1
a72 1

a112 1
	// John, DEBUGROTARY is used only on PC, no need to make it any better, it will be removed
d117 1
a117 2
  return false; //RLD Paolo, I added this so it would compile correctly.  Not sure what the correct value is.
                //VNT Rob, it's an unused bool type so any value is ok, Ill make it void eventually
a125 1

d134 1
d144 2
d167 1
d251 1
a251 1

d334 1
d501 1
d512 12
a523 1
#if (1)
d527 20
d560 34
d610 3
a612 1
#if (0)
d615 5
a619 2
				_stprintf(mbuf,_T("<%s>"), GetWinPilotPolarInternalName(94));
				Message::AddMessage(15000, 3, mbuf);
d622 1
d872 4
d877 1
d885 4
a888 1

d891 1
d900 2
d919 1
d939 1
d974 1
d977 25
d1031 2
a1032 1
		propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall);
d1064 1
d1101 1
d1135 35
d1207 1
d1242 1
d1265 1
d1290 1
d1309 1
d1354 3
d1358 1
a1358 1

a1359 1
  if (iWidth == 320 && iHeight == 240) ScreenSize=(ScreenSize_t)ss320x240; //  QVGA
a1360 1
  if (iWidth == 640 && iHeight == 480) ScreenSize=(ScreenSize_t)ss640x480; //   VGA
d1362 2
d1367 4
a1370 1
        wsprintf(tbuf,_T("++++++ ERROR UNKNOWN RESOLUTION %dx%d !%s"),iWidth,iHeight,NEWLINE); // 091119
d1475 4
d1483 4
d2194 36
d2657 27
a2683 1
///: 091016
d2686 9
d2697 1
a2697 1
			if (WayPointCalc[wpindex].IsLandable)
d2707 1
a2727 1
	return MACCREADY;
d2748 535
@


8.26
log
@pre cambio fonts portrait
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.25 2009/11/09 00:17:12 root Exp root $
d1029 1
a1029 1
			propGetFontSettingsFromString(TEXT("14,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
d1044 1
a1044 1
			propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
d1078 2
a1079 2
			propGetFontSettingsFromString(TEXT("44,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("36,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
d1083 1
a1083 1
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig);
@


8.25
log
@1.16a
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.24 2009/11/04 12:36:07 root Exp root $
d70 1
d511 7
d797 10
d863 2
d1208 1
a1208 1
        wsprintf(tbuf,_T("++++++ ERROR UNKNOWN RESOLUTION %dx%d !\r\n"),iWidth,iHeight);
d1228 48
a1275 3

		MapWindow::RequestMapScale = 0.18;  // 091108 was 0.3
		MapWindow::MapScale = 0.18;	// ditto
d1277 1
d1294 1
a1294 1
	StartupStore(_T(". Init LK8000\n"));
d1311 1
d1315 1
d1319 1
d1323 1
d1327 1
d1331 1
d1335 5
d1396 4
a1399 1
	  SetTextColor(hDC,RGB_BLACK);  // black 
d1402 4
a1405 1
	  SetTextColor(hDC,RGB_WHITE);  // white
d1519 1
a1519 1
    _stprintf(sTmp,_T("+++ SetModelType ERROR! ModelName returned invalid value <%d> from Registry!\n"), Temp);
d1528 1
a1528 1
  _stprintf(sTmp,_T(". SetModelType: Name=<%s> Type=%d\n"),GlobalModelName, GlobalModelType);
d1627 1
a1627 1
    StartupStore(TEXT("++++++ CRITIC- gmfbasename returned null GetModuleFileName\n"));
d1631 1
a1631 1
    StartupStore(TEXT("++++++ CRITIC- gmfbasename starting without a leading backslash\n"));
d1658 1
a1658 1
    StartupStore(TEXT("++++++ CRITIC- GetGlobalFileName returned NULL\n"));
d1662 1
a1662 1
    StartupStore(TEXT("++++++ CRITIC- GetGlobalFileName starting without a leading backslash\n"));
d1852 3
a1854 2
 * Returns: 0 if OK . 
 * 1 - n other errors not really needed to handle. See below
d1866 3
a1868 2
///: This will not be called from PC versions

d1873 1
d1877 4
d1882 1
a1884 1
  _stprintf(dstdir,TEXT("\\Windows"));
d1886 40
a1925 1
  _stprintf(tbuf,_T(". InstallSystems DLL from <%s> to <%s>\n"), srcdir, dstdir);
d1927 22
a1948 5
  if (  GetFileAttributes(srcdir) != FILE_ATTRIBUTE_DIRECTORY) {
	StartupStore(_T("------ Warning, InstallSystem could not find source directory <%s> !\n"),srcdir); // 091104
	StartupStore(_T("------ NO DLL install available\n"));
	StartupStore(_T("------ NO font will be installed on device\n"));
	return 1;
d1950 10
d1961 6
a1966 3
  if (  GetFileAttributes(dstdir) != FILE_ATTRIBUTE_DIRECTORY) {
	StartupStore(_T("------ Warning, InstallSystem could not find target directory <%s>\n"),dstdir);
	StartupStore(_T("------ NO DLL install available\n"));
d1981 1
a1981 1
		StartupStore(_T(". GRecordDll.dll already installed in device, very well.\n"));
d1984 15
a1998 1
			StartupStore(_T("++++++ COULD NOT INSTALL <%s> inside device. Bad!\n"),srcfile);
d2000 24
a2023 1
			StartupStore(_T("...... GRecordDll.dll installed using <%s>. Great.\n"),srcfile);
d2026 2
d2030 15
a2044 2
  _stprintf(dstdir,TEXT("\\Windows\\Fonts"));
  _stprintf(tbuf,_T(". InstallSystem Fonts from <%s> to <%s>\n"), srcdir, dstdir);
d2047 20
a2066 4
  if (  GetFileAttributes(dstdir) != FILE_ATTRIBUTE_DIRECTORY) {
	StartupStore(_T("------ Warning, InstallSystem could not find target directory <%s>\n"),dstdir);
	StartupStore(_T("------ NO font will be installed on device\n"));
	return 2;
d2068 5
d2076 1
a2076 1
  StartupStore(_T(". Copy TAHOMA fonts\n"));
d2080 1
a2080 1
	StartupStore(_T(". Font TAHOMA.TTF was already installed onboard, good.\n"));
d2082 5
a2086 4
	if ( !CopyFile(srcfile,dstfile,TRUE)) 
		StartupStore(_T("------ Could not copy TAHOMA.TTF on device, not good.\n"));
	else
		StartupStore(_T(". Font TAHOMA.TTF installed on device\n"));
d2090 1
a2090 2

  StartupStore(_T(". Copy TAHOMABD fonts\n"));
d2094 1
a2094 1
	StartupStore(_T(". Font TAHOMABD.TTF was already installed onboard, good.\n"));
d2096 5
a2100 4
	if ( !CopyFile(srcfile,dstfile,TRUE)) 
		StartupStore(_T("------ Could not copy TAHOMABD.TTF on device, not good.\n"));
	else
		StartupStore(_T(". Font TAHOMABD.TTF installed on device\n"));
d2111 2
a2112 2
	StartupStore(_T(". DejaVu fonts found already installed on system\n"));
	return 4;
d2115 2
a2116 1
	StartupStore(_T("--- Could not copy DejaVu fonts for some reason\n"));
d2134 1
a2134 1
  StartupStore(_T(". End of InstalLSystem()\n"));
d2149 2
d2276 1
a2276 1
	StartupStore(_T("Ok\n"));
@


8.24
log
@1.15c
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.23 2009/11/01 19:54:50 root Exp root $
d508 9
d521 1
a521 1
				wsprintf(mbuf,_T("$PDSXT,Direzione Gara,ATTENZIONE - gara sospesa per incipiente mal tempo*14"));
d1209 2
a1210 2
		MapWindow::RequestMapScale = 0.3; 
		MapWindow::MapScale = 0.3;
d1296 1
a1296 1
#ifdef FIVV
d1299 1
a1299 1
#include "/v/xcsoar/fivv/cidcontest.h"
a1780 1
short InstallFonts() {
d1782 1
a1782 4
TCHAR srcdir[MAX_PATH];
TCHAR dstdir[MAX_PATH];
TCHAR srcfile[MAX_PATH];
TCHAR dstfile[MAX_PATH];
d1784 1
a1784 4
//_stprintf(srcdir,TEXT("%s%S\\Fonts"),gmfpathname(), XCSDATADIR ); // TESTFIX 091001 REMOVE
LocalPath(srcdir,TEXT(LKD_SYSTEM));
///: _stprintf(dstdir,TEXT("\\Windows\\Fonts"),gmfpathname() ); // BUGFIX 091001 REMOVE
_stprintf(dstdir,TEXT("\\Windows\\Fonts"));
d1786 18
d1805 10
a1814 3
if (  GetFileAttributes(srcdir) != FILE_ATTRIBUTE_DIRECTORY) return 1;
if (  GetFileAttributes(dstdir) != FILE_ATTRIBUTE_DIRECTORY) return 2;

d1816 1
a1816 6
_stprintf(srcfile,TEXT("%s\\TAHOMA.TTF"),srcdir);
_stprintf(dstfile,TEXT("%s\\TAHOMA.TTF"),dstdir);
CopyFile(srcfile,dstfile,TRUE);
_stprintf(srcfile,TEXT("%s\\TAHOMABD.TTF"),srcdir);
_stprintf(dstfile,TEXT("%s\\TAHOMABD.TTF"),dstdir);
CopyFile(srcfile,dstfile,TRUE);
d1819 66
a1884 5
_stprintf(srcfile,TEXT("%s\\DejaVuSansCondensed2.ttf"),srcdir);
_stprintf(dstfile,TEXT("%s\\DejaVuSansCondensed2.ttf"),dstdir);
//if (  GetFileAttributes(srcfile) != FILE_ATTRIBUTE_NORMAL) return 3;
if (  GetFileAttributes(dstfile) != 0xffffffff ) return 4;
if ( !CopyFile(srcfile, dstfile, TRUE)) return 5;
d1886 4
a1889 4
// From now on we attempt to copy without overwriting
_stprintf(srcfile,TEXT("%s\\DejaVuSansCondensed-Bold2.ttf"),srcdir);
_stprintf(dstfile,TEXT("%s\\DejaVuSansCondensed-Bold2.ttf"),dstdir);
CopyFile(srcfile,dstfile,TRUE);
d1891 3
a1893 3
_stprintf(srcfile,TEXT("%s\\DejaVuSansCondensed-BoldOblique2.ttf"),srcdir);
_stprintf(dstfile,TEXT("%s\\DejaVuSansCondensed-BoldOblique2.ttf"),dstdir);
CopyFile(srcfile,dstfile,TRUE);
d1895 3
a1897 3
_stprintf(srcfile,TEXT("%s\\DejaVuSansCondensed-Oblique2.ttf"),srcdir);
_stprintf(dstfile,TEXT("%s\\DejaVuSansCondensed-Oblique2.ttf"),dstdir);
CopyFile(srcfile,dstfile,TRUE);
d1900 1
d1902 1
a1902 1
return 0;
@


8.23
log
@1.15b
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.22 2009/10/23 11:28:46 root Exp root $
d1179 1
a1179 1
        wsprintf(tbuf,_T("--- ERROR UNKNOWN RESOLUTION %dx%d !\r\n"),iWidth,iHeight);
d1219 1
a1219 1
	StartupStore(_T("Init LK8000\n"));
d1427 1
a1427 1
    _stprintf(sTmp,_T("SetModelType ERROR! ModelName returned invalid value <%d> from Registry!\n"), Temp);
d1436 1
a1436 1
  _stprintf(sTmp,_T("SetModelType: Name=<%s> Type=%d\n"),GlobalModelName, GlobalModelType);
d1535 1
a1535 1
    StartupStore(TEXT("CRITIC- gmfbasename returned null GetModuleFileName\n"));
d1539 1
a1539 1
    StartupStore(TEXT("CRITIC- gmfbasename starting without a leading backslash\n"));
d1566 1
a1566 1
    StartupStore(TEXT("CRITIC- GetGlobalFileName returned NULL\n"));
d1570 1
a1570 1
    StartupStore(TEXT("CRITIC- GetGlobalFileName starting without a leading backslash\n"));
d1780 1
a1780 1
LocalPath(srcdir,TEXT(LKD_FONTS));
d1847 3
a1849 1
	LocalPath(srcpath,TEXT(XCSPROFILE));
d1904 1
a1904 1
	StartupStore(_T("Init ModeTable for LK8000: "));
@


8.22
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.21 2009/10/19 16:28:21 root Exp root $
d528 1
a528 4
				//wsprintf(mbuf,_T("BESTALTERNATE: %s"), WayPointList[BestAlternate].Name);
				_stprintf(mbuf,_T("BESTALTERNATE: %s at %.1f%s"), WayPointList[BestAlternate].Name,
					DISTANCEMODIFY*WayPointCalc[BestAlternate].Distance,
					(Units::GetDistanceName()));
d1200 2
a1201 2
		MapWindow::RequestMapScale = 0.2; 
		MapWindow::MapScale = 0.2;
@


8.21
log
@1.14b
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.20 2009/10/12 13:25:20 root Exp root $
d592 4
a595 1
		if (!dontdrawthemap) return 0;
d697 4
a700 1
			if (MapSpaceMode<=MSM_MAP) return 0;
d707 1
d2171 17
@


8.20
log
@1.12b
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.19 2009/10/01 15:06:06 root Exp root $
d63 2
d496 1
a496 1
			///: long press on center navbox currently disabled
d508 30
d2093 2
d2104 17
a2120 2
	else
		retval = (InfoType[i-9] >> 8) & 0xff; // cruise
d2125 39
@


8.19
log
@pre localpath
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.18 2009/09/30 16:13:55 root Exp root $
d254 1
d269 2
a270 1
  short i,curs,nc,iter;
d1743 4
a1746 2
_stprintf(srcdir,TEXT("%s%S\\Fonts"),gmfpathname(), XCSDATADIR );
_stprintf(dstdir,TEXT("\\Windows\\Fonts"),gmfpathname() );
d1793 2
a1794 1
	_stprintf(srcdir,TEXT("%s%S"),gmfpathname(), XCSDATADIR );
d1810 2
a1811 1
	_stprintf(srcpath,TEXT("%s%S\\%S"),gmfpathname(), XCSDATADIR , XCSPROFILE);
d1877 1
a1878 3
	ModeTable[LKMODE_WP][WP_AIRPORTS]	=	MSM_AIRPORTS;
	ModeTable[LKMODE_WP][WP_COMMON]		=	MSM_COMMON;
	ModeTable[LKMODE_WP][WP_RECENT]		=	MSM_RECENT;
d1887 3
d1893 4
a1896 3
	ModeType[LKMODE_MAP]=MP_WELCOME;
	ModeType[LKMODE_WP]=WP_LANDABLE;
	ModeType[LKMODE_INFOMODE]=IM_CRUISE;
d1901 1
d1987 3
@


8.18
log
@pre optimi
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.17 2009/09/20 20:29:00 root Exp $
d356 1
d358 2
a359 2
	short yup, ydown, xleft, xright;
	short sizeup, sizeright;
d362 5
d375 16
a392 1
	sizeright=MapWindow::MapRect.right-MapWindow::MapRect.left;
d394 1
a406 5
// TODO: move it to defines, together with MapWindow's
// TODO: make it static with a doinit
#define AIRCRAFTMENUSIZE	IBLSCALE(28)
	xleft=(sizeright-AIRCRAFTMENUSIZE)/3-IBLSCALE(15); // VNT10 090909 CHECK FIX, was 3 . Enlarge center area
	xright=sizeright-AIRCRAFTMENUSIZE-xleft; 
d417 2
a418 1
		if (Y>= (sizeup-BottomSize-IBLSCALE(2)) ) { // bugfix era 15, troppo 090731
d429 1
a429 1
			if ( X>xright ) {
d451 1
a451 1
			if ( X<xleft ) { // following is ugly
d505 1
a506 1
			MapWindow::RefreshMap();
a537 10
/*
				///: no reason to handle these here, no action required and impossible to reach
				///: TODO CHECK REMOVABLE
				case MSM_COMMON:
							LKForceDoCommon=true;
							break;
				case MSM_RECENT:
							LKForceDoRecent=true;
							break;
*/
a543 3
//			#ifndef DISABLEAUDIO  
//			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK")); //  REMOVE FIX
//			#endif
a577 9
/*
			case MSM_WELCOME:
			case MSM_INFO_THERMAL:
			case MSM_INFO_CRUISE:
			case MSM_INFO_TASK:
			case MSM_INFO_AUX:
			case MSM_INFO_TRI:
						break;
*/
d582 1
a582 12
/* FIX REMOVE
		switch(MapSpaceMode) {
			case MSM_LANDABLE:
			case MSM_AIRPORTS:
				numpages=Numpages; // TODO use Numpages[MapSpaceMode]
				break;
			case MSM_COMMON:
			case MSM_RECENT:
				numpages=CommonNumpages;
				break;
		}
*/
@


8.17
log
@10d
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.16 2009/09/16 19:03:02 root Exp root $
d494 1
a494 1
		if ( (MapSpaceMode == MSM_LANDABLE || MapSpaceMode==MSM_AIRPORTS) && Y<=SortBoxY ) {
d498 1
a498 1
			for (i=1, j=4; i<4; i++) {
d513 8
d529 1
d531 1
d569 4
d720 12
d742 1
a742 1
		if (dontdrawthemap) {
d744 1
a744 1
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_HIGHCLICK"));
d757 1
a757 2
		///: do not emulate a return key, normally
	        ///: return 13;
d770 2
d789 2
d815 1
a815 1
		propGetFontSettingsFromString(TEXT("72,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);	// 64 600
d821 3
a823 1
		propGetFontSettingsFromString(TEXT("50,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontTarget);	// 46 600
d845 2
d853 2
d876 2
d884 2
d911 2
d920 2
d944 2
d953 2
d981 2
d990 2
d1015 2
d1024 2
d1045 2
d1064 4
a1067 2
  logfontTarget.lfQuality = CLEARTYPE_COMPAT_QUALITY;; 
  logfontBig.lfQuality = CLEARTYPE_COMPAT_QUALITY; 
d1070 2
a1072 1
  logfontSymbol.lfQuality = ANTIALIASED_QUALITY; 
d1079 2
a1080 1
  logfontSymbol.lfCharSet = SYMBOL_CHARSET;
d1089 2
d1869 2
a1870 1
///: Conversion between submenus and global mapspace modes
d1874 1
d1877 1
a1877 1
	for (short i=0; i<=LKMODE_TOP; i++)
d1890 1
d1909 15
d2024 1
d2049 6
@


8.16
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.15 2009/09/16 10:57:50 root Exp root $
d1173 2
@


8.15
log
@bo ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.14 2009/09/09 22:59:44 root Exp root $
d67 3
d626 6
a631 1
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
d636 1
d641 6
a646 1
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
a1843 1
#define CURTYPE	ModeType[ModeIndex]
d1862 2
a1863 1
		CURTYPE=0; // point to first
d1875 2
a1876 1
		CURTYPE=ModeTableTop[ModeIndex]; // point to first
@


8.14
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.13 2009/09/07 19:08:30 root Exp root $
d413 1
a413 1
				if (  (BottomMode+1) >MAXBOTTOMMODES ) {
d418 1
a418 1
						BottomMode=0;
d420 1
a420 1
						BottomMode=1;
d435 2
a436 2
				if ((BottomMode-1) == 0) {
					if (DisplayMode != dmCircling) BottomMode=MAXBOTTOMMODES;
d438 1
a438 1
						BottomMode=0;
d447 2
a448 2
					BottomMode=MAXBOTTOMMODES;
				} else if ( ((BottomMode-1)==1)&& (DisplayMode!=dmCircling)) {
d490 2
a491 2
		///: CLICK ON SORTBOX line at the top, only with no map
		if ( MapSpaceMode >MSM_MAP && Y<=SortBoxY ) {
d510 2
d545 1
a545 1
						numpages=Numpages; // TODO use Numpages[MapSpaceMode]
d549 2
d556 11
d782 3
a784 3
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); //Title
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); //Title
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); //MapWindow
d787 3
a789 3
		propGetFontSettingsFromString(TEXT("64,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // FIX
		propGetFontSettingsFromString(TEXT("48,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);  // FIX
		propGetFontSettingsFromString(TEXT("32,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); // FIX
d811 3
a813 3
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); //Title
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); //Title
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); //MapWindow
d815 3
a817 3
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); // FIX
d838 3
a840 3
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); //Title
		propGetFontSettingsFromString(TEXT("28,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); //Title
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); //MapWindow
d842 3
a844 3
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); // FIX
d847 2
a848 2
	// Units are too big, tahoma is not enough. Units are disabled by default.
	// This is also used by 640x480 devices actually, if SE_VGA is not disabled
d870 3
a872 3
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); //Title
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); //Title
		propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); //MapWindow
d874 3
a876 3
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); // FIX
d899 3
a901 3
		propGetFontSettingsFromString(TEXT("38,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); //Title
		propGetFontSettingsFromString(TEXT("38,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); //Title
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); //MapWindow
d903 3
a905 3
		propGetFontSettingsFromString(TEXT("56,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // FIX
		propGetFontSettingsFromString(TEXT("44,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);  // FIX
		propGetFontSettingsFromString(TEXT("28,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); // FIX
d908 3
a910 3
	/////////////////////////////////////////////////////////////
	////////////////       Portrait  mode        ////////////////
	/////////////////////////////////////////////////////////////
d932 3
a934 3
		propGetFontSettingsFromString(TEXT("17,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); //Title
		propGetFontSettingsFromString(TEXT("17,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); //Title
		propGetFontSettingsFromString(TEXT("15,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); //MapWindow
d936 3
a938 3
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); // FIX
d962 3
a964 3
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); //Title
		propGetFontSettingsFromString(TEXT("34,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); //Title
		propGetFontSettingsFromString(TEXT("30,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); //MapWindow
d966 3
a968 3
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); // FIX
d982 3
a984 3
		propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBig); //Title
		propGetFontSettingsFromString(TEXT("12,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), &logfontInfoBigItalic); //Title
		propGetFontSettingsFromString(TEXT("9,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoNormal); //MapWindow
d986 3
a988 3
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelBig);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelMedium);  // FIX
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontPanelSmall); // FIX
d1125 2
a1126 1
		///: Normal alternates forced on for LK8000. In MapWindow3 if not valid they are reset off
d1132 24
d1801 1
a1801 1
	///: this table is for submenus
d1812 3
a1814 1
	ModeTable[LKMODE_INFOMODE][IM_HORIZON]	=	MSM_INFO_HORIZON;
d1957 17
@


8.13
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.12 2009/09/02 20:29:45 root Exp $
d62 1
d382 5
a386 2
	xleft=sizeright/3; // TODO FIX 
	xright=sizeright-xleft; 
d471 3
a473 2
			///: long press on center navbox
			if (keytime>300) {
d482 1
d484 1
a485 3
			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
d506 3
d521 3
a523 3
			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
d543 1
d550 1
d554 1
d565 1
d1168 1
a1168 1
	  SetTextColor(hDC,RGB(0x00,0x00,0x00));  // black 
d1171 1
a1171 1
	  SetTextColor(hDC,RGB(0xff,0xff,0xff));  // white
d1174 1
a1174 1
	  SetTextColor(hDC,RGB(0x00,0xff,0x00));  // green
d1177 1
a1177 1
	  SetTextColor(hDC,RGB(0xff,0x00,0x00));  // red
d1180 1
a1180 1
	  SetTextColor(hDC,RGB(0x00,0x00,0xff));  // blue
d1183 1
a1183 1
	  SetTextColor(hDC,RGB(0xff,0xff,0x00));  // yellow
d1186 1
a1186 1
	  SetTextColor(hDC,RGB(0x00,0xff,0xff));  // cyan
d1189 1
a1189 1
	  SetTextColor(hDC,RGB(0xff,0x00,0xff));  // magenta
d1192 1
a1192 1
	  SetTextColor(hDC,RGB(0xcc,0xcc,0xcc));  // light grey
d1195 1
a1195 1
	  SetTextColor(hDC,RGB(0x99,0x99,0x99));  // grey
d1198 1
a1198 1
	  SetTextColor(hDC,RGB(0xc2,0xff,0xc2));  //  light green
d1201 1
a1201 1
	  SetTextColor(hDC,RGB(0xff,0xc2,0xc2));  // light red
d1204 1
a1204 1
	  SetTextColor(hDC,RGB(0xff,0xff,0xc2));  // light yellow
d1207 1
a1207 1
	  SetTextColor(hDC,RGB(0xc2,0xff,0xff));  // light cyan
d1210 1
a1210 1
	  SetTextColor(hDC,RGB(255,265,0));  // orange
d1213 1
a1213 1
	  SetTextColor(hDC,RGB(255,184,51));  // light orange
d1216 1
a1216 1
	  SetTextColor(hDC,RGB(179,179,255));  // light blue
d1219 1
a1219 1
	  SetTextColor(hDC,RGB(0x00,0xff,0xff));  // magenta so we know it's wrong: nobody use magenta..
d1840 17
d1909 1
@


8.12
log
@progress lk values
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.11 2009/07/30 13:38:15 root Exp root $
d470 1
a470 1
				MapSpaceMode=MSM_MAP;
d477 1
a477 32
			///: FIX temp mapspace advance to map. Should be nextmapspace
			if ((MapSpaceMode+1) >MSM_TOP ) 
				MapSpaceMode=MSM_MAP;
			else {
				switch(++MapSpaceMode) {
					case MSM_LANDABLE:
					case MSM_AIRPORTS:
						///: force DoNearest to run at once
						LKForceDoNearest=true;
						LKevent=LKEVENT_NEWRUN;
						SelectedPage[MapSpaceMode]=0;
						SelectedRaw[MapSpaceMode]=0;
						break;
					case MSM_COMMON:
						LKForceDoCommon=true;
						LKevent=LKEVENT_NEWRUN;
						SelectedPage[MapSpaceMode]=0;
						SelectedRaw[MapSpaceMode]=0;
						break;
					case MSM_RECENT:
						LKForceDoRecent=true;
						LKevent=LKEVENT_NEWRUN;
						SelectedPage[MapSpaceMode]=0;
						SelectedRaw[MapSpaceMode]=0;
						break;
					case MSM_INFO_CRUISE:
						break;
					default:
						break;
				}
			}
			//NextMapSpace();
d594 1
a594 1
				NextMapSpace();
d603 1
a603 1
				PreviousMapSpace();
d1093 1
a1095 1
	if ( AircraftCategory == (AircraftCategory_t)umParaglider ) return;
d1097 8
a1104 4
	///: Normal alternates forced on for LK8000. In MapWindow3 if not valid they are reset off
	OnAlternate1=true;
	OnAlternate2=true;
	OnBestAlternate=true;
d1738 31
a1768 6
///: MapSpaceMode=0  welcome screen
///: MapSpaceMode=1  moving map
///: MapSpaceMode=2  nearest landings
///: MapSpaceMode=3  nearest airports
///: MapSpaceMode=4  common waypoints
///: MapSpaceMode=5  recent waypoints
d1770 3
a1772 1
void NextMapSpace() {
d1774 23
a1796 2
	if ((MapSpaceMode+1) >MSM_TOP ) {
		MapSpaceMode=MSM_MAP+1;
d1798 1
a1798 24
		switch(++MapSpaceMode) {
			case MSM_LANDABLE:
			case MSM_AIRPORTS:
				///: force DoNearest to run at once
				LKForceDoNearest=true;
				LKevent=LKEVENT_NEWRUN;
				SelectedPage[MapSpaceMode]=0;
				SelectedRaw[MapSpaceMode]=0;
				break;
			case MSM_COMMON:
				LKForceDoCommon=true;
				LKevent=LKEVENT_NEWRUN;
				SelectedPage[MapSpaceMode]=0;
				SelectedRaw[MapSpaceMode]=0;
				break;
			case MSM_RECENT:
				LKForceDoRecent=true;
				LKevent=LKEVENT_NEWRUN;
				SelectedPage[MapSpaceMode]=0;
				SelectedRaw[MapSpaceMode]=0;
				break;
			default:
				break;
		}
d1800 1
a1802 2
///: temp do not return to map
void PreviousMapSpace() {
d1804 78
a1881 27
	if ((MapSpaceMode-1) <=MSM_MAP )
		MapSpaceMode=MSM_TOP;
	else {
		switch(--MapSpaceMode) {
			case MSM_LANDABLE:
			case MSM_AIRPORTS:
				///: force DoNearest to run at once
				LKForceDoNearest=true;
				LKevent=LKEVENT_NEWRUN;
				SelectedPage[MapSpaceMode]=0;
				SelectedRaw[MapSpaceMode]=0;
				break;
			case MSM_COMMON:
				LKForceDoCommon=true;
				LKevent=LKEVENT_NEWRUN;
				SelectedPage[MapSpaceMode]=0;
				SelectedRaw[MapSpaceMode]=0;
				break;
			case MSM_RECENT:
				LKForceDoRecent=true;
				LKevent=LKEVENT_NEWRUN;
				SelectedPage[MapSpaceMode]=0;
				SelectedRaw[MapSpaceMode]=0;
				break;
			default:
				break;
		}
d1883 1
d1885 1
@


8.11
log
@9i
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.10 2009/07/24 14:31:52 root Exp root $
d56 1
d63 2
d356 1
d389 1
a389 1
	if (NewMap &&  DrawBottom && vkmode==0) {
d393 1
a393 1
		if (Y>= (sizeup-BottomSize-IBLSCALE(15)) ) {
d463 1
d465 1
d467 2
a468 1
			if (keytime>1000) {
d477 2
a478 6
			///: MapSpaceMode=0  welcome screen
			///: MapSpaceMode=1  moving map
			///: MapSpaceMode=2  nearest landings
			///: MapSpaceMode=3  nearest airports
			///: MapSpaceMode=4  recent waypoints
			if ((MapSpaceMode+1) >MSM_TOP )
d481 26
a506 6
				///: force DoNearest to run at once
				LKForceDoNearest=true;
				++MapSpaceMode; 
				LKevent=LKEVENT_NEWRUN;
				SelectedPage[MapSpaceMode]=0;
				SelectedRaw[MapSpaceMode]=0;
d508 1
d528 15
a542 2
			SortedMode[MapSpaceMode]=j;
			LKForceDoNearest=true;
d560 1
a560 1
	if (vkmode>0) {
d563 12
a574 1
		LKForceDoNearest=true;
d576 10
d588 1
a588 1
			case 2:
d590 1
a590 1
				if (++SelectedPage[MapSpaceMode] >=Numpages) {
d604 1
a604 1
			case 1:
d609 1
a609 1
					SelectedPage[MapSpaceMode]=(Numpages-1);
d624 18
d652 1
a652 1
			if (MapSpaceMode<2) return 0;
d656 2
a657 1
			if (--SelectedRaw[MapSpaceMode] <0) SelectedRaw[MapSpaceMode]=Numraws-1;
d671 1
a671 1
			if (MapSpaceMode<2) return 0;
d675 2
a676 1
			if (++SelectedRaw[MapSpaceMode] >=Numraws) SelectedRaw[MapSpaceMode]=0;
d712 1
d745 3
d762 3
d792 3
d820 3
d847 3
d879 3
d907 4
a910 1
		propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontInfoSmall);
d941 3
d971 3
d991 3
d1011 3
d1027 3
d1124 1
d1722 114
@


8.10
log
@9g
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.9 2009/07/24 10:00:00 root Exp root $
d60 1
a60 1

d352 1
d387 1
a387 1
		///: CLICKS on NAVBOXES
d491 26
a516 1
		} 
d663 1
d677 1
d703 1
d729 1
d753 1
d782 1
d808 1
d838 1
d865 1
d882 1
d898 1
d912 1
d1017 2
@


8.9
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.8 2009/07/22 10:53:48 root Exp root $
d636 3
d649 3
d673 5
d699 3
d722 3
d750 3
d775 3
d804 3
d830 3
d846 3
a852 1
  logfontTitle.lfQuality = ANTIALIASED_QUALITY; 
d856 1
d859 5
d865 1
d874 3
d1058 1
a1058 1
	  SetTextColor(hDC,RGB(160,0xff,160));  //  light green
d1064 1
a1064 1
	  SetTextColor(hDC,RGB(0xff,0xff,160));  // light yellow
d1067 1
a1067 1
	  SetTextColor(hDC,RGB(99,0xff,0xff));  // light cyan
@


8.8
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.7 2009/07/17 15:26:15 root Exp root $
d59 2
d344 1
a346 2
// 0 is always thermal mode, and does not account
#define MAXBOTTOMMODES 5
d365 2
a366 2
		yup=((sizeup-BottomSize-TopSize)/2.7)+MapWindow::MapRect.top+TopSize;
		ydown=MapWindow::MapRect.bottom-BottomSize-((sizeup-BottomSize)/2.7);
d368 2
a369 2
		yup=(sizeup/2.7)+MapWindow::MapRect.top;
		ydown=MapWindow::MapRect.bottom-(sizeup/2.7);
d371 1
a371 1
//	TCHAR buf[100];
d384 1
a384 1
	if (NewMap &&  DrawBottom) {
a456 3
			#ifndef DISABLEAUDIO
		        // if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
d462 1
a462 1
				MapSpaceMode=1;
d474 2
a475 2
			if ((MapSpaceMode+1) >3 )
				MapSpaceMode=1;
d480 3
a488 1

d495 52
d548 1
a548 1
		///: we are processing up/down in mapspacemode
d927 13
d1017 1
a1017 1
	  SetTextColor(hDC,RGB(128,0xff,128));  //  light green
@


8.7
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.6 2009/07/14 19:52:03 root Exp root $
d340 2
d349 2
d360 17
a376 6
	short sizeup=MapWindow::MapRect.bottom-MapWindow::MapRect.top;
	short sizeright=MapWindow::MapRect.right-MapWindow::MapRect.left;
	short yup=(sizeup/3)+MapWindow::MapRect.top;
	short ydown=MapWindow::MapRect.bottom-(sizeup/3);
	short xleft=sizeright/3; // TODO FIX 
	short xright=sizeright-xleft; 
d384 3
d392 1
d405 1
a405 1
                                                if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_BELL"));
d411 1
d417 1
d430 1
a430 1
                                        	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_BELL"));
d432 1
d440 1
a440 1
                                       	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_BELL"));
d443 1
d449 1
d466 1
a466 1
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_BELL"));
d468 1
d471 13
a483 1
			if ((MapSpaceMode+1) >2 ) MapSpaceMode=1; else ++MapSpaceMode; // 3 for recent
d496 10
a505 1
		if (dontdrawthemap) return 0;
d515 9
a523 1
		if (dontdrawthemap) return 0;
d544 1
d550 10
a559 3
		/*
		 * FIX ready: do not pass virtual ENTER while in Panmode.
		 * Currently it is allowed, should be better tested.  VNT 090702
d564 4
a567 3
		return 0; // ignore it
		*/
	        return 13;
d914 546
@


8.6
log
@spostato initscreensize e aggiunti drawmap
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.5 2009/07/11 12:23:47 root Exp root $
d435 2
a436 1
			///: Do something useful with a <center> virtual key .. in the very near future
d439 1
d446 1
a446 1
			if ((MapSpaceMode+1) >3 ) MapSpaceMode=1; else ++MapSpaceMode;
@


8.5
log
@revised
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.4 2009/07/05 22:58:13 root Exp root $
d345 3
d437 12
d454 1
d457 1
d467 1
d478 15
a492 8
	/*
	 * After some betas, it is clear to me that discriminating on a long keypress is complicating life too much
	 * so it is now disabled. It could be enabled as a user choice, but I don't think so, right now. VNT 090702
	
	if (keytime>=VKTIMELONG)
		return 27;
	else {
	 */
d503 1
a503 1
//	}
d737 42
@


8.4
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.3 2009/07/01 22:25:49 root Exp root $
d338 1
a338 2
	TODO use vk to exit thermal mode
	
a351 1
	//static short BOTTOMSIZE= Appearance.StatisticsFont.Height + Appearance.MapWindowFont.Height;
d363 2
a364 2
	// Handle fullscreen 8000 mode 
	// sound clicks require some attention here
d375 1
a375 1
			// We might in the future handle long presses also here to gain 3 more buttons
d396 1
a396 1
			if ( X<xleft ) { // following is ugly but im tired and have to go
d432 1
a432 1
			// Do something useful with a <center> virtual key .. in the very near future
d439 1
a439 1
	// Emulate real keypresses with wParam
d458 1
a458 1
	// no click for already clicked events
d462 1
a462 1
	 * so it is now disabled. It could be enabled as a user choice, but don't think so right now. VNT 090702
d712 1
a712 1
// VNT need some different initialisations for para, delta, etc.
d746 1
a746 1
#ifndef DISABLEAUDIO
d749 1
a749 1
#endif
d758 1
a758 1
#ifndef DISABLEAUDIO
d761 1
a761 1
#endif
d778 1
a778 1
	// rules tbd
@


8.3
log
@wip
ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.2 2009/06/27 17:18:12 root Exp $
d347 1
a347 1
#ifdef DEBUG_PROCVK
d352 1
a352 1
#endif
d361 1
a361 1
#ifdef DEBUG_PROCVK
d363 1
a363 1
#endif
d366 1
a366 1
	// sound clicks requires some attention here
d379 1
a379 1
#ifdef DEBUG_PROCVK
d382 1
a382 1
#endif
d384 1
a384 1
#ifndef DISABLEAUDIO
d386 1
a386 1
#endif
d393 1
a393 1
#ifndef DISABLEAUDIO
d395 1
a395 1
#endif
d399 1
a399 1
#ifdef DEBUG_PROCVK
d402 1
a402 1
#endif
d407 1
a407 1
#ifndef DISABLEAUDIO
d409 1
a409 1
#endif
d416 1
a416 1
#ifndef DISABLEAUDIO
d418 1
a418 1
#endif
d422 1
a422 1
#ifndef DISABLEAUDIO
d424 1
a424 1
#endif
d427 1
a427 1
#ifdef DEBUG_PROCVK
d430 2
a431 2
#endif
#ifndef DISABLEAUDIO
d433 4
a436 2
#endif
			// Do something useful with a <center> virtual key .. in the near future
d443 1
a443 1
#ifndef DISABLEAUDIO
d445 1
a445 1
#endif
d452 1
a452 1
#ifndef DISABLEAUDIO
d454 1
a454 1
#endif
d461 5
d469 4
a472 2
/*
		// do not pass virtual ENTER while in Panmode: currently it is allowed
d478 1
a478 1
*/
d480 1
a480 1
	}
d510 1
a510 1
  // > ALSO UNSED SPLITTER VALUES ARE FINE TUNED!
d516 1
a516 1
	case (ScreenSize_t)ss800x480:		// PASSED OK-1 090701 VENTA
d518 1
a518 1
		propGetFontSettingsFromString(TEXT("64,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
d520 1
a520 1
		propGetFontSettingsFromString(TEXT("40,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
d524 2
a525 2
		propGetFontSettingsFromString(TEXT("48,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
		propGetFontSettingsFromString(TEXT("48,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
d529 1
a529 1
	case (ScreenSize_t)ss480x272:
d531 1
a531 1
		propGetFontSettingsFromString(TEXT("38,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
d533 1
a533 1
		propGetFontSettingsFromString(TEXT("24,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
d542 5
a546 5
			propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
			propGetFontSettingsFromString(TEXT("24,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
			propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
			BottomSize=37; // Title+Value-4 plus something more
d549 1
a549 1
	case (ScreenSize_t)ss480x234:
d551 1
a551 1
		propGetFontSettingsFromString(TEXT("38,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
d553 1
a553 1
		propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
d563 2
a564 2
			propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
			propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
d566 1
a566 1
			BottomSize=36; // Title+Value-4
d571 1
a571 1
	// This is also used by 640x480 devices actually, since SE_VGA is not disabled
d573 1
a573 1
	case (ScreenSize_t)ss320x240:		// PASSED OK-1 090701 VENTA
d595 1
a595 1
	case (ScreenSize_t)ss640x480:		// PASSED OK-1 090701 VENTA
d597 1
a597 1
		propGetFontSettingsFromString(TEXT("62,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
d621 1
a621 1
	case (ScreenSize_t)ss240x320:		// PASSED OK-1 090701 VENTA
d643 1
a643 1
	case (ScreenSize_t)ss480x640:		// PASSED OK-1 090701 VENTA
d682 2
a683 2
  logfontTarget.lfQuality = ANTIALIASED_QUALITY; 
  logfontBig.lfQuality = ANTIALIASED_QUALITY; 
@


8.2
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 8.1 2009/06/19 20:28:25 venta Exp root $
d498 1
d501 2
a502 1
  
d507 2
a508 3
	case (ScreenSize_t)ss800x480:
	 	propGetFontSettingsFromString(TEXT("36,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
		propGetFontSettingsFromString(TEXT("48,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
a509 1
		propGetFontSettingsFromString(TEXT("48,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
a510 1
		propGetFontSettingsFromString(TEXT("18,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
d513 5
d521 1
a521 2
	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
		propGetFontSettingsFromString(TEXT("24,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
d523 1
a523 2
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("12,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
d526 13
a538 1
		BottomSize=36; // Title+Value-4
d541 1
a541 2
	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
		propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
d543 1
a543 2
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("12,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
d546 13
a558 1
		BottomSize=36; // Title+Value-4
d562 6
a567 6
	case (ScreenSize_t)ss320x240:
	 	propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
		propGetFontSettingsFromString(TEXT("20,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
		propGetFontSettingsFromString(TEXT("30,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		propGetFontSettingsFromString(TEXT("16,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("8,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
d570 14
a583 1
		BottomSize=24; // Title+Value-4
d586 4
a589 6
	case (ScreenSize_t)ss640x480:
	 	propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
		propGetFontSettingsFromString(TEXT("40,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
		propGetFontSettingsFromString(TEXT("60,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		propGetFontSettingsFromString(TEXT("32,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("16,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
d592 14
a605 1
		BottomSize=56; // Title+Value-4
d608 24
a631 11
	// Portrait 

	case (ScreenSize_t)ss240x320:
	 	propGetFontSettingsFromString(TEXT("9,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
		propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
		propGetFontSettingsFromString(TEXT("28,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		propGetFontSettingsFromString(TEXT("11,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("6,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
		propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontMedium);
		propGetFontSettingsFromString(TEXT("6,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontSmall);
		BottomSize=20; // Title+Value-4  a bit bigger here
d634 4
a637 6
	case (ScreenSize_t)ss480x640:
	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
		propGetFontSettingsFromString(TEXT("40,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
		propGetFontSettingsFromString(TEXT("56,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), &logfontBig);
		propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("12,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
d640 15
a654 1
		BottomSize=40; // Title+Value-4 a bit bigger here
d660 1
d665 1
a665 1
		propGetFontSettingsFromString(TEXT("16,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
@


8.1
log
@beta8
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 1.7 2009/06/17 01:49:09 root Exp root $
a53 1
//#include "MapWindow.h"
d56 3
d344 1
a344 1
#define MAXBOTTOMMODES 4
d347 1
a347 1
#ifdef DEBUG_VIRTUALKEY
d353 2
a354 1
	static short BOTTOMSIZE= Appearance.StatisticsFont.Height + Appearance.MapWindowFont.Height;
d361 1
a361 1
#ifdef DEBUG_VIRTUALKEY
d368 9
a376 1
		if (Y>= (sizeup-BOTTOMSIZE-IBLSCALE(15)) ) {
d379 2
a380 2
#ifdef DEBUG_VIRTUALKEY
				wsprintf(buf,_T("RIGHT in limit=%d"),sizeup-BOTTOMSIZE-IBLSCALE(20));
d399 2
a400 2
#ifdef DEBUG_VIRTUALKEY
				wsprintf(buf,_T("LEFT in limit=%d"),sizeup-BOTTOMSIZE-IBLSCALE(20));
d427 2
a428 2
#ifdef DEBUG_VIRTUALKEY
			wsprintf(buf,_T("CENTER in limit=%d"),sizeup-BOTTOMSIZE-IBLSCALE(20));
d431 3
d461 13
a473 3
	else
		return 13;

d486 1
d496 1
d510 1
d512 2
d522 2
d532 2
d537 1
a537 1
	// Units are too big, tahoma is not enough. Like this small obsoleted screen geometry.
d540 1
a540 1
		propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), &logfontTarget);
d544 2
d555 2
d563 1
a563 1
	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
d566 5
a570 3
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("16,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
		BottomSize=34; // Title+Value-4
d574 1
a574 1
	 	propGetFontSettingsFromString(TEXT("36,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
d577 5
a581 3
		propGetFontSettingsFromString(TEXT("40,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("32,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
		BottomSize=72; // Title+Value-4
d592 2
d603 2
d610 3
d629 30
d662 11
d674 27
@


1.7
log
@beta8
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 1.6 2009/06/16 14:07:26 root Exp root $
@


1.6
log
@in corso
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 1.5 2009/06/15 09:32:29 root Exp root $
d472 2
a473 1
  // Scalable master size for screen resolution
d492 2
a493 2
		propGetFontSettingsFromString(TEXT("14,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
		BottomSize=38; // Title+Value-4
d499 1
a499 1
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
d501 1
a501 1
		BottomSize=38; // Title+Value-4
d504 1
d506 1
a506 1
	 	propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontTitle);
d509 12
a520 3
		propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), &logfontValue);
		propGetFontSettingsFromString(TEXT("10,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), &logfontUnit);
		BottomSize=38; // Title+Value-4
d531 1
a531 1
		BottomSize=38; // Title+Value-4
@


1.5
log
@ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 1.4 2009/06/14 11:29:03 root Exp root $
d104 2
d455 47
a501 2
   // TODO> rewrite from scratch font handling for newmap
   BottomSize= Appearance.StatisticsFont.Height + Appearance.MapWindowFont.Height;
d503 65
d572 2
@



1.4
log
@provvisorio ok
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 1.3 2009/06/11 19:50:22 root Exp root $
d340 1
a340 1
#define MAXBOTTOMMODES 3
d352 4
a355 4
	short yup=sizeup/3;
	short ydown=sizeup-yup;
	short xleft=sizeright/3;
	short xright=sizeright-xleft;
@


1.3
log
@alpha
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 1.2 2009/06/01 21:17:16 root Exp root $
d331 1
a331 1
	Virtual Key Manager by Venta
d341 1
d356 1
a356 1

d358 1
a359 3
#ifndef DISABLEAUDIO
        if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
#endif
d361 1
d374 5
a378 2
					if ( DisplayMode == dmCircling) BottomMode=0;
					else BottomMode=1;
d380 3
a382 1

d397 1
d407 1
d409 3
a411 1
					
d424 23
a446 3
	if (Y<yup)   return 38;
	if (Y>ydown) return 40;
	return 13;
d450 6
d457 3
@


1.2
log
@funziona
@
text
@d34 1
a34 1
  $Id: Utils2.cpp,v 1.1 2009/06/01 12:50:16 root Exp root $
d54 2
d330 11
d342 78
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
  $Id: Utils.cpp,v 1.202 2009/05/24 10:56:52 jwharington Exp $
d52 1
a55 10
/*
#define RASIZE 200
#define MAXITERFILTER 10

typedef struct {
        int     array[RASIZE]; // rotary array with a predefined max capacity
        short   start;          // pointer to current first item in rotarybuf if used
        short   size;           // real size of rotary buffer (0-size)
} ifilter_s;
*/
d57 3
a59 3

bool InitLDRotary(ldrotary_s *buf, short bsize) {
short i;
d62 1
d64 24
a87 1
	if (bsize <3 || bsize>MAXLDROTARYSIZE) return false;
d96 2
d101 1
d105 2
a106 1
static errs=0;
d109 18
d129 2
a130 1
		if (errs>0) if (errs>2) {
d134 3
a136 1
			InitLDRotary(&rotaryLD,90);
d141 1
d145 1
d150 1
d154 1
d158 1
a158 1
	// need to fill up buffer before start to emptying it
d163 1
d167 1
d172 1
d177 1
d180 10
d192 1
d196 1
a196 1

a198 1
//	if ( buf->valid == false) return(0); // unavailable
a201 6
/*
	if (bc.start==0) 
		bcold=bc.size-1; 
	else
		bcold=bc.start-1;
*/
d215 1
a215 1
	if (altdiff == 0 ) return(999); // infinitum
d218 1
d224 1
d226 1
a226 1
	if (eff>200) eff=999;
@
