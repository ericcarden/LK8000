head	8.46;
access;
symbols
	beta8:8.1;
locks
	root:8.46; strict;
comment	@// @;


8.46
date	2010.12.12.14.33.14;	author root;	state Exp;
branches;
next	8.45;

8.45
date	2010.04.13.15.26.53;	author root;	state Exp;
branches;
next	8.44;

8.44
date	2010.02.15.13.02.06;	author root;	state Exp;
branches;
next	8.43;

8.43
date	2010.02.13.13.32.12;	author root;	state Exp;
branches;
next	8.42;

8.42
date	2010.01.26.23.41.05;	author root;	state Exp;
branches;
next	8.41;

8.41
date	2009.12.29.16.14.49;	author root;	state Exp;
branches;
next	8.40;

8.40
date	2009.12.21.15.35.01;	author root;	state Exp;
branches;
next	8.39;

8.39
date	2009.12.17.20.40.00;	author root;	state Exp;
branches;
next	8.38;

8.38
date	2009.12.05.19.32.18;	author root;	state Exp;
branches;
next	8.37;

8.37
date	2009.11.24.00.42.23;	author root;	state Exp;
branches;
next	8.36;

8.36
date	2009.11.23.00.51.51;	author root;	state Exp;
branches;
next	8.35;

8.35
date	2009.11.11.00.52.23;	author root;	state Exp;
branches;
next	8.34;

8.34
date	2009.11.10.22.21.51;	author root;	state Exp;
branches;
next	8.33;

8.33
date	2009.11.09.21.04.46;	author root;	state Exp;
branches;
next	8.32;

8.32
date	2009.11.01.01.21.29;	author root;	state Exp;
branches;
next	8.31;

8.31
date	2009.10.23.11.27.16;	author root;	state Exp;
branches;
next	8.30;

8.30
date	2009.10.19.23.11.36;	author root;	state Exp;
branches;
next	8.29;

8.29
date	2009.10.16.10.59.50;	author root;	state Exp;
branches;
next	8.28;

8.28
date	2009.10.12.13.25.12;	author root;	state Exp;
branches;
next	8.27;

8.27
date	2009.10.01.15.04.49;	author root;	state Exp;
branches;
next	8.26;

8.26
date	2009.09.28.09.50.14;	author root;	state Exp;
branches;
next	8.25;

8.25
date	2009.09.24.16.21.48;	author root;	state Exp;
branches;
next	8.24;

8.24
date	2009.09.21.08.58.36;	author root;	state Exp;
branches;
next	8.23;

8.23
date	2009.09.20.20.28.35;	author root;	state Exp;
branches;
next	8.22;

8.22
date	2009.09.19.01.07.31;	author root;	state Exp;
branches;
next	8.21;

8.21
date	2009.09.16.10.56.39;	author root;	state Exp;
branches;
next	8.20;

8.20
date	2009.09.09.22.59.39;	author root;	state Exp;
branches;
next	8.19;

8.19
date	2009.09.07.19.08.20;	author root;	state Exp;
branches;
next	8.18;

8.18
date	2009.09.02.20.28.34;	author root;	state Exp;
branches;
next	8.17;

8.17
date	2009.07.30.13.38.07;	author root;	state Exp;
branches;
next	8.16;

8.16
date	2009.07.24.14.32.15;	author root;	state Exp;
branches;
next	8.15;

8.15
date	2009.07.24.08.38.15;	author root;	state Exp;
branches;
next	8.14;

8.14
date	2009.07.22.18.53.58;	author root;	state Exp;
branches;
next	8.13;

8.13
date	2009.07.22.17.53.03;	author root;	state Exp;
branches;
next	8.12;

8.12
date	2009.07.22.10.54.02;	author root;	state Exp;
branches;
next	8.11;

8.11
date	2009.07.21.13.14.10;	author root;	state Exp;
branches;
next	8.10;

8.10
date	2009.07.17.15.25.21;	author root;	state Exp;
branches;
next	8.9;

8.9
date	2009.07.14.19.50.56;	author root;	state Exp;
branches;
next	8.8;

8.8
date	2009.07.13.21.59.03;	author root;	state Exp;
branches;
next	8.7;

8.7
date	2009.07.05.22.57.54;	author root;	state Exp;
branches;
next	8.6;

8.6
date	2009.07.01.22.26.20;	author root;	state Exp;
branches;
next	8.5;

8.5
date	2009.06.30.14.47.48;	author root;	state Exp;
branches;
next	8.4;

8.4
date	2009.06.28.21.30.41;	author root;	state Exp;
branches;
next	8.3;

8.3
date	2009.06.27.17.18.37;	author root;	state Exp;
branches;
next	8.2;

8.2
date	2009.06.24.10.03.57;	author root;	state Exp;
branches;
next	8.1;

8.1
date	2009.06.19.20.28.25;	author venta;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.16.14.07.36;	author root;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.15.09.32.09;	author root;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.14.11.28.43;	author root;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.11.19.50.42;	author root;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.11.10.00.03;	author root;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.10.22.49.40;	author root;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.08.11.33.21;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.07.11.38.58;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.06.12.21.38;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.04.16.02.47;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.01.21.16.28;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.28.20.18.51;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.27.11.27.14;	author root;	state Exp;
branches;
next	;


desc
@iniziale
@

8.46
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: MapWindow3.cpp,v 8.45 2010/04/13 15:26:53 root Exp root $ BAD
*/

#include "StdAfx.h"
#include "options.h"
#include "Cpustats.h"
#include "XCSoar.h"
#include "compatibility.h"
#include "McReady.h"
#include "externs.h"
#include <windows.h>
#include <math.h>
#include <tchar.h>
#include "InfoBoxLayout.h"
#include "LKMapWindow.h"
#include "buildnumber.h"
#if LKOBJ
#include "LKObjects.h"
#endif

#if (WINDOWSPC>0)
#include <wingdi.h>
#endif

extern void DrawGlideCircle(HDC hdc, POINT Orig, RECT rc );
extern void MapWaypointLabelAdd(TCHAR *Name, int X, int Y, TextInBoxMode_t Mode, int AltArivalAGL, bool inTask, 
	bool isLandable, bool isAirport, bool isExcluded, int index);
extern int _cdecl MapWaypointLabelListCompare(const void *elem1, const void *elem2 );

extern void DrawMapSpace(HDC hdc, RECT rc);
extern void DrawNearest(HDC hdc, RECT rc);
extern void DrawNearestTurnpoint(HDC hdc, RECT rc);
extern void DrawCommon(HDC hdc, RECT rc);
extern void DrawTraffic(HDC hdc, RECT rc);
extern void DrawWelcome8000(HDC hdc, RECT rc);
#ifdef CPUSTATS
extern void DrawCpuStats(HDC hdc, RECT rc);
#endif
#ifdef DRAWDEBUG
extern void DrawDebug(HDC hdc, RECT rc);
#endif

extern void WriteInfo(HDC hdc, bool *showunit, TCHAR *BufferValue, TCHAR *BufferUnit, TCHAR *BufferTitle, 
				short *columnvalue, short *columntitle, short *row1, short *row2, short *row3);

extern int PDABatteryPercent;
extern int PDABatteryTemperature;
extern int MapWaypointLabelListCount;
extern void ConvToUpper(TCHAR *str);

typedef struct{
  TCHAR Name[NAME_SIZE+1];
  POINT Pos;
  TextInBoxMode_t Mode;
  int AltArivalAGL;
  bool inTask;
  bool isLandable; // VENTA5
  bool isAirport; // VENTA5
  bool isExcluded;
  int  index;
}MapWaypointLabel_t;


extern MapWaypointLabel_t MapWaypointLabelList[];


/*
 * The VisualGlide by Paolo Ventafridda
 * Sort of a Stocker dynamic chart!
 *
 * VisualGlide=1 : Steady sector/circle
 *             2 : Moving sector/circle   optional configurable, not much useful.
 */
void MapWindow::DrawGlideCircle(HDC hdc, POINT Orig, RECT rc )
{
  double tmp=0;
  TCHAR gtext[LKSIZEBUFFERLARGE];
  char text[LKSIZETEXT]; 
  double cruise=1;
  int i;
  double gunit;
  COLORREF oldcolor=0;
  HFONT oldfont;

  static double maxcruise;
  static double mincruise;
  static int spread;

  maxcruise=(GlidePolar::bestld); 
  mincruise=(GlidePolar::bestld/4);

  cruise= CALCULATED_INFO.AverageLD; 

  if ( cruise <= 0 ) cruise = GlidePolar::bestld; // 091215 let cruise be always reasonable
  if ( cruise < mincruise ) return;
  if ( cruise >maxcruise ) cruise=maxcruise;


  // Spread from 
  static short turn=1;
  static short count=0;
  spread += (10 * turn); 
  if ( spread <-25 || spread >25 ) turn*=-1;
  if ( ++count >6) count=-1;

  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
  // SetBkMode(hdc,TRANSPARENT);

  //oldfont = (HFONT)SelectObject(hdc, MapWindowBoldFont); // FIXFONT
  oldfont = (HFONT)SelectObject(hdc, LK8InfoNormalFont); // FIXFONT

  // 100m or 300ft scale
  if ( Units::GetUserAltitudeUnit() == unMeter ) gunit=100; else gunit = 91.44;

  for (i=1; i<9; i++) {

      SelectObject(hdc, hpVisualGlideHeavyBlack); // 091215
#if 0
    // toggling colors 
    if (turn>0 ) {
      if ( (i==2 || i==4 || i==6 || i == 8) ) SelectObject(hdc, hpVisualGlideHeavyRed);
      else SelectObject(hdc, hpVisualGlideLightRed);
    } else {
      if ( (i==2 || i==4 || i==6 || i == 8) ) SelectObject(hdc, hpVisualGlideHeavyBlack);
      else SelectObject(hdc, hpVisualGlideLightBlack);
    }
#endif
#if 0
    if (turn>0 )
		SelectObject(hdc, hpVisualGlideHeavyRed);
    else
		SelectObject(hdc, hpVisualGlideHeavyBlack);
#endif

    /*
     * TRACKUP, NORTHUP, NORTHCIRCLE, TRACKCIRCLE, NORTHTRACK
     */
	if ( ( DisplayOrientation == TRACKUP) || (DisplayOrientation == NORTHCIRCLE) || (DisplayOrientation == TRACKCIRCLE)
		&& (DisplayMode != dmCircling) ) {

		if ( VisualGlide == 1 ) {
			tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
			DrawArc(hdc, Orig.x, Orig.y,(int)tmp, rc, 315, 45);
		} else {
			tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
			DrawArc(hdc, Orig.x, Orig.y,(int)tmp, rc, 330+spread, 30+spread);
		}
	} else {
		tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
		Circle(hdc, Orig.x,Orig.y,(int)tmp, rc, true, false);
	}


	if (turn>0) oldcolor=SetTextColor(hdc, RGB_BLACK); 
	else oldcolor=SetTextColor(hdc, RGB_BLUE); // red

	if ( i==2 || i==4 || i==6 || i==8 ) { 
		if ( Units::GetUserAltitudeUnit() == unMeter ) 
			wsprintf(gtext,_T("-%dm"),i*100); 
		else
			wsprintf(gtext,_T("-%dft"),i*300);

			ExtTextOut( hdc, Orig.x+35, Orig.y-5 - (int) tmp, 0, NULL, gtext , _tcslen(gtext), NULL );
	}

	SetTextColor(hdc,oldcolor);
	if (turn>0)
		oldcolor=SetTextColor(hdc, RGB_BLACK); // dark grey
	else
		oldcolor=SetTextColor(hdc, RGB_BLUE); // red

	if ( i==2 || i==4 || i==6 || i==8 ) {
		if ( Units::GetUserDistanceUnit() == unKiloMeter ) {

			//sprintf(text,"%3.1f Km",i*100*cruise /1000);
			sprintf(text,"%3.0fkm",i*100*cruise /1000);
		} else
			if ( Units::GetUserDistanceUnit() == unNauticalMiles ) {

				//sprintf(text,"%3.1f nmi", i*100*cruise / 1852);
				sprintf(text,"%3.0fnm", i*100*cruise / 1852);
			} else
				if ( Units::GetUserDistanceUnit() == unStatuteMiles ) {
					//sprintf(text,"%3.1f mi", i*100*cruise / 1609);
					sprintf(text,"%3.0fm", i*100*cruise / 1609);
				}

				wsprintf(gtext,_T("%S"),text);; 
					ExtTextOut( hdc, Orig.x-100, Orig.y-5 - (int) tmp, 0, NULL, gtext , _tcslen(gtext), NULL );
	}	
	SetTextColor(hdc,oldcolor);

  }

  SelectObject(hdc, oldfont);
  SetTextColor(hdc,oldcolor);

}


void MapWindow::DrawHeading(HDC hdc, POINT Orig, RECT rc ) {

   if (GPS_INFO.NAVWarning) return; // 100214

   if (MapScale>5 || (DisplayMode == dmCircling)) return;
   POINT p2;

   #if 0
   if ( !( DisplayOrientation == TRACKUP || DisplayOrientation == NORTHCIRCLE || DisplayOrientation == TRACKCIRCLE )) return;
   double tmp = 12000*ResMapScaleOverDistanceModify;
   p2.x=Orig.x;
   p2.y=Orig.y-(int)tmp;
   #else
   double tmp = 12000*ResMapScaleOverDistanceModify;
   if ( !( DisplayOrientation == TRACKUP || DisplayOrientation == NORTHCIRCLE || DisplayOrientation == TRACKCIRCLE )) {
	double trackbearing = DrawInfo.TrackBearing;
	p2.y= Orig.y - (int)(tmp*fastcosine(trackbearing));
	p2.x= Orig.x + (int)(tmp*fastsine(trackbearing));
   } else {
	p2.x=Orig.x;
	p2.y=Orig.y-(int)tmp;
   }
   #endif

   if (BlackScreen)
	   _DrawLine(hdc, PS_SOLID, NIBLSCALE(1), Orig, p2, RGB_INVDRAW, rc); // 091109
   else
	   _DrawLine(hdc, PS_SOLID, NIBLSCALE(1), Orig, p2, RGB_BLACK, rc);

}

void MapWindow::DrawMapSpace(HDC hdc,  RECT rc ) {

  HFONT oldfont;
  HBRUSH hB;

  TextInBoxMode_t TextDisplayMode;
  TCHAR Buffer[LKSIZEBUFFERLARGE*2];
#ifdef DRAWLKSTATUS
  bool dodrawlkstatus=false;
#endif
  static bool doinit=true;
  static POINT p[10];

  #if LKOBJ
  if (MapSpaceMode==MSM_WELCOME) {
	if (INVERTCOLORS)
		hB=LKBrush_Petrol;
	  else
		hB=LKBrush_Mlight;
  } else {
	if (INVERTCOLORS)
		hB=LKBrush_Mdark;
	  else
		hB=LKBrush_Mlight;
  }
  #else
  if (INVERTCOLORS)
	hB=CreateSolidBrush(RGB_MDARK);
  else
	hB=CreateSolidBrush(RGB_MLIGHT);
  #endif
  oldfont = (HFONT)SelectObject(hdc, LKINFOFONT); // save font
  FillRect(hdc,&rc, hB); 
  #ifndef LKOBJ
  DeleteObject(hB);
  #endif
  //oldbkmode=SetBkMode(hdc,TRANSPARENT);

  if (doinit) {
	p[0].x=0; p[0].y=rc.bottom-BottomSize-NIBLSCALE(2); p[1].x=rc.right-1; p[1].y=p[0].y;
	p[2].x=0; p[2].y=0; p[3].x=rc.right-1; p[3].y=0; // 091230 right-1
	p[4].x=0; p[4].y=0; p[5].x=0; p[5].y=rc.bottom-BottomSize-NIBLSCALE(2);
	p[6].x=rc.right-1; p[6].y=0; p[7].x=rc.right-1; p[7].y=rc.bottom-BottomSize-NIBLSCALE(2); // 091230 right-1

//	p[8].x=0; p[8].y=rc.bottom-BottomSize-NIBLSCALE(2); p[9].x=rc.right; p[9].y=p[8].y;
	doinit=false; 
  }

  if (INVERTCOLORS) {
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[2], p[3], RGB_GREEN, rc);
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[4], p[5], RGB_GREEN, rc);
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[6], p[7], RGB_GREEN, rc);
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[0], p[1], RGB_GREEN, rc);
  } else {
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[2], p[3], RGB_DARKGREEN, rc);
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[4], p[5], RGB_DARKGREEN, rc);
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[6], p[7], RGB_DARKGREEN, rc);
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[0], p[1], RGB_DARKGREEN, rc);
  }


#ifdef DRAWLKSTATUS 
  if (LKevent==LKEVENT_NEWRUN) dodrawlkstatus=true;
#endif

  switch (MapSpaceMode) {
	case MSM_WELCOME:
#if (1)
		static double firsttime=GPS_INFO.Time;
		// delayed automatic exit from welcome mode
		if ( GPS_INFO.Time > (firsttime+1.0) ) {
			SetModeType(LKMODE_MAP,MP_MOVING);
			LKevent=LKEVENT_NONE;
			break;
		}
#endif
		DrawWelcome8000(hdc, rc);
		break;
	case MSM_LANDABLE:
	case MSM_AIRPORTS:
		DrawNearest(hdc, rc);
		break;
	case MSM_NEARTPS:
		DrawNearestTurnpoint(hdc, rc);
		break;
	case MSM_COMMON:
	case MSM_RECENT:
		DrawCommon(hdc, rc);
		break;
	case MSM_MAP:
		break;
	case MSM_INFO_THERMAL:
	case MSM_INFO_CRUISE:
	case MSM_INFO_TASK:
	case MSM_INFO_AUX:
	case MSM_INFO_TRI:
	case MSM_INFO_TRF:
	case MSM_INFO_TARGET:
		DrawInfoPage(hdc,rc, false);
		break;
	case MSM_TRAFFIC:
		DrawTraffic(hdc,rc);
		break;
	default:
		TextDisplayMode.AsInt = 0;
		TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextDisplayMode.AsFlag.NoSetFont = 1; 
		TextDisplayMode.AsFlag.AlligneCenter = 1;
		SelectObject(hdc, LK8TargetFont);
		_stprintf(Buffer,TEXT("MapSpaceMode=%d"),MapSpaceMode);
		TextInBox(hdc, Buffer, (rc.right-rc.left)/2, NIBLSCALE(50) , 0, TextDisplayMode, false);
		break;
	}
#ifdef DRAWLKSTATUS
  // no need to clear dodrawlkstatus, it is already reset at each run
  if (dodrawlkstatus) DrawLKStatus(hdc, rc);
#endif
  //SetBkMode(hdc,oldbkmode);
  SelectObject(hdc, oldfont); 
}

void MapWindow::DrawWelcome8000(HDC hdc, RECT rc) {

  SIZE textSize, headerSize;
  TCHAR Buffer[LKSIZEBUFFERLARGE];

  short bottomlines;
  short middlex=(rc.right-rc.left)/2;
  //short left=rc.left+NIBLSCALE(5);
  short contenttop=rc.top+NIBLSCALE(50);

  switch (LKevent) {
	case LKEVENT_NONE:
		break;
	case LKEVENT_ENTER:
		// Event are cleared from called inner functions, but we do it nevertheless..
		SetModeType(LKMODE_MAP, MP_MOVING);
		LKevent=LKEVENT_NONE; // check if removable 
		break;
	default:
		LKevent=LKEVENT_NONE;
		break;
  }
  
  SelectObject(hdc, LK8BigFont);
  _stprintf(Buffer,TEXT("LK8000"));
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &headerSize);
  LKWriteText(hdc, Buffer, middlex, (headerSize.cy/2)+NIBLSCALE(2) , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE, false);

  _stprintf(Buffer,TEXT("Tactical Flight Computer"));
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
  SelectObject(hdc, LK8MediumFont);
  LKWriteText(hdc, Buffer, middlex, (headerSize.cy/2)+(textSize.cy/2)+NIBLSCALE(4)+1 , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE, false);


  //SelectObject(hdc, LK8InfoBigFont);
  SelectObject(hdc, LK8TitleFont);
  _stprintf(Buffer,TEXT("%s v%s.%s"),_T(LKFORK),_T(LKVERSION),_T(LKRELEASE));
#if NOSIM
  if (SIMMODE) _tcscat(Buffer,_T(" (Simulator)"));
#else
#ifdef _SIM_
  _tcscat(Buffer,_T(" (Simulator)"));
#endif
#endif
  LKWriteText(hdc, Buffer, middlex, contenttop+(textSize.cy*1) , 0, WTMODE_OUTLINED, WTALIGN_CENTER,RGB_AMBER, false);


  _stprintf(Buffer,TEXT("Click on center screen to begin"));
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
  LKWriteText(hdc, Buffer, middlex, ((rc.bottom-rc.top)-textSize.cy)/2 , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_SWHITE, false);


  SelectObject(hdc, LK8UnitFont);
  if (ScreenSize==0) {
	_stprintf(Buffer,TEXT("**SCREEN %dx%d NOT SUPPORTED**"),rc.right,rc.bottom );
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
	bottomlines=rc.bottom-BottomSize-(textSize.cy*3);
	LKWriteText(hdc, Buffer, middlex, bottomlines , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
	_stprintf(Buffer,TEXT("FONTS WILL NOT BE GOOD OR UNUSABLE"));
	LKWriteText(hdc, Buffer, middlex, bottomlines+textSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_SWHITE, false);
  } else {
	_stprintf(Buffer,TEXT("%s build#%d"), XCSoar_Version,BUILDNUMBER);
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
	bottomlines=rc.bottom-BottomSize-(textSize.cy*3);
	LKWriteText(hdc, Buffer, middlex, bottomlines , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
	_stprintf(Buffer,TEXT("WWW.LK8000.IT by Paolo Ventafridda (coolwind@@lk8000.it)"));
	LKWriteText(hdc, Buffer, middlex, bottomlines+textSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_SWHITE, false);
 }

  SelectObject(hdc, LK8InfoSmallFont);

  _stprintf(Buffer, _T("%d WPs, %0.1fM free"),NumberOfWayPoints,CheckFreeRam()/1000000.0);
  if (PGNumberOfGates>0) _tcscat(Buffer,_T(" (+Tsk Gates)"));
#ifndef NDEBUG
  _tcscat(Buffer,_T(" (+debug)"));
#endif
#ifdef CPUSTATS
  _tcscat(Buffer,_T(" (+cpustats)"));
#endif
#ifdef DRAWLOAD
  _tcscat(Buffer,_T(" (+drawload)"));
#endif
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
  LKWriteText(hdc, Buffer, middlex, bottomlines-(textSize.cy)-NIBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_SWHITE, false);

  _stprintf(Buffer, _T(""));
  if (GPSAltitudeOffset != 0) _stprintf(Buffer, _T("(GpsOffset %+.0f)"), GPSAltitudeOffset/1000*ALTITUDEMODIFY); // 100429 /1000
#ifndef WINDOWSPC
  if (!LoggerGActive()) _tcscat(Buffer,_T(" (No GRecord)"));
#endif
  LKWriteText(hdc, Buffer, middlex, bottomlines-(textSize.cy*2)-NIBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_SWHITE, false);

  if (WarningHomeDir) {
	TCHAR nopath[MAX_PATH];
	LocalPath(nopath,_T(""));
	MessageBoxX(hWndMapWindow, nopath, _T("CHECK INSTALLATION!"), MB_OK|MB_ICONEXCLAMATION);
	WarningHomeDir=false;
  }
#if ( !defined(WINDOWSPC) || WINDOWSPC==0 )
  static bool checktickcountbug=true; // 100510
  if (checktickcountbug) {
	DWORD counts=GetTickCount();
	if (counts >(unsigned)2073600000l) {
		MessageBoxX(hWndMapWindow, gettext(TEXT("Please exit LK8000 and reset your device.\n")),
                TEXT("Device need reset!"),
                MB_OK|MB_ICONEXCLAMATION);
	}
	checktickcountbug=false;
  }
#endif
  static bool checksafetyaltitude=true; // 100709
  if (!ISPARAGLIDER) // 100925
  if (checksafetyaltitude) {
	if (SAFETYALTITUDEARRIVAL<50) {
		MessageBoxX(hWndMapWindow, gettext(TEXT("CHECK safety arrival altitude\n")),
                TEXT("Warning!"),
                MB_OK|MB_ICONEXCLAMATION);
	}
	checksafetyaltitude=false;
  }
  return;
}


#ifdef CPUSTATS
void MapWindow::DrawCpuStats(HDC hdc, RECT rc) {

  if (Appearance.InverseInfoBox == true) return;

  TCHAR Buffer[LKSIZEBUFFERLARGE];
  TextInBoxMode_t TextDisplayMode;
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.WhiteBorder = 1; // inside a white circle
  TextDisplayMode.AsFlag.Border = 1;      // add a black border to the circle

#if (WINDOWSPC>0)
  wsprintf(Buffer,_T("CPU Draw=%d Calc=%d us"), Cpu_Draw, Cpu_Calc);
#else
  wsprintf(Buffer,_T("CPU Draw=%d Calc=%d ms"), Cpu_Draw, Cpu_Calc);
#endif
  TextInBox(hdc, Buffer, 000, 200 , 0, TextDisplayMode, false);
#if (WINDOWSPC>0)
  wsprintf(Buffer,_T("CPU Inst=%d Port=%d us"), Cpu_Instrument, Cpu_Port);
#else
  wsprintf(Buffer,_T("CPU Inst=%d Port=%d ms"), Cpu_Instrument, Cpu_Port);
#endif
  TextInBox(hdc, Buffer, 000, 240 , 0, TextDisplayMode, false);

  //wsprintf(Buffer,_T("Landsc=%d Geom=%d"), InfoBoxLayout::landscape, InfoBoxLayout::InfoBoxGeometry);
  //TextInBox(hdc, Buffer, 000, 280 , 0, TextDisplayMode, false);
  //wsprintf(Buffer,_T("Recents=%d"), RecentNumber);
  //TextInBox(hdc, Buffer, 000, 280 , 0, TextDisplayMode, false);

}
#endif

#ifdef DRAWDEBUG
void MapWindow::DrawDebug(HDC hdc, RECT rc) {

  TCHAR Buffer[LKSIZEBUFFERLARGE];
  TextInBoxMode_t TextDisplayMode;
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.WhiteBorder = 1; // inside a white circle
  TextDisplayMode.AsFlag.Border = 1;      // add a black border to the circle

  wsprintf(Buffer,_T("ModeIndex=%d CURTYPE=%d MSM=%d"), ModeIndex, ModeType[ModeIndex],MapSpaceMode );
  TextInBox(hdc, Buffer, 000, 200 , 0, TextDisplayMode, false);
  wsprintf(Buffer,_T("MTableTop=%d ModeTable=%d=MSM"), ModeTableTop[ModeIndex], ModeTable[ModeIndex][ModeType[ModeIndex]] );
  TextInBox(hdc, Buffer, 000, 240 , 0, TextDisplayMode, false);

}
#endif


void MapWindow::WriteInfo(HDC hdc, bool *showunit, TCHAR *BufferValue, TCHAR *BufferUnit, TCHAR *BufferTitle, 
				short *columnvalue, short *columntitle, short *row1, short *row2, short *row3) {

  static bool doinit=true;
  static short unitrowoffset=0;
  if (doinit) {
	switch(ScreenSize) {
		case ss896x672:
			unitrowoffset=6;
			break;
		case ss800x480:
			unitrowoffset=10;
			break;
		case ss640x480:
			unitrowoffset=5;
			break;
		case ss400x240:
			unitrowoffset=7;
			break;
		case ss480x272:
			unitrowoffset=5;
			break;
		case ss480x234:
			unitrowoffset=3;
			break;
		case ss320x240:
			unitrowoffset=3;
			break;
		// portrait mode
		case ss240x320:
			unitrowoffset=-5;
			break;
		case ss272x480:
			unitrowoffset=-14;
			break;
		case ss480x640:
			unitrowoffset=-8;
			break;
		case ss480x800:
			unitrowoffset=-19;
			break;
		case ss720x408:
			unitrowoffset=8;
			break;
		default:
			break;
	}
	doinit=false;
  }

  SelectObject(hdc, LK8PanelBigFont);
  if (*showunit)
	LKWriteText(hdc, BufferValue, *columnvalue,*row1, 0, WTMODE_NORMAL,WTALIGN_RIGHT, RGB_WHITE, false);
  else
	LKWriteText(hdc, BufferValue, *columnvalue,*row1, 0, WTMODE_NORMAL,WTALIGN_RIGHT, RGB_AMBER, false);

  if (*showunit==true && !HideUnits) {
       	SelectObject(hdc, LK8PanelUnitFont); // 091230
        LKWriteText(hdc, BufferUnit, *columnvalue,*row2+unitrowoffset, 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_WHITE, false);
  }
  SelectObject(hdc, LK8PanelSmallFont);
  LKWriteText(hdc, BufferTitle, *columntitle,*row3, 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_LIGHTGREEN, false);

}

// Turn Rate Indicator
void MapWindow::DrawTRI(HDC hDC, const RECT rc)
{
  POINT Start;
  
  static short top=(((rc.bottom-BottomSize-(rc.top+TOPLIMITER)-BOTTOMLIMITER)/PANELROWS)+rc.top+TOPLIMITER)- (rc.top+TOPLIMITER);

  Start.y = ((rc.bottom-BottomSize-top)/2)+top-NIBLSCALE(10);
  Start.x = (rc.right - rc.left)/2;

  HPEN		hpBlack;
  HBRUSH	hbBlack;
  HPEN		hpWhite;
  HBRUSH	hbWhite;
  HPEN		hpBorder;
  HBRUSH	hbBorder;
  HPEN   hpOld;
  HBRUSH hbOld;

  // gauge size radius
  static int radius = NIBLSCALE(65);
  static int planesize = radius-NIBLSCALE(10);
  // planebody
  static int planeradius = NIBLSCALE(6);
  static int tailsize = planesize/4+NIBLSCALE(2);
  static int innerradius = radius - NIBLSCALE(8);
  static POINT d00[2][2],d15[2][4],d30[2][4], d45[2][4], d60[2][4];
  static bool doinit=true;
  TCHAR Buffer[LKSIZEBUFFERVALUE];
  double beta=0.0;
  bool disabled=false;

  if (doinit) {
  // [a][b]  a=0 external circle a=1 inner circle  b=1-4

  d00[0][0].x= Start.x - radius;
  d00[0][0].y= Start.y;
  d00[1][0].x= Start.x - innerradius;
  d00[1][0].y= Start.y;
  d00[0][1].x= Start.x + radius;
  d00[0][1].y= Start.y;
  d00[1][1].x= Start.x + innerradius;
  d00[1][1].y= Start.y;

  d15[0][0].x= Start.x - (long) (radius*fastcosine(15.0));
  d15[0][0].y= Start.y + (long) (radius*fastsine(15.0));
  d15[1][0].x= Start.x - (long) (innerradius*fastcosine(15.0));
  d15[1][0].y= Start.y + (long) (innerradius*fastsine(15.0));
  d15[0][1].x= Start.x - (long) (radius*fastcosine(15.0));
  d15[0][1].y= Start.y - (long) (radius*fastsine(15.0));
  d15[1][1].x= Start.x - (long) (innerradius*fastcosine(15.0));
  d15[1][1].y= Start.y - (long) (innerradius*fastsine(15.0));
  d15[0][2].x= Start.x + (long) (radius*fastcosine(15.0));
  d15[0][2].y= Start.y + (long) (radius*fastsine(15.0));
  d15[1][2].x= Start.x + (long) (innerradius*fastcosine(15.0));
  d15[1][2].y= Start.y + (long) (innerradius*fastsine(15.0));
  d15[0][3].x= Start.x + (long) (radius*fastcosine(15.0));
  d15[0][3].y= Start.y - (long) (radius*fastsine(15.0));
  d15[1][3].x= Start.x + (long) (innerradius*fastcosine(15.0));
  d15[1][3].y= Start.y - (long) (innerradius*fastsine(15.0));

  d30[0][0].x= Start.x - (long) (radius*fastcosine(30.0));
  d30[0][0].y= Start.y + (long) (radius*fastsine(30.0));
  d30[1][0].x= Start.x - (long) (innerradius*fastcosine(30.0));
  d30[1][0].y= Start.y + (long) (innerradius*fastsine(30.0));
  d30[0][1].x= Start.x - (long) (radius*fastcosine(30.0));
  d30[0][1].y= Start.y - (long) (radius*fastsine(30.0));
  d30[1][1].x= Start.x - (long) (innerradius*fastcosine(30.0));
  d30[1][1].y= Start.y - (long) (innerradius*fastsine(30.0));
  d30[0][2].x= Start.x + (long) (radius*fastcosine(30.0));
  d30[0][2].y= Start.y + (long) (radius*fastsine(30.0));
  d30[1][2].x= Start.x + (long) (innerradius*fastcosine(30.0));
  d30[1][2].y= Start.y + (long) (innerradius*fastsine(30.0));
  d30[0][3].x= Start.x + (long) (radius*fastcosine(30.0));
  d30[0][3].y= Start.y - (long) (radius*fastsine(30.0));
  d30[1][3].x= Start.x + (long) (innerradius*fastcosine(30.0));
  d30[1][3].y= Start.y - (long) (innerradius*fastsine(30.0));

  d45[0][0].x= Start.x - (long) (radius*fastcosine(45.0));
  d45[0][0].y= Start.y + (long) (radius*fastsine(45.0));
  d45[1][0].x= Start.x - (long) (innerradius*fastcosine(45.0));
  d45[1][0].y= Start.y + (long) (innerradius*fastsine(45.0));
  d45[0][1].x= Start.x - (long) (radius*fastcosine(45.0));
  d45[0][1].y= Start.y - (long) (radius*fastsine(45.0));
  d45[1][1].x= Start.x - (long) (innerradius*fastcosine(45.0));
  d45[1][1].y= Start.y - (long) (innerradius*fastsine(45.0));
  d45[0][2].x= Start.x + (long) (radius*fastcosine(45.0));
  d45[0][2].y= Start.y + (long) (radius*fastsine(45.0));
  d45[1][2].x= Start.x + (long) (innerradius*fastcosine(45.0));
  d45[1][2].y= Start.y + (long) (innerradius*fastsine(45.0));
  d45[0][3].x= Start.x + (long) (radius*fastcosine(45.0));
  d45[0][3].y= Start.y - (long) (radius*fastsine(45.0));
  d45[1][3].x= Start.x + (long) (innerradius*fastcosine(45.0));
  d45[1][3].y= Start.y - (long) (innerradius*fastsine(45.0));

  d60[0][0].x= Start.x - (long) (radius*fastcosine(60.0));
  d60[0][0].y= Start.y + (long) (radius*fastsine(60.0));
  d60[1][0].x= Start.x - (long) (innerradius*fastcosine(60.0));
  d60[1][0].y= Start.y + (long) (innerradius*fastsine(60.0));
  d60[0][1].x= Start.x - (long) (radius*fastcosine(60.0));
  d60[0][1].y= Start.y - (long) (radius*fastsine(60.0));
  d60[1][1].x= Start.x - (long) (innerradius*fastcosine(60.0));
  d60[1][1].y= Start.y - (long) (innerradius*fastsine(60.0));
  d60[0][2].x= Start.x + (long) (radius*fastcosine(60.0));
  d60[0][2].y= Start.y + (long) (radius*fastsine(60.0));
  d60[1][2].x= Start.x + (long) (innerradius*fastcosine(60.0));
  d60[1][2].y= Start.y + (long) (innerradius*fastsine(60.0));
  d60[0][3].x= Start.x + (long) (radius*fastcosine(60.0));
  d60[0][3].y= Start.y - (long) (radius*fastsine(60.0));
  d60[1][3].x= Start.x + (long) (innerradius*fastcosine(60.0));
  d60[1][3].y= Start.y - (long) (innerradius*fastsine(60.0));

  doinit=false;
  } // end dirty hack doinit

  //if (!CALCULATED_INFO.Flying) {
  // speed is in m/s
  if (GPS_INFO.Speed <5.5) disabled=true; 

  if (disabled) {
	#if LKOBJ
	hpBlack = LKPen_Grey_N1;
	hbBlack = LKBrush_Grey;
	#else
	hpBlack = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_GREY);
	hbBlack = (HBRUSH)CreateSolidBrush(RGB_GREY);
	#endif
  } else {
	#if LKOBJ
	hpBlack = LKPen_Black_N1;
	hbBlack = LKBrush_Black;
	#else
	hpBlack = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_BLACK);
	hbBlack = (HBRUSH)CreateSolidBrush(RGB_BLACK);
	#endif
  	beta = DerivedDrawInfo.BankAngle;
  }
  #if LKOBJ
  hpWhite = LKPen_White_N1;
  hbWhite = LKBrush_White;
  hpBorder = LKPen_Grey_N2;
  hbBorder = LKBrush_Grey;
  #else
  hpWhite = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_WHITE);
  hbWhite = (HBRUSH)CreateSolidBrush( RGB_WHITE);
  hpBorder = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB_GREY);
  hbBorder = (HBRUSH)CreateSolidBrush( RGB_GREY);
  #endif

  hpOld = (HPEN)SelectObject(hDC, hpWhite);
  hbOld = (HBRUSH)SelectObject(hDC, hbWhite);
  Circle(hDC, Start.x, Start.y, radius, rc, false, true );
  SelectObject(hDC, hpBorder);
  SelectObject(hDC, hbBorder);
  Circle(hDC, Start.x, Start.y, radius+NIBLSCALE(2), rc, false, false );

  SelectObject(hDC, hpBlack);
  SelectObject(hDC, hbBlack); 
  Circle(hDC, Start.x, Start.y, planeradius, rc, false, true );

  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d00[0][0], d00[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d00[0][1], d00[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d15[0][0], d15[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d15[0][1], d15[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d15[0][2], d15[1][2], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d15[0][3], d15[1][3], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d30[0][0], d30[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d30[0][1], d30[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d30[0][2], d30[1][2], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d30[0][3], d30[1][3], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d45[0][0], d45[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d45[0][1], d45[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d45[0][2], d45[1][2], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d45[0][3], d45[1][3], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d60[0][0], d60[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d60[0][1], d60[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d60[0][2], d60[1][2], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), d60[0][3], d60[1][3], RGB_BLUE,rc);

  POINT a1, a2;

  a1.x = Start.x - (long) ( planesize * fastcosine(beta));
  a1.y = Start.y - (long) ( planesize * fastsine(beta));
  a2.x = Start.x + (long) ( planesize * fastcosine(beta));
  a2.y = Start.y + (long) ( planesize * fastsine(beta));
    if (disabled) 
	_DrawLine(hDC, PS_SOLID, NIBLSCALE(4), a1, a2, RGB_GREY,rc);
    else
	_DrawLine(hDC, PS_SOLID, NIBLSCALE(4), a1, a2, RGB_BLACK,rc); 

  a1.x = Start.x;
  a1.y = Start.y;
  a2.x = Start.x + (long) ( tailsize * fastsine(beta));
  a2.y = Start.y - (long) ( tailsize * fastcosine(beta));
  if (disabled) 
	_DrawLine(hDC, PS_SOLID, NIBLSCALE(4), a1, a2, RGB_GREY,rc);
  else
	_DrawLine(hDC, PS_SOLID, NIBLSCALE(4), a1, a2, RGB_BLACK,rc);

  TextInBoxMode_t Mode;
  Mode.AsInt=0;
  Mode.AsFlag.Color = TEXTBLUE;
  Mode.AsFlag.NoSetFont = 1;
  Mode.AsFlag.WhiteBold = 0;
  Mode.AsFlag.AlligneRight = 0;
  Mode.AsFlag.AlligneCenter = 1;

  SelectObject(hDC, LK8TitleFont);
  int bankindy=Start.y+radius/2;
#ifndef __MINGW32__
  if (beta > 1)
	_stprintf(Buffer, TEXT("%2.0f°"), beta);
  else if (beta < -1)
	_stprintf(Buffer, TEXT("%2.0f°"), -beta);
  else
	_tcscpy(Buffer, TEXT("--"));
#else
  if (beta > 1)
	_stprintf(Buffer, TEXT("%2.0fÂ°"), beta);
  else if (beta < -1)
	_stprintf(Buffer, TEXT("%2.0fÂ°"), -beta);
  else
	_tcscpy(Buffer, TEXT("--"));
#endif

  LKWriteText(hDC, Buffer, Start.x , bankindy, 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_BLUE, false);

  if (!disabled) MapWindow::RefreshMap();

  SelectObject(hDC, hbOld);
  SelectObject(hDC, hpOld);
  #ifndef LKOBJ
  DeleteObject((HPEN)hpBlack);
  DeleteObject((HBRUSH)hbBlack);
  DeleteObject((HPEN)hpWhite);
  DeleteObject((HBRUSH)hbWhite);
  DeleteObject((HPEN)hpBorder);
  DeleteObject((HBRUSH)hbBorder);
  #endif
}


// LK Status message
void MapWindow::DrawLKStatus(HDC hdc, RECT rc) {
#ifdef DRAWLKSTATUS

  TextInBoxMode_t TextDisplayMode;
  TCHAR Buffer[LKSIZEBUFFERLARGE];

  short bottomlines;
  short middlex=(rc.right-rc.left)/2;
  short left=rc.left+NIBLSCALE(5);
  short contenttop=rc.top+NIBLSCALE(50);

  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTBLACK;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  //TextDisplayMode.AsFlag.AlligneRight = 0;
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  TextDisplayMode.AsFlag.WhiteBold = 1;
  TextDisplayMode.AsFlag.Border = 1;
  // HFONT oldfont=(HFONT)SelectObject(hdc, LK8PanelBigFont);

  switch(ModeIndex) {
	case LKMODE_MAP:
		wsprintf(Buffer,TEXT("MAP mode, 1 of 1"));
		break;
	case LKMODE_INFOMODE:
		_stprintf(Buffer,TEXT("%d-%d"), ModeIndex,CURTYPE+1);
		break;
	case LKMODE_WP:
		_stprintf(Buffer,TEXT("%d-%d"), ModeIndex,CURTYPE+1);
		break;
	case LKMODE_NAV:
		_stprintf(Buffer,TEXT("%d-%d"), ModeIndex,CURTYPE+1);
		break;
	default:
		wsprintf(Buffer,TEXT("UNKOWN mode"));
		break;
  }
  TextInBox(hdc, Buffer, middlex, 200 , 0, TextDisplayMode, false);

  //SelectObject(hdc, oldfont);
#endif
  return;
}


// invertable is used coped with LKTextBlack: if both are active, then text is forced reversed
void MapWindow::LKWriteText(HDC hDC, const TCHAR* wText, int x, int y, 
                          int maxsize, const bool mode, const short align, COLORREF rgb_text, bool invertable ) {

	SIZE tsize;
	if (maxsize==0) maxsize=_tcslen(wText);
  
	GetTextExtentPoint(hDC, wText, maxsize, &tsize);

	// by default, LK8000 is white on black, i.e. inverted
	if ((!INVERTCOLORS) || (LKTextBlack&&invertable)) switch(rgb_text) { // 091110
		case RGB_WHITE:
			rgb_text=RGB_BLACK;
			break;
		case RGB_BLACK:
			rgb_text=RGB_WHITE;
			break;
		case RGB_SBLACK:		// FIXED MISSING 100511
			rgb_text=RGB_SWHITE;
			break;
		case RGB_LIGHTGREEN:
			// rgb_text=RGB_DARKBLUE; 100915
			rgb_text=RGB_DARKGREEN;
			break;
		case RGB_LIGHTRED:
			rgb_text=RGB_DARKRED;
			break;
		case RGB_LIGHTYELLOW:
			rgb_text=RGB_DARKYELLOW;
			break;
		case RGB_SWHITE:
			rgb_text=RGB_SBLACK;
			break;
		case RGB_AMBER:
			rgb_text=RGB_ORANGE;
			break;
		case RGB_PETROL:
			rgb_text=RGB_ICEWHITE;
			break;
	}

	switch(align) {
		case WTALIGN_RIGHT:
			x -= tsize.cx;
			break;
		case WTALIGN_CENTER:
			x -= tsize.cx/2;
			y -= tsize.cy/2;
			break;
	}
//rgb_text=RGB_MAGENTA;

	switch(mode) {
		case  WTMODE_OUTLINED:
			switch (rgb_text ) {
				// Here we invert colors, looking at the foreground. The trick is that the foreground
				// colour is slightly different white to white, in order to understand how to invert it
				// correctly!
				case RGB_BLACK:
				//case RGB_SWHITE:
					// text black, light background
					SetTextColor(hDC,RGB_WHITE);
					break;
				case RGB_SWHITE:  
					SetTextColor(hDC,RGB_SBLACK);
					break;
				case RGB_SBLACK:
					SetTextColor(hDC,RGB_SWHITE);
					break;
				case RGB_DARKBLUE:
					SetTextColor(hDC,RGB_WHITE);
					break;
				case RGB_GREEN:
					SetTextColor(hDC,RGB_BLACK);
					break;
				case RGB_PETROL:
				case RGB_DARKGREY:
				case RGB_VDARKGREY:
				case RGB_DARKGREEN:
					SetTextColor(hDC,RGB_WHITE);
					break;
				default:
					// this is the default also for white text. Normally we are writing on a 
					// not-too-light background
					SetTextColor(hDC,RGB_BLACK);
					break;
			}
				

#if (WINDOWSPC>0)
			ExtTextOut(hDC, x+1, y, 0, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x+2, y, 0, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x-1, y, 0, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x-2, y, 0, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x, y+1, 0, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x, y-1, 0, NULL, wText, maxsize, NULL);

			if (ScreenSize == (ScreenSize_t)ss800x480) {
				ExtTextOut(hDC, x, y+2, 0, NULL, wText, maxsize, NULL); 
				ExtTextOut(hDC, x, y-2, 0, NULL, wText, maxsize, NULL); 
				ExtTextOut(hDC, x-3, y, 0, NULL, wText, maxsize, NULL); 
				ExtTextOut(hDC, x+3, y, 0, NULL, wText, maxsize, NULL); 
				ExtTextOut(hDC, x, y+3, 0, NULL, wText, maxsize, NULL); 
				ExtTextOut(hDC, x, y-3, 0, NULL, wText, maxsize, NULL); 
			}

			SetTextColor(hDC,rgb_text); 
			ExtTextOut(hDC, x, y, 0, NULL, wText, maxsize, NULL);
			SetTextColor(hDC,RGB_BLACK); 
#else

			ExtTextOut(hDC, x+2, y, ETO_OPAQUE, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x+1, y, ETO_OPAQUE, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x-1, y, ETO_OPAQUE, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x-2, y, ETO_OPAQUE, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x, y+1, ETO_OPAQUE, NULL, wText, maxsize, NULL);
			ExtTextOut(hDC, x, y-1, ETO_OPAQUE, NULL, wText, maxsize, NULL);

			if (ScreenSize == (ScreenSize_t)ss800x480) {
				ExtTextOut(hDC, x+3, y, ETO_OPAQUE, NULL, wText, maxsize, NULL);
				ExtTextOut(hDC, x-3, y, ETO_OPAQUE, NULL, wText, maxsize, NULL);
				ExtTextOut(hDC, x, y+2, ETO_OPAQUE, NULL, wText, maxsize, NULL);
				ExtTextOut(hDC, x, y-2, ETO_OPAQUE, NULL, wText, maxsize, NULL);
				ExtTextOut(hDC, x, y+3, ETO_OPAQUE, NULL, wText, maxsize, NULL);
				ExtTextOut(hDC, x, y-3, ETO_OPAQUE, NULL, wText, maxsize, NULL);
			}

			SetTextColor(hDC,rgb_text);

			ExtTextOut(hDC, x, y, ETO_OPAQUE, NULL, wText, maxsize, NULL);
			SetTextColor(hDC,RGB_BLACK);
#endif
			break;

		case WTMODE_NORMAL:

#if (WINDOWSPC>0)
			SetTextColor(hDC,rgb_text); 
			ExtTextOut(hDC, x, y, 0, NULL, wText, maxsize, NULL);
			SetTextColor(hDC,RGB_BLACK); 
#else
			SetTextColor(hDC,rgb_text); 
      			ExtTextOut(hDC, x, y, ETO_OPAQUE, NULL, wText, maxsize, NULL);
			SetTextColor(hDC,RGB_BLACK); 
#endif
			break;

	}

//	SelectObject(hDC, hbOld);

	return;

}


// Sight Traffic graphics
void MapWindow::DrawTarget(HDC hDC, const RECT rc, int ttop, int tbottom, int tleft, int tright)
{

  HPEN   hp, hpOld;
  HBRUSH hb, hbOld;


  static bool doinit=true;
  bool disabled=false,notraffic=false;

  static POINT cross_top, cross_bottom, cross_left, cross_right;
  static POINT degline_top[10];
  static POINT degline_bottom[10];
  static POINT altline_left[6];
  static POINT altline_right[6];


  static int nleft,nright,ntop,nbottom;
  static int ncenterx, ncentery;
  if (doinit) {

	nleft=tleft+IBLSCALE(3);
	nright=tright;
	ntop=ttop;
	nbottom=tbottom;
	ncenterx=((nright-nleft)/2)+nleft;
	ncentery=((nbottom-ntop)/2)+ntop;

	cross_top.x=ncenterx;
	cross_top.y=ntop;
	cross_bottom.x=ncenterx;
	cross_bottom.y=nbottom;
	cross_left.x=nleft;
	cross_left.y=ncentery;
	cross_right.x=nright;
	cross_right.y=ncentery;

	// hoffset is the position of vertical green lines on the horizon, each one representing
	// 20 degrees shift. The [0] and [5] are for 10 to 20 degrees target's offset
	// The 9th line on extreme position is not drawn
	int deg10=(nleft-ncenterx)/9; 
	// height of the vertical line
	int hdeg=(ncentery-ntop)/7;

	degline_top[0].x		=	ncenterx-deg10;
	degline_top[0].y		=	ncentery-hdeg;
	degline_bottom[0].x		=	ncenterx-deg10;
	degline_bottom[0].y		=	ncentery+hdeg;
	// right side
	degline_top[5].x		=	ncenterx+deg10;
	degline_top[5].y		=	ncentery-hdeg;
	degline_bottom[5].x		=	ncenterx+deg10;
	degline_bottom[5].y		=	ncentery+hdeg;

	degline_top[1].x		=	ncenterx-(deg10*2);
	degline_top[1].y		=	ncentery-hdeg;
	degline_bottom[1].x		=	ncenterx-(deg10*2);
	degline_bottom[1].y		=	ncentery+hdeg;
	degline_top[6].x		=	ncenterx+(deg10*2);
	degline_top[6].y		=	ncentery-hdeg;
	degline_bottom[6].x		=	ncenterx+(deg10*2);
	degline_bottom[6].y		=	ncentery+hdeg;
	
	degline_top[2].x		=	ncenterx-(deg10*4);
	degline_top[2].y		=	ncentery-hdeg;
	degline_bottom[2].x		=	ncenterx-(deg10*4);
	degline_bottom[2].y		=	ncentery+hdeg;
	degline_top[7].x		=	ncenterx+(deg10*4);
	degline_top[7].y		=	ncentery-hdeg;
	degline_bottom[7].x		=	ncenterx+(deg10*4);
	degline_bottom[7].y		=	ncentery+hdeg;

	degline_top[3].x		=	ncenterx-(deg10*6);
	degline_top[3].y		=	ncentery-hdeg;
	degline_bottom[3].x		=	ncenterx-(deg10*6);
	degline_bottom[3].y		=	ncentery+hdeg;
	degline_top[8].x		=	ncenterx+(deg10*6);
	degline_top[8].y		=	ncentery-hdeg;
	degline_bottom[8].x		=	ncenterx+(deg10*6);
	degline_bottom[8].y		=	ncentery+hdeg;

	degline_top[4].x		=	ncenterx-(deg10*8);
	degline_top[4].y		=	ncentery-hdeg;
	degline_bottom[4].x		=	ncenterx-(deg10*8);
	degline_bottom[4].y		=	ncentery+hdeg;
	degline_top[9].x		=	ncenterx+(deg10*8);
	degline_top[9].y		=	ncentery-hdeg;
	degline_bottom[9].x		=	ncenterx+(deg10*8);
	degline_bottom[9].y		=	ncentery+hdeg;


	// sizes of horizontal altitudes lines
	int alth=(int)((ncentery-ntop)/3.5);
	int altw=(int)((ncenterx-nleft)/3.5);

	altline_left[0].x		=	ncenterx-altw;
	altline_left[0].y		=	ncentery-alth;
	altline_right[0].x		=	ncenterx+altw;
	altline_right[0].y		=	ncentery-alth;

	altline_left[1].x		=	ncenterx-altw;
	altline_left[1].y		=	ncentery-(alth*2);
	altline_right[1].x		=	ncenterx+altw;
	altline_right[1].y		=	ncentery-(alth*2);

	altline_left[2].x		=	ncenterx-altw;
	altline_left[2].y		=	ncentery-(alth*3);
	altline_right[2].x		=	ncenterx+altw;
	altline_right[2].y		=	ncentery-(alth*3);


	altline_left[3].x		=	ncenterx-altw;
	altline_left[3].y		=	ncentery+alth;
	altline_right[3].x		=	ncenterx+altw;
	altline_right[3].y		=	ncentery+alth;

	altline_left[4].x		=	ncenterx-altw;
	altline_left[4].y		=	ncentery+(alth*2);
	altline_right[4].x		=	ncenterx+altw;
	altline_right[4].y		=	ncentery+(alth*2);

	altline_left[5].x		=	ncenterx-altw;
	altline_left[5].y		=	ncentery+(alth*3);
	altline_right[5].x		=	ncenterx+altw;
	altline_right[5].y		=	ncentery+(alth*3);

	doinit=false;
  } 

  // The flag "disabled" will force no plane to be painted

  // Check target exists, just for safe
  if (LKTargetIndex>=0 && LKTargetIndex<MAXTRAFFIC) {
	if (!GPS_INFO.FLARM_Traffic[LKTargetIndex].Locked) {
		disabled=true;
		notraffic=true;
	}
  } else {
	disabled=true;
	notraffic=true;
  }

  // check visibility +-80 degrees
  double tangle = LKTraffic[LKTargetIndex].Bearing -  GPS_INFO.TrackBearing;
  if (tangle < -180.0) {
	tangle += 360.0;
  } else {
	if (tangle > 180.0)
		tangle -= 360.0;
  }

  if (tangle<-80 || tangle >80) {
	disabled=true;
  }

  COLORREF hscalecol, vscalecol;
  // First we draw the cross sight
  if (disabled) {
	if (notraffic) {
		if (Appearance.InverseInfoBox) {
			_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_left, cross_right, RGB_GREY,rc);
			_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_top, cross_bottom, RGB_GREY,rc);
		} else {
			_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_left, cross_right, RGB_DARKGREY,rc);
			_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_top, cross_bottom, RGB_DARKGREY,rc);
		}
		hscalecol=RGB_DARKGREEN;
		vscalecol=RGB_DARKGREEN;
	} else {
		_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_left, cross_right, RGB_DARKGREY,rc);
		_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_top, cross_bottom, RGB_DARKGREY,rc);
		hscalecol=RGB_DARKGREEN;
		vscalecol=RGB_DARKGREEN;
	}
  } else {
	if (Appearance.InverseInfoBox) {
		_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_left, cross_right, RGB_ICEWHITE,rc);
		_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_top, cross_bottom, RGB_ICEWHITE,rc);
		hscalecol=RGB_GREEN;
		vscalecol=RGB_GREEN;
	} else {
		_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_left, cross_right, RGB_DARKGREY,rc);
		_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_top, cross_bottom, RGB_DARKGREY,rc);
		hscalecol=RGB_DARKGREEN;
		vscalecol=RGB_DARKGREEN;
	}
  }


  // Then we draw the scales, degrees on horizontal line
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[0], degline_bottom[0], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[5], degline_bottom[5], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[1], degline_bottom[1], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[6], degline_bottom[6], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[2], degline_bottom[2], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[7], degline_bottom[7], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[3], degline_bottom[3], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[8], degline_bottom[8], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[4], degline_bottom[4], hscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), degline_top[9], degline_bottom[9], hscalecol,rc);
  // altitudes on vertical line
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), altline_left[0], altline_right[0], vscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), altline_left[1], altline_right[1], vscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), altline_left[2], altline_right[2], vscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), altline_left[3], altline_right[3], vscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), altline_left[4], altline_right[4], vscalecol,rc);
  _DrawLine(hDC, PS_SOLID, NIBLSCALE(1), altline_left[5], altline_right[5], vscalecol,rc);



  // If out of range, paint diff bearing
  TCHAR tbear[10];
  if (disabled && !notraffic) {
	if (tangle > 1) {
		_stprintf(tbear, TEXT("%2.0fÂ°Â»"), tangle);
	} else {
		if (tangle < -1) {
			_stprintf(tbear, TEXT("Â«%2.0fÂ°"), -tangle);
		} else {
			_tcscpy(tbear, TEXT("Â«Â»"));
		}
	}
	SelectObject(hDC, LK8PanelBigFont);
	switch ( LKTraffic[LKTargetIndex].Status ) {
		case LKT_GHOST:
			LKWriteText(hDC, tbear, ncenterx,ncentery, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_LIGHTYELLOW, false);
			break;
		case LKT_ZOMBIE:
			LKWriteText(hDC, tbear, ncenterx,ncentery, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_LIGHTRED, false);
			break;
		default:
			LKWriteText(hDC, tbear, ncenterx,ncentery, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, false);
			break;
	}

	// do not paint bearing, it is confusing
	#if 0
	double tbearing = LKTraffic[LKTargetIndex].Bearing;
	if (tbearing != 360) {
		_stprintf(tbear, TEXT("%2.0fÂ°"), tbearing);
	} else {
		_stprintf(tbear, TEXT("0Â°"));
	}
	LKWriteText(hDC, tbear, ncenterx,ncentery, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, false);
	#endif
  }


  // Target wing size, half of it
  #define TWINGSIZE	NIBLSCALE(53)
  POINT tcenter;
  // Paint the airplane only if within 160 deg sight angle
  if (!disabled) {

	// Position of the glider on the sight screen
	int leftwingsize=0, rightwingsize=0;
	COLORREF planecolor;
	int tailsize= (TWINGSIZE/4) +NIBLSCALE(2);

	tcenter.x= (int)(ncenterx+(((ncenterx-nleft)/80)*tangle));

	if ( LKTraffic[LKTargetIndex].AltArriv >300 ) {
		tcenter.y=nbottom;
	} else {
		if ( LKTraffic[LKTargetIndex].AltArriv <-300 ) {
			tcenter.y=ntop+IBLSCALE(5);
			tailsize=IBLSCALE(5);
		} else {
			tcenter.y=ncentery+ (int) (((ncentery-ntop)/300.0)*LKTraffic[LKTargetIndex].AltArriv);
		}
	}

	if (Appearance.InverseInfoBox) {
		switch(LKTraffic[LKTargetIndex].Status) {
			case LKT_GHOST:
				planecolor=RGB_LIGHTYELLOW;
				break;
			case LKT_ZOMBIE:
				planecolor=RGB_LIGHTRED;
				break;
			default:
				planecolor=RGB_WHITE;
				break;
		}
	} else {
		switch(LKTraffic[LKTargetIndex].Status) {
			case LKT_GHOST:
				planecolor=RGB_ORANGE;
				break;
			case LKT_ZOMBIE:
				planecolor=RGB_RED;
				break;
			default:
				planecolor=RGB_BLACK;
				break;
		}
	}

	hp = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), planecolor);
	hb = (HBRUSH)CreateSolidBrush( planecolor);
	hpOld = (HPEN) SelectObject(hDC, hp);
	hbOld = (HBRUSH) SelectObject(hDC, hb);

	// does the glider exceed screen space on the right?
	if (tangle>1) {
		leftwingsize=TWINGSIZE;
		// if right wing is exceeding space, reduce it
		if ( (tcenter.x+TWINGSIZE) >nright ) {
			rightwingsize=  nright-tcenter.x;
		} else
			rightwingsize=TWINGSIZE;
	}

	// Now check the left wing
	if (tangle<1) {
		rightwingsize=TWINGSIZE;
		if ( (tcenter.x-TWINGSIZE) < nleft ) {
			leftwingsize=  tcenter.x-nleft;
		} else
			leftwingsize=TWINGSIZE;
	}

	if (tangle==0) {
		rightwingsize=TWINGSIZE;
		leftwingsize=TWINGSIZE;
	}

	Circle(hDC, tcenter.x, tcenter.y, NIBLSCALE(6), rc, false, true );

	POINT a1, a2;

	// Draw the wing
	a1.x = tcenter.x - leftwingsize;
	a1.y = tcenter.y;
	a2.x = tcenter.x + rightwingsize;
	a2.y = tcenter.y;
	_DrawLine(hDC, PS_SOLID, NIBLSCALE(4), a1, a2, planecolor,rc);
	// Draw the tail
	a1.x = tcenter.x;
	a1.y = tcenter.y;
	a2.x = tcenter.x;
	a2.y = tcenter.y - tailsize;
	_DrawLine(hDC, PS_SOLID, NIBLSCALE(4), a1, a2, planecolor,rc);

	SelectObject(hDC, hbOld);
	SelectObject(hDC, hpOld);
	DeleteObject((HPEN)hp);
	DeleteObject((HBRUSH)hb);
  }

  // always paint the bearing difference, cleverly
  if (!disabled && !notraffic) {
	if (tangle > 1) {
		_stprintf(tbear, TEXT("%2.0fÂ°Â»"), tangle);
	} else {
		if (tangle < -1) {
			_stprintf(tbear, TEXT("Â«%2.0fÂ°"), -tangle);
		} else {
			_tcscpy(tbear, TEXT("Â«Â»"));
		}
	}
	SelectObject(hDC, LK8PanelBigFont);
	// if target is below middle line, paint on top
	int yposbear;
	if (tcenter.y >= ncentery ) {
		yposbear=altline_left[2].y;
	} else
		yposbear=altline_left[5].y;

//	LKWriteText(hDC, tbear, ncenterx,altline_left[5].y, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, false);
	switch ( LKTraffic[LKTargetIndex].Status ) {
		case LKT_GHOST:
			//LKWriteText(hDC, tbear, ncenterx,ncentery, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_LIGHTYELLOW, false);
			LKWriteText(hDC, tbear, ncenterx,yposbear, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_LIGHTYELLOW, false);
			break;
		case LKT_ZOMBIE:
			//LKWriteText(hDC, tbear, ncenterx,ncentery, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_LIGHTRED, false);
			LKWriteText(hDC, tbear, ncenterx,yposbear, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_LIGHTRED, false);
			break;
		default:
			//LKWriteText(hDC, tbear, ncenterx,ncentery, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, false);
			LKWriteText(hDC, tbear, ncenterx,yposbear, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, false);
			break;
	}
  }

}
@


8.45
log
@*** empty log message ***
@
text
@d2 5
a6 1
  $Id: MapWindow3.cpp,v 8.44 2010/02/15 13:02:06 root Exp root $ BAD
a12 1
//#include "Utils2.h"
a13 2
//#include "MapWindow.h"
//#include "Units.h"
a15 1
//#include "InputEvents.h"
a19 4
//#include "Logger.h"
//#include "Process.h"
//#include "RasterTerrain.h" // 091109
//#include "LKUtils.h"
d22 3
a24 6

/* REMOVE
#define ISPARAGLIDER (AircraftCategory == (AircraftCategory_t)umParaglider)
#define CURTYPE	ModeType[ModeIndex]
#define INVERTCOLORS  (Appearance.InverseInfoBox)
*/
a70 6
/* REMOVE
#define LKINFOFONT	LK8SmallFont		// was InfoWindowFont
///: km for distance, kmh for speed etc.  in map overlay 
#define LKMAPFONT	LK8MapFont		// was MapWindowFont
*/

a89 5
  //static short rcx=rc.left+rc.right/2-30; 
  //static short rcy=rc.top+rc.bottom-35;
  //short rcx=rc.left+rc.right/2-NIBLSCALE(20); 
  //short rcy=rc.bottom-NIBLSCALE(15); // 35

a167 1
		///: if (count<5) 091215 always show values
a193 1
				///: if (count<5) 091215
d211 3
a214 1

a215 3


   POINT p2;
d218 12
d250 13
d267 1
d270 1
d272 1
a284 3
///: VERY STRANGE. On HP310 the VGA bug will not display correctly this line if drawn before the others..
///: or probably other lines are interfering with this one drawn before! 090916
///:  _DrawLine(hdc, PS_SOLID, NIBLSCALE(1), p[0], p[1], RGB_GREEN, rc);
d304 1
a304 1
#if (0)
d306 2
a307 6
		///: delayed automatic exit from welcome mode
		#ifdef _SIM_
		if ( GPS_INFO.Time > (firsttime+30.0) ) { // timeout
		#else
		if ( GPS_INFO.Time > (firsttime+60.0) ) { // timeout
		#endif
a334 1
		///: TODO check events are cleared
d351 1
a351 1
  ///: no need to clear dodrawlkstatus, it is already reset at each run
a367 1

d372 1
a372 1
		///: Event are cleared from called inner functions, but we do it nevertheless..
d394 4
a397 1
  _stprintf(Buffer,TEXT("%s %s v%s.%s"),_T(LKNAME),_T(LKFORK),_T(LKVERSION),_T(LKRELEASE));
d401 2
a402 1
  LKWriteText(hdc, Buffer, middlex, contenttop+(textSize.cy*1) , 0, WTMODE_NORMAL, WTALIGN_CENTER,RGB_WHITE, false);
d407 1
a407 1
  LKWriteText(hdc, Buffer, middlex, ((rc.bottom-rc.top)-textSize.cy)/2 , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN, false);
d417 1
a417 1
	LKWriteText(hdc, Buffer, middlex, bottomlines+textSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
d423 2
a424 2
	_stprintf(Buffer,TEXT("Evolved from XCSoar 5.2.4 by Paolo Ventafridda (venta@@bware.it)"));
	LKWriteText(hdc, Buffer, middlex, bottomlines+textSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
d430 1
d441 1
a441 1
  LKWriteText(hdc, Buffer, middlex, bottomlines-(textSize.cy)-NIBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN, false);
d444 1
a444 1
  if (GPSAltitudeOffset >0) _stprintf(Buffer, _T("(GPSoffset=%+.0f)"), GPSAltitudeOffset);
d448 1
a448 1
  LKWriteText(hdc, Buffer, middlex, bottomlines-(textSize.cy*2)-NIBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN, false);
d450 28
d537 52
a588 5
	SelectObject(hdc, LK8PanelBigFont);
	if (*showunit)
		LKWriteText(hdc, BufferValue, *columnvalue,*row1, 0, WTMODE_NORMAL,WTALIGN_RIGHT, RGB_WHITE, false);
	else
		LKWriteText(hdc, BufferValue, *columnvalue,*row1, 0, WTMODE_NORMAL,WTALIGN_RIGHT, RGB_AMBER, false);
d590 6
a595 6
	if (*showunit==true && !HideUnits) {
        	SelectObject(hdc, LK8PanelUnitFont); // 091230
	        LKWriteText(hdc, BufferUnit, *columnvalue,*row2, 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_WHITE, false);
	}
        SelectObject(hdc, LK8PanelSmallFont);
        LKWriteText(hdc, BufferTitle, *columntitle,*row3, 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_LIGHTGREEN, false);
d599 1
a599 3
///:
///: Turn Rate Indicator
///:
d618 1
a618 1
  ///: gauge size radius
d621 1
a621 1
  ///: planebody
d632 1
a632 1
  ///: [a][b]  a=0 external circle a=1 inner circle  b=1-4
d715 1
a715 1
  ///: speed is in m/s
d719 4
d725 1
d727 4
d733 1
d736 6
d746 1
d830 1
d837 1
d841 1
a841 3
///:
///: LK Status message
///:
a843 1
  //static HBRUSH hB= CreateSolidBrush(RGB(0x00,0x00, 0x00)); 
d887 1
a887 13
/*

	align
		WTALIGN_LEFT (default)
		WTALIGN_RIGHT
		WTALIGN_CENTER

	mode
		WTMODE_NORMAL (default)
		WTMODE_OUTLINED

*/
///: 0901110 invertable is used coped with LKTextBlack: if both are active, then text is forced reversed
d896 1
a896 1
	///: by default, LK8000 is white on black, i.e. inverted
d904 3
d908 2
a909 1
			rgb_text=RGB_DARKBLUE;
d923 3
d942 3
a944 3
				///: Here we invert colors, looking at the foreground. The trick is that the foreground
				///: colour is slightly different white to white, in order to understand how to invert it
				///: correctly!
a945 1
				case RGB_DARKBLUE:
d947 1
a947 1
					///: text black, light background
d950 2
a951 2
				case RGB_SWHITE:
					SetTextColor(hDC,RGB_DARKGREEN);
d954 13
a966 1
					SetTextColor(hDC,RGB_LIGHTGREY);
d969 2
a970 2
					///: this is the default also for white text. Normally we are writing on a 
					///: not-too-light background
d1043 1
a1043 3
///:
///: Sight Traffic graphics
///:
d1081 3
a1083 3
	///: hoffset is the position of vertical green lines on the horizon, each one representing
	///: 20 degrees shift. The [0] and [5] are for 10 to 20 degrees target's offset
	///: The 9th line on extreme position is not drawn
d1085 1
a1085 1
	///: height of the vertical line
d1092 1
a1092 1
	///: right side
d1135 1
a1135 1
	///: sizes of horizontal altitudes lines
d1173 1
a1173 1
  ///: The flag "disabled" will force no plane to be painted
d1175 1
a1175 1
  ///: Check target exists, just for safe
d1186 1
a1186 1
  ///: check visibility +-80 degrees
d1200 1
a1200 1
  ///: First we draw the cross sight
d1220 4
a1223 2
		_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_left, cross_right, RGB_LIGHTGREY,rc);
		_DrawLine(hDC, PS_SOLID, NIBLSCALE(1), cross_top, cross_bottom, RGB_LIGHTGREY,rc);
d1227 2
a1229 2
	hscalecol=RGB_DARKGREEN;
	vscalecol=RGB_DARKGREEN;
d1233 1
a1233 1
  ///: Then we draw the scales, degrees on horizontal line
d1244 1
a1244 1
  ///: altitudes on vertical line
d1254 1
a1254 1
  ///: If out of range, paint diff bearing
d1267 13
a1279 2
	LKWriteText(hDC, tbear, ncenterx,ncentery, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, false);
	///: do not paint bearing, it is confusing
d1292 1
a1292 1
  ///: Target wing size, half of it
d1295 1
a1295 1
  ///: Paint the airplane only if within 160 deg sight angle
d1298 1
a1298 1
	///: Position of the glider on the sight screen
d1319 1
a1319 1
				planecolor=RGB_YELLOW;
d1322 1
a1322 1
				planecolor=RGB_RED;
d1347 1
a1347 1
	///: does the glider exceed screen space on the right?
d1350 1
a1350 1
		///: if right wing is exceeding space, reduce it
d1357 1
a1357 1
	///: Now check the left wing
d1375 1
a1375 1
	///: Draw the wing
d1381 1
a1381 1
	///: Draw the tail
d1394 1
a1394 1
  ///: always paint the bearing difference, cleverly
d1406 2
a1407 1
	///: if target is below middle line, paint on top
d1409 1
a1409 1
		LKWriteText(hDC, tbear, ncenterx,altline_left[2].y, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, false);
d1411 17
a1427 1
		LKWriteText(hDC, tbear, ncenterx,altline_left[5].y, 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, false);
@


8.44
log
@pre split
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.43 2010/02/13 13:32:12 root Exp root $ BAD
d9 1
a9 1
#include "Utils2.h"
d11 2
a12 2
#include "MapWindow.h"
#include "Units.h"
d15 1
a15 1
#include "InputEvents.h"
d20 4
a23 4
#include "Logger.h"
#include "Process.h"
#include "RasterTerrain.h" // 091109
#include "LKUtils.h"
d27 1
d31 1
d46 1
d78 1
d82 1
a82 540


// Work in Progress...
// VENTA5 modified to declutter boxed outlandings and turnpoints symbols with no names and
// to make airport names visible in middle zoom levels. Also supposed to be smarter in deciding
// if an airport or outlanding need to be fully visible with arrival height or not.
// Fully configurable in config menu...
//
void MapWindow::DrawWaypointsNew(HDC hdc, const RECT rc)
{
  unsigned int i; 
  int bestwp=-1;
  TCHAR Buffer[LKSIZEBUFFER];
  TCHAR Buffer2[LKSIZEBUFFER];
  TCHAR sAltUnit[LKSIZEBUFFERUNIT];
  TextInBoxMode_t TextDisplayMode;


  // if pan mode, show full names
  int pDisplayTextType = DisplayTextType;
#if 0 // 091217  let pan mode share the same displatexttype as usual
  if (EnablePan) {
    pDisplayTextType = DISPLAYNAME;
  }
#endif

  if (!WayPointList) return;

  _tcscpy(sAltUnit, Units::GetAltitudeName());

  MapWaypointLabelListCount = 0;

  // VENTA5 Preliminar check to exclude boxed outlandings

  int arrivalcutoff=0, foundairport=0;
  bool isairport;
  bool islandpoint;

  if (MapScale <=20) for(i=0;i<NumberOfWayPoints;i++) {

    if (WayPointList[i].Visible == FALSE )	continue; // 091123 false

    if ((WayPointList[i].Flags & AIRPORT) == AIRPORT) {
	if (WayPointList[i].Reachable == FALSE)	{ // 091123 false
		SelectObject(hDCTemp,hBmpAirportUnReachable);
	} else {
		SelectObject(hDCTemp,hBmpAirportReachable);
		if ( arrivalcutoff < (int)(WayPointList[i].AltArivalAGL)) {
			arrivalcutoff = (int)(WayPointList[i].AltArivalAGL);
			bestwp=i; foundairport++;
		}
	}
    } else {
	if ( (WayPointList[i].Flags & LANDPOINT) == LANDPOINT) {
		///: outlanding
		if (WayPointList[i].Reachable == FALSE)	  // 091123
			SelectObject(hDCTemp,hBmpFieldUnReachable);
		else { 
			SelectObject(hDCTemp,hBmpFieldReachable);
			///: get the outlanding as bestwp only if no other choice
			if (foundairport == 0) { 
				///: do not set arrivalcutoff: any next reachable airport is better than an outlanding
				if ( arrivalcutoff < (int)(WayPointList[i].AltArivalAGL)) bestwp=i;  
			}
		}
	} else continue; // do not draw icons for normal turnpoints here
    }

    DrawBitmapX(hdc, WayPointList[i].Screen.x-IBLSCALE(10), WayPointList[i].Screen.y-IBLSCALE(10), 20,20, hDCTemp,0,0,SRCPAINT);
    DrawBitmapX(hdc, WayPointList[i].Screen.x-IBLSCALE(10), WayPointList[i].Screen.y-IBLSCALE(10), 20,20, hDCTemp,20,0,SRCAND);

  } // for all waypoints

  if (foundairport==0 && bestwp>=0)  arrivalcutoff = (int)WayPointList[bestwp].AltArivalAGL;


  for(i=0;i<NumberOfWayPoints;i++)
    {
      if(WayPointList[i].Visible )
	{

#ifdef HAVEEXCEPTIONS
	  __try{
#endif

	    bool irange = false;
	    bool intask = false;
	    bool islandable;	// isairport+islandpoint
	    bool excluded=false;
	    bool dowrite;

	    intask = WaypointInTask(i);
	    dowrite = intask; // initially set only for intask
	    TextDisplayMode.AsInt = 0;

	    // airports are also landpoints. should be better handled
	    isairport=((WayPointList[i].Flags & AIRPORT) == AIRPORT);
	    islandpoint=((WayPointList[i].Flags & LANDPOINT) == LANDPOINT);

	    if (isairport || islandpoint) islandable=true; else islandable=false;

 	    // always in range if MapScale <=10  since no zoom in waypoints is documented and .Zoom is always 0. 
	    irange = WaypointInRange(i); 

	    if(MapScale > 20) { 
	      SelectObject(hDCTemp,hInvSmall);
	      irange=false;
	      goto NiklausWirth; // with compliments
	    } 

	    if( islandable ) { 

	      if(WayPointList[i].Reachable){

		TextDisplayMode.AsFlag.Reachable = 1;

		if ( isairport )
		  SelectObject(hDCTemp,hBmpAirportReachable);
		else
		  SelectObject(hDCTemp,hBmpFieldReachable);

		if ((DeclutterLabels<2)||intask) { 

		  dowrite = true;
		  // exclude outlandings worst than visible airports, only when there are visible reachable airports!
		  if ( isairport==false && islandpoint==true ) {
		    if ( (int)WayPointList[i].AltArivalAGL >=2000 ) { // more filter
		      excluded=true;
		    } else {
		      if ( (bestwp>=0) && (i==(unsigned)bestwp) && (foundairport==0) ) { // this outlanding is the best option
			isairport=true;
			islandpoint=false; // make it an airport TODO paint it as best
		      } else
			{
			  if ( foundairport >0 ) {
			    if ( (int)WayPointList[i].AltArivalAGL <= arrivalcutoff ) {
			      excluded=true;
			    } 
			    /*
			      if (MapScale >3 && MapScale <10 ) {
			      if ( (i!=bestwp)  && (arrivalcutoff>600) ) {
			      if ( (arrivalcutoff / ((int)WayPointList[i].AltArivalAGL+1))<4) {
			      excluded=true;
			      }
			      if (foundairport>2) excluded=true;
			      }
			      } else {
			      if ( (int)WayPointList[i].AltArivalAGL <= arrivalcutoff ) {
			      excluded=true;
			      } 
			      }
			    */
			  }
			}
		    }

		  }  else
		    // do not display airport arrival if close to the best so far.
		    // ex: best arrival is 1200m, include onlye below 1200/4  (prevent division by zero)
		    // This way we only display far points, and skip closer points 
		    // WE NEED MORE INFO ABOUT LANDING POINTS: THE .CUP FORMAT WILL LET US KNOW WHAT IS
		    // BEST TO SHOW AND WHAT IS NOT. Winpilot format is useless here.
		    {
		      dowrite=true;// TEST FIX not necessary probably
		      // it's an airport
		      if ( (bestwp>=0) && (i != (unsigned)bestwp) && (arrivalcutoff>600) ) {
			if ( (arrivalcutoff / ((int)WayPointList[i].AltArivalAGL+1))<4 ) {
			  excluded=true;
			}
		      }
		    } 
		}


	      } else  // landable waypoint is unreachable
		{
		  dowrite=true; 
		  if ( isairport ) {
		    SelectObject(hDCTemp,hBmpAirportUnReachable);
		  } else {
		    SelectObject(hDCTemp,hBmpFieldUnReachable);
		  }
		}
	    } else { // waypoint is an ordinary turnpoint
	      if(MapScale > 4) {
		if (BlackScreen) // 091109
			SelectObject(hDCTemp,hInvSmall);
		else
			SelectObject(hDCTemp,hSmall);
	      } else {
		if (BlackScreen) // 091109
			SelectObject(hDCTemp,hInvTurnPoint);
		else
			SelectObject(hDCTemp,hTurnPoint);
	      }

	    } // end landable-not landable

	  NiklausWirth:

	    if (intask || (OutlinedTp==(OutlinedTp_t)otAll) ) { 
	      TextDisplayMode.AsFlag.WhiteBold = 1;
	      TextDisplayMode.AsFlag.Color=TEXTWHITE; 
	    }
	

	// No matter of how we thought to draw it, let it up to the user..
	switch(NewMapDeclutter) {
		case 0:
			excluded=false; // no decluttering: show all airports and outlandings
			break;
		case 1:
			if ( isairport ) excluded=false; //  show all airports, declutter outlandings
			break;
		default:
			break; // else work normally
	}


	    // here come both turnpoints and landables..
	    if( intask || irange || dowrite) {  // irange almost always set when MapScale <=10 

	      bool draw_alt = TextDisplayMode.AsFlag.Reachable && ((DeclutterLabels<1) || intask); // reachable landing point!

	      if (excluded==true) draw_alt=false; // exclude close outlandings

	      switch(pDisplayTextType) {

	      case DISPLAYNAMEIFINTASK:  // TODO CHECK IT
		dowrite = intask;
		if (intask) {
		  if (draw_alt) {
		  if ( ArrivalValue == (ArrivalValue_t) avAltitude ) {
			if ( (MapBox == (MapBox_t)mbUnboxedNoUnit) || (MapBox == (MapBox_t)mbBoxedNoUnit) )
			    wsprintf(Buffer, TEXT("%s:%d"),
				     WayPointList[i].Name, 
				     (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY));
			else
			    wsprintf(Buffer, TEXT("%s:%d%s"),
				     WayPointList[i].Name, 
				     (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
				     sAltUnit);


		  } else
			    wsprintf(Buffer, TEXT("%s:%d"),
				     WayPointList[i].Name, 
				     (int)(WayPointCalc[i].GR)); 

		  if ( (MapBox == (MapBox_t)mbBoxed) || (MapBox == (MapBox_t)mbBoxedNoUnit)) {
			  TextDisplayMode.AsFlag.Border = 1;
			  TextDisplayMode.AsFlag.WhiteBold = 0;
		  } else
		  	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      		TextDisplayMode.AsFlag.Color=TEXTWHITE; 

		  }
		  else {
		    wsprintf(Buffer, TEXT("%s"),WayPointList[i].Name);
		    // TODO CHECK THIS, UNTESTED..
                    if (islandable && isairport) {
		       TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      		TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		    }
		  }
		}
		break;

	      case DISPLAYNAME:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		if ( (islandable && !isairport) && MapScale >=10 ) dowrite=0; // FIX then no need to go further

		if (draw_alt) {
		  if ( ArrivalValue == (ArrivalValue_t) avAltitude ) {
			if ( (MapBox == (MapBox_t)mbUnboxedNoUnit) || (MapBox == (MapBox_t)mbBoxedNoUnit) )
		  		wsprintf(Buffer, TEXT("%s:%d"), WayPointList[i].Name, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY));
			else
		  		wsprintf(Buffer, TEXT("%s:%d%s"), WayPointList[i].Name, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), sAltUnit);
		  } else 
		  	wsprintf(Buffer, TEXT("%s:%d"), WayPointList[i].Name, (int)WayPointCalc[i].GR);

		  //wsprintf(Buffer, TEXT("%s:%d:%d"), WayPointList[i].Name, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), (int)MapScale);
		  if ( (MapBox == (MapBox_t)mbBoxed) || (MapBox == (MapBox_t)mbBoxedNoUnit)) {
			  TextDisplayMode.AsFlag.Border = 1;
			  TextDisplayMode.AsFlag.WhiteBold = 0;
		  } else
		  	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
		  	TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		} else {
		  wsprintf(Buffer, TEXT("%s"),WayPointList[i].Name);
		  //wsprintf(Buffer, TEXT("%s%d"),WayPointList[i].Name,(int)MapScale);
		  if (islandable && isairport) {
		    TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
		    TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		  }
		}
				  
		break;
	      case DISPLAYNUMBER:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		if ( (islandable && !isairport) && MapScale >=10 ) dowrite=0; // FIX then no need to go further

		if (draw_alt) {
		  if ( ArrivalValue == (ArrivalValue_t) avAltitude ) {
			if ( (MapBox == (MapBox_t)mbUnboxedNoUnit) || (MapBox == (MapBox_t)mbBoxedNoUnit) )
		  		wsprintf(Buffer, TEXT("%d:%d"), WayPointList[i].Number, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY));
			else
		  		wsprintf(Buffer, TEXT("%d:%d%s"), WayPointList[i].Number, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), sAltUnit);
		  } else
		  	wsprintf(Buffer, TEXT("%d:%d"), WayPointList[i].Number, (int)(WayPointCalc[i].GR));
		  if ( (MapBox == (MapBox_t)mbBoxed) || (MapBox == (MapBox_t)mbBoxedNoUnit)) {
			  TextDisplayMode.AsFlag.Border = 1;
			  TextDisplayMode.AsFlag.WhiteBold = 0;
		  } else
		  	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      		TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		} else {
		  wsprintf(Buffer, TEXT("%d"),WayPointList[i].Number);
		  if (islandable && isairport) {
		    TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      		TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		  }
		}
		break;
	      case DISPLAYFIRSTFIVE:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		_tcsncpy(Buffer2, WayPointList[i].Name, 5);
		Buffer2[5] = '\0';
		if (draw_alt) {
		  if ( ArrivalValue == (ArrivalValue_t) avAltitude ) {
			if ( (MapBox == (MapBox_t)mbUnboxedNoUnit) || (MapBox == (MapBox_t)mbBoxedNoUnit) )
			  wsprintf(Buffer, TEXT("%s:%d"),
				   Buffer2, 
				   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY));
			else
			  wsprintf(Buffer, TEXT("%s:%d%s"),
				   Buffer2, 
				   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
				   sAltUnit);
		  } else
			  wsprintf(Buffer, TEXT("%s:%d"),
				   Buffer2, 
				   (int)(WayPointCalc[i].GR) );

		  if ( (MapBox == (MapBox_t)mbBoxed) || (MapBox == (MapBox_t)mbBoxedNoUnit)) {
			  TextDisplayMode.AsFlag.Border = 1;
			  TextDisplayMode.AsFlag.WhiteBold = 0;
		  } else
		  	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      		TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		}
		else {
		  wsprintf(Buffer, TEXT("%s"),Buffer2);
		  if (islandable && isairport) {
		    TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      	    TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		  }

		}
				  
		break;
	      case DISPLAYFIRSTTHREE:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		_tcsncpy(Buffer2, WayPointList[i].Name, 3);
		Buffer2[3] = '\0';
		if (draw_alt) {
		  if ( ArrivalValue == (ArrivalValue_t) avAltitude ) {
			if ( (MapBox == (MapBox_t)mbUnboxedNoUnit) || (MapBox == (MapBox_t)mbBoxedNoUnit) )
			  wsprintf(Buffer, TEXT("%s:%d"),
				   Buffer2, 
				   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY));
			else
			  wsprintf(Buffer, TEXT("%s:%d%s"),
				   Buffer2, 
				   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
				   sAltUnit);


		  } else
			  wsprintf(Buffer, TEXT("%s:%d"),
				   Buffer2, 
				   (int)(WayPointCalc[i].GR) );

		  if ( (MapBox == (MapBox_t)mbBoxed) || (MapBox == (MapBox_t)mbBoxedNoUnit)) {
			  TextDisplayMode.AsFlag.Border = 1;
			  TextDisplayMode.AsFlag.WhiteBold = 0;
		  } else
		  	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      	    	TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		}
		else {
		  wsprintf(Buffer, TEXT("%s"),Buffer2);
		  if (islandable && isairport) {
		    TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      	    TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		  }

		}
				  
				  
		break;
	      case DISPLAYNONE:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		if (draw_alt) {
		  if ( ArrivalValue == (ArrivalValue_t) avAltitude ) {
			if ( (MapBox == (MapBox_t)mbUnboxedNoUnit) || (MapBox == (MapBox_t)mbBoxedNoUnit) )
			  wsprintf(Buffer, TEXT("%d"), 
				   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY));
			else
			  wsprintf(Buffer, TEXT("%d%s"), 
				   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
				   sAltUnit);
		  } else
			  wsprintf(Buffer, TEXT("%d"), 
				   (int)(WayPointCalc[i].GR) );

		  if ( (MapBox == (MapBox_t)mbBoxed) || (MapBox == (MapBox_t)mbBoxedNoUnit)) {
			  TextDisplayMode.AsFlag.Border = 1;
			  TextDisplayMode.AsFlag.WhiteBold = 0;
		  } else
		  	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	      	    TextDisplayMode.AsFlag.Color=TEXTWHITE; 
		}
		else {
		  Buffer[0]= '\0';
		  dowrite=false;
		}
	      default:
#if (WINDOWSPC<1)
		ASSERT(0);
#endif
		break;

	      } // end intask/irange/dowrite

	      if (MapScale>=3 && MapScale<10 && islandable && dowrite) { // can't find a better solution for this 
		if (isairport)
		  TextInBox(hdc, Buffer, WayPointList[i].Screen.x+5, WayPointList[i].Screen.y, 0, TextDisplayMode, false);  
		else
		  TextInBox(hdc, Buffer, WayPointList[i].Screen.x+5, WayPointList[i].Screen.y, 0, TextDisplayMode, true);  
		dowrite=false; // do not pass it along
	      }
	      if (MapScale<3 && islandable && dowrite) { // damned irange problems
		TextInBox(hdc, Buffer, WayPointList[i].Screen.x+5,
			  WayPointList[i].Screen.y, 0, TextDisplayMode, false);  
		dowrite=false; // do not pass it along
	      }
	      if (MapScale>=10 && MapScale<20 && islandable && dowrite) { // damned irange problems
		TextInBox(hdc, Buffer, WayPointList[i].Screen.x+5,
			  WayPointList[i].Screen.y, 0, TextDisplayMode, true); 
		dowrite=false; // do not pass it along
	      }

		///: Do not show takeoff for gliders, check TakeOffWayPoint 
		if (i==RESWP_TAKEOFF) {
			if (TakeOffWayPoint) {
				intask=false; // 091031 let TAKEOFF be decluttered
				WayPointList[i].Visible=TRUE;
			} else {
				WayPointList[i].Visible=FALSE;
				dowrite=false;
			}
		}
	      if (dowrite) { 
		MapWaypointLabelAdd(
				    Buffer,
				    WayPointList[i].Screen.x+5,
				    WayPointList[i].Screen.y,
				    TextDisplayMode,
				    (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY),
				    intask,islandable,isairport,excluded,i);
	      }
	    } // end if intask
      
#ifdef HAVEEXCEPTIONS
	  }__finally
#endif
	     { ; }
	} // if visible
    } // for all waypoints
 
  qsort(&MapWaypointLabelList, MapWaypointLabelListCount, sizeof(MapWaypointLabel_t), MapWaypointLabelListCompare);

  int j;

  // now draw task/landable waypoints in order of range (closest last)
  // writing unconditionally

  for (j=MapWaypointLabelListCount-1; j>=0; j--){

    MapWaypointLabel_t *E = &MapWaypointLabelList[j];

    // draws if they are in task unconditionally,
    // otherwise, does comparison
    if ( E->inTask || (E->isLandable && !E->isExcluded) ) { 
      TextInBox(hdc, E->Name, E->Pos.x,
		E->Pos.y, 0, E->Mode, 
		false); 
    }
  }

  // now draw normal waypoints in order of range (furthest away last)
  // without writing over each other (or the task ones)
  for (j=0; j<MapWaypointLabelListCount; j++) {

    MapWaypointLabel_t *E = &MapWaypointLabelList[j];

    if (!E->inTask && !E->isLandable ) {

      if ( TextInBox(hdc, E->Name, E->Pos.x, E->Pos.y, 0, E->Mode, true) == true) {
	if(MapScale > 4) {
		if (BlackScreen) // 091109
	 		 SelectObject(hDCTemp,hInvSmall);
		else
	 		 SelectObject(hDCTemp,hSmall);
	} else {
		if (BlackScreen) // 091109
	  		SelectObject(hDCTemp,hInvTurnPoint);
		else
	  		SelectObject(hDCTemp,hTurnPoint);
	}

	DrawBitmapX(hdc,
		    E->Pos.x-IBLSCALE(10), 
		    E->Pos.y-IBLSCALE(10),
		    20,20,
		    hDCTemp,0,0,SRCPAINT);
        
	DrawBitmapX(hdc,
		    E->Pos.x-IBLSCALE(10), 
		    E->Pos.y-IBLSCALE(10),
		    20,20,
		    hDCTemp,20,0,SRCAND);
      }


    }
  }

} // end DrawWaypoint
d105 2
a106 2
  //short rcx=rc.left+rc.right/2-IBLSCALE(20); 
  //short rcy=rc.bottom-IBLSCALE(15); // 35
d240 1
a240 1
	   _DrawLine(hdc, PS_SOLID, IBLSCALE(1), Orig, p2, RGB_INVDRAW, rc); // 091109
d242 1
a242 1
	   _DrawLine(hdc, PS_SOLID, IBLSCALE(1), Orig, p2, RGB_BLACK, rc);
d246 1
d248 2
a249 20
/*
 * LK8000 interface for XCS by Paolo Ventafridda
 */
void MapWindow::DrawLook8000(HDC hdc,  RECT rc )
{
  HFONT		oldfont=0;
  SIZE TextSize, TextSize2;
///  TextInBoxMode_t TextDisplayMode;
  TCHAR Buffer[LKSIZEBUFFERLARGE];
  TCHAR BufferValue[LKSIZEBUFFERVALUE];
  TCHAR BufferUnit[LKSIZEBUFFERUNIT];
  TCHAR BufferTitle[LKSIZEBUFFERTITLE];
  char text[LKSIZETEXT];
  int index=-1;
  double Value;
  short rcx, rcy;
  short wlen;
  bool redwarning; // 091203

  short leftmargin=0;
d251 5
d257 1
a257 1
  static short tlen;
d259 8
a266 1
	if (NewMap==false) return;
d268 5
d274 3
a276 2
	redwarning=false;
	oldfont = (HFONT)SelectObject(hdc, LKINFOFONT); // FIXFONT
d278 14
a291 1
	//if ( InfoBoxLayout::landscape && IsMapFullScreen() && !EnablePan ) DrawBottom=true;
a292 2
	if ( IsMapFullScreen() && !EnablePan ) DrawBottom=true; // TODO maybe also !TargetPan
		else DrawBottom=false;
d294 3
a296 4
        if (DrawBottom && MapSpaceMode!= MSM_MAP) {
		DrawMapSpace(hdc, rc);
		goto Drawbottom;
	}
d298 13
a310 60

    	if (doinit) {
		doinit=false; // TODO OPTIMIZE ALL
	}
	// TODO make a table out of these values when they are confirmed and avoid calculating them each time
	// All these values are fine tuned for font/resolution/screenmode.
	if ( ScreenSize < (ScreenSize_t)sslandscape ) {
		if ( MapWindow::IsMapFullScreen() ) {
			switch (ScreenSize) {			// portrait fullscreen
				case (ScreenSize_t)ss240x320:
					tlen=6;
					break;
				default:
					tlen=6;
					break;
			}
		} else {
			switch (ScreenSize) {			// portrait not fullscreen
				case (ScreenSize_t)ss240x320:
					tlen=6;
					break;
				default:
					tlen=6;
					break;
			}
		}
	} else  {
		if ( MapWindow::IsMapFullScreen() ) {
			switch (ScreenSize) {			// landscape fullscreen
				case (ScreenSize_t)ss800x480:
				case (ScreenSize_t)ss400x240:
				case (ScreenSize_t)ss480x272:
					tlen=9;
					break;
				case (ScreenSize_t)ss320x240:
					tlen=8; // 091114 reduced from 9
					break;
				case (ScreenSize_t)ss640x480:
					tlen=8;
					break;
				case (ScreenSize_t)ss896x672:
					tlen=10;
					break;
				default:
					tlen=9;
					break;
			}
		} else {
			switch (ScreenSize) {			// landscape not fullscreen
				case (ScreenSize_t)ss480x272:
					tlen=7; // 091114 reduced from 9
					break;
				case (ScreenSize_t)ss320x240:
				case (ScreenSize_t)ss640x480:
					tlen=6; // 091114 reduced from 7
					break;
				default:
					tlen=7;
					break;
			}
d312 38
d351 7
d359 1
d361 2
a362 1
  // First we draw flight related values such as instant efficiency, altitude, new infoboxes etc.
d364 4
a367 8
  ///: if (MapWindow::IsMapFullScreen() && LKVarioBar) { // 091111 added Vario for PG 091115 configurable
  if (MapWindow::IsMapFullScreen() && LKVarioBar && !EnablePan) { // 091214 Vario non available in pan mode
	leftmargin=(LKVarioSize+IBLSCALE(3)); // VARIOWIDTH + middle separator right extension
	tlen-=2; // 091115
	
  } else {
	leftmargin=0;
  }
a368 2
  ///: 091122 no overlay - we are still drawing MC and the wind on bottom left!
  if ( Look8000 == (Look8000_t)lxcNoOverlay ) goto drawOverlay;
d370 17
a386 22
  if ( ValidTaskPoint(ActiveWayPoint) != false ) {
     index = Task[ActiveWayPoint].Index;
     ///: if ( index >0 ) BUGFIX 091016
     if ( index >=0 )
     {
  	if (DisplayMode != dmCircling) 
	{
	  rcx=rc.left+leftmargin+IBLSCALE(1);
	  rcy=rc.top+IBLSCALE(1);
	} else {
/*
	///: 091110 no need to display Thermal Band profile for para!
	  if (ISPARAGLIDER)
	  	rcx=rc.left+leftmargin+IBLSCALE(1);
	  else
	  	rcx=rc.left+leftmargin+IBLSCALE(40);
*/
	///: 091123 use ThermalBar flag 
	if (ThermalBar) // 091123 corrected inverted 091125
	  	rcx=rc.left+leftmargin+IBLSCALE(40);
	  else
	  	rcx=rc.left+leftmargin+IBLSCALE(1);
d388 4
a391 2
	  rcy=rc.top+IBLSCALE(1);
	}
a392 1
	// Waypoint name and distance
d394 4
a397 878
	SelectObject(hdc, LK8TargetFont);

#if 0
	// Active colours
	if (WayPointList[index].Reachable) {
		TextDisplayMode.AsFlag.Color = TEXTGREEN; 
	} else {
		TextDisplayMode.AsFlag.Color = TEXTRED;
	}
#endif
	///: 091203 redwarning
	if (WayPointCalc[index].AltArriv[AltArrivMode]>0 && !WayPointList[index].Reachable ) redwarning=true;
	else redwarning=false;

	///: TODO MAKE IT AN LKPROCESS
	wlen=wcslen(WayPointList[index].Name);
 	if (wlen>tlen) {
 	 	_tcsncpy(Buffer, WayPointList[index].Name, tlen); Buffer[tlen]='\0';
	} else {
 	 	_tcsncpy(Buffer, WayPointList[index].Name, wlen); Buffer[wlen]='\0';
	}

 	 ConvToUpper(Buffer);
	 LKWriteText(hdc,Buffer, rcx+IBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
 	 GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);

	 LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
	 LKWriteText(hdc,BufferValue, rcx+IBLSCALE(2), rcy+TextSize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);

 	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize2);
	if (!HideUnits) {
	 SelectObject(hdc, LKMAPFONT); // FIXFONT
	 LKWriteText(hdc, BufferUnit, rcx+IBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-IBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 
	}

	///: DIFF Bearing value displayed only when not circling
  	if (DisplayMode != dmCircling) 
	{
		LKFormatValue(LK_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
		SelectObject(hdc, LK8BigFont);
		LKWriteText(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ IBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, true);
       }


		// Draw efficiency required and altitude arrival for destination waypoint
		// For paragliders, average efficiency and arrival destination

		SelectObject(hdc, LK8BigFont); // use this font for big values

		if ( !ISPARAGLIDER ) { // 091110
			LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);

			GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
			rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
			rcx=rc.right-IBLSCALE(10);
			if (redwarning)  // 091203
				LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_RED, true);
			else
				LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE, true);

			// Altitude difference with current MC
			LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
			///: 091203 warn about obstacles when positive arrivals!
			if (redwarning) 
				LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, 
					WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_RED, true);
			else
				LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, 
					WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
		}

	} // index>0
    } // valid taskpoint

  ///: 091110 moved out from task paragliders stuff - this is painted on the right
  if ( ISPARAGLIDER ) {
	SelectObject(hdc, LK8BigFont); // use this font for big values
  	if (DisplayMode == dmCircling)
		LKFormatValue(LK_TC_30S, false, BufferValue, BufferUnit, BufferTitle);
	else
		LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);

	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
	rcx=rc.right-IBLSCALE(10);
	LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE, true);
/*
  if ( ValidTaskPoint(ActiveWayPoint) != false ) 
     index = Task[ActiveWayPoint].Index;
     if ( index >=0 )
*/
	// Altitude difference with current MC
	LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
	if (redwarning)
		LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_RED, true);
	else
		LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
  }

drawOverlay:
  ///: 091122 MC value 
  if (McOverlay) {
	SelectObject(hdc, LK8BigFont); 
	LKFormatValue(LK_MC, false, BufferValue, BufferUnit, BufferTitle);
	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10)-TextSize.cy;
	rcx=rc.right-IBLSCALE(10);
	LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE, true);
  }
  if ( Look8000 == (Look8000_t)lxcNoOverlay ) goto Drawbottom;




  ///: if ( (Look8000==(Look8000_t)lxcAdvanced) || ISPARAGLIDER ) { 091115 lxcStandard available for PG also
  if ( (Look8000==(Look8000_t)lxcAdvanced) ) {

	SelectObject(hdc, LK8BigFont); 
	if (ISPARAGLIDER) {
		// LKFormatValue(LK_VARIO, false, BufferValue, BufferUnit, BufferTitle);
		///: 091203 TODO this is NOT HGPS really, since NavAltitude uses Baro is available
		LKFormatValue(LK_HNAV, false, BufferValue, BufferUnit, BufferTitle); // 091115
	} else {
		LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);
	}
	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	///: rcx=rc.left+IBLSCALE(1)+leftmargin+GlideBarOffset;   // 091110
	if (!EnablePan) // 091214
		rcx=rc.left+IBLSCALE(10)+leftmargin+GlideBarOffset;   // 091115
	else
		rcx=rc.left+IBLSCALE(10)+leftmargin;   // 091115
	if (ISPARAGLIDER)
		rcy=(rc.bottom + rc.top-BottomSize)/2 -TextSize.cy-IBLSCALE(5);
	else
		rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);

	if (ISPARAGLIDER) {
		LKWriteText(hdc, BufferValue, rcx, rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
		if (!HideUnits) {
			SelectObject(hdc, LKMAPFONT);  // FIXFONT
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
		}

	} else {
		LKWriteText(hdc, BufferValue, rcx+IBLSCALE(9), rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
	}

	///: rcx+=IBLSCALE(9); 091115

	if (ISPARAGLIDER || LKVarioBar) { // 100213
		//LKFormatValue(LK_HGPS, false, BufferValue, BufferUnit, BufferTitle);
		LKFormatValue(LK_VARIO, false, BufferValue, BufferUnit, BufferTitle); // 091115
		SelectObject(hdc, LK8BigFont); 
		GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
		rcy+=TextSize.cy;
		LKWriteText(hdc, BufferValue, rcx,rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
		if (!HideUnits) {
			SelectObject(hdc, LKMAPFONT); // FIXFONT
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
		}
	}

	LKFormatValue(LK_GNDSPEED, false, BufferValue, BufferUnit, BufferTitle);
	SelectObject(hdc, LK8BigFont); 
	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	rcy+=TextSize.cy;
	LKWriteText(hdc, BufferValue, rcx,rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
	if (!HideUnits) {
		SelectObject(hdc, LKMAPFONT);  // FIXFONT
		LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
	}

	LKFormatValue(LK_TIME_LOCALSEC, false, BufferValue, BufferUnit, BufferTitle);

	if ( ScreenSize < (ScreenSize_t)sslandscape ) {
		if (MapWindow::IsMapFullScreen() ) {
			// SelectObject(hdc, LK8MediumFont);  091125
			SelectObject(hdc, LK8ValueFont); 
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(10),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
		} else {
			SelectObject(hdc, LK8MediumFont); 
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(27),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
		}
	} else {
		if (MapWindow::IsMapFullScreen() ) {
			SelectObject(hdc, LK8TargetFont); 
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(30),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
		} else {
			SelectObject(hdc, LK8MediumFont); 
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(28),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
		}
	}

  }

  /*
   * We want a standard interface for everybody with a minimal configuration. 
   * This navbox mode is NOT optional, and it will not be configurable.
   */

Drawbottom:
  if (DrawBottom) {

    RECT nrc;

    nrc.left=0;
    nrc.top=rc.bottom-BottomSize;
    nrc.right=rc.right;
    nrc.bottom=rc.bottom;

  HPEN hP;
  // HBRUSH hB,bB; REMOVE 090927
  HBRUSH hB;
  if ( INVERTCOLORS ) {
  	hB = (HBRUSH)CreateSolidBrush(RGB_NDARK);
	hP = (HPEN)CreatePen(PS_SOLID,0,RGB_YELLOW);
  } else {
  	hB = (HBRUSH)CreateSolidBrush(RGB_NLIGHT);
	hP = (HPEN)CreatePen(PS_SOLID,0,RGB_BLACK);
  }

#if (WINDOWSPC>0)
  HDC hdc2=CreateCompatibleDC(hdc);
  HBITMAP bitmapnew=CreateCompatibleBitmap(hdc,rc.right,rc.bottom);
  SelectObject(hdc2,bitmapnew); 
  FillRect(hdc2,&nrc, hB); 

  BLENDFUNCTION bs;
  bs.BlendOp=AC_SRC_OVER;
  bs.BlendFlags=0;
  bs.SourceConstantAlpha=195;
  bs.AlphaFormat=0;

  AlphaBlend(hdc,0,rc.bottom-BottomSize,rc.right,BottomSize,hdc2,0,rc.bottom-BottomSize,rc.right,BottomSize,bs);
#else
  FillRect(hdc,&nrc, hB); 
#endif


  ///:
  ///: NAVBOXES
  ///:


  static bool wascircling=false; // init not circling of course
  static short OldBottomMode=BM_FIRST;
  bool showunit=false;

  if ( (DisplayMode == dmCircling) && !wascircling) {
	// switch to thermal mode
	OldBottomMode=BottomMode;
	BottomMode=BM_TRM;
	wascircling=true;
  }
  if ( (DisplayMode != dmCircling) && wascircling) {
	// back to cruise mode
	BottomMode=OldBottomMode;
	wascircling=false;
  }

  /*
   *   FIRST VALUE
   */

  showunit=true; // normally we do have a unit to show


  switch(BottomMode) {
	case BM_TRM:
		///: showunit=LKFormatValue(LK_TC_AVG, true, BufferValue, BufferUnit, BufferTitle);
		index=GetInfoboxIndex(1,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		showunit=LKFormatValue(LK_TL_AVG, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_HGPS, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:
		showunit=LKFormatValue(LK_TC_ALL, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_FIN_DIST, true, BufferValue, BufferUnit, BufferTitle);
		break;

	case BM_SYS:
		LKFormatValue(LK_BATTERY, true, BufferValue, BufferUnit, BufferTitle);
		break;

	case BM_ALT:
		LKFormatValue(LK_BESTALTERN_GR, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		showunit=false;
		break;

	case BM_CUS:
		index=GetInfoboxType(1);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	case BM_CUS2:
		index=GetInfoboxIndex(1,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(1,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  rcx=rc.left+(rc.right/(splitter*2))-IBLSCALE(5); // FIX make it static in doinit
#include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);

  /*
   *   SECOND VALUE
   */
  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(2,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		showunit=LKFormatValue(LK_GNDSPEED, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_HBARO, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:
		showunit=LKFormatValue(LK_ODOMETER, true, BufferValue, BufferUnit, BufferTitle); // 091221
		// showunit=false; 091221
		break;
	case BM_TSK:
		LKFormatValue(LK_FIN_ALTDIFF, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_SYS:
		// TODO MAKE ENTRY IN LKPROCESS
		Value=PDABatteryTemperature;
		if (Value<1||Value>100) {
  			wsprintf(BufferValue, TEXT("----"));
		}
		else {
			sprintf(text,"%.0lf",Value);
  			wsprintf(BufferValue, TEXT("%S%S"),text,_T(DEG));
		}
		showunit=false;
  		wsprintf(BufferTitle, TEXT("Btemp"),text);
		break;

	case BM_ALT:
		showunit=LKFormatValue(LK_BESTALTERN_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
		wcscpy(BufferTitle,_T("<<<"));
		break;
	case BM_CUS:
		index=GetInfoboxType(2);
		showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(2,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(2,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  rcx+=(rc.right/splitter); 
#include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);


  /*
   *   THIRD VALUE
   */

  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(3,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		LKFormatValue(LK_HNAV, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_QFE, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:
		LKFormatValue(LK_TIMEFLIGHT, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_FIN_ETE, true, BufferValue, BufferUnit, BufferTitle);
		///: showunit=false; 091222
		break;
	case BM_SYS:
		// TODO MAKE IT in LKPROCESS
		Value=GPS_INFO.SatellitesUsed;
		if (Value<1 || Value>30) {
			wsprintf(BufferValue,TEXT("---"));
 			//TextDisplayMode.AsFlag.Color = TEXTRED;
		}
		else {
		//	if (Value<3)
 		//		TextDisplayMode.AsFlag.Color = TEXTYELLOW;
  			sprintf(text,"%d",(int)Value);
			wsprintf(BufferValue, TEXT("%S"),text);
		}
  		showunit=false;
  		wsprintf(BufferTitle, TEXT("SAT"));
		break;
	case BM_ALT:
		LKFormatValue(LK_ALTERN1_GR, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		showunit=false;
		break;
	case BM_CUS:
		index=GetInfoboxType(3);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(3,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(3,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  rcx+=(rc.right/splitter); 
#include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);

  /*
   *   FOURTH VALUE
   */

  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(4,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		///: showunit=LKFormatValue(LK_TC_GAIN, true, BufferValue, BufferUnit, BufferTitle);
	case BM_CRU:
		showunit=LKFormatValue(LK_NEXT_DIST, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_HAGL, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:  

		showunit=LKFormatValue(LK_HOME_DIST, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_TASK_DISTCOV, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_SYS:
		LKFormatValue(LK_EMPTY, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
		break;
	case BM_ALT:
		LKFormatValue(LK_ALTERN1_ARRIV, true, BufferValue, BufferUnit, BufferTitle);
		wcscpy(BufferTitle,_T("<<<"));
		break;
	case BM_CUS:
		index=GetInfoboxType(4);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(4,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(4,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }


  rcx+=(rc.right/splitter); 
#include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);


  /*
   *   FIFTH VALUE
   */

  if (splitter<5) goto EndOfNavboxes;
  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(5,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		///: LKFormatValue(LK_TC_30S, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_CRU: 
		LKFormatValue(LK_NEXT_GR, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_FL, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:
		LKFormatValue(LK_HOMERADIAL, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
		break;
	case BM_TSK:
// TODO MAKE IT LKPROCESS
  		Value=ALTITUDEMODIFY*CALCULATED_INFO.TaskStartAltitude;
		if (Value>0) {
			sprintf(text,"%d",(int)Value);
			wsprintf(BufferValue, TEXT("%S"),text);
		} else
			wsprintf(BufferValue, TEXT("---"));

  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
 		wsprintf(BufferTitle, TEXT("Start"),text);
		break;
	case BM_SYS:
		LKFormatValue(LK_EMPTY, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_ALT:
		LKFormatValue(LK_ALTERN2_GR, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		showunit=false;
		break;
	case BM_CUS:
		index=GetInfoboxType(5);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(5,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(5,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }


  rcx+=(rc.right/splitter)-IBLSCALE(7);  // shorter value
#include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);


  /*
   *   SIXTH VALUE
   */

  if (splitter<6) goto EndOfNavboxes;
  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		///: showunit=LKFormatValue(LK_VARIO, true, BufferValue, BufferUnit, BufferTitle);
		index=GetInfoboxIndex(6,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		showunit=LKFormatValue(LK_LD_AVR, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		LKFormatValue(LK_AQNH, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
		break;
	case BM_AUX:
		LKFormatValue(LK_LD_CRUISE, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_SPEEDTASK_ACH, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_SYS:
		if (LoggerGActive()) {
  			wsprintf(BufferValue, TEXT("OK"));
		} else {
  			wsprintf(BufferValue, TEXT("NO!"));
		}
  		wsprintf(BufferTitle, TEXT("GRec"));
		showunit=false;
		break;
	case BM_ALT:
		LKFormatValue(LK_ALTERN2_ARRIV, true, BufferValue, BufferUnit, BufferTitle);
		wcscpy(BufferTitle,_T("<<<"));
		break;
	case BM_CUS:
		index=GetInfoboxType(6);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(6,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(6,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }


  rcx+=(rc.right/splitter)-IBLSCALE(11); 
#include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);


  /*
   *    CLEAN UP 
   */

EndOfNavboxes:
  DeleteObject(hB);
  DeleteObject(hP);
#if (WINDOWSPC>0)
  DeleteObject(bitmapnew);
  DeleteDC(hdc2);
#endif

} // drawbottom

  ///: Do not draw wind, IBOX, LOCKED infos when in special menus
  if (DrawBottom && MapSpaceMode != MSM_MAP) goto TheEnd;


  //
  // Draw wind 
  //
  SelectObject(hdc, LK8TargetFont);

  LKFormatValue(LK_WIND, false, BufferValue, BufferUnit, BufferTitle);
  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
  rcy=TextSize.cy;
 
  if (DrawBottom)
  	LKWriteText(hdc, BufferValue, rc.left+IBLSCALE(5)+leftmargin, rc.bottom - BottomSize- rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
  else
  	LKWriteText(hdc, BufferValue, rc.left+IBLSCALE(5)+leftmargin, rc.bottom - rcy-IBLSCALE(5), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);

   if ( UseMapLock && MapLock ) {
	_stprintf(Buffer,TEXT("MAPLOCK"));
  	SelectObject(hdc, LKMAPFONT); // FIXFONT
  	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	if (DrawBottom)
  		///: LKWriteText(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true); 091110
  		LKWriteText(hdc, Buffer, ((rc.right-rc.left-leftmargin)/2)+leftmargin, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true);
  	else
  		///: LKWriteText(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true); 091110
  		LKWriteText(hdc, Buffer, ((rc.right-rc.left-leftmargin)/2)+leftmargin,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true);

   }
   if ( !MapWindow::IsMapFullScreen() && InfoFocus>=0 ) {

	_stprintf(Buffer,TEXT("IBOX"));
  	SelectObject(hdc, LKMAPFONT); // FIXFONT
  	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  	LKWriteText(hdc, Buffer, rc.right - (TextSize.cx)-IBLSCALE(20) ,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_LIGHTGREEN, true);
	if (iboxtoclick) {
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK")); 
		#endif
		iboxtoclick=false;
	}
   } 

TheEnd:

  // restore font and return
  SelectObject(hdc, oldfont); 


}

void MapWindow::DrawMapSpace(HDC hdc,  RECT rc ) {

  HFONT oldfont;
  HBRUSH hB;

  TextInBoxMode_t TextDisplayMode;
  TCHAR Buffer[LKSIZEBUFFERLARGE*2];
#ifdef DRAWLKSTATUS
  bool dodrawlkstatus=false;
#endif
  static bool doinit=true;
  static POINT p[10];

  if (INVERTCOLORS)
	hB=CreateSolidBrush(RGB_MDARK);
  else
	hB=CreateSolidBrush(RGB_MLIGHT);
  oldfont = (HFONT)SelectObject(hdc, LKINFOFONT); // save font
  FillRect(hdc,&rc, hB); 
  DeleteObject(hB);
  //oldbkmode=SetBkMode(hdc,TRANSPARENT);

  if (doinit) {
	p[0].x=0; p[0].y=rc.bottom-BottomSize-IBLSCALE(2); p[1].x=rc.right-1; p[1].y=p[0].y;
	p[2].x=0; p[2].y=0; p[3].x=rc.right-1; p[3].y=0; // 091230 right-1
	p[4].x=0; p[4].y=0; p[5].x=0; p[5].y=rc.bottom-BottomSize-IBLSCALE(2);
	p[6].x=rc.right-1; p[6].y=0; p[7].x=rc.right-1; p[7].y=rc.bottom-BottomSize-IBLSCALE(2); // 091230 right-1

//	p[8].x=0; p[8].y=rc.bottom-BottomSize-IBLSCALE(2); p[9].x=rc.right; p[9].y=p[8].y;
	doinit=false; 
  }

///: VERY STRANGE. On HP310 the VGA bug will not display correctly this line if drawn before the others..
///: or probably other lines are interfering with this one drawn before! 090916
///:  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[0], p[1], RGB_GREEN, rc);
  if (INVERTCOLORS) {
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[2], p[3], RGB_GREEN, rc);
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[4], p[5], RGB_GREEN, rc);
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[6], p[7], RGB_GREEN, rc);
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[0], p[1], RGB_GREEN, rc);
  } else {
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[2], p[3], RGB_DARKGREEN, rc);
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[4], p[5], RGB_DARKGREEN, rc);
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[6], p[7], RGB_DARKGREEN, rc);
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[0], p[1], RGB_DARKGREEN, rc);
  }


#ifdef DRAWLKSTATUS 
  if (LKevent==LKEVENT_NEWRUN) dodrawlkstatus=true;
#endif

  switch (MapSpaceMode) {
	case MSM_WELCOME:
#if (0)
		static double firsttime=GPS_INFO.Time;
		///: delayed automatic exit from welcome mode
		#ifdef _SIM_
		if ( GPS_INFO.Time > (firsttime+30.0) ) { // timeout
		#else
		if ( GPS_INFO.Time > (firsttime+60.0) ) { // timeout
		#endif
			SetModeType(LKMODE_MAP,MP_MOVING);
			LKevent=LKEVENT_NONE;
			break;
		}
#endif
		DrawWelcome8000(hdc, rc);
		break;
	case MSM_LANDABLE:
	case MSM_AIRPORTS:
		DrawNearest(hdc, rc);
		break;
	case MSM_NEARTPS:
		DrawNearestTurnpoint(hdc, rc);
		break;
	case MSM_COMMON:
	case MSM_RECENT:
		DrawCommon(hdc, rc);
		break;
	case MSM_MAP:
		break;
	case MSM_INFO_THERMAL:
	case MSM_INFO_CRUISE:
	case MSM_INFO_TASK:
	case MSM_INFO_AUX:
	case MSM_INFO_TRI:
		///: TODO check events are cleared
		DrawInfoPage(hdc,rc, false);
		break;
	default:
		TextDisplayMode.AsInt = 0;
		TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextDisplayMode.AsFlag.NoSetFont = 1; 
		TextDisplayMode.AsFlag.AlligneCenter = 1;
		SelectObject(hdc, LK8TargetFont);
		_stprintf(Buffer,TEXT("MapSpaceMode=%d"),MapSpaceMode);
		TextInBox(hdc, Buffer, (rc.right-rc.left)/2, IBLSCALE(50) , 0, TextDisplayMode, false);
		break;
	}
#ifdef DRAWLKSTATUS
  ///: no need to clear dodrawlkstatus, it is already reset at each run
  if (dodrawlkstatus) DrawLKStatus(hdc, rc);
#endif
  //SetBkMode(hdc,oldbkmode);
  SelectObject(hdc, oldfont); 
}

void MapWindow::DrawWelcome8000(HDC hdc, RECT rc) {

  SIZE textSize, headerSize;
  TCHAR Buffer[LKSIZEBUFFERLARGE];

  short bottomlines;
  short middlex=(rc.right-rc.left)/2;
  //short left=rc.left+IBLSCALE(5);
  short contenttop=rc.top+IBLSCALE(50);


  switch (LKevent) {
	case LKEVENT_NONE:
		break;
	case LKEVENT_ENTER:
		///: Event are cleared from called inner functions, but we do it nevertheless..
		SetModeType(LKMODE_MAP, MP_MOVING);
		LKevent=LKEVENT_NONE; // check if removable 
		break;
	default:
		LKevent=LKEVENT_NONE;
		break;
  }
  
  SelectObject(hdc, LK8BigFont);
  _stprintf(Buffer,TEXT("LK8000"));
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &headerSize);
  LKWriteText(hdc, Buffer, middlex, (headerSize.cy/2)+IBLSCALE(2) , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE, false);

  _stprintf(Buffer,TEXT("Tactical Flight Computer"));
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
  SelectObject(hdc, LK8MediumFont);
  LKWriteText(hdc, Buffer, middlex, (headerSize.cy/2)+(textSize.cy/2)+IBLSCALE(4)+1 , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE, false);


  //SelectObject(hdc, LK8InfoBigFont);
  SelectObject(hdc, LK8TitleFont);
  _stprintf(Buffer,TEXT("%s %s v%s.%s"),_T(LKNAME),_T(LKFORK),_T(LKVERSION),_T(LKRELEASE));
#ifdef _SIM_
d400 1
a400 1254
  LKWriteText(hdc, Buffer, middlex, contenttop+(textSize.cy*1) , 0, WTMODE_NORMAL, WTALIGN_CENTER,RGB_WHITE, false);


  _stprintf(Buffer,TEXT("Click on center screen to begin"));
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
  LKWriteText(hdc, Buffer, middlex, ((rc.bottom-rc.top)-textSize.cy)/2 , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN, false);


  SelectObject(hdc, LK8UnitFont);
  if (ScreenSize==0) {
	_stprintf(Buffer,TEXT("**SCREEN %dx%d NOT SUPPORTED**"),rc.right,rc.bottom );
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
	bottomlines=rc.bottom-BottomSize-(textSize.cy*3);
	LKWriteText(hdc, Buffer, middlex, bottomlines , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
	_stprintf(Buffer,TEXT("FONTS WILL NOT BE GOOD OR UNUSABLE"));
	LKWriteText(hdc, Buffer, middlex, bottomlines+textSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
  } else {
	_stprintf(Buffer,TEXT("%s build#%d"), XCSoar_Version,BUILDNUMBER);
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
	bottomlines=rc.bottom-BottomSize-(textSize.cy*3);
	LKWriteText(hdc, Buffer, middlex, bottomlines , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
	_stprintf(Buffer,TEXT("Evolved from XCSoar 5.2.4 by Paolo Ventafridda (venta@@bware.it)"));
	LKWriteText(hdc, Buffer, middlex, bottomlines+textSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
 }

  SelectObject(hdc, LK8InfoSmallFont);

  _stprintf(Buffer, _T("%d WPs, %0.1fM free"),NumberOfWayPoints,CheckFreeRam()/1000000.0);
#ifndef NDEBUG
  _tcscat(Buffer,_T(" (+debug)"));
#endif
#ifdef CPUSTATS
  _tcscat(Buffer,_T(" (+cpustats)"));
#endif
#ifdef DRAWLOAD
  _tcscat(Buffer,_T(" (+drawload)"));
#endif
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
  LKWriteText(hdc, Buffer, middlex, bottomlines-(textSize.cy)-IBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN, false);

  _stprintf(Buffer, _T(""));
  if (GPSAltitudeOffset >0) _stprintf(Buffer, _T("(GPSoffset=%+.0f)"), GPSAltitudeOffset);
#ifndef WINDOWSPC
  if (!LoggerGActive()) _tcscat(Buffer,_T(" (No GRecord)"));
#endif
  LKWriteText(hdc, Buffer, middlex, bottomlines-(textSize.cy*2)-IBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN, false);

  return;
}

///:
///: DRAW NEAREST
///:

void MapWindow::DrawNearest(HDC hdc, RECT rc) {

///: Maximum number of characters for waypoint name. Should be dynamically calculated?
///: CAUTION a line should be adjusted by hand! Not a reference value!!
#define MAXNLNAME 12 

  SIZE WPTextSize, DSTextSize, BETextSize, RETextSize, AATextSize, HLTextSize, MITextSize;
  TCHAR Buffer[LKSIZEBUFFERLARGE];
//  TCHAR bufferUnit[LKSIZEBUFFERUNIT], bufferValue[LKSIZEBUFFERVALUE], bufferTitle[LKSIZEBUFFERTITLE]; REMOVE
  static RECT s_sortBox[6]; 
  ///: we size each buffer twice the maximum expected lenght
  static TCHAR Buffer1[MAXNEAREST][MAXNUMPAGES][24], Buffer2[MAXNEAREST][MAXNUMPAGES][10], Buffer3[MAXNEAREST][MAXNUMPAGES][10];
  static TCHAR Buffer4[MAXNEAREST][MAXNUMPAGES][12], Buffer5[MAXNEAREST][MAXNUMPAGES][12];
  static short maxnlname;
  char text[30];
  short i, k, iRaw, wlen, rli=0, curpage, drawn_items_onpage;
  double Value;
  COLORREF rcolor;

  ///: column0 starts after writing 1:2 (ModeIndex:CURTYPE+1) with a different font..
  static short Column0;
  static short Column1, Column2, Column3, Column4, Column5;
  ///static short SortColumn1, SortColumn2, SortColumn3, SortColumn4, SortColumn5;
  static POINT p1, p2;
  static short rawspace;
  ///: Printable area for live nearest values
  static short left,right,bottom;
  ///: one for each mapspace, no matter if 0 and 1 are unused

  ///: Vertical and horizontal spaces
  #define INTERRAW	1
//  #define HEADRAW	3
///: top of header text character
  #define HEADRAW	IBLSCALE(6)	
  HBRUSH sortbrush;
  //HPEN hpen;
  //HPEN oldpen;
  RECT invsel;

  //int oldbkmode=SetBkMode(hdc,TRANSPARENT);

  static bool doinit=true;

  if (INVERTCOLORS) {
  	if ( (sortbrush=CreateSolidBrush(RGB_LIGHTGREEN)) == NULL) {
		DoStatusMessage(_T("ERR-011 Brush DrawNearest failed"));
  		sortbrush=CreateSolidBrush(RGB_WHITE);
	}
	//hpen=(HPEN)CreatePen(PS_SOLID,2,RGB_DARKGREEN);
  } else {
  	sortbrush=CreateSolidBrush(RGB_DARKGREEN);
	//hpen=(HPEN)CreatePen(PS_SOLID,2,RGB_BLACK);
  }

  ///:
  ///: DrawNearest INIT HACK /////////////////////////////////////////////
  ///:
  if (doinit) {

  ///: Set screen borders to avoid writing on extreme pixels
  if ( ScreenSize < (ScreenSize_t)sslandscape ) {
	///: Portrait mode has tight horizontal margins...
	left=rc.left+IBLSCALE(1);
	right=rc.right-IBLSCALE(1);
  	bottom=rc.bottom-BottomSize-IBLSCALE(2);
	maxnlname=MAXNLNAME-5; // 7 chars max, 8 sized
  	_stprintf(Buffer,TEXT("MAKSJSMM"));  
  } else {
	left=rc.left+IBLSCALE(5);
	right=rc.right-IBLSCALE(5);
  	bottom=rc.bottom-BottomSize;
	///: maxnlname=MAXNLNAME; 100213 FIX
  	///: _stprintf(Buffer,TEXT("MilMalMkp23M")); 
	maxnlname=MAXNLNAME-3; // 9 chars, sized 10
  	_stprintf(Buffer,TEXT("ABCDEFGHMx")); 
  }

///:  WAYPOINT  DISTANCE  BEARING reqE  AltArriv

  SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest  was LK8Title
  ///: Size waypoint name to 12 characters FIX make it as MAXNLNAME !
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &WPTextSize);

  ///: Size distance
  _stprintf(Buffer,TEXT("000.0")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &DSTextSize);

  //: Bearing
  _stprintf(Buffer,TEXT("<<123")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &BETextSize);

  //: reqE
  _stprintf(Buffer,TEXT("5299")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &RETextSize);

  //: Altitude Arrival
  _stprintf(Buffer,TEXT("+9999")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &AATextSize);

  SelectObject(hdc, LK8InfoNormalFont);
  _stprintf(Buffer,TEXT("MMMM")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &HLTextSize);

  SelectObject(hdc, LK8PanelMediumFont);  
  _stprintf(Buffer,TEXT("1.1")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &MITextSize);

  //short intercolumn=(right-left-WPTextSize.cx-DSTextSize.cx-BETextSize.cx-RETextSize.cx-AATextSize.cx)/3; // era 4 FIX
  short afterwpname=left+WPTextSize.cx+IBLSCALE(5);
  short intercolumn=(right-afterwpname- DSTextSize.cx-BETextSize.cx-RETextSize.cx-AATextSize.cx)/3; 
  ///: limit intercolumn to something reasonable..
  //if (intercolumn>IBLSCALE(35)) intercolumn=IBLSCALE(35);

  ///: Col0 is where APTS 1/3 can be written, after ModeIndex:Curtype
  Column0=MITextSize.cx+LEFTLIMITER+IBLSCALE(5);
  Column1=left;							// WP align left
  //Column2=Column1+WPTextSize.cx+intercolumn/2;	// DS align right
  Column2=afterwpname+DSTextSize.cx;						// DS align right
  Column3=Column2+intercolumn+BETextSize.cx;			// BE align right
  Column4=Column3+intercolumn+RETextSize.cx;			// RE align right
  Column5=Column4+intercolumn+AATextSize.cx;			// AA align right


  if ( ScreenSize < (ScreenSize_t)sslandscape ) {
	///: Portrait mode has plenty of vertical space...
  	//TopSize=rc.top+(HEADRAW*3)+HLTextSize.cy;
  	TopSize=rc.top+HEADRAW*2+HLTextSize.cy;
  	p1.x=0; p1.y=TopSize; p2.x=rc.right; p2.y=p1.y;
  	//TopSize+=(WPTextSize.cy);
  	TopSize+=HEADRAW;
  	Numraws=(bottom - TopSize) / (WPTextSize.cy+(INTERRAW*2));
  	if (Numraws>MAXNEAREST) Numraws=MAXNEAREST;
  	rawspace=(WPTextSize.cy+INTERRAW);
  } else {
  	//TopSize=rc.top+HEADRAW+HLTextSize.cy;
  	TopSize=rc.top+HEADRAW*2+HLTextSize.cy;
  	p1.x=0; p1.y=TopSize; p2.x=rc.right; p2.y=p1.y;
//  	TopSize+=(WPTextSize.cy/4);
  	TopSize+=HEADRAW/2;
  	Numraws=(bottom - TopSize) / (WPTextSize.cy+INTERRAW);
  	if (Numraws>MAXNEAREST) Numraws=MAXNEAREST;
  	rawspace=(WPTextSize.cy+INTERRAW);
  }

#define INTERBOX intercolumn/2

  ///: Wpname
  s_sortBox[0].left=Column0; // FIX 090925 era solo 0
  if ( ScreenSize < (ScreenSize_t)sslandscape ) s_sortBox[0].right=left+WPTextSize.cx-IBLSCALE(2);
  else s_sortBox[0].right=left+WPTextSize.cx-IBLSCALE(10);
  s_sortBox[0].top=2;
  s_sortBox[0].bottom=p1.y;
  SortBoxX[0]=s_sortBox[0].right;

  ///: Distance
  if ( ScreenSize < (ScreenSize_t)sslandscape ) s_sortBox[1].left=Column1+afterwpname-INTERBOX;
  else s_sortBox[1].left=Column1+afterwpname-INTERBOX-IBLSCALE(2);
  s_sortBox[1].right=Column2+INTERBOX;
  s_sortBox[1].top=2;
  s_sortBox[1].bottom=p1.y;
  SortBoxX[1]=s_sortBox[1].right;

  ///: Bearing
  s_sortBox[2].left=Column2+INTERBOX;
  s_sortBox[2].right=Column3+INTERBOX;
  s_sortBox[2].top=2;
  s_sortBox[2].bottom=p1.y;
  SortBoxX[2]=s_sortBox[2].right;

  ///: reqE
  s_sortBox[3].left=Column3+INTERBOX;
  s_sortBox[3].right=Column4+INTERBOX;
  s_sortBox[3].top=2;
  s_sortBox[3].bottom=p1.y;
  SortBoxX[3]=s_sortBox[3].right;

  ///: AltArr
  s_sortBox[4].left=Column4+INTERBOX;
  //s_sortBox[4].right=Column5+INTERBOX;
  s_sortBox[4].right=rc.right-1;
  s_sortBox[4].top=2;
  s_sortBox[4].bottom=p1.y;
  SortBoxX[4]=s_sortBox[4].right;

  SortBoxY=p1.y;

  ///: Caution: could be wrong? no..
  //Numpages=(short)ceil( (float)MAXNEAREST / (float)Numraws );
  Numpages=roundupdivision(MAXNEAREST, Numraws);
  if (Numpages>MAXNUMPAGES) Numpages=MAXNUMPAGES;
  else if (Numpages<1) Numpages=1;

  ///: set the initial highlighted item to the first, in each MapSpace
  SelectedRaw[MSM_LANDABLE]=0; SelectedRaw[MSM_AIRPORTS]=0;
  ///: 
  SelectedPage[MSM_LANDABLE]=0; SelectedPage[MSM_AIRPORTS]=0;

  doinit=false;
  return;
  } // doinit
  ///:
  ///: END INIT HACK /////////////////////////////////////////
  ///:

  ///: Recalculate real number of pages... BUG FIX 
  Numpages=roundupdivision(SortedNumber, Numraws);
  if (Numpages>MAXNUMPAGES) Numpages=MAXNUMPAGES;
  else if (Numpages<1) Numpages=1;

///:  TCHAR vbuf[100]; // REMOVE VENTA
///:  wsprintf(vbuf,_T("Numpages=%d sortednum=%d numraws=%d"),Numpages, SortedNumber, Numraws );
///:  DoStatusMessage(vbuf);

  ///: current page in use by current mapspacemode
  curpage=SelectedPage[MapSpaceMode];
  if (curpage<0||curpage>=MAXNUMPAGES) { // TODO also >Numpages
	DoStatusMessage(_T("ERR-091 curpage invalid!")); // TODO FIX this happening
	///: immediate action!
	SelectedPage[MapSpaceMode]=0;
	LKevent=LKEVENT_NONE;
	return;
  }

  ///: synthetic event handler . Remember to always clear events!
  switch (LKevent) {
	case LKEVENT_NONE:
		break;
	case LKEVENT_ENTER:
		LKevent=LKEVENT_NONE;
		if (MapSpaceMode==MSM_LANDABLE) 
			i=SortedLandableIndex[SelectedRaw[MapSpaceMode]+(curpage*Numraws)];
		else
			i=SortedAirportIndex[SelectedRaw[MapSpaceMode] + (curpage*Numraws)];

		if ( !ValidWayPoint(i)) {
			///: dont say error if empty list and an enter was pressed
			if (SortedNumber>0)
				DoStatusMessage(_T("ERR-019 Invalid selection")); // 090912 TODO FIX this happening
			break;
		}
		SelectedWaypoint=i;
		PopupWaypointDetails();
		SetModeType(LKMODE_MAP,MP_MOVING);
		///: originally without event, forced now by SetModeType
		LKevent=LKEVENT_NONE; 
		return;
		break;
	case LKEVENT_DOWN:
		if (++SelectedRaw[MapSpaceMode] >=Numraws) SelectedRaw[MapSpaceMode]=0;
		///: Event to be cleared at the end
		break;
	case LKEVENT_UP:
		if (--SelectedRaw[MapSpaceMode] <0) SelectedRaw[MapSpaceMode]=Numraws-1;
		///: Event to be cleared at the end
		break;
	case LKEVENT_PAGEUP:
		LKevent=LKEVENT_NONE;
		break;
	case LKEVENT_PAGEDOWN:
		LKevent=LKEVENT_NONE;
		break;
	case LKEVENT_NEWRUN:
		///: cleared at the end
		for (i=0; i<MAXNEAREST; i++) {
			for (k=0; k<MAXNUMPAGES; k++) {
				_stprintf(Buffer1[i][k],_T("------------")); // 12 chars
				_stprintf(Buffer2[i][k],_T("----"));
				_stprintf(Buffer3[i][k],_T("----"));
				_stprintf(Buffer4[i][k],_T("----"));
				_stprintf(Buffer5[i][k],_T("----"));
			}
		}
		break;
	case LKEVENT_NEWPAGE:
		///: cleared at the end
		break;
	default:
		LKevent=LKEVENT_NONE;
		break;
  }

  ///: Draw Headline

  if (INVERTCOLORS)
	  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
  else
	  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_DARKGREEN, rc);

  SelectObject(hdc, LK8InfoNormalFont); // Heading line

  short cursortbox=SortedMode[MapSpaceMode];

  //SetBkMode(hdc,TRANSPARENT);

  if ( ScreenSize < (ScreenSize_t)sslandscape ) { // portrait mode
	FillRect(hdc,&s_sortBox[cursortbox], sortbrush); 
	//oldpen=(HPEN)SelectObject(hdc,hpen);
	//Rectangle(hdc,s_sortBox[cursortbox].left, s_sortBox[cursortbox].top, s_sortBox[cursortbox].right, s_sortBox[cursortbox].bottom); 

	///: lk status index
	_stprintf(Buffer,TEXT("%d.%d"),ModeIndex,CURTYPE+1);
  	SelectObject(hdc, LK8PanelMediumFont); 

	LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0,  WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);
  	SelectObject(hdc, LK8InfoNormalFont); 

	if (MapSpaceMode==MSM_LANDABLE) 
 		_stprintf(Buffer,TEXT("LND %d/%d"),  curpage+1,Numpages); 
 	else
 	 	_stprintf(Buffer,TEXT("APT %d/%d"),  curpage+1, Numpages); 
	if (cursortbox == 0)
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

	 _stprintf(Buffer,TEXT("Dist")); 
	if (cursortbox==1)
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("Dir")); 
	if (cursortbox==2)
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("rEff")); 
	if (cursortbox==3)
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("AltA")); 
	if (cursortbox==4)
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);


  } else {
	FillRect(hdc,&s_sortBox[cursortbox], sortbrush);
	//oldpen=(HPEN)SelectObject(hdc,hpen);
	//Rectangle(hdc,s_sortBox[cursortbox].left, s_sortBox[cursortbox].top, s_sortBox[cursortbox].right, s_sortBox[cursortbox].bottom); 

	if ( (ScreenSize == (ScreenSize_t)ss640x480) || (ScreenSize == (ScreenSize_t)ss320x240) || (ScreenSize == ss896x672) ) {

		///: lk status index
		_stprintf(Buffer,TEXT("%d.%d"),ModeIndex,CURTYPE+1);
  		SelectObject(hdc, LK8PanelMediumFont); 
		LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);
  		SelectObject(hdc, LK8InfoNormalFont); 

		if (MapSpaceMode==MSM_LANDABLE) 
			_stprintf(Buffer,TEXT("LNDB %d/%d"), curpage+1,Numpages); 
		else
			_stprintf(Buffer,TEXT("APTS %d/%d"), curpage+1, Numpages); 
		if (cursortbox==0)
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

		_stprintf(Buffer,TEXT("Dist")); 
		if (cursortbox==1)
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Dir")); 
		if (cursortbox==2)
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("rEff")); 
		if (cursortbox==3)
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Arriv")); 
		if (cursortbox==4)
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);
	} else {
		///: lk status index
		_stprintf(Buffer,TEXT("%d.%d"),ModeIndex,CURTYPE+1);
  		SelectObject(hdc, LK8PanelMediumFont); 
		LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);
  		SelectObject(hdc, LK8InfoNormalFont); 

		if (MapSpaceMode==MSM_LANDABLE) 
			_stprintf(Buffer,TEXT("LNDB %d/%d"),  curpage+1,Numpages); 
		else
			_stprintf(Buffer,TEXT("APTS %d/%d"), curpage+1, Numpages); 
		if (cursortbox==0)
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

		_stprintf(Buffer,TEXT("Distance")); 
		if (cursortbox==1)
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Direction")); 
		if (cursortbox==2)
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("ReqEff")); 
		if (cursortbox==3)
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("AltArr")); 
		if (cursortbox==4)
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);
	}
	

  } // landscape mode


  ///: Draw values

  SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest

  ///: try to reduce conflicts, as task thread could change it while we are using it here.
  ///: so we copy it and clear it here once forever in this run
  bool ndr=NearestDataReady;
  NearestDataReady=false;

  //TCHAR vbuf[100]; // REMOVE VENTA
  //wsprintf(vbuf,_T("MAXNEAREST=%d Numraws=%d Numpages=%d calc=%d"),MAXNEAREST, Numraws, Numpages, (short)(ceil(MAXNEAREST/Numraws)));
  //DoStatusMessage(vbuf);

  ///: numraws always <= MAXNEAREST 
  for (i=0, drawn_items_onpage=0; i<Numraws; i++) {
	iRaw=TopSize+(rawspace*i);
	short curraw=(curpage*Numraws)+i;
	if (curraw>=MAXNEAREST) break;
	if (MapSpaceMode==MSM_LANDABLE) {
		rli=SortedLandableIndex[curraw];
	} else {
		rli=SortedAirportIndex[curraw];
	}


	if (!ndr) {
		goto KeepOldValues;
	}
	if ( ValidWayPoint(rli) ) {

		///: Waypoint name
		wlen=wcslen(WayPointList[rli].Name);
		if (wlen>maxnlname) {
			_tcsncpy(Buffer, WayPointList[rli].Name, maxnlname); Buffer[maxnlname]='\0';
		}
		else {
			_tcsncpy(Buffer, WayPointList[rli].Name, wlen); Buffer[wlen]='\0';
		}
		ConvToUpper(Buffer); // 100213 FIX UPPERCASE DRAWNEAREST
		_tcscpy(Buffer1[i][curpage],Buffer); 

		///: Distance
		Value=WayPointCalc[rli].Distance*DISTANCEMODIFY;
         	_stprintf(Buffer2[i][curpage],TEXT("%0.1lf"),Value);

		///: relative bearing

		if (DisplayMode != dmCircling) {
			Value = WayPointCalc[rli].Bearing -  GPS_INFO.TrackBearing;

			if (Value < -180.0)
				Value += 360.0;
			else
				if (Value > 180.0)
					Value -= 360.0;

#ifndef __MINGW32__
			if (Value > 1)
				_stprintf(Buffer3[i][curpage], TEXT("%2.0f°»"), Value);
			else
				if (Value < -1)
					_stprintf(Buffer3[i][curpage], TEXT("«%2.0f°"), -Value);
				else
					_tcscpy(Buffer3[i][curpage], TEXT("«»"));
#else
			if (Value > 1)
				_stprintf(Buffer3[i][curpage], TEXT("%2.0fÂ°Â»"), Value);
			else
				if (Value < -1)
					_stprintf(Buffer3[i][curpage], TEXT("Â«%2.0fÂ°"), -Value);
				else
					_tcscpy(Buffer3[i][curpage], TEXT("Â«Â»"));
#endif
		} else
			_stprintf(Buffer3[i][curpage],_T("---"));

		///: Requested GR
		Value=WayPointCalc[rli].GR;
		if (Value<1 || Value>=INVALID_GR) 
			_stprintf(Buffer4[i][curpage],_T("---"));
		else {
			if (Value>99) sprintf(text,"%.0f",Value);
			else sprintf(text,"%.1f",Value);
			_stprintf(Buffer4[i][curpage],_T("%S"),text);
		}

		///: arrival altitude QUIQUI
		//LKFormatValue(LK_NEXT_ALTDIFF, true, Buffer5[i][curpage], bufferUnit, bufferTitle);
//* TESTFIX 091005 REMOVE
		Value=ALTITUDEMODIFY*WayPointCalc[rli].AltArriv[AltArrivMode];
		if (Value <-9999 ||  Value >9999 )
			strcpy(text,"---");
		else
			sprintf(text,"%+.0f",Value);
		wsprintf(Buffer5[i][curpage], TEXT("%S"),text);
//*/

	} else {
		///: Invalid waypoint, fill in all empty data and maybe break loop
		_stprintf(Buffer1[i][curpage],_T("------------"));
		_stprintf(Buffer2[i][curpage],_T("---"));
		_stprintf(Buffer3[i][curpage],_T("---"));
		_stprintf(Buffer4[i][curpage],_T("---"));
		_stprintf(Buffer5[i][curpage],_T("---"));
	}


KeepOldValues:

	if ( ValidWayPoint(rli) ) {

		drawn_items_onpage++;

		if ( ((WayPointList[rli].Flags & AIRPORT) == AIRPORT) ) // BUGFIX old  rli and not i
		{
			rcolor=RGB_WHITE;
  			SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest
		} else {
			rcolor=RGB_LIGHTYELLOW;
  			SelectObject(hdc, LK8InfoBigItalicFont); // Text font for Nearest
		}
		///: if ((WayPointCalc[rli].VGR == 3 )) 091205
		if ((WayPointCalc[rli].VGR == 3 )|| (!WayPointList[rli].Reachable)) // 091205
			rcolor=RGB_LIGHTRED;
	} else 
			rcolor=RGB_GREY;

  	///: _stprintf(Buffer,TEXT("MMMMMMMMMMMM")); 
	LKWriteText(hdc, Buffer1[i][curpage], Column1, iRaw , 0, WTMODE_NORMAL, WTALIGN_LEFT, rcolor, false);
	
	///: set again correct font
  	SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest
  	///: _stprintf(Buffer,TEXT("000.0")); 
	LKWriteText(hdc, Buffer2[i][curpage], Column2, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("<<123")); 
	LKWriteText(hdc, Buffer3[i][curpage], Column3, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("123")); 
	LKWriteText(hdc, Buffer4[i][curpage], Column4, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("+9999")); 
	LKWriteText(hdc, Buffer5[i][curpage], Column5, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  ///: FOR
  } 


  ///: clear flag, and don't outbox
  if (LKevent==LKEVENT_NEWRUN || LKevent==LKEVENT_NEWPAGE ) {
		LKevent=LKEVENT_NONE;
		return;
  }

  ///: BOXOUT SELECTED ITEM
  ///: check that we don't have an empty list
  if (drawn_items_onpage>0) {

	if (SelectedRaw[MapSpaceMode] <0 || SelectedRaw[MapSpaceMode]>(Numraws-1)) {
		///: DoStatusMessage(_T("DBG-021 Invalid selected raw"));
		return;
	}
	///: avoid boxing and selecting nonexistent items
	///: selectedraw starts from 0, drawnitems from 1...
	if (SelectedRaw[MapSpaceMode] >= drawn_items_onpage) {
		if (LKevent==LKEVENT_DOWN) SelectedRaw[MapSpaceMode]=0;
		else 
		///: up from top to bottom, bottom empty, look for the last valid one (ie first going back from bottom)
		if (LKevent==LKEVENT_UP) SelectedRaw[MapSpaceMode]=drawn_items_onpage-1;
		else {
			DoStatusMessage(_T("Cant find valid raw"));
			SelectedRaw[MapSpaceMode]=0;
		}
	}

	
	invsel.left=left;
	invsel.right=right;
	invsel.top=TopSize+(rawspace*SelectedRaw[MapSpaceMode])+IBLSCALE(2);
	invsel.bottom=TopSize+(rawspace*(SelectedRaw[MapSpaceMode]+1))-IBLSCALE(1);
	InvertRect(hdc,&invsel);
	//Rectangle(hdc,invsel.left-1,invsel.top-1,invsel.right+1,invsel.bottom+1);

  } 

  LKevent=LKEVENT_NONE;
  //SetBkMode(hdc,oldbkmode); // not needed?
  //SelectObject(hdc,oldpen);
  DeleteObject(sortbrush);
  //DeleteObject(hpen);
  return;
}


#ifdef CPUSTATS
void MapWindow::DrawCpuStats(HDC hdc, RECT rc) {

  if (Appearance.InverseInfoBox == true) return;

  TCHAR Buffer[LKSIZEBUFFERLARGE];
  TextInBoxMode_t TextDisplayMode;
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.WhiteBorder = 1; // inside a white circle
  TextDisplayMode.AsFlag.Border = 1;      // add a black border to the circle

#if (WINDOWSPC>0)
  wsprintf(Buffer,_T("CPU Draw=%d Calc=%d us"), Cpu_Draw, Cpu_Calc);
#else
  wsprintf(Buffer,_T("CPU Draw=%d Calc=%d ms"), Cpu_Draw, Cpu_Calc);
#endif
  TextInBox(hdc, Buffer, 000, 200 , 0, TextDisplayMode, false);
#if (WINDOWSPC>0)
  wsprintf(Buffer,_T("CPU Inst=%d Port=%d us"), Cpu_Instrument, Cpu_Port);
#else
  wsprintf(Buffer,_T("CPU Inst=%d Port=%d ms"), Cpu_Instrument, Cpu_Port);
#endif
  TextInBox(hdc, Buffer, 000, 240 , 0, TextDisplayMode, false);

  //wsprintf(Buffer,_T("Landsc=%d Geom=%d"), InfoBoxLayout::landscape, InfoBoxLayout::InfoBoxGeometry);
  //TextInBox(hdc, Buffer, 000, 280 , 0, TextDisplayMode, false);
  //wsprintf(Buffer,_T("Recents=%d"), RecentNumber);
  //TextInBox(hdc, Buffer, 000, 280 , 0, TextDisplayMode, false);

}
#endif

#ifdef DRAWDEBUG
void MapWindow::DrawDebug(HDC hdc, RECT rc) {

  TCHAR Buffer[LKSIZEBUFFERLARGE];
  TextInBoxMode_t TextDisplayMode;
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.WhiteBorder = 1; // inside a white circle
  TextDisplayMode.AsFlag.Border = 1;      // add a black border to the circle

  wsprintf(Buffer,_T("ModeIndex=%d CURTYPE=%d MSM=%d"), ModeIndex, ModeType[ModeIndex],MapSpaceMode );
  TextInBox(hdc, Buffer, 000, 200 , 0, TextDisplayMode, false);
  wsprintf(Buffer,_T("MTableTop=%d ModeTable=%d=MSM"), ModeTableTop[ModeIndex], ModeTable[ModeIndex][ModeType[ModeIndex]] );
  TextInBox(hdc, Buffer, 000, 240 , 0, TextDisplayMode, false);

}
#endif

///:
///: DRAW COMMONs
///:

void MapWindow::DrawCommon(HDC hdc, RECT rc) {

///: Maximum number of characters for waypoint name. Should be dynamically calculated?
///: CAUTION a line should be adjusted by hand! Not a reference value!!
#define MAXNLNAME 12 

  SIZE WPTextSize, DSTextSize, BETextSize, RETextSize, AATextSize, HLTextSize, MITextSize;
  TCHAR Buffer[LKSIZEBUFFERLARGE];
  static RECT s_sortBox[6]; 
  ///: we size each buffer twice the maximum expected lenght
  static TCHAR Buffer1[MAXCOMMON][MAXCOMMONNUMPAGES][24], Buffer2[MAXCOMMON][MAXCOMMONNUMPAGES][10], Buffer3[MAXCOMMON][MAXCOMMONNUMPAGES][10];
  static TCHAR Buffer4[MAXCOMMON][MAXCOMMONNUMPAGES][12], Buffer5[MAXCOMMON][MAXCOMMONNUMPAGES][12];
  static short maxnlname;
  char text[LKSIZETEXT];
  short i, k, iRaw, wlen, rli=0, curpage, drawn_items_onpage;
  double Value;
  COLORREF rcolor;


  static short Column0, Column1, Column2, Column3, Column4, Column5;
  static POINT p1, p2;
  static short rawspace;
  ///: Printable area for live nearest values
  static short left,right,bottom;
  ///: one for each mapspace, no matter if 0 and 1 are unused

  ///: Vertical and horizontal spaces
  #define INTERRAW	1
//  #define HEADRAW	3
///: top of header text character
  #define HEADRAW	IBLSCALE(6)	
  RECT invsel;
  //HPEN selpen;
  //HPEN oldpen;
  

  static bool doinit=true;
  if (INVERTCOLORS) {
	CreateSolidBrush(RGB_LIGHTGREEN);
	//selpen=(HPEN)CreatePen(PS_SOLID,2,RGB_DARKGREEN);
  } else {
	CreateSolidBrush(RGB_DARKBLUE);
	//selpen=(HPEN)CreatePen(PS_SOLID,2,RGB_BLACK);
  }

  ///:
  ///: DrawCommon INIT HACK /////////////////////////////////////////////
  ///:
  if (doinit) {

  ///: Set screen borders to avoid writing on extreme pixels
  if ( ScreenSize < (ScreenSize_t)sslandscape ) {
	///: Portrait mode has tight horizontal margins...
	left=rc.left+IBLSCALE(1);
	right=rc.right-IBLSCALE(1);
  	bottom=rc.bottom-BottomSize-IBLSCALE(2);
	maxnlname=MAXNLNAME-5; // 7 chars max, 8 sized
  	_stprintf(Buffer,TEXT("MAKSJSMM"));  
  } else {
	left=rc.left+IBLSCALE(5);
	right=rc.right-IBLSCALE(5);
  	bottom=rc.bottom-BottomSize;
	///: maxnlname=MAXNLNAME;  100213
  	///: _stprintf(Buffer,TEXT("MilMalMkp23M"));  100213
	maxnlname=MAXNLNAME-3; // 9 chars, sized 10 100213
  	_stprintf(Buffer,TEXT("ABCDEFGHMx")); 
  }

///:  WAYPOINT  DISTANCE  BEARING reqE  AltArriv

  SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest  was LK8Title
  ///: Size waypoint name to 12 characters FIX make it as MAXNLNAME !
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &WPTextSize);

  ///: Size distance
  _stprintf(Buffer,TEXT("000.0")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &DSTextSize);

  //: Bearing
  _stprintf(Buffer,TEXT("<<123")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &BETextSize);

  //: reqE
  _stprintf(Buffer,TEXT("5299")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &RETextSize);

  //: Altitude Arrival
  _stprintf(Buffer,TEXT("+9999")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &AATextSize);

  SelectObject(hdc, LK8InfoNormalFont);
  _stprintf(Buffer,TEXT("MMMM")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &HLTextSize);

  SelectObject(hdc, LK8PanelMediumFont);
  _stprintf(Buffer,TEXT("1.1"));
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &MITextSize);

  //short intercolumn=(right-left-WPTextSize.cx-DSTextSize.cx-BETextSize.cx-RETextSize.cx-AATextSize.cx)/3; // era 4 FIX
  short afterwpname=left+WPTextSize.cx+IBLSCALE(5);
  short intercolumn=(right-afterwpname- DSTextSize.cx-BETextSize.cx-RETextSize.cx-AATextSize.cx)/3; 

  Column0=MITextSize.cx+LEFTLIMITER+IBLSCALE(5);
  Column1=left;							// WP align left
  //Column2=Column1+WPTextSize.cx+intercolumn/2;	// DS align right
  Column2=afterwpname+DSTextSize.cx;						// DS align right
  Column3=Column2+intercolumn+BETextSize.cx;			// BE align right
  Column4=Column3+intercolumn+RETextSize.cx;			// RE align right
  Column5=Column4+intercolumn+AATextSize.cx;			// AA align right


  if ( ScreenSize < (ScreenSize_t)sslandscape ) {
	///: Portrait mode has plenty of vertical space...
  	//TopSize=rc.top+(HEADRAW*3)+HLTextSize.cy;
  	TopSize=rc.top+HEADRAW*2+HLTextSize.cy;
  	p1.x=0; p1.y=TopSize; p2.x=rc.right; p2.y=p1.y;
  	//TopSize+=(WPTextSize.cy);
  	TopSize+=HEADRAW;
  	CommonNumraws=(bottom - TopSize) / (WPTextSize.cy+(INTERRAW*2));
  	if (CommonNumraws>MAXCOMMON) CommonNumraws=MAXCOMMON;
  	rawspace=(WPTextSize.cy+INTERRAW);
  } else {
  	//TopSize=rc.top+HEADRAW+HLTextSize.cy;
  	TopSize=rc.top+HEADRAW*2+HLTextSize.cy;
  	p1.x=0; p1.y=TopSize; p2.x=rc.right; p2.y=p1.y;
//  	TopSize+=(WPTextSize.cy/4);
  	TopSize+=HEADRAW/2;
  	CommonNumraws=(bottom - TopSize) / (WPTextSize.cy+INTERRAW);
  	if (CommonNumraws>MAXCOMMON) CommonNumraws=MAXCOMMON;
  	rawspace=(WPTextSize.cy+INTERRAW);
  }

#define INTERBOX intercolumn/2

  ///: Wpname
  s_sortBox[0].left=0;
  if ( ScreenSize < (ScreenSize_t)sslandscape ) s_sortBox[0].right=left+WPTextSize.cx-IBLSCALE(2);
  else s_sortBox[0].right=left+WPTextSize.cx-IBLSCALE(10);
  s_sortBox[0].top=0;
  s_sortBox[0].bottom=p1.y;
  SortBoxX[0]=s_sortBox[0].right;

  ///: Distance
  if ( ScreenSize < (ScreenSize_t)sslandscape ) s_sortBox[1].left=Column1+afterwpname-INTERBOX;
  else s_sortBox[1].left=Column1+afterwpname-INTERBOX-IBLSCALE(2);
  s_sortBox[1].right=Column2+INTERBOX;
  s_sortBox[1].top=0;
  s_sortBox[1].bottom=p1.y;
  SortBoxX[1]=s_sortBox[1].right;

  ///: Bearing
  s_sortBox[2].left=Column2+INTERBOX;
  s_sortBox[2].right=Column3+INTERBOX;
  s_sortBox[2].top=0;
  s_sortBox[2].bottom=p1.y;
  SortBoxX[2]=s_sortBox[2].right;

  ///: reqE
  s_sortBox[3].left=Column3+INTERBOX;
  s_sortBox[3].right=Column4+INTERBOX;
  s_sortBox[3].top=0;
  s_sortBox[3].bottom=p1.y;
  SortBoxX[3]=s_sortBox[3].right;

  ///: AltArr
  s_sortBox[4].left=Column4+INTERBOX;
  s_sortBox[4].right=Column5+INTERBOX;
  s_sortBox[4].top=0;
  s_sortBox[4].bottom=p1.y;
  SortBoxX[4]=s_sortBox[4].right;

  SortBoxY=p1.y;

  ///: Caution: could be wrong? no..
  //CommonNumpages=(short)ceil( (float)MAXCOMMON / (float)CommonNumraws );
  CommonNumpages=roundupdivision(MAXCOMMON, CommonNumraws);
  if (CommonNumpages>MAXCOMMONNUMPAGES) CommonNumpages=MAXCOMMONNUMPAGES; 
  else if (CommonNumpages<1) CommonNumpages=1;

  ///: set the initial highlighted item to the first, in each MapSpace
  SelectedRaw[MSM_COMMON]=0; 
  ///: 
  SelectedPage[MSM_COMMON]=0;

  doinit=false;
  return;
  } // doinit
  ///:
  ///: END INIT HACK /////////////////////////////////////////
  ///:

  int *pNumber;
  int *pIndex;
  switch(MapSpaceMode) {
	case MSM_COMMON:
			pNumber=&CommonNumber;
			pIndex=CommonIndex;
			break;
	case MSM_RECENT:
	default:
			pNumber=&RecentNumber;
			pIndex=RecentIndex;
			break;
	
  }

///:TCHAR venta[100];
///:_stprintf(venta,_T("CommonNumber=%d"),CommonNumber);
///:DoStatusMessage(venta);


  ///: calculate again real number of pages
  //CommonNumpages=roundupdivision(CommonNumber, CommonNumraws); OLD
  CommonNumpages=roundupdivision(*pNumber, CommonNumraws);
  if (CommonNumpages>MAXCOMMONNUMPAGES) CommonNumpages=MAXCOMMONNUMPAGES;
  else if (CommonNumpages<1) CommonNumpages=1;
  ///: current page in use by current mapspacemode
  curpage=SelectedPage[MapSpaceMode];
  if (curpage<0||curpage>=MAXCOMMONNUMPAGES) {
	DoStatusMessage(_T("ERR-092 current page invalid!")); // TODO FIX this to happen
	///: immediate action to resolve this problem, take it back to normality
	SelectedPage[MapSpaceMode]=0;
	LKevent=LKEVENT_NONE;
	return;
  }
  ///: list changed, and we are now over the real new size> resetting
  if (curpage>=CommonNumpages) curpage=0; // BUGFIX 090915 curpage > should be >=

  ///: synthetic event handler . Remember to always clear events!
  switch (LKevent) {
	case LKEVENT_NONE:
		break;
	case LKEVENT_ENTER:
		// i=CommonIndex[SelectedRaw[MapSpaceMode] + (curpage*CommonNumraws)]; OLD
		i=pIndex[SelectedRaw[MapSpaceMode] + (curpage*CommonNumraws)];

		if ( !ValidWayPoint(i)) {
			///: dont say error if empty list and an enter was pressed
			if (*pNumber) 
				DoStatusMessage(_T("ERR-018 Invalid selection"));
			break;
		}
		SelectedWaypoint=i;
		PopupWaypointDetails();
		SetModeType(LKMODE_MAP, MP_MOVING);
//		LKevent=LKEVENT_NONE;
		return;
		break;
	case LKEVENT_DOWN:
		if (++SelectedRaw[MapSpaceMode] >=CommonNumraws) SelectedRaw[MapSpaceMode]=0;
		///: Event to be cleared at the end
		break;
	case LKEVENT_UP:
		if (--SelectedRaw[MapSpaceMode] <0) SelectedRaw[MapSpaceMode]=CommonNumraws-1;
		///: Event to be cleared at the end
		break;
	case LKEVENT_PAGEUP:
		LKevent=LKEVENT_NONE;
		break;
	case LKEVENT_PAGEDOWN:
		LKevent=LKEVENT_NONE;
		break;
	case LKEVENT_NEWRUN:
		///: cleared at the end
		for (i=0; i<MAXCOMMON; i++) {
			for (k=0; k<MAXCOMMONNUMPAGES; k++) {
				_stprintf(Buffer1[i][k],_T("------------")); // 12 chars
				_stprintf(Buffer2[i][k],_T("----"));
				_stprintf(Buffer3[i][k],_T("----"));
				_stprintf(Buffer4[i][k],_T("----"));
				_stprintf(Buffer5[i][k],_T("----"));
			}
		}
		break;
	case LKEVENT_NEWPAGE:
		///: cleared at the end
		break;
	default:
		LKevent=LKEVENT_NONE;
		break;
  }

  ///: Draw Headline

  if (INVERTCOLORS)
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
  else
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_DARKGREEN, rc);

  SelectObject(hdc, LK8InfoNormalFont); // Heading line


  ///: short cursortbox=SortedMode[MapSpaceMode];
  //short cursortbox=1;

  if ( ScreenSize < (ScreenSize_t)sslandscape ) { // portrait mode
	///: Commons do NOT use sort modes, so we don't even paint a selection
	///: FillRect(hdc,&SortBox[cursortbox], sortbrush); 

	///: lk status index
	_stprintf(Buffer,TEXT("%d:%d"),ModeIndex,CURTYPE+1);
	SelectObject(hdc, LK8PanelMediumFont);
	LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);
	SelectObject(hdc, LK8InfoNormalFont);

	if (MapSpaceMode == MSM_COMMON )
  		_stprintf(Buffer,TEXT("COMN %d/%d"),  curpage+1, CommonNumpages); 
	else
  		_stprintf(Buffer,TEXT("HIST %d/%d"), curpage+1, CommonNumpages); 
	LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);


	 _stprintf(Buffer,TEXT("Dist")); 
	///: always sorted manually here!
	LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("Dir")); 
	LKWriteText(hdc, Buffer, Column3, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("rEff")); 
	LKWriteText(hdc, Buffer, Column4, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("AltA")); 
	LKWriteText(hdc, Buffer, Column5, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);


  } else {

	///: lk status index
	_stprintf(Buffer,TEXT("%d.%d"),ModeIndex,CURTYPE+1);
	SelectObject(hdc, LK8PanelMediumFont);
	LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);
	SelectObject(hdc, LK8InfoNormalFont);

	if ( (ScreenSize == (ScreenSize_t)ss640x480) || (ScreenSize == (ScreenSize_t)ss320x240) || ScreenSize == ss896x672 ) {
		if (MapSpaceMode == MSM_COMMON )
			_stprintf(Buffer,TEXT("COMN %d/%d"), curpage+1,CommonNumpages); 
		else
			_stprintf(Buffer,TEXT("HIST %d/%d"),  curpage+1,CommonNumpages); 
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

		_stprintf(Buffer,TEXT("Dist")); 
		///: always sorted manually here!
		//TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Dir")); 
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("rEff")); 
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Arriv")); 
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);
	} else {
		if (MapSpaceMode==MSM_COMMON)
			_stprintf(Buffer,TEXT("COMN %d/%d"), curpage+1,CommonNumpages); 
		else
			_stprintf(Buffer,TEXT("HIST %d/%d"), curpage+1,CommonNumpages); 
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

		_stprintf(Buffer,TEXT("Distance")); 
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Direction")); 
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("ReqEff")); 
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("AltArr")); 
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);
	}
	

  } // landscape mode

  ///: Draw values

  SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest

  ///: try to reduce conflicts, as task thread could change it while we are using it here.
  ///: so we copy it and clear it here once forever in this run
  bool ndr;
  switch (MapSpaceMode) {
	case MSM_COMMON:
  		ndr=CommonDataReady;
  		CommonDataReady=false;
		break;
	case MSM_RECENT:
  		ndr=RecentDataReady;
  		RecentDataReady=false;
		break;
	default:
		ndr=false;
		break;
   }

  //TCHAR vbuf[100]; // REMOVE VENTA
  //wsprintf(vbuf,_T("MAXNEAREST=%d Numraws=%d Numpages=%d calc=%d"),MAXNEAREST, Numraws, Numpages, (short)(ceil(MAXNEAREST/Numraws)));
  //DoStatusMessage(vbuf);

  ///: numraws always <= MAXNEAREST 
  for (i=0, drawn_items_onpage=0; i<CommonNumraws; i++) {
	iRaw=TopSize+(rawspace*i);
	short curraw=(curpage*CommonNumraws)+i;
	if (curraw>=MAXCOMMON) break;
	rli=pIndex[curraw];


	if (!ndr) goto KeepOldValues;
	if ( ValidWayPoint(rli) ) {

		///: Waypoint name
		wlen=wcslen(WayPointList[rli].Name);
		if (wlen>maxnlname) {
			_tcsncpy(Buffer, WayPointList[rli].Name, maxnlname); Buffer[maxnlname]='\0';
		}
		else {
			_tcsncpy(Buffer, WayPointList[rli].Name, wlen); Buffer[wlen]='\0';
		}
		ConvToUpper(Buffer); // 100213 FIX UPPERCASE DRAWNEAREST
		_tcscpy(Buffer1[i][curpage],Buffer); 

		///: Distance
		Value=WayPointCalc[rli].Distance*DISTANCEMODIFY;
         	_stprintf(Buffer2[i][curpage],TEXT("%0.1lf"),Value);

		///: relative bearing

		if (DisplayMode != dmCircling) {
			Value = WayPointCalc[rli].Bearing -  GPS_INFO.TrackBearing;

			if (Value < -180.0)
				Value += 360.0;
			else
				if (Value > 180.0)
					Value -= 360.0;

#ifndef __MINGW32__
			if (Value > 1)
				_stprintf(Buffer3[i][curpage], TEXT("%2.0f°»"), Value);
			else
				if (Value < -1)
					_stprintf(Buffer3[i][curpage], TEXT("«%2.0f°"), -Value);
				else
					_tcscpy(Buffer3[i][curpage], TEXT("«»"));
#else
			if (Value > 1)
				_stprintf(Buffer3[i][curpage], TEXT("%2.0fÂ°Â»"), Value);
			else
				if (Value < -1)
					_stprintf(Buffer3[i][curpage], TEXT("Â«%2.0fÂ°"), -Value);
				else
					_tcscpy(Buffer3[i][curpage], TEXT("Â«Â»"));
#endif
		} else
			_stprintf(Buffer3[i][curpage],_T("---"));

		///: Requested GR
		Value=WayPointCalc[rli].GR;
		if (Value<1 || Value>=INVALID_GR) 
			_stprintf(Buffer4[i][curpage],_T("---"));
		else {
			if (Value>99) sprintf(text,"%.0f",Value);
			else sprintf(text,"%.1f",Value);
			_stprintf(Buffer4[i][curpage],_T("%S"),text);
		}

		///: arrival altitude
		Value=ALTITUDEMODIFY*WayPointCalc[rli].AltArriv[AltArrivMode];
		if (Value <-9999 ||  Value >9999 )
			strcpy(text,"---");
		else
			sprintf(text,"%+.0f",Value);
		wsprintf(Buffer5[i][curpage], TEXT("%S"),text);

	} else {
		///: Invalid waypoint, fill in all empty data and maybe break loop
		_stprintf(Buffer1[i][curpage],_T("------------"));
		_stprintf(Buffer2[i][curpage],_T("---"));
		_stprintf(Buffer3[i][curpage],_T("---"));
		_stprintf(Buffer4[i][curpage],_T("---"));
		_stprintf(Buffer5[i][curpage],_T("---"));
	}


KeepOldValues:

	if ( ValidWayPoint(rli) ) {
  		SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest
		drawn_items_onpage++;
		///: Common turnpoints are mixed, so we must be sure that reachable is checked only against a landable
		if ((WayPointCalc[rli].VGR == 3 )|| ( WayPointCalc[rli].IsLandable && !WayPointList[rli].Reachable)) // 091205
			rcolor=RGB_LIGHTRED;
		else
			rcolor=RGB_WHITE;
	} else 
			rcolor=RGB_GREY;
			//TextDisplayMode.AsFlag.Color = TEXTGREY;

  	///: _stprintf(Buffer,TEXT("MMMMMMMMMMMM")); 
	LKWriteText(hdc, Buffer1[i][curpage], Column1, iRaw , 0, WTMODE_NORMAL, WTALIGN_LEFT, rcolor, false);
	
	///: set again correct font
  	SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest
  	///: _stprintf(Buffer,TEXT("000.0")); 
	LKWriteText(hdc, Buffer2[i][curpage], Column2, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("<<123")); 
	LKWriteText(hdc, Buffer3[i][curpage], Column3, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("123")); 
	LKWriteText(hdc, Buffer4[i][curpage], Column4, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("+9999")); 
	LKWriteText(hdc, Buffer5[i][curpage], Column5, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  ///: FOR
  } 

a401 518
  ///: clear flag, and don't outbox
  if (LKevent==LKEVENT_NEWRUN || LKevent==LKEVENT_NEWPAGE ) {
		LKevent=LKEVENT_NONE;
		return;
  }

  ///: BOXOUT SELECTED ITEM
  ///: check that we don't have an empty list
    if (drawn_items_onpage>0) {  // BUGFIX , was err: ValidWayPOint(rli) !!

	if (SelectedRaw[MapSpaceMode] <0 || SelectedRaw[MapSpaceMode]>(CommonNumraws-1)) {
		///: DoStatusMessage(_T("DBG-022 Invalid selected raw"));
		LKevent=LKEVENT_NONE;
		return;
	}
	///: avoid boxing and selecting nonexistent items
	///: selectedraw starts from 0, drawnitems from 1...
	///: In this case we set the first one, or last one, assuming we are rotating forward or backward
	if (SelectedRaw[MapSpaceMode] >= drawn_items_onpage) {
		if (LKevent==LKEVENT_DOWN) SelectedRaw[MapSpaceMode]=0;
		else 
		///: up from top to bottom, bottom empty, look for the last valid one (ie first going back from bottom)
		if (LKevent==LKEVENT_UP) SelectedRaw[MapSpaceMode]=drawn_items_onpage-1;
		else {
			DoStatusMessage(_T("Cant find valid raw"));
			SelectedRaw[MapSpaceMode]=0;
		}
	}
	invsel.left=left;
	invsel.right=right;
	invsel.top=TopSize+(rawspace*SelectedRaw[MapSpaceMode])+IBLSCALE(2);
	invsel.bottom=TopSize+(rawspace*(SelectedRaw[MapSpaceMode]+1))-IBLSCALE(1);
	InvertRect(hdc,&invsel);
	//oldpen=(HPEN)SelectObject(hdc,selpen);
	//Rectangle(hdc,invsel.left-1,invsel.top-1,invsel.right+1,invsel.bottom+1);
  	//SelectObject(hdc,oldpen);
  } 

  //DeleteObject(selpen);
  LKevent=LKEVENT_NONE;
  return;
}

void VDrawLine(const HDC&hdc, const RECT rc, int x1, int y1, int x2, int y2, COLORREF col) {
/*
#ifndef NOLINETO
  MoveToEx(hdc, x1, y1, NULL);
  LineTo(hdc, x2, y2);
#else
*/
  POINT p0,p1;
  p0.x = x1;
  p0.y = y1;
  p1.x = x2;
  p1.y = y2;
//  Polyline(hdc, p, 2);
//#endif
MapWindow::_DrawLine(hdc, PS_SOLID, IBLSCALE(1), p0, p1, col, rc);
}



///:
///: DrawInfo
///:
void MapWindow::DrawInfoPage(HDC hdc,  RECT rc, bool forceinit )
{
  HFONT		oldfont=0;
  //SIZE TextSize;
  TCHAR Buffer[LKSIZEBUFFERLARGE];
  TCHAR BufferTitle[LKSIZEBUFFERTITLE];
  TCHAR BufferValue[LKSIZEBUFFERVALUE];
  TCHAR BufferUnit[LKSIZEBUFFERUNIT];
  //char text[LKSIZETEXT];
  int index=-1;
  //double Value;

  ///: lenght of waypoint name
  static short tlen=0;
  static bool doinit=true;
  static short	column[PANELCOLUMNS+1], hcolumn[(PANELCOLUMNS*2)+1], qcolumn[(PANELCOLUMNS*4)+1];
  static short	row[PANELROWS+1], hrow[(PANELCOLUMNS*2)+1], qrow[(PANELROWS*4)+1];

  bool showunit=false;

  if (forceinit) doinit=true;

	oldfont = (HFONT)SelectObject(hdc, LKINFOFONT); // save font

  if (doinit) {
	doinit=false;
	///: function can only be called in fullscreen  and thus can be inited here
	if ( ScreenSize < (ScreenSize_t)sslandscape ) {
		switch (ScreenSize) {			// portrait fullscreen
			case (ScreenSize_t)ss240x320:
				tlen=6;
				break;
			default:
				tlen=7;
				break;
		}
	} else  {
		switch (ScreenSize) {			// landscape fullscreen
			case (ScreenSize_t)ss800x480:
			case (ScreenSize_t)ss400x240:
			case (ScreenSize_t)ss480x272:
				tlen=9;
				break;
			case (ScreenSize_t)ss320x240:
			case (ScreenSize_t)ss640x480:
			case (ScreenSize_t)ss896x672:
				tlen=9;
				break;
			default:
				tlen=8;
				break;
		}
	}


	column[0]=LEFTLIMITER;
	column[1]=((rc.right-RIGHTLIMITER-LEFTLIMITER)/PANELCOLUMNS)+LEFTLIMITER;
	column[2]=column[1]*2-LEFTLIMITER;
	column[3]=column[1]*3-LEFTLIMITER*2;
	column[PANELCOLUMNS]=rc.right-RIGHTLIMITER;
	row[0]=rc.top+TOPLIMITER;
	row[1]=((rc.bottom-BottomSize-row[0]-BOTTOMLIMITER)/PANELROWS)+row[0];
	row[2]=((rc.bottom-BottomSize-row[0]-BOTTOMLIMITER)/PANELROWS)*2+row[0];
	row[3]=((rc.bottom-BottomSize-row[0]-BOTTOMLIMITER)/PANELROWS)*3+row[0];
	row[PANELROWS]=rc.bottom-BottomSize-BOTTOMLIMITER;

	hcolumn[0]=column[0];
	hcolumn[1]=(column[1]-column[0])/2;
	hcolumn[2]=column[1];
	hcolumn[3]=(column[2]-column[1])/2+column[1];
	hcolumn[4]=column[2];
	hcolumn[5]=(column[3]-column[2])/2+column[2];
	hcolumn[6]=column[3];
	hcolumn[7]=(column[4]-column[3])/2+column[3];
	hcolumn[8]=column[4];

	hrow[0]=row[0];
	hrow[1]=(row[1]-row[0])/2;
	hrow[2]=row[1];
	hrow[3]=(row[2]-row[1])/2+row[1];
	hrow[4]=row[2];
	hrow[5]=(row[3]-row[2])/2+row[2];
	hrow[6]=row[3];
	hrow[7]=(row[4]-row[3])/2+row[3];
	hrow[8]=row[4];

	qcolumn[0]=hcolumn[0];
	qcolumn[1]=(hcolumn[1]-hcolumn[0])/2+hcolumn[0];
	qcolumn[2]=hcolumn[1];
	qcolumn[3]=(hcolumn[2]-hcolumn[1])/2+hcolumn[1];
	qcolumn[4]=hcolumn[2];
	qcolumn[5]=(hcolumn[3]-hcolumn[2])/2+hcolumn[2];
	qcolumn[6]=hcolumn[3];
	qcolumn[7]=(hcolumn[4]-hcolumn[3])/2+hcolumn[3];
	qcolumn[8]=hcolumn[4];
	qcolumn[9]=(hcolumn[5]-hcolumn[4])/2+hcolumn[4];
	qcolumn[10]=hcolumn[5];
	qcolumn[11]=(hcolumn[6]-hcolumn[5])/2+hcolumn[5];
	qcolumn[12]=hcolumn[6];
	qcolumn[13]=(hcolumn[7]-hcolumn[6])/2+hcolumn[6];
	qcolumn[14]=hcolumn[7];
	qcolumn[15]=(hcolumn[8]-hcolumn[7])/2+hcolumn[7];
	qcolumn[16]=hcolumn[8];

	qrow[0]=hrow[0];
	qrow[1]=(hrow[1]-hrow[0])/2+hrow[0];
	qrow[2]=hrow[1];
	qrow[3]=(hrow[2]-hrow[1])/2+hrow[1];
	qrow[4]=hrow[2];
	qrow[5]=(hrow[3]-hrow[2])/2+hrow[2];
	qrow[6]=hrow[3];
	qrow[7]=(hrow[4]-hrow[3])/2+hrow[3];
	qrow[8]=hrow[4];
	qrow[9]=(hrow[5]-hrow[4])/2+hrow[4];
	qrow[10]=hrow[5];
	qrow[11]=(hrow[6]-hrow[5])/2+hrow[5];
	qrow[12]=hrow[6];
	qrow[13]=(hrow[7]-hrow[6])/2+hrow[6];
	qrow[14]=hrow[7];
	qrow[15]=(hrow[8]-hrow[7])/2+hrow[7];
	qrow[16]=hrow[8];

	qrow[5]+=IBLSCALE(6);
	qrow[6]+=IBLSCALE(6);
	qrow[7]+=IBLSCALE(6);
	qrow[8]+=IBLSCALE(6)*2;
	qrow[9]+=IBLSCALE(6)*2;
	qrow[10]+=IBLSCALE(6)*2;
	qrow[11]+=IBLSCALE(6)*3;
	qrow[12]+=IBLSCALE(6)*3;
	qrow[13]+=IBLSCALE(6)*3;

  } // doinit

#include "./LKMW3include2.cpp"

	SelectObject(hdc, LK8PanelBigFont);
#include "./LKMW3include1.cpp"

	///:
	///: handle events here
	///:
	switch (LKevent) {
		case LKEVENT_NONE:
			break;
		case LKEVENT_ENTER:
			break;
		case LKEVENT_NEWRUN:
			break;
		case LKEVENT_PAGEUP:
			break;
		case LKEVENT_PAGEDOWN:
			break;
		default:
			break;
	}
	LKevent=LKEVENT_NONE; 

	COLORREF icolor; // 091229

	///:
	///: R0 C0	= status
	///:
	SelectObject(hdc, LK8PanelMediumFont);
	switch(CURTYPE) {
		case IM_THERMAL:
			wsprintf(Buffer,_T("%d.%d Thermal"),ModeIndex, CURTYPE+1);
			break;
		case IM_CRUISE:
			wsprintf(Buffer,_T("%d.%d Cruise"),ModeIndex, CURTYPE+1); 
			break;
		case IM_TASK:
			wsprintf(Buffer,_T("%d.%d Task"),ModeIndex, CURTYPE+1);
			break;
		case IM_AUX:
			wsprintf(Buffer,_T("%d.%d Custom"),ModeIndex, CURTYPE+1);
			break;
		case IM_TRI:
			wsprintf(Buffer,_T("%d.%d Turn"), ModeIndex, CURTYPE+1);
			break;
		default:
			wsprintf(Buffer,_T("error"));
			break;
	}
        LKWriteText(hdc, Buffer, qcolumn[0],qrow[0], 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

	///:
	///: R0 C1
	///:
	icolor=RGB_WHITE;
	switch(CURTYPE) {
		case IM_THERMAL:
		case IM_CRUISE:
		case IM_TASK:
		case IM_AUX:
			if ( ValidTaskPoint(ActiveWayPoint) != false ) {
				index = Task[ActiveWayPoint].Index;
				///: if ( index >0 ) {  BUGFIX 091016
				if ( index >=0 ) {
					_tcscpy(Buffer, WayPointList[index].Name);
				} else {
					wsprintf(Buffer,_T("[no dest]"));
					icolor=RGB_AMBER;
				}
			} else {
				wsprintf(Buffer,_T("[no dest]"));
				icolor=RGB_AMBER;
			}
			break;
		case IM_TRI:
			wsprintf(Buffer,_T("Experimental"));
			break;
		default:
			wsprintf(Buffer,_T("error"));
			icolor=RGB_AMBER;
			break;
	}
        LKWriteText(hdc, Buffer, qcolumn[8],qrow[1], 0, WTMODE_NORMAL, WTALIGN_CENTER, icolor, false);

	///:
	///: R0 C2	= time of day
	///:
	LKFormatValue(LK_TIME_LOCALSEC, false, BufferValue, BufferUnit, BufferTitle); // 091219
        LKWriteText(hdc, BufferValue, qcolumn[16],qrow[0], 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	if (CURTYPE == IM_TRI) goto label_InfoTest;

	VDrawLine(hdc,rc, qcolumn[0],qrow[2],qcolumn[16],qrow[2],RGB_DARKGREEN);
	VDrawLine(hdc,rc, qcolumn[0],qrow[8],qcolumn[16],qrow[8],RGB_DARKGREEN);

	///:
	///: R1 C1
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_NEXT_DIST, true, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4], &qrow[3],&qrow[4],&qrow[2]);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_NEXT_DIST, true, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4], &qrow[3],&qrow[4],&qrow[2]);
			break;
		case IM_AUX:
			index=GetInfoboxType(1);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4], &qrow[3],&qrow[4],&qrow[2]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4], &qrow[3],&qrow[4],&qrow[2]);
			break;
	}

	///:
	///: R1 C2
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_BRG, true, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[8],&qcolumn[8], &qrow[3],&qrow[4],&qrow[2]);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_BRGDIFF, true, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9],&qcolumn[8], &qrow[3],&qrow[4],&qrow[2]);
			break;
		case IM_AUX:
			index=GetInfoboxType(2);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[8],&qcolumn[8], &qrow[3],&qrow[4],&qrow[2]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9],&qcolumn[8], &qrow[3],&qrow[4],&qrow[2]);
			break;
	}


	///:
	///: R1 C3
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[12], &qcolumn[12], &qrow[3],&qrow[4],&qrow[2]);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[12], &qcolumn[12], &qrow[3],&qrow[4],&qrow[2]);
			break;
		case IM_AUX:
			index=GetInfoboxType(3);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[12], &qcolumn[12], &qrow[3],&qrow[4],&qrow[2]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[12], &qcolumn[12], &qrow[3],&qrow[4],&qrow[2]);
			break;
	}

	///:
	///: R1 C4
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16],&qcolumn[16], 
											&qrow[3],&qrow[4],&qrow[2]);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16],&qcolumn[16], 
											&qrow[3],&qrow[4],&qrow[2]);
			break;
		case IM_AUX:
			index=GetInfoboxType(4);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16],&qcolumn[16], 
											&qrow[3],&qrow[4],&qrow[2]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16],&qcolumn[16], 
											&qrow[3],&qrow[4],&qrow[2]);
			break;
	}

	///:
	///: R2  C1
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_HNAV, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_AUX:
			index=GetInfoboxType(5);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			break;
	}
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4],&qcolumn[4], &qrow[6],&qrow[7],&qrow[5]);

	///:
	///: R2  C2
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_GNDSPEED, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[8], &qcolumn[8], &qrow[6],&qrow[7],&qrow[5]);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_BRG, true , BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[8], &qrow[6],&qrow[7],&qrow[5]);
			break;
		case IM_AUX:
			index=GetInfoboxType(6);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[8], &qcolumn[8], &qrow[6],&qrow[7],&qrow[5]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[8], &qrow[6],&qrow[7],&qrow[5]);
			break;
	}

	///:
	///: R2  C3
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_VARIO, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_LD_CRUISE, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_AUX:
			index=GetInfoboxType(7);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			break;
	}
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[12], &qcolumn[12],&qrow[6],&qrow[7],&qrow[5]);

	///:
	///: R2  C4
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_FL, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_LD_INST, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_AUX:
			index=GetInfoboxType(8);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			break;
	}
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[6],&qrow[7],&qrow[5]);

	///:
	///: R3  C1
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_TC_GAIN, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_CRUISE:
			showunit=LKFormatValue(LK_HNAV, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_TASK:
			showunit=LKFormatValue(LK_FIN_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_AUX:
			index=GetInfoboxType(9);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			break;
	}
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[9],&qrow[10],&qrow[8]);
d403 3
a405 27
	///:
	///: R3  C2
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_TC_30S, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[8], &qcolumn[8],&qrow[9],&qrow[10],&qrow[8]);
			break;
		case IM_CRUISE:
			showunit=LKFormatValue(LK_TRACK, true, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[8],&qrow[9],&qrow[10],&qrow[8]);
			break;
		case IM_TASK:
			showunit=LKFormatValue(LK_FIN_DIST, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[8], &qcolumn[8],&qrow[9],&qrow[10],&qrow[8]);
			break;
		case IM_AUX:
			index=GetInfoboxType(10);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[8], &qcolumn[8],&qrow[9],&qrow[10],&qrow[8]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[8],&qrow[9],&qrow[10],&qrow[8]);
			break;
	}
a406 23
	///:
	///: R3  C3
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_TC_AVG, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_CRUISE:
			showunit=LKFormatValue(LK_GNDSPEED, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_TASK:
			showunit=LKFormatValue(LK_TASK_DISTCOV, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_AUX:
			index=GetInfoboxType(11);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			break;
	}
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[12], &qcolumn[12],&qrow[9],&qrow[10],&qrow[8]);
d408 16
d425 1
a425 26
	///:
	///: R3  C4
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_TC_ALL, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			break;
		case IM_CRUISE:
			showunit=LKFormatValue(LK_FL, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_TASK:
			showunit=LKFormatValue(LK_FIN_GR, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_AUX:
			index=GetInfoboxType(12);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			break;
	}
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[9],&qrow[10],&qrow[8]);
d427 12
d440 6
a445 27
	///:
	///: R4  C1
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_WIND, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[5], &qcolumn[4],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_CRUISE:
			showunit=LKFormatValue(LK_WIND, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[5], &qcolumn[4],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_TASK:
			showunit=LKFormatValue(LK_FIN_ALTDIFF0, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_AUX:
			index=GetInfoboxType(13);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[12],&qrow[13],&qrow[11]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[12],&qrow[13],&qrow[11]);
			break;
	}
d447 2
a448 27
	///:
	///: R4  C2
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_EMPTY, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[9],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_CRUISE:
			showunit=LKFormatValue(LK_TL_AVG, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[9],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_TASK:
			showunit=LKFormatValue(LK_LKFIN_ETE, false, BufferValue, BufferUnit, BufferTitle); 
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[9],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_AUX:
			index=GetInfoboxType(14);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[8], &qcolumn[8],&qrow[12],&qrow[13],&qrow[11]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[9],&qrow[12],&qrow[13],&qrow[11]);
			break;
	}
a449 27
	///:
	///: R4  C3
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_EMPTY, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[13], &qcolumn[13],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_CRUISE:
			showunit=LKFormatValue(LK_TC_ALL, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[13], &qcolumn[13],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_TASK:
			showunit=LKFormatValue(LK_SPEEDTASK_ACH, true, BufferValue, BufferUnit, BufferTitle); 
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[13], &qcolumn[13],&qrow[12],&qrow[13],&qrow[11]);
			break;
		case IM_AUX:
			index=GetInfoboxType(15);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[12], &qcolumn[12],&qrow[12],&qrow[13],&qrow[11]);
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[13], &qcolumn[13],&qrow[12],&qrow[13],&qrow[11]);
			break;
	}
d451 2
a452 24
	///:
	///: R4  C4
	///:
	showunit=false;
	switch(CURTYPE) {
		case IM_THERMAL:
			showunit=LKFormatValue(LK_EMPTY, false, BufferValue, BufferUnit, BufferTitle);
			break;
		case IM_CRUISE:
		case IM_TASK:
			showunit=LKFormatValue(LK_MC, true, BufferValue, BufferUnit, BufferTitle); 
			break;
		case IM_AUX:
			index=GetInfoboxType(16);
			showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			break;
		default:
			LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
			_stprintf(BufferUnit,_T(""));
			break;
	}
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[12],&qrow[13],&qrow[11]);
	goto label_End;
d454 1
a454 1
label_InfoTest:
d456 6
a461 2
	VDrawLine(hdc,rc, qcolumn[0],qrow[2],qcolumn[16],qrow[2],RGB_DARKGREEN);
	DrawTRI(hdc, rc);
d463 12
a474 46
     if (InfoBoxLayout::landscape) {
	showunit=true; // 091219
	///: right
	LKFormatValue(LK_TRACK, true, BufferValue, BufferUnit, BufferTitle);
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[14], &qcolumn[14],&qrow[3],&qrow[4],&qrow[2]);
	LKFormatValue(LK_GNDSPEED, true, BufferValue, BufferUnit, BufferTitle);
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[14], &qcolumn[14],&qrow[6],&qrow[7],&qrow[5]);
	LKFormatValue(LK_HNAV, true, BufferValue, BufferUnit, BufferTitle);
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[15], &qcolumn[15],&qrow[9],&qrow[10],&qrow[8]);
	LKFormatValue(LK_VARIO, true, BufferValue, BufferUnit, BufferTitle);
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[14], &qcolumn[14],&qrow[12],&qrow[13],&qrow[11]);

	///: left
	LKFormatValue(LK_TAS, true, BufferValue, BufferUnit, BufferTitle);
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[3], &qcolumn[3],&qrow[6],&qrow[7],&qrow[5]);

	_stprintf(BufferValue,_T("%.0fÂ°"),CALCULATED_INFO.BankAngle);
	_stprintf(BufferTitle,_T("Bank"));
	_stprintf(BufferUnit,_T(""));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[3],&qrow[4],&qrow[2]);
     } else {
	showunit=true;
	///: right
	LKFormatValue(LK_TRACK, true, BufferValue, BufferUnit, BufferTitle);
	_stprintf(BufferUnit,_T(""));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[14], &qcolumn[14],&qrow[3],&qrow[4],&qrow[2]);
	LKFormatValue(LK_GNDSPEED, true, BufferValue, BufferUnit, BufferTitle);
	_stprintf(BufferUnit,_T(""));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[6],&qrow[7],&qrow[5]);
	LKFormatValue(LK_HNAV, true, BufferValue, BufferUnit, BufferTitle);
	_stprintf(BufferUnit,_T(""));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[9],&qrow[10],&qrow[8]);
	LKFormatValue(LK_VARIO, true, BufferValue, BufferUnit, BufferTitle);
	_stprintf(BufferUnit,_T(""));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[12],&qrow[13],&qrow[11]);

	///: left
	LKFormatValue(LK_TAS, true, BufferValue, BufferUnit, BufferTitle);
	_stprintf(BufferUnit,_T(""));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[2], &qcolumn[2],&qrow[6],&qrow[7],&qrow[5]);

	_stprintf(BufferValue,_T("%.0fÂ°"),CALCULATED_INFO.BankAngle);
	_stprintf(BufferTitle,_T("Bank"));
	_stprintf(BufferUnit,_T(""));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[3],&qrow[4],&qrow[2]);
     }
d476 4
a479 4
#if 0
	_stprintf(BufferValue,_T("%0.1f"),CALCULATED_INFO.TurnRate);
	_stprintf(BufferTitle,_T("Rate"));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[3], &qcolumn[3],&qrow[9],&qrow[10],&qrow[8]);
d481 1
a481 2
	LKFormatValue(LK_GLOAD, true, BufferValue, BufferUnit, BufferTitle);
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[12],&qrow[13],&qrow[11]);
d484 9
a492 3
        wsprintf(BufferTitle, TEXT("NOT FOR IFR USAGE"));
	SelectObject(hdc, LK8PanelSmallFont);
	LKWriteText(hdc, BufferTitle, qcolumn[8],qrow[12], 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_ORANGE, false);
d494 4
a497 3
label_End:
  // restore font and return
  SelectObject(hdc, oldfont); 
d500 2
d530 1
a530 1
  Start.y = ((rc.bottom-BottomSize-top)/2)+top-IBLSCALE(10);
d543 2
a544 2
  static int radius = IBLSCALE(65);
  static int planesize = radius-IBLSCALE(10);
d546 3
a548 3
  static int planeradius = IBLSCALE(6);
  static int tailsize = planesize/4+IBLSCALE(2);
  static int innerradius = radius - IBLSCALE(8);
d643 1
a643 1
	hpBlack = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB_GREY);
d646 1
a646 1
	hpBlack = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB_BLACK);
d650 1
a650 1
  hpWhite = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB_WHITE);
d652 1
a652 1
  hpBorder = (HPEN)CreatePen(PS_SOLID, IBLSCALE(2), RGB_GREY);
d660 1
a660 1
  Circle(hDC, Start.x, Start.y, radius+IBLSCALE(2), rc, false, false );
d666 18
a683 18
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d00[0][0], d00[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d00[0][1], d00[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d15[0][0], d15[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d15[0][1], d15[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d15[0][2], d15[1][2], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d15[0][3], d15[1][3], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d30[0][0], d30[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d30[0][1], d30[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d30[0][2], d30[1][2], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d30[0][3], d30[1][3], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d45[0][0], d45[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d45[0][1], d45[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d45[0][2], d45[1][2], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d45[0][3], d45[1][3], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d60[0][0], d60[1][0], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d60[0][1], d60[1][1], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d60[0][2], d60[1][2], RGB_BLUE,rc);
  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), d60[0][3], d60[1][3], RGB_BLUE,rc);
d692 1
a692 1
	_DrawLine(hDC, PS_SOLID, IBLSCALE(4), a1, a2, RGB_GREY,rc);
d694 1
a694 1
	_DrawLine(hDC, PS_SOLID, IBLSCALE(4), a1, a2, RGB_BLACK,rc); 
d701 1
a701 1
	_DrawLine(hDC, PS_SOLID, IBLSCALE(4), a1, a2, RGB_GREY,rc);
d703 1
a703 1
	_DrawLine(hDC, PS_SOLID, IBLSCALE(4), a1, a2, RGB_BLACK,rc);
d758 2
a759 2
  short left=rc.left+IBLSCALE(5);
  short contenttop=rc.top+IBLSCALE(50);
d835 4
d946 1
a946 1
///: DRAW NEARESTTURNPOINT QUI
d948 2
d951 2
a952 1
void MapWindow::DrawNearestTurnpoint(HDC hdc, RECT rc) {
a953 3
///: Maximum number of characters for waypoint name. Should be dynamically calculated?
///: CAUTION a line should be adjusted by hand! Not a reference value!!
#define MAXNLNAME 12 
d955 2
a956 31
  SIZE WPTextSize, DSTextSize, BETextSize, RETextSize, AATextSize, HLTextSize, MITextSize;
  TCHAR Buffer[LKSIZEBUFFERLARGE];
  static RECT s_sortBox[6]; 
  ///: we size each buffer twice the maximum expected lenght
  static TCHAR Buffer1[MAXNEARTURNPOINT][MAXTURNPOINTNUMPAGES][24], Buffer2[MAXNEARTURNPOINT][MAXTURNPOINTNUMPAGES][10];
  static TCHAR Buffer3[MAXNEARTURNPOINT][MAXTURNPOINTNUMPAGES][10];
  static TCHAR Buffer4[MAXNEARTURNPOINT][MAXTURNPOINTNUMPAGES][12], Buffer5[MAXNEARTURNPOINT][MAXTURNPOINTNUMPAGES][12];
  static short s_maxnlname;
  char text[30];
  short i, k, iRaw, wlen, rli=0, curpage, drawn_items_onpage;
  double value;
  COLORREF rcolor;

  ///: column0 starts after writing 1:2 (ModeIndex:CURTYPE+1) with a different font..
  static short Column0;
  static short Column1, Column2, Column3, Column4, Column5;
  static POINT p1, p2;
  static short s_rawspace;
  ///: Printable area for live nearest values
  static short left,right,bottom;
  ///: one for each mapspace, no matter if 0 and 1 are unused

  ///: Vertical and horizontal spaces
  #define INTERRAW	1
///: top of header text character
  #define HEADRAW	IBLSCALE(6)	
  HBRUSH sortbrush;
  //HPEN hpen;
  //HPEN oldpen;
  //HPEN selpen;
  RECT invsel;
d958 5
a962 1
  static bool doinit=true;
a963 9
  if (INVERTCOLORS) {
  	sortbrush=CreateSolidBrush(RGB_LIGHTGREEN);
	//hpen=(HPEN)CreatePen(PS_SOLID,2,RGB_DARKGREEN);
	//selpen=(HPEN)CreatePen(PS_SOLID,2,RGB_DARKGREEN);
  } else {
  	sortbrush=CreateSolidBrush(RGB_DARKGREEN);
	//hpen=(HPEN)CreatePen(PS_SOLID,2,RGB_BLACK);
	//selpen=(HPEN)CreatePen(PS_SOLID,2,RGB_BLACK);
  }
d965 2
a966 3
  ///:
  ///: DrawNearestTurnpoint INIT HACK /////////////////////////////////////////////
  ///:
d969 116
a1084 8
  ///: Set screen borders to avoid writing on extreme pixels
  if ( ScreenSize < (ScreenSize_t)sslandscape ) {
	///: Portrait mode has tight horizontal margins...
	left=rc.left+IBLSCALE(1);
	right=rc.right-IBLSCALE(1);
  	bottom=rc.bottom-BottomSize-IBLSCALE(2);
	s_maxnlname=MAXNLNAME-5; // 7 chars max, 8 sized
  	_stprintf(Buffer,TEXT("MAKSJSMM"));  
d1086 2
a1087 7
	left=rc.left+IBLSCALE(5);
	right=rc.right-IBLSCALE(5);
  	bottom=rc.bottom-BottomSize;
	///: s_maxnlname=MAXNLNAME;
  	///: _stprintf(Buffer,TEXT("MilMalMkp23M"));   100213
	s_maxnlname=MAXNLNAME-3; // 9 chars, sized 10
  	_stprintf(Buffer,TEXT("ABCDEFGHMx")); 
d1090 4
a1093 50
///:  WAYPOINT  DISTANCE  BEARING reqE  AltArriv

  SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest  was LK8Title
  ///: Size waypoint name to 12 characters FIX make it as MAXNLNAME !
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &WPTextSize);

  ///: Size distance
  _stprintf(Buffer,TEXT("000.0")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &DSTextSize);

  //: Bearing
  _stprintf(Buffer,TEXT("<<123")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &BETextSize);

  //: reqE
  _stprintf(Buffer,TEXT("5299")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &RETextSize);

  //: Altitude Arrival
  _stprintf(Buffer,TEXT("+9999")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &AATextSize);

  SelectObject(hdc, LK8InfoNormalFont); // Heading line  was MapWindow QUI
  _stprintf(Buffer,TEXT("MMMM")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &HLTextSize);

  SelectObject(hdc, LK8PanelMediumFont);  
  _stprintf(Buffer,TEXT("1.1")); 
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &MITextSize);

  short afterwpname=left+WPTextSize.cx+IBLSCALE(5);
  short intercolumn=(right-afterwpname- DSTextSize.cx-BETextSize.cx-RETextSize.cx-AATextSize.cx)/3; 

  ///: Col0 is where APTS 1/3 can be written, after ModeIndex:Curtype
  Column0=MITextSize.cx+LEFTLIMITER+IBLSCALE(5);
  Column1=left;							// WP align left
  Column2=afterwpname+DSTextSize.cx;						// DS align right
  Column3=Column2+intercolumn+BETextSize.cx;			// BE align right
  Column4=Column3+intercolumn+RETextSize.cx;			// RE align right
  Column5=Column4+intercolumn+AATextSize.cx;			// AA align right


  if ( ScreenSize < (ScreenSize_t)sslandscape ) {
	///: Portrait mode has plenty of vertical space...
  	TopSize=rc.top+HEADRAW*2+HLTextSize.cy;
  	p1.x=0; p1.y=TopSize; p2.x=rc.right; p2.y=p1.y;
  	TopSize+=HEADRAW;
  	TurnpointNumraws=(bottom - TopSize) / (WPTextSize.cy+(INTERRAW*2));
  	if (TurnpointNumraws>MAXNEARTURNPOINT) TurnpointNumraws=MAXNEARTURNPOINT;
  	s_rawspace=(WPTextSize.cy+INTERRAW);
d1095 2
a1096 6
  	TopSize=rc.top+HEADRAW*2+HLTextSize.cy;
  	p1.x=0; p1.y=TopSize; p2.x=rc.right; p2.y=p1.y;
  	TopSize+=HEADRAW/2;
  	TurnpointNumraws=(bottom - TopSize) / (WPTextSize.cy+INTERRAW);
  	if (TurnpointNumraws>MAXNEARTURNPOINT) TurnpointNumraws=MAXNEARTURNPOINT;
  	s_rawspace=(WPTextSize.cy+INTERRAW);
d1099 2
a1100 75
#define INTERBOX intercolumn/2

  ///: Wpname
  s_sortBox[0].left=Column0; // FIX 090925 era solo 0
  if ( ScreenSize < (ScreenSize_t)sslandscape ) s_sortBox[0].right=left+WPTextSize.cx-IBLSCALE(2);
  else s_sortBox[0].right=left+WPTextSize.cx-IBLSCALE(10);
  s_sortBox[0].top=2;
  s_sortBox[0].bottom=p1.y;
  SortBoxX[0]=s_sortBox[0].right;

  ///: Distance
  if ( ScreenSize < (ScreenSize_t)sslandscape ) s_sortBox[1].left=Column1+afterwpname-INTERBOX;
  else s_sortBox[1].left=Column1+afterwpname-INTERBOX-IBLSCALE(2);
  s_sortBox[1].right=Column2+INTERBOX;
  s_sortBox[1].top=2;
  s_sortBox[1].bottom=p1.y;
  SortBoxX[1]=s_sortBox[1].right;

  ///: Bearing
  s_sortBox[2].left=Column2+INTERBOX;
  s_sortBox[2].right=Column3+INTERBOX;
  s_sortBox[2].top=2;
  s_sortBox[2].bottom=p1.y;
  SortBoxX[2]=s_sortBox[2].right;

  ///: reqE
  s_sortBox[3].left=Column3+INTERBOX;
  s_sortBox[3].right=Column4+INTERBOX;
  s_sortBox[3].top=2;
  s_sortBox[3].bottom=p1.y;
  SortBoxX[3]=s_sortBox[3].right;

  ///: AltArr
  s_sortBox[4].left=Column4+INTERBOX;
  //s_sortBox[4].right=Column5+INTERBOX;
  s_sortBox[4].right=rc.right-1;
  s_sortBox[4].top=2;
  s_sortBox[4].bottom=p1.y;
  SortBoxX[4]=s_sortBox[4].right;

  SortBoxY=p1.y;

  ///: Caution: could be wrong? no..
  TurnpointNumpages=roundupdivision(MAXNEARTURNPOINT, TurnpointNumraws);
  if (TurnpointNumpages>MAXTURNPOINTNUMPAGES) TurnpointNumpages=MAXTURNPOINTNUMPAGES;
  else if (TurnpointNumpages<1) TurnpointNumpages=1;

  ///: set the initial highlighted item to the first, in each MapSpace
  SelectedRaw[MSM_NEARTPS]=0;
  SelectedPage[MSM_NEARTPS]=0;

  doinit=false;
  return;
  } // doinit
  ///:
  ///: END INIT HACK /////////////////////////////////////////
  ///:

  ///: Recalculate real number of pages... BUG FIX QUI
  TurnpointNumpages=roundupdivision(SortedTurnpointNumber, TurnpointNumraws);
  if (TurnpointNumpages>MAXTURNPOINTNUMPAGES) TurnpointNumpages=MAXTURNPOINTNUMPAGES;
  else if (TurnpointNumpages<1) TurnpointNumpages=1;

//  TCHAR vbuf[100]; // REMOVE VENTA
//  wsprintf(vbuf,_T("Numpages=%d sortednum=%d numraws=%d"),Numpages, SortedNumber, Numraws );
//  DoStatusMessage(vbuf);

  ///: current page in use by current mapspacemode
  curpage=SelectedPage[MapSpaceMode];
  if (curpage<0||curpage>=MAXTURNPOINTNUMPAGES) { // TODO also >Numpages
	DoStatusMessage(_T("ERR-091 curpage invalid!")); // TODO FIX this happening
	///: immediate action!
	SelectedPage[MapSpaceMode]=0;
	LKevent=LKEVENT_NONE;
	return;
d1103 10
a1112 13
  ///: synthetic event handler . Remember to always clear events!
  switch (LKevent) {
	case LKEVENT_NONE:
		break;
	case LKEVENT_ENTER:
		LKevent=LKEVENT_NONE;
		i=SortedTurnpointIndex[SelectedRaw[MapSpaceMode]+(curpage*TurnpointNumraws)];

		if ( !ValidWayPoint(i)) {
			///: dont say error if empty list and an enter was pressed
			if (SortedTurnpointNumber>0)
				DoStatusMessage(_T("ERR-055 Invalid selection")); 
			break;
d1114 18
a1131 39
		SelectedWaypoint=i;
		PopupWaypointDetails();
		SetModeType(LKMODE_MAP,MP_MOVING);
		///: originally without event, forced now by SetModeType
		LKevent=LKEVENT_NONE; 
		return;
		break;
	case LKEVENT_DOWN:
		if (++SelectedRaw[MapSpaceMode] >=TurnpointNumraws) SelectedRaw[MapSpaceMode]=0;
		///: Event to be cleared at the end
		break;
	case LKEVENT_UP:
		if (--SelectedRaw[MapSpaceMode] <0) SelectedRaw[MapSpaceMode]=TurnpointNumraws-1;
		///: Event to be cleared at the end
		break;
	case LKEVENT_PAGEUP:
		LKevent=LKEVENT_NONE;
		break;
	case LKEVENT_PAGEDOWN:
		LKevent=LKEVENT_NONE;
		break;
	case LKEVENT_NEWRUN:
		///: cleared at the end
		for (i=0; i<MAXNEARTURNPOINT; i++) {
			for (k=0; k<MAXTURNPOINTNUMPAGES; k++) {
				_stprintf(Buffer1[i][k],_T("------------")); // 12 chars
				_stprintf(Buffer2[i][k],_T("----"));
				_stprintf(Buffer3[i][k],_T("----"));
				_stprintf(Buffer4[i][k],_T("----"));
				_stprintf(Buffer5[i][k],_T("----"));
			}
		}
		break;
	case LKEVENT_NEWPAGE:
		///: cleared at the end
		break;
	default:
		LKevent=LKEVENT_NONE;
		break;
a1133 1
  ///: Draw Headline
d1135 18
a1152 4
  if (INVERTCOLORS)
	  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
  else
	  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_DARKGREEN, rc);
a1153 1
  SelectObject(hdc, LK8InfoNormalFont); // Heading line
a1154 1
  short cursortbox=SortedMode[MapSpaceMode];
d1156 19
a1174 84
  if ( ScreenSize < (ScreenSize_t)sslandscape ) { // portrait mode
	FillRect(hdc,&s_sortBox[cursortbox], sortbrush); 
	//SelectObject(hdc,hpen);
	//Rectangle(hdc,s_sortBox[cursortbox].left, s_sortBox[cursortbox].top, s_sortBox[cursortbox].right, s_sortBox[cursortbox].bottom); 

	///: lk status index
	_stprintf(Buffer,TEXT("%d.%d"),ModeIndex,CURTYPE+1);
  	SelectObject(hdc, LK8PanelMediumFont); 
	LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0,  WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);
  	SelectObject(hdc, LK8InfoNormalFont); 

 		_stprintf(Buffer,TEXT("TPS %d/%d"),  curpage+1,TurnpointNumpages); 
	if (cursortbox==0)
 		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK, false);
	else
 		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

	 _stprintf(Buffer,TEXT("Dist")); 
	if (cursortbox==1)
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("Dir")); 
	if (cursortbox==2)
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("rEff")); 
	if (cursortbox==3)
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

	_stprintf(Buffer,TEXT("AltA")); 
	if (cursortbox==4)
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
	else
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);


  } else {
	FillRect(hdc,&s_sortBox[cursortbox], sortbrush); 
	//SelectObject(hdc,hpen);
	//Rectangle(hdc,s_sortBox[cursortbox].left, s_sortBox[cursortbox].top, s_sortBox[cursortbox].right, s_sortBox[cursortbox].bottom);

	if ( (ScreenSize == (ScreenSize_t)ss640x480) || (ScreenSize == (ScreenSize_t)ss320x240)|| ScreenSize==ss896x672 ) {

		///: lk status index
		_stprintf(Buffer,TEXT("%d.%d"),ModeIndex,CURTYPE+1);
  		SelectObject(hdc, LK8PanelMediumFont); 
		LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);
  		SelectObject(hdc, LK8InfoNormalFont); 

		_stprintf(Buffer,TEXT("TPS %d/%d"), curpage+1, TurnpointNumpages); 
		if (cursortbox==0)
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

		_stprintf(Buffer,TEXT("Dist")); 
		if (cursortbox==1)
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Dir")); 
		if (cursortbox==2)
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("rEff")); 
		if (cursortbox==3)
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Arriv")); 
		if (cursortbox==4)
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);
d1176 1
a1176 35
		///: lk status index
		_stprintf(Buffer,TEXT("%d.%d"),ModeIndex,CURTYPE+1);
  		SelectObject(hdc, LK8PanelMediumFont); 
		LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);
  		SelectObject(hdc, LK8InfoNormalFont); 

		_stprintf(Buffer,TEXT("TPS %d/%d"),  curpage+1,TurnpointNumpages); 
		if (cursortbox==0)
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN, false);

		_stprintf(Buffer,TEXT("Distance")); 
		if (cursortbox==1)
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("Direction")); 
		if (cursortbox==2)
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("ReqEff")); 
		if (cursortbox==3)
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);

		_stprintf(Buffer,TEXT("AltArr")); 
		if (cursortbox==4)
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK, false);
		else
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE, false);
d1178 3
a1180 1
	
a1181 1
  } // landscape mode
d1183 5
d1189 4
d1194 1
a1194 1
  ///: Draw values
d1196 9
a1204 21
  SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest

  ///: try to reduce conflicts, as task thread could change it while we are using it here.
  ///: so we copy it and clear it here once forever in this run
  bool ndr=NearestTurnpointDataReady;
  NearestTurnpointDataReady=false;

  //TCHAR vbuf[100]; // REMOVE VENTA
  //wsprintf(vbuf,_T("MAXNEAREST=%d Numraws=%d Numpages=%d calc=%d"),MAXNEAREST, Numraws, Numpages, (short)(ceil(MAXNEAREST/Numraws)));
  //DoStatusMessage(vbuf);

  ///: numraws always <= MAXNEAREST 
  for (i=0, drawn_items_onpage=0; i<TurnpointNumraws; i++) {
	iRaw=TopSize+(s_rawspace*i);
	short curraw=(curpage*TurnpointNumraws)+i;
	if (curraw>=MAXNEARTURNPOINT) break;
	rli=SortedTurnpointIndex[curraw];


	if (!ndr) {
		goto KeepOldValues;
a1205 1
	if ( ValidWayPoint(rli) ) {
d1207 11
a1217 4
		///: Waypoint name
		wlen=wcslen(WayPointList[rli].Name);
		if (wlen>s_maxnlname) {
			_tcsncpy(Buffer, WayPointList[rli].Name, s_maxnlname); Buffer[s_maxnlname]='\0';
d1219 11
a1229 2
		else {
			_tcsncpy(Buffer, WayPointList[rli].Name, wlen); Buffer[wlen]='\0';
d1231 1
a1231 2
		ConvToUpper(Buffer); // 100213 FIX UPPERCASE DRAWNEAREST
		_tcscpy(Buffer1[i][curpage],Buffer); 
d1233 14
a1246 14
		///: Distance
		value=WayPointCalc[rli].Distance*DISTANCEMODIFY;
         	_stprintf(Buffer2[i][curpage],TEXT("%0.1lf"),value);

		///: relative bearing

		if (DisplayMode != dmCircling) {
			value = WayPointCalc[rli].Bearing -  GPS_INFO.TrackBearing;

			if (value < -180.0)
				value += 360.0;
			else
				if (value > 180.0)
					value -= 360.0;
d1248 5
a1252 17
#ifndef __MINGW32__
			if (value > 1)
				_stprintf(Buffer3[i][curpage], TEXT("%2.0f°»"), value);
			else
				if (value < -1)
					_stprintf(Buffer3[i][curpage], TEXT("«%2.0f°"), -value);
				else
					_tcscpy(Buffer3[i][curpage], TEXT("«»"));
#else
			if (value > 1)
				_stprintf(Buffer3[i][curpage], TEXT("%2.0fÂ°Â»"), value);
			else
				if (value < -1)
					_stprintf(Buffer3[i][curpage], TEXT("Â«%2.0fÂ°"), -value);
				else
					_tcscpy(Buffer3[i][curpage], TEXT("Â«Â»"));
#endif
d1254 2
a1255 11
			_stprintf(Buffer3[i][curpage],_T("---"));

		///: Requested GR
		value=WayPointCalc[rli].GR;
		if (value<1 || value>=INVALID_GR) 
			_stprintf(Buffer4[i][curpage],_T("---"));
		else {
			if (value>99) sprintf(text,"%.0f",value);
			else sprintf(text,"%.1f",value);
			_stprintf(Buffer4[i][curpage],_T("%S"),text);
		}
d1257 3
a1259 15
		///: arrival altitude
		value=ALTITUDEMODIFY*WayPointCalc[rli].AltArriv[AltArrivMode];
		if (value <-9999 ||  value >9999 )
			strcpy(text,"---");
		else
			sprintf(text,"%+.0f",value);
		wsprintf(Buffer5[i][curpage], TEXT("%S"),text);

	} else {
		///: Invalid waypoint, fill in all empty data and maybe break loop
		_stprintf(Buffer1[i][curpage],_T("------------"));
		_stprintf(Buffer2[i][curpage],_T("---"));
		_stprintf(Buffer3[i][curpage],_T("---"));
		_stprintf(Buffer4[i][curpage],_T("---"));
		_stprintf(Buffer5[i][curpage],_T("---"));
d1262 1
d1264 1
a1264 11
KeepOldValues:

	if ( ValidWayPoint(rli) ) {
		drawn_items_onpage++;
		rcolor=RGB_WHITE;
		///: Nearest Turnpoint do not have precalculated obstacles, so we cannot use Reachable
		if (WayPointCalc[rli].VGR == 3 ) // 091205
			rcolor=RGB_LIGHTRED;
  		SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest
	} else 
		rcolor=RGB_GREY;
d1266 12
a1277 16
  	///: _stprintf(Buffer,TEXT("MMMMMMMMMMMM")); 
	LKWriteText(hdc, Buffer1[i][curpage], Column1, iRaw , 0, WTMODE_NORMAL, WTALIGN_LEFT, rcolor, false);
	
	///: set again correct font
  	SelectObject(hdc, LK8InfoBigFont); // Text font for Nearest
  	///: _stprintf(Buffer,TEXT("000.0")); 
	LKWriteText(hdc, Buffer2[i][curpage], Column2, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("<<123")); 
	LKWriteText(hdc, Buffer3[i][curpage], Column3, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("123")); 
	LKWriteText(hdc, Buffer4[i][curpage], Column4, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);

  	///: _stprintf(Buffer,TEXT("+9999")); 
	LKWriteText(hdc, Buffer5[i][curpage], Column5, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor, false);
d1279 4
a1282 8
  ///: FOR
  } 


  ///: clear flag, and don't outbox
  if (LKevent==LKEVENT_NEWRUN || LKevent==LKEVENT_NEWPAGE ) {
		LKevent=LKEVENT_NONE;
		return;
d1285 9
a1293 18
  ///: BOXOUT SELECTED ITEM
  ///: check that we don't have an empty list
  if (drawn_items_onpage>0) {

	if (SelectedRaw[MapSpaceMode] <0 || SelectedRaw[MapSpaceMode]>(TurnpointNumraws-1)) {
		DoStatusMessage(_T("ERR-051 Invalid selected raw"));
		return;
	}
	///: avoid boxing and selecting nonexistent items
	///: selectedraw starts from 0, drawnitems from 1...
	if (SelectedRaw[MapSpaceMode] >= drawn_items_onpage) {
		if (LKevent==LKEVENT_DOWN) SelectedRaw[MapSpaceMode]=0;
		else 
		///: up from top to bottom, bottom empty, look for the last valid one (ie first going back from bottom)
		if (LKevent==LKEVENT_UP) SelectedRaw[MapSpaceMode]=drawn_items_onpage-1;
		else {
			DoStatusMessage(_T("ERR-050 Cant find valid raw"));
			SelectedRaw[MapSpaceMode]=0;
d1296 7
a1302 9
	invsel.left=left;
	invsel.right=right;
	invsel.top=TopSize+(s_rawspace*SelectedRaw[MapSpaceMode])+IBLSCALE(2);
	invsel.bottom=TopSize+(s_rawspace*(SelectedRaw[MapSpaceMode]+1))-IBLSCALE(1);
	InvertRect(hdc,&invsel);
	//oldpen=(HPEN)SelectObject(hdc,selpen);
	//Rectangle(hdc,invsel.left-1,invsel.top-1,invsel.right+1,invsel.bottom+1);
  	//SelectObject(hdc,oldpen);
	//DeleteObject(selpen);
a1303 6
  } 

  LKevent=LKEVENT_NONE;
  DeleteObject(sortbrush);
  //DeleteObject(hpen);
  return;
a1304 1

@


8.43
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.42 2010/01/26 23:41:05 root Exp root $ BAD
d763 2
d1077 1
a1077 1
	if (ISPARAGLIDER) {
d1917 1
a1917 1
  ///: INIT HACK /////////////////////////////////////////////
d1933 4
a1936 2
	maxnlname=MAXNLNAME;
  	_stprintf(Buffer,TEXT("MilMalMkp23M")); 
d2330 1
d2587 1
a2587 1
  ///: INIT HACK /////////////////////////////////////////////
d2603 4
a2606 2
	maxnlname=MAXNLNAME;
  	_stprintf(Buffer,TEXT("MilMalMkp23M")); 
d2962 1
d4336 1
a4336 1
  ///: INIT HACK /////////////////////////////////////////////
d4352 4
a4355 2
	s_maxnlname=MAXNLNAME;
  	_stprintf(Buffer,TEXT("MilMalMkp23M")); 
d4721 1
@


8.42
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.41 2009/12/29 16:14:49 root Exp root $ BAD
d806 1
d1195 4
a1198 1
		showunit=LKFormatValue(LK_TC_AVG, true, BufferValue, BufferUnit, BufferTitle);
d1203 3
d1229 5
d1235 6
d1256 4
d1263 3
d1267 1
a1267 1
		showunit=LKFormatValue(LK_GNDSPEED, true, BufferValue, BufferUnit, BufferTitle); // 091221
d1296 12
d1325 4
d1332 3
d1336 2
a1337 1
		LKFormatValue(LK_HAGL, true, BufferValue, BufferUnit, BufferTitle);
d1369 12
d1397 3
a1399 1
		showunit=LKFormatValue(LK_TC_GAIN, true, BufferValue, BufferUnit, BufferTitle);
d1401 1
d1405 3
d1416 1
a1416 1
		LKFormatValue(LK_TIMEFLIGHT, true, BufferValue, BufferUnit, BufferTitle);
d1428 12
d1459 4
a1462 1
		LKFormatValue(LK_TC_30S, true, BufferValue, BufferUnit, BufferTitle);
d1468 3
d1500 12
d1531 4
a1534 1
		showunit=LKFormatValue(LK_VARIO, true, BufferValue, BufferUnit, BufferTitle);
d1539 4
a1550 1
// TODO MAKE IT LKPROCESS
a1554 1
 			//TextDisplayMode.AsFlag.Color = TEXTRED;
d1556 1
a1556 1
  		wsprintf(BufferTitle, TEXT("OLCg"));
d1568 12
d1833 1
a1833 1
  _stprintf(Buffer, _T("%0.2f Mb free"),CheckFreeRam()/1000000.0);
d1849 1
a1849 1
  if (!LoggerGActive()) _tcscat(Buffer,_T(" (NO LOGGER GRECORD!)"));
d3614 1
a3614 1
			showunit=LKFormatValue(LK_FIN_GR, false, BufferValue, BufferUnit, BufferTitle);
d3640 1
a3640 1
			showunit=LKFormatValue(LK_FIN_LD, false, BufferValue, BufferUnit, BufferTitle);
d4082 1
a4082 1
#if (0)
@


8.41
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.40 2009/12/21 15:35:01 root Exp root $ BAD
d1046 1
a1046 1
		LKFormatValue(LK_HGPS, false, BufferValue, BufferUnit, BufferTitle); // 091115
d1289 1
a1289 1
		LKFormatValue(LK_HGPS, true, BufferValue, BufferUnit, BufferTitle);
d1571 1
a1571 1
	p[2].x=0; p[2].y=0; p[3].x=rc.right; p[3].y=0;
d1573 1
a1573 1
	p[6].x=rc.right; p[6].y=0; p[7].x=rc.right; p[7].y=rc.bottom-BottomSize-IBLSCALE(2);
d3168 1
d3199 1
d3212 1
d3214 1
a3214 1
			} else
d3216 2
d3224 1
d3227 1
a3227 1
        LKWriteText(hdc, Buffer, qcolumn[8],qrow[1], 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
d3256 1
a3256 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3271 1
a3271 1
			LKFormatValue(LK_BRG, true, BufferValue, BufferUnit, BufferTitle);
d3276 1
a3276 1
			LKFormatValue(LK_BRGDIFF, true, BufferValue, BufferUnit, BufferTitle);
d3281 1
a3281 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3302 1
a3302 1
			LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
d3307 1
a3307 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3322 1
a3322 1
			LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
d3328 1
a3328 1
			LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);
d3334 2
a3335 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3341 1
d3353 1
a3353 1
			showunit=LKFormatValue(LK_HGPS, false, BufferValue, BufferUnit, BufferTitle);
d3361 1
a3361 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3375 1
a3375 1
			LKFormatValue(LK_GNDSPEED, false, BufferValue, BufferUnit, BufferTitle);
d3380 1
a3380 1
			LKFormatValue(LK_BRG, true , BufferValue, BufferUnit, BufferTitle);
d3385 1
a3385 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3400 1
a3400 1
			LKFormatValue(LK_VARIO, false, BufferValue, BufferUnit, BufferTitle);
d3404 1
a3404 1
			LKFormatValue(LK_LD_CRUISE, false, BufferValue, BufferUnit, BufferTitle);
d3408 1
a3408 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3422 1
a3422 1
			LKFormatValue(LK_FL, false, BufferValue, BufferUnit, BufferTitle);
d3426 1
a3426 1
			LKFormatValue(LK_LD_INST, false, BufferValue, BufferUnit, BufferTitle);
d3430 2
a3431 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3435 1
d3449 1
a3449 1
			showunit=LKFormatValue(LK_HGPS, false, BufferValue, BufferUnit, BufferTitle);
d3456 1
a3456 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3470 1
a3470 1
			LKFormatValue(LK_TC_30S, false, BufferValue, BufferUnit, BufferTitle);
d3474 1
a3474 1
			LKFormatValue(LK_TRACK, true, BufferValue, BufferUnit, BufferTitle);
d3483 1
a3483 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3498 1
a3498 1
			LKFormatValue(LK_TC_AVG, false, BufferValue, BufferUnit, BufferTitle);
d3508 1
a3508 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3523 2
a3524 1
			LKFormatValue(LK_TC_ALL, false, BufferValue, BufferUnit, BufferTitle);
d3527 1
a3527 1
			LKFormatValue(LK_FL, false, BufferValue, BufferUnit, BufferTitle);
d3530 1
a3530 1
			LKFormatValue(LK_FIN_LD, false, BufferValue, BufferUnit, BufferTitle);
d3534 2
a3535 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3539 1
d3551 1
a3551 1
			LKFormatValue(LK_WIND, false, BufferValue, BufferUnit, BufferTitle);
d3555 1
a3555 1
			LKFormatValue(LK_WIND, false, BufferValue, BufferUnit, BufferTitle);
d3564 1
a3564 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3579 1
a3579 1
			LKFormatValue(LK_EMPTY, false, BufferValue, BufferUnit, BufferTitle);
d3583 1
a3583 1
			LKFormatValue(LK_TL_AVG, false, BufferValue, BufferUnit, BufferTitle);
d3592 1
a3592 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3607 1
a3607 1
			LKFormatValue(LK_EMPTY, false, BufferValue, BufferUnit, BufferTitle);
d3611 1
a3611 1
			LKFormatValue(LK_TC_ALL, false, BufferValue, BufferUnit, BufferTitle);
d3615 1
a3615 1
			LKFormatValue(LK_SPEEDTASK_ACH, true, BufferValue, BufferUnit, BufferTitle); 
d3620 1
a3620 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3635 1
a3635 1
			LKFormatValue(LK_EMPTY, false, BufferValue, BufferUnit, BufferTitle);
d3639 1
a3639 1
			LKFormatValue(LK_MC, true, BufferValue, BufferUnit, BufferTitle); 
d3643 2
a3644 1
			LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d3648 1
d3666 1
a3666 1
	LKFormatValue(LK_HGPS, true, BufferValue, BufferUnit, BufferTitle);
a3674 2
	showunit=false;

d3677 1
d3680 1
a3680 1
	showunit=false; // 091221
d3683 1
d3686 1
d3688 2
a3689 1
	LKFormatValue(LK_HGPS, true, BufferValue, BufferUnit, BufferTitle);
d3692 1
d3697 1
d3702 1
d3729 4
a3732 1
        LKWriteText(hdc, BufferValue, *columnvalue,*row1, 0, WTMODE_NORMAL,WTALIGN_RIGHT, RGB_WHITE, false);
a3733 1
        SelectObject(hdc, LK8PanelSmallFont);
d3735 1
d3738 1
@


8.40
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.39 2009/12/17 20:40:00 root Exp root $ BAD
d1295 2
a1296 2
		LKFormatValue(LK_FIN_ETE, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
d3643 2
a3645 1

d3665 20
@


8.39
log
@1.17f
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.38 2009/12/05 19:32:18 root Exp root $ BAD
d98 1
d102 1
d1242 2
a1243 2
		LKFormatValue(LK_GNDSPEED, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
d3226 1
a3226 1
	LKFormatValue(LK_TIME_LOCAL, false, BufferValue, BufferUnit, BufferTitle);
d3643 1
a3643 1
	showunit=false;
d3645 1
d3647 1
a3647 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[3],&qrow[4],&qrow[2]);
d3649 1
a3649 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[6],&qrow[7],&qrow[5]);
d3651 1
a3651 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[9],&qrow[10],&qrow[8]);
d3653 20
a3672 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16], &qcolumn[16],&qrow[12],&qrow[13],&qrow[11]);
@


8.38
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.37 2009/11/24 00:42:23 root Exp root $ BAD
d630 1
a630 4

  double cruise= CALCULATED_INFO.AverageLD;
  static double maxcruise=(GlidePolar::bestld); 
  static double mincruise=(GlidePolar::bestld/4);
d635 1
a635 1
  static int spread=0;
d641 10
a650 1
  if ( cruise < 0 ) cruise = GlidePolar::bestld;
d673 3
a675 3
      SelectObject(hdc, hpVisualGlideHeavyBlack);
#if (0)
    // toggling colors are not used
d684 6
d694 18
a711 17
    if ( ( DisplayOrientation == TRACKUP) || (DisplayOrientation == NORTHCIRCLE) 
	 || (DisplayOrientation == TRACKCIRCLE)
	 && (DisplayMode != dmCircling) )
      {
	if ( VisualGlide == 1 ) {
	  tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
	  DrawArc(hdc, Orig.x, Orig.y,(int)tmp, rc, 315, 45);
	} else
	  {
	    tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
	    DrawArc(hdc, Orig.x, Orig.y,(int)tmp, rc, 330+spread, 30+spread);
	  }
      } else
      {
	tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
	Circle(hdc, Orig.x,Orig.y,(int)tmp, rc, true, false);
      }
d713 5
d719 2
a720 24
    if (turn>0||true) oldcolor=SetTextColor(hdc, RGB_BLACK); 
    else oldcolor=SetTextColor(hdc, RGB_RED); // red
    if ( i==2 || i==4 || i==6 || i==8 ) { 
      if ( Units::GetUserAltitudeUnit() == unMeter ) wsprintf(gtext,_T("-%dm"),i*100); else
	wsprintf(gtext,_T("-%dft"),i*300);
      if (count<5)
	ExtTextOut( hdc, Orig.x+35, Orig.y-5 - (int) tmp, 0, NULL, gtext , _tcslen(gtext), NULL );
    }
    SetTextColor(hdc,oldcolor);
    if (turn>0||true) oldcolor=SetTextColor(hdc, RGB_BLACK); // dark grey
    else oldcolor=SetTextColor(hdc, RGB_RED); // red
    if ( i==2 || i==4 || i==6 || i==8 ) {
      if ( Units::GetUserDistanceUnit() == unKiloMeter ) 
	{
	  //sprintf(text,"%3.1f Km",i*100*cruise /1000);
	  sprintf(text,"%3.0fkm",i*100*cruise /1000);
	} else  if ( Units::GetUserDistanceUnit() == unNauticalMiles ) 
	{
	  //sprintf(text,"%3.1f nmi", i*100*cruise / 1852);
	  sprintf(text,"%3.0fnm", i*100*cruise / 1852);
	} else  if ( Units::GetUserDistanceUnit() == unStatuteMiles )
	{
	  //sprintf(text,"%3.1f mi", i*100*cruise / 1609);
	  sprintf(text,"%3.0fm", i*100*cruise / 1609);
d723 27
a749 5
      wsprintf(gtext,_T("%S"),text);; 
      if (count<5)
	ExtTextOut( hdc, Orig.x-100, Orig.y-5 - (int) tmp, 0, NULL, gtext , _tcslen(gtext), NULL );
    }
    SetTextColor(hdc,oldcolor);
d883 2
a884 1
  if (MapWindow::IsMapFullScreen() && LKVarioBar) { // 091111 added Vario for PG 091115 configurable
d1050 4
a1053 1
	rcx=rc.left+IBLSCALE(10)+leftmargin+GlideBarOffset;   // 091115
d1715 1
a1715 1
	_stprintf(Buffer,TEXT("Evoluted from XCSoar 5.2.4 by Paolo Ventafridda (venta@@bware.it)"));
d2296 2
a2297 1
		if ((WayPointCalc[rli].VGR == 3 ))
d2913 5
a2917 1
		rcolor=RGB_WHITE;
d4604 3
@


8.37
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.36 2009/11/23 00:51:51 root Exp root $ BAD
d114 1
a114 4
  if (MapScale <=20) for(i=0;i<NumberOfWayPoints;i++) 
    {
      if (WayPointList[i].Visible == false )	continue;
//      if ( (WayPointList[i].Flags & LANDPOINT) != LANDPOINT) continue; // FIX VENTA8 nasty
d116 1
a116 12
      if ((WayPointList[i].Flags & AIRPORT) == AIRPORT) {
	if (WayPointList[i].Reachable == false)	{
	  SelectObject(hDCTemp,hBmpAirportUnReachable);
	} else
	  {
	    SelectObject(hDCTemp,hBmpAirportReachable);
	    if ( arrivalcutoff < (int)(WayPointList[i].AltArivalAGL)) {
	      arrivalcutoff = (int)(WayPointList[i].AltArivalAGL);
	      bestwp=i; foundairport++;
	    }
	  }
      } 
d118 25
d144 2
a145 13
      else  if ( (WayPointList[i].Flags & LANDPOINT) == LANDPOINT) {

    	// outlanding
	if (WayPointList[i].Reachable == false)	 
	  SelectObject(hDCTemp,hBmpFieldUnReachable);
	else { 
	  SelectObject(hDCTemp,hBmpFieldReachable);
	  if (foundairport == 0) { // get the outlanding as bestwp only if no other choice
	    // do not set arrivalcutoff: any next reachable airport is better than an outlanding
	    if ( arrivalcutoff < (int)(WayPointList[i].AltArivalAGL)) bestwp=i;  
	  }
	}
      } else continue; // do not draw icons for normal turnpoints here
d147 1
a147 11
      DrawBitmapX(hdc,
		  WayPointList[i].Screen.x-IBLSCALE(10), 
		  WayPointList[i].Screen.y-IBLSCALE(10),
		  20,20,
		  hDCTemp,0,0,SRCPAINT);

      DrawBitmapX(hdc,
		  WayPointList[i].Screen.x-IBLSCALE(10), 
		  WayPointList[i].Screen.y-IBLSCALE(10),
		  20,20,
		  hDCTemp,20,0,SRCAND);
a148 1
    }
d177 2
a178 2
	    irange = WaypointInRange(i); // always in range if MapScale <=10  since no zoom in waypoints is documented
	    // and .Zoom is always 0. 
d777 1
d786 1
d812 1
a812 1
					tlen=7;
d821 1
a821 1
					tlen=7;
d829 1
d834 1
a834 1
					tlen=8; // 091114 reducted from 9
d839 3
d894 3
a896 1
	if (ThermalBar) // 091123
a897 2
	  else
	  	rcx=rc.left+leftmargin+IBLSCALE(40);
d906 1
a906 1
#if (0)
d909 1
a909 1
	TextDisplayMode.AsFlag.Color = TEXTGREEN; 
d911 1
a911 1
	TextDisplayMode.AsFlag.Color = TEXTRED;
d914 4
d959 4
a962 1
			LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE, true);
d966 7
a972 1
			LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d997 4
a1000 1
	LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d1024 1
d1077 2
a1078 1
			SelectObject(hdc, LK8MediumFont); 
d1681 15
a1695 6
  _stprintf(Buffer,TEXT("%s build#%d"), XCSoar_Version,BUILDNUMBER);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &textSize);
  bottomlines=rc.bottom-BottomSize-(textSize.cy*3);
  LKWriteText(hdc, Buffer, middlex, bottomlines , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
  _stprintf(Buffer,TEXT("Evoluted from XCSoar 5.2.4 by Paolo Ventafridda (venta@@bware.it)"));
  LKWriteText(hdc, Buffer, middlex, bottomlines+textSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE, false);
d2069 1
a2069 1
	if ( (ScreenSize == (ScreenSize_t)ss640x480) || (ScreenSize == (ScreenSize_t)ss320x240) ) {
d2733 1
a2733 1
	if ( (ScreenSize == (ScreenSize_t)ss640x480) || (ScreenSize == (ScreenSize_t)ss320x240) ) {
d3020 1
d3026 1
d4393 1
a4393 1
	if ( (ScreenSize == (ScreenSize_t)ss640x480) || (ScreenSize == (ScreenSize_t)ss320x240) ) {
@


8.36
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.35 2009/11/11 00:52:23 root Exp root $ BAD
d878 2
a879 2
  ///: 091115 no overlay - we are still drawing the wind on bottom left!
  if ( Look8000 == (Look8000_t)lxcNoOverlay ) goto Drawbottom;
d891 1
d897 6
d940 1
a940 1
	   // Bearing 
d992 12
@


8.35
log
@senza thermal band
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.34 2009/11/10 22:21:51 root Exp root $ BAD
d789 2
d808 1
d842 1
a842 1
					tlen=9;
d854 1
a854 1
					tlen=9;
d858 1
a858 1
					tlen=7;
d870 11
d888 1
a888 1
	  rcx=rc.left+IBLSCALE(1);
d893 1
a893 1
	  	rcx=rc.left+IBLSCALE(1);
d895 1
a895 1
	  	rcx=rc.left+IBLSCALE(40);
d963 1
a963 1
  ///: 091110 moved out from task paragliders stuff
d988 2
a989 1
  if ( (Look8000==(Look8000_t)lxcAdvanced) || ISPARAGLIDER ) {
d993 2
a994 1
		LKFormatValue(LK_VARIO, false, BufferValue, BufferUnit, BufferTitle);
d999 6
a1004 2
	rcx=rc.left+IBLSCALE(1)+GlideBarOffset; 
	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
d1017 1
a1017 1
	rcx+=IBLSCALE(9);
d1020 2
a1021 1
		LKFormatValue(LK_HGPS, false, BufferValue, BufferUnit, BufferTitle);
d1453 1
a1453 1
  	LKWriteText(hdc, BufferValue, rc.left+IBLSCALE(5), rc.bottom - BottomSize- rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d1455 1
a1455 1
  	LKWriteText(hdc, BufferValue, rc.left+IBLSCALE(5), rc.bottom - rcy-IBLSCALE(5), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d1462 2
a1463 1
  		LKWriteText(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true);
d1465 2
a1466 1
  		LKWriteText(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true);
@


8.34
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.33 2009/11/09 21:04:46 root Exp root $ BAD
d877 6
a882 1
	  rcx=rc.left+IBLSCALE(40);
d922 4
a926 1
		LKFormatValue(LK_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
d928 2
a929 2
  	  SelectObject(hdc, LK8BigFont);
	  LKWriteText(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ IBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, true);
d931 1
a931 1
       }
d933 2
d936 9
a944 2
 	 // Draw efficiency required and altitude arrival for destination waypoint
	 // For paragliders, average efficiency and arrival destination
d946 2
a947 1
	  SelectObject(hdc, LK8BigFont); // use this font for big values
d949 21
a969 4
	  if ( ISPARAGLIDER )
		  LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);
	  else
		  LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
a970 8
	  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	  rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
	  rcx=rc.right-IBLSCALE(10);
	  LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE, true);

	  // Altitude difference with current MC
	 LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
	  LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
a972 2
	} // index>0
    } // valid taskpoint
@


8.33
log
@1.16b
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.32 2009/11/01 01:21:29 root Exp root $ BAD
d22 1
d95 1
d192 1
a192 1
	      SelectObject(hDCTemp,hSmall);
d272 4
a275 1
		SelectObject(hDCTemp,hSmall);
d277 4
a280 1
		SelectObject(hDCTemp,hTurnPoint);
d598 4
a601 1
	  SelectObject(hDCTemp,hSmall);
d603 4
a606 1
	  SelectObject(hDCTemp,hTurnPoint);
d754 1
a754 1
   if (MapScale>4 || (DisplayMode == dmCircling)) return;
d763 4
a766 1
   _DrawLine(hdc, PS_SOLID, IBLSCALE(1), Orig, p2, RGB_BLACK, rc);
d902 1
a902 1
	 LKWriteText(hdc,Buffer, rcx+IBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE);
d906 1
a906 1
	 LKWriteText(hdc,BufferValue, rcx+IBLSCALE(2), rcy+TextSize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE);
d911 1
a911 1
	 LKWriteText(hdc, BufferUnit, rcx+IBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-IBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE); 
d921 1
a921 1
	  LKWriteText(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ IBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE);
d939 1
a939 1
	  LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE);
d943 1
a943 1
	  LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE);
d962 1
a962 1
		LKWriteText(hdc, BufferValue, rcx, rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d965 1
a965 1
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d969 1
a969 1
		LKWriteText(hdc, BufferValue, rcx+IBLSCALE(9), rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d979 1
a979 1
		LKWriteText(hdc, BufferValue, rcx,rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d982 1
a982 1
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d990 1
a990 1
	LKWriteText(hdc, BufferValue, rcx,rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d993 1
a993 1
		LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d1001 1
a1001 1
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(10),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE);
d1004 1
a1004 1
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(27),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE);
d1009 1
a1009 1
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(30),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE);
d1012 1
a1012 1
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(28),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE);
d1128 1
a1128 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE);
d1176 1
a1176 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE);
d1229 1
a1229 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE);
d1271 1
a1271 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE);
d1325 1
a1325 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE);
d1376 1
a1376 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE);
d1407 1
a1407 1
  	LKWriteText(hdc, BufferValue, rc.left+IBLSCALE(5), rc.bottom - BottomSize- rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d1409 1
a1409 1
  	LKWriteText(hdc, BufferValue, rc.left+IBLSCALE(5), rc.bottom - rcy-IBLSCALE(5), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d1416 1
a1416 1
  		LKWriteText(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE);
d1418 1
a1418 1
  		LKWriteText(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE);
d1426 1
a1426 1
  	LKWriteText(hdc, Buffer, rc.right - (TextSize.cx)-IBLSCALE(20) ,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_LIGHTGREEN);
d1578 1
a1578 1
  LKWriteText(hdc, Buffer, middlex, (headerSize.cy/2)+IBLSCALE(2) , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE);
d1583 1
a1583 1
  LKWriteText(hdc, Buffer, middlex, (headerSize.cy/2)+(textSize.cy/2)+IBLSCALE(4)+1 , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE);
d1592 1
a1592 1
  LKWriteText(hdc, Buffer, middlex, contenttop+(textSize.cy*1) , 0, WTMODE_NORMAL, WTALIGN_CENTER,RGB_WHITE);
d1597 1
a1597 1
  LKWriteText(hdc, Buffer, middlex, ((rc.bottom-rc.top)-textSize.cy)/2 , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN);
d1604 1
a1604 1
  LKWriteText(hdc, Buffer, middlex, bottomlines , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE);
d1606 1
a1606 1
  LKWriteText(hdc, Buffer, middlex, bottomlines+textSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE);
d1621 1
a1621 1
  LKWriteText(hdc, Buffer, middlex, bottomlines-(textSize.cy)-IBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN);
d1628 1
a1628 1
  LKWriteText(hdc, Buffer, middlex, bottomlines-(textSize.cy*2)-IBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN);
d1938 1
a1938 1
	LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0,  WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d1946 1
a1946 1
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK);
d1948 1
a1948 1
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d1952 1
a1952 1
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d1954 1
a1954 1
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d1958 1
a1958 1
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d1960 1
a1960 1
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d1964 1
a1964 1
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d1966 1
a1966 1
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d1970 1
a1970 1
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d1972 1
a1972 1
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d1985 1
a1985 1
		LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d1993 1
a1993 1
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK);
d1995 1
a1995 1
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d1999 1
a1999 1
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d2001 1
a2001 1
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2005 1
a2005 1
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d2007 1
a2007 1
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2011 1
a2011 1
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d2013 1
a2013 1
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2017 1
a2017 1
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d2019 1
a2019 1
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2024 1
a2024 1
		LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d2032 1
a2032 1
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK);
d2034 1
a2034 1
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d2038 1
a2038 1
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d2040 1
a2040 1
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2044 1
a2044 1
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d2046 1
a2046 1
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2050 1
a2050 1
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d2052 1
a2052 1
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2056 1
a2056 1
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d2058 1
a2058 1
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2191 1
a2191 1
	LKWriteText(hdc, Buffer1[i][curpage], Column1, iRaw , 0, WTMODE_NORMAL, WTALIGN_LEFT, rcolor);
d2196 1
a2196 1
	LKWriteText(hdc, Buffer2[i][curpage], Column2, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d2199 1
a2199 1
	LKWriteText(hdc, Buffer3[i][curpage], Column3, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d2202 1
a2202 1
	LKWriteText(hdc, Buffer4[i][curpage], Column4, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d2205 1
a2205 1
	LKWriteText(hdc, Buffer5[i][curpage], Column5, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d2612 1
a2612 1
	LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d2619 1
a2619 1
	LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d2624 1
a2624 1
	LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2627 1
a2627 1
	LKWriteText(hdc, Buffer, Column3, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2630 1
a2630 1
	LKWriteText(hdc, Buffer, Column4, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2633 1
a2633 1
	LKWriteText(hdc, Buffer, Column5, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2641 1
a2641 1
	LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d2649 1
a2649 1
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d2654 1
a2654 1
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2657 1
a2657 1
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2660 1
a2660 1
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2663 1
a2663 1
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2669 1
a2669 1
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d2672 1
a2672 1
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2675 1
a2675 1
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2678 1
a2678 1
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2681 1
a2681 1
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d2807 1
a2807 1
	LKWriteText(hdc, Buffer1[i][curpage], Column1, iRaw , 0, WTMODE_NORMAL, WTALIGN_LEFT, rcolor);
d2812 1
a2812 1
	LKWriteText(hdc, Buffer2[i][curpage], Column2, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d2815 1
a2815 1
	LKWriteText(hdc, Buffer3[i][curpage], Column3, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d2818 1
a2818 1
	LKWriteText(hdc, Buffer4[i][curpage], Column4, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d2821 1
a2821 1
	LKWriteText(hdc, Buffer5[i][curpage], Column5, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d3073 1
a3073 1
        LKWriteText(hdc, Buffer, qcolumn[0],qrow[0], 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d3101 1
a3101 1
        LKWriteText(hdc, Buffer, qcolumn[8],qrow[1], 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE);
d3107 1
a3107 1
        LKWriteText(hdc, BufferValue, qcolumn[16],qrow[0], 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d3536 1
a3536 1
	LKWriteText(hdc, BufferTitle, qcolumn[8],qrow[12], 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_ORANGE);
d3548 1
a3548 1
        LKWriteText(hdc, BufferValue, *columnvalue,*row1, 0, WTMODE_NORMAL,WTALIGN_RIGHT, RGB_WHITE);
d3552 1
a3552 1
	        LKWriteText(hdc, BufferUnit, *columnvalue,*row2, 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_WHITE);
d3554 1
a3554 1
        LKWriteText(hdc, BufferTitle, *columntitle,*row3, 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_LIGHTGREEN);
d3768 1
a3768 1
  LKWriteText(hDC, Buffer, Start.x , bankindy, 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_BLUE);
d3844 1
d3846 1
a3846 1
                          int maxsize, const bool mode, const short align, COLORREF rgb_text ) {
d3854 1
a3854 1
	if (!INVERTCOLORS) switch(rgb_text) {
d4263 1
a4263 1
	LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0,  WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d4268 1
a4268 1
 		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK);
d4270 1
a4270 1
 		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d4274 1
a4274 1
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4276 1
a4276 1
		LKWriteText(hdc, Buffer, Column2, HEADRAW , 0, WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4280 1
a4280 1
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4282 1
a4282 1
		LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4286 1
a4286 1
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4288 1
a4288 1
		LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4292 1
a4292 1
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4294 1
a4294 1
		LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4307 1
a4307 1
		LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d4312 1
a4312 1
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK);
d4314 1
a4314 1
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d4318 1
a4318 1
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4320 1
a4320 1
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4324 1
a4324 1
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4326 1
a4326 1
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4330 1
a4330 1
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4332 1
a4332 1
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4336 1
a4336 1
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4338 1
a4338 1
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4343 1
a4343 1
		LKWriteText(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d4348 1
a4348 1
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK);
d4350 1
a4350 1
			LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0,WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d4354 1
a4354 1
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4356 1
a4356 1
			LKWriteText(hdc, Buffer, Column2, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4360 1
a4360 1
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4362 1
a4362 1
			LKWriteText(hdc, Buffer, Column3, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4366 1
a4366 1
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4368 1
a4368 1
			LKWriteText(hdc, Buffer, Column4, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4372 1
a4372 1
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_BLACK);
d4374 1
a4374 1
			LKWriteText(hdc, Buffer, Column5, HEADRAW , 0,WTMODE_NORMAL, WTALIGN_RIGHT, RGB_WHITE);
d4491 1
a4491 1
	LKWriteText(hdc, Buffer1[i][curpage], Column1, iRaw , 0, WTMODE_NORMAL, WTALIGN_LEFT, rcolor);
d4496 1
a4496 1
	LKWriteText(hdc, Buffer2[i][curpage], Column2, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d4499 1
a4499 1
	LKWriteText(hdc, Buffer3[i][curpage], Column3, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d4502 1
a4502 1
	LKWriteText(hdc, Buffer4[i][curpage], Column4, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
d4505 1
a4505 1
	LKWriteText(hdc, Buffer5[i][curpage], Column5, iRaw , 0, WTMODE_NORMAL, WTALIGN_RIGHT, rcolor);
@


8.32
log
@1.15b
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.31 2009/10/23 11:27:16 root Exp $ BAD
d36 1
a36 1
	bool isLandable, bool isAirport, bool isExcluded);
d68 1
a160 1

d532 10
d549 1
a549 1
				    intask,islandable,isairport,excluded);
d1563 1
a1563 1
  _stprintf(Buffer,TEXT("Tactical Glide Computer"));
d1608 1
d1610 1
@


8.31
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.30 2009/10/19 23:11:36 root Exp root $ BAD
d1549 1
a1549 1
  _stprintf(Buffer,TEXT("LK 8000"));
d1553 1
a1553 1
  _stprintf(Buffer,TEXT("flight computer"));
d1556 1
a1556 1
  LKWriteText(hdc, Buffer, middlex, (headerSize.cy/2)+(textSize.cy/2)+IBLSCALE(4) , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE);
@


8.30
log
@1.14b
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.29 2009/10/16 10:59:50 root Exp root $ BAD
d1385 1
a1385 1
	_stprintf(Buffer,TEXT("LOCKED"));
d1389 1
a1389 1
  		LKWriteText(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_LIGHTGREEN);
d1391 1
a1391 1
  		LKWriteText(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_LIGHTGREEN);
@


8.29
log
@prefix activewaypoint
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.28 2009/10/12 13:25:12 root Exp root $ BAD
d842 2
a843 1
     if ( index >0 )
d952 1
a952 1
		LKWriteText(hdc, Buffer, rcx,rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE);
d1526 1
a1526 1
  SIZE TextSize;
d1550 2
a1551 2
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  LKWriteText(hdc, Buffer, middlex, (TextSize.cy/2)+IBLSCALE(2) , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE);
d1554 1
d1556 1
a1556 1
  LKWriteText(hdc, Buffer, middlex, (TextSize.cy/2)+TextSize.cy-IBLSCALE(4) , 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_SWHITE);
d1565 1
a1565 1
  LKWriteText(hdc, Buffer, middlex, contenttop+(TextSize.cy*1) , 0, WTMODE_NORMAL, WTALIGN_CENTER,RGB_WHITE);
d1569 2
a1570 2
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  LKWriteText(hdc, Buffer, middlex, ((rc.bottom-rc.top)-TextSize.cy)/2 , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN);
d1575 2
a1576 2
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  bottomlines=rc.bottom-BottomSize-(TextSize.cy*3);
d1579 1
a1579 1
  LKWriteText(hdc, Buffer, middlex, bottomlines+TextSize.cy , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_WHITE);
d1593 2
a1594 2
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  LKWriteText(hdc, Buffer, middlex, bottomlines-(TextSize.cy)-IBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN);
d1597 3
a1599 3
  if (GPSAltitudeOffset >0) _stprintf(Buffer, _T("(GPS OFFSET=%+.0f)"), GPSAltitudeOffset);
  if (!LoggerGActive()) _tcscat(Buffer,_T(" (NO GRECORD)"));
  LKWriteText(hdc, Buffer, middlex, bottomlines-(TextSize.cy*2)-IBLSCALE(2) , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN);
d3056 2
a3057 1
				if ( index >0 ) {
@


8.28
log
@1.12b
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.27 2009/10/01 15:04:49 root Exp root $ BAD
d635 1
d2122 1
a2122 1
		Value=WayPointCalc[rli].AltArriv[AltArrivMode];
d2748 1
a2748 1
		Value=WayPointCalc[rli].AltArriv[AltArrivMode];
d4431 1
a4431 1
		value=WayPointCalc[rli].AltArriv[AltArrivMode];
@


8.27
log
@pre localpath
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.26 2009/09/28 09:50:14 root Exp root $
d24 1
d214 1
a214 1
		      if ( i==bestwp && foundairport==0 ) { // this outlanding is the best option
d250 1
a250 1
		      if ( (i != bestwp) && (arrivalcutoff>600) ) {
d628 2
a629 2
  short rcx=rc.left+rc.right/2-IBLSCALE(20); 
  short rcy=rc.bottom-IBLSCALE(15); // 35
d756 1
a756 1
  int index=-1, value;
d1080 1
a1080 1
		showunit=LKFormatValue(LK_BESTALTERN_GR, true, BufferValue, BufferUnit, BufferTitle);
d1082 1
d1115 1
a1115 1
		LKFormatValue(LK_FIN_ALTDIFF0, true, BufferValue, BufferUnit, BufferTitle);
d1124 1
a1124 1
			sprintf(text,"%.0lf%",Value);
d1420 1
a1420 1
  TCHAR Buffer[LKSIZEBUFFERLARGE];
a1523 2
  //static HBRUSH hB= CreateSolidBrush(RGB(0x00,0x00, 0x00)); 

d1529 1
a1529 1
  short left=rc.left+IBLSCALE(5);
a1531 1
  SelectObject(hdc, LK8TargetFont);
d1546 1
d1550 2
a1551 1
  _stprintf(Buffer,TEXT("advanced glide computer"));
a1554 28
  SelectObject(hdc, LK8InfoBigFont);
  _stprintf(Buffer,TEXT("ScreenSize: %d x %d"),rc.right, rc.bottom);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);

/************

  /TextInBox(hdc, Buffer, left, contenttop , 0, TextDisplayMode, false);
#if (WINDOWSPC>0)
  _stprintf(Buffer,TEXT("WindowsPC version"));
#else
  _stprintf(Buffer,TEXT("Configuration: %s%S"), gmfpathname(),XCSDATADIR);
#endif
  /TextInBox(hdc, Buffer, left, contenttop+TextSize.cy , 0, TextDisplayMode, false);

  if (LoggerGActive()) 
  	_stprintf(Buffer,TEXT("Grecord DLL: Ok"));
  else {
  	TextDisplayMode.AsFlag.Color = TEXTRED;
  	_stprintf(Buffer,TEXT("Grecord DLL: NO"));
  }
  /TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*2) , 0, TextDisplayMode, false);

  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  _stprintf(Buffer,TEXT("Waypoints loaded: %d"), NumberOfWayPoints);
  /TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*3) , 0, TextDisplayMode, false);
  _stprintf(Buffer,TEXT("Airspace loaded: %d-%d-%d"), NumberOfAirspacePoints,NumberOfAirspaceAreas,
		NumberOfAirspaceCircles);
  /TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*4) , 0, TextDisplayMode, false);
d1556 3
d1560 1
a1560 2
  _stprintf(Buffer,_T("SIMULATION, NO GPS"));
  /TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*5) , 0, TextDisplayMode, false);
d1562 1
a1563 4
************/
  SelectObject(hdc, LK8InfoBigFont);
  _stprintf(Buffer,TEXT("%s"),XCSoar_Version);
  LKWriteText(hdc, Buffer, middlex, contenttop+(TextSize.cy*1) , 0, WTMODE_NORMAL, WTALIGN_CENTER,RGB_WHITE);
d1566 3
a1568 1
  LKWriteText(hdc, Buffer, middlex, ((rc.bottom-rc.top)-BottomSize)/2 , 0, WTMODE_NORMAL, WTALIGN_CENTER, RGB_LIGHTGREEN);
d1571 1
a1571 1
  _stprintf(Buffer,TEXT("%s"), XCSoar_Version);
d1578 20
d1613 1
d1812 3
a1814 3
//  TCHAR vbuf[100]; // REMOVE VENTA
//  wsprintf(vbuf,_T("Numpages=%d sortednum=%d numraws=%d"),Numpages, SortedNumber, Numraws );
//  DoStatusMessage(vbuf);
d2118 4
a2121 2
		///: arrival altitude
		Value=WayPointCalc[rli].AltArriv;
d2127 1
d2190 1
a2190 1
		DoStatusMessage(_T("Invalid selected raw"));
d2484 4
d2571 1
a2571 1
  short cursortbox=1;
d2747 1
a2747 1
		Value=WayPointCalc[rli].AltArriv;
d2806 1
a2806 1
		DoStatusMessage(_T("Invalid selected raw"));
d2863 1
a2863 1
  SIZE TextSize;
d2868 1
a2868 1
  char text[LKSIZETEXT];
d2870 1
a2870 1
  double Value;
d3138 1
a3138 1
			showunit=LKFormatValue(LK_NEXT_ALTDIFF0, false, BufferValue, BufferUnit, BufferTitle);
d3196 1
a3196 1
			showunit=LKFormatValue(LK_NEXT_ALTDIFF0, false, BufferValue, BufferUnit, BufferTitle);
d3737 1
a3737 1
  if (!disabled) MapWindow:RefreshMap();
d3784 3
d4430 1
a4430 1
		value=WayPointCalc[rli].AltArriv;
@


8.26
log
@preclean
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.25 2009/09/24 16:21:48 root Exp root $
d749 1
a749 1
  TextInBoxMode_t TextDisplayMode;
a854 1
	TextDisplayMode.AsInt = 0;
d860 1
a860 1
		TextDisplayMode.AsFlag.Color = TEXTRED;
a862 4
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	TextDisplayMode.AsFlag.NoSetFont = 1; 
	TextDisplayMode.AsFlag.AlligneRight = 0;
a871 1
 	 //TextInBox(hdc, Buffer, rcx+IBLSCALE(2),rcy, 0, TextDisplayMode, false);   // NAME
a876 1
	 //TextInBox(hdc, BufferValue, rcx+IBLSCALE(2),rcy+TextSize.cy, 0, TextDisplayMode, false); 
a880 1
	 //TextInBox(hdc, BufferUnit, rcx+IBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-IBLSCALE(1), 0, TextDisplayMode, false); 
a882 12
/* REMOVE
  	 Value=CALCULATED_INFO.WaypointDistance*DISTANCEMODIFY; 
	 _stprintf(Buffer,TEXT("%0.1lf"),Value);
	 /TextInBox(hdc, Buffer, rcx+IBLSCALE(2),rcy+TextSize.cy, 0, TextDisplayMode, false); 

 	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize2);
	if (!HideUnits) {
	 wsprintf(BufferUnit, TEXT("%s"),Units::GetDistanceName());
	 SelectObject(hdc, LKMAPFONT);
	 /TextInBox(hdc, BufferUnit, rcx+IBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-IBLSCALE(1), 0, TextDisplayMode, false); 
	}
*/
a888 25
/* REMOVE
	    Value = CALCULATED_INFO.WaypointBearing -  GPS_INFO.TrackBearing;

	    if (Value < -180.0)
	      Value += 360.0;
	    else
	    if (Value > 180.0)
	      Value -= 360.0;

#ifndef __MINGW32__
	    if (Value > 1)
	      _stprintf(Buffer, TEXT("%2.0f°»"), Value);
	    else if (Value < -1)
	      _stprintf(Buffer, TEXT("«%2.0f°"), -Value);
	    else
	      _tcscpy(Buffer, TEXT("«»"));
#else
	    if (Value > 1)
	      _stprintf(Buffer, TEXT("%2.0fÂ°Â»"), Value);
	    else if (Value < -1)
	      _stprintf(Buffer, TEXT("Â«%2.0fÂ°"), -Value);
	    else
	      _tcscpy(Buffer, TEXT("Â«Â»"));
#endif
*/
a890 7
	  TextDisplayMode.AsInt = 0;
	  TextDisplayMode.AsFlag.Color = TEXTWHITE;
	  TextDisplayMode.AsFlag.NoSetFont = 1; 
	  TextDisplayMode.AsFlag.WhiteBold = 1;
	  TextDisplayMode.AsFlag.AlligneRight = 0;
	  TextDisplayMode.AsFlag.AlligneCenter = 1;
//	  TextInBox(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ IBLSCALE(15), 0, TextDisplayMode, false);
a899 5
	  TextDisplayMode.AsInt = 0;
	  TextDisplayMode.AsFlag.NoSetFont = 1; 
	  TextDisplayMode.AsFlag.Color = TEXTWHITE;
	  TextDisplayMode.AsFlag.WhiteBold = 1;
	  TextDisplayMode.AsFlag.AlligneRight = 1;
a908 1
	  // TextInBox(hdc, BufferValue, rcx,rcy, 0, TextDisplayMode, false);  // GR
a909 18
/* REMOVE
	  if ( ISPARAGLIDER )
		Value=CALCULATED_INFO.AverageLD;
	  else
		Value=WayPointCalc[index].GR;

	  if (Value <1 || Value >=ALTERNATE_MAXVALIDGR )
		strcpy(text,"---");
	  else 
		if (Value >= 100) sprintf(text,"%.0lf",Value);
		else sprintf(text,"%.1lf",Value);
	  wsprintf(Buffer, TEXT("%S"),text);
	  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	  rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
	  rcx=rc.right-IBLSCALE(10);
	  /TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  // GR
*/

a912 3
////	  _stprintf(Buffer,TEXT("%+1.0f"), ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
////	  TextInBox(hdc, Buffer, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, TextDisplayMode, false);   // ALT
	 // TextInBox(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, TextDisplayMode, false);   // ALT
a920 6
	TextDisplayMode.AsInt = 0;
	TextDisplayMode.AsFlag.NoSetFont = 1; 
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextDisplayMode.AsFlag.WhiteBold = 1;
	TextDisplayMode.AsFlag.AlligneRight = 0;

a923 8
/*
		if (GPS_INFO.VarioAvailable) {
		      Value = LIFTMODIFY*GPS_INFO.Vario;
		    } else {
		      Value = LIFTMODIFY*CALCULATED_INFO.Vario;
		    }
		_stprintf(Buffer,TEXT("%+0.1f"),Value);
*/
a925 7
/*
	  	Value=DerivedDrawInfo.AverageLD;
	  	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"++"); else
			if (Value==0) sprintf(text,"---"); 
				else sprintf(text,"%.0f",Value);
  		wsprintf(Buffer, TEXT("%S"),text);
*/
a926 1
//	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
a931 2
////		TextInBox(hdc, Buffer, rcx, rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
//		TextInBox(hdc, BufferValue, rcx, rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
a933 1
//			wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
a934 1
		//	TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
a938 2
////		TextInBox(hdc, Buffer, rcx+IBLSCALE(9), rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
//		TextInBox(hdc, BufferValue, rcx+IBLSCALE(9), rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
a945 2
//		Value= ALTITUDEMODIFY*GPS_INFO.Altitude; // CHECK Altitude vs NavAltitude TODO 090921
//		_stprintf(Buffer,TEXT("%0.0f"),Value);
a946 1
//		GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
a948 1
// missing deleted original ehm
a950 1
//			wsprintf(BufferUnit, TEXT("%s"),Units::GetAltitudeName());
a951 1
//			TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
a956 2
//	Value=  SPEEDMODIFY*GPS_INFO.Speed;  // REMOVE
//	_stprintf(Buffer,TEXT("%0.0f"),Value);
a957 1
//	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
a959 2
////	TextInBox(hdc, Buffer, rcx,rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
//	TextInBox(hdc, BufferValue, rcx,rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
a961 1
////		wsprintf(BufferUnit, TEXT("%s"),Units::GetHorizontalSpeedName());
a962 1
//		TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
d966 1
a966 23
	LKFormatValue(LK_TIME_LOCAL, false, BufferValue, BufferUnit, BufferTitle);
/* REMOVE
	int d=DetectCurrentTime();
	bool negative = (d<0);
  	int dd = abs(d) % (3600*24);

	int thours = (dd/3600);
	int tmins = (dd/60-thours*60);
	int tseconds = (dd-tmins*60-thours*3600);
	thours = thours % 24;
	if (negative) {
		if (thours>0) {
			thours = -thours;
		} else if (tmins>0) {
			tmins = -tmins;
		} else {
			tseconds = -tseconds;
		}
	}
	_stprintf(Buffer,TEXT("%d:%02d:%02d"),thours, tmins, tseconds);
*/
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN; 
d971 1
a971 2
//			TextInBox(hdc, Buffer, rc.right-IBLSCALE(10),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(10),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_LIGHTGREEN);
d974 1
a974 2
//			TextInBox(hdc, Buffer, rc.right-IBLSCALE(27),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(27),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_LIGHTGREEN);
d979 1
a979 2
//			TextInBox(hdc, Buffer, rc.right-IBLSCALE(30),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(30),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_LIGHTGREEN);
d982 1
a982 2
//			TextInBox(hdc, Buffer, rc.right-IBLSCALE(28),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(28),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_LIGHTGREEN);
a984 1
	TextDisplayMode.AsFlag.Color = TEXTWHITE; 
a1036 9
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  TextDisplayMode.AsFlag.WhiteBold = 0;
  TextDisplayMode.AsFlag.WhiteBorder = 0; // inside a white circle
  TextDisplayMode.AsFlag.Border = 0;      // add a black border to the circle
  TextDisplayMode.AsFlag.AlligneRight = 0;


d1062 1
a1062 9
		showunit=LKFormatValue(LK_TC_AVG, false, BufferValue, BufferUnit, BufferTitle);
/*
	  	Value= LIFTMODIFY*CALCULATED_INFO.AverageThermal;
		  if (Value<20) sprintf(text,"%+.1lf",Value);
			  else sprintf(text,"%+.0lf",Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
		wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
  		wsprintf(BufferTitle, TEXT("Thermal"),text);
*/
d1065 1
a1065 9
		showunit=LKFormatValue(LK_TL_AVG, false, BufferValue, BufferUnit, BufferTitle);
/*
	  	Value= LIFTMODIFY*CALCULATED_INFO.LastThermalAverage;
		  if (Value<20) sprintf(text,"%+.1lf",Value);
			  else sprintf(text,"%+.0lf",Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
		wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
  		wsprintf(BufferTitle, TEXT("Thermal"),text);
*/
d1068 1
a1068 9
		showunit=LKFormatValue(LK_TC_ALL, false, BufferValue, BufferUnit, BufferTitle);
/*
		if (CALCULATED_INFO.timeCircling <=0) Value=0; else
		Value = LIFTMODIFY*CALCULATED_INFO.TotalHeightClimb /CALCULATED_INFO.timeCircling;
		sprintf(text,"%+.1lf",Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
		wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
	 	wsprintf(BufferTitle, TEXT("ThAll"),text);
*/
d1071 1
a1071 11
		showunit=LKFormatValue(LK_FIN_DIST, false, BufferValue, BufferUnit, BufferTitle);
/*
		Value=CALCULATED_INFO.TaskDistanceToGo*DISTANCEMODIFY;
                if (Value>99)
                	sprintf(text,"%.0f",Value);
                else
                	sprintf(text,"%.1f",Value);
                wsprintf(BufferValue, TEXT("%S"),text);
                wsprintf(BufferUnit, TEXT("%s"),(Units::GetDistanceName()));
  		wsprintf(BufferTitle, TEXT("Dist"),text);
*/
d1075 1
a1075 11
		LKFormatValue(LK_BATTERY, false, BufferValue, BufferUnit, BufferTitle);
/*
		Value=PDABatteryPercent;
		if (Value<1||Value>100) sprintf(text,"---");
		else sprintf(text,"%.0lf%%",Value);
		if (Value<15 ) TextDisplayMode.AsFlag.Color = TEXTLIGHTRED;
		else if (Value<30 ) TextDisplayMode.AsFlag.Color = TEXTLIGHTYELLOW;
  		wsprintf(BufferValue, TEXT("%S"),text);
		showunit=false;
  		wsprintf(BufferTitle, TEXT("Batt"),text);
*/
d1079 2
a1080 29
		showunit=LKFormatValue(LK_BESTALTERN_GR, false, BufferValue, BufferUnit, BufferTitle);
/*
		if ( ValidWayPoint(BestAlternate)) {
			Value=WayPointCalc[BestAlternate].GR;
			if (Value <1 || Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"---"); else
				{
				if (Value>99) sprintf(text,"%.0f",Value);
				else sprintf(text,"%.1f",Value);
				}
  			wsprintf(BufferValue, TEXT("%S"),text);
			if ( !WayPointList[BestAlternate].Reachable ) 
				TextDisplayMode.AsFlag.Color = TEXTLIGHTRED;

			wlen=wcslen(WayPointList[BestAlternate].Name);
			if (wlen>8) {
				_tcsncpy(Buffer, WayPointList[BestAlternate].Name, 8); Buffer[8]='\0';
			}
			else {
				_tcsncpy(Buffer, WayPointList[BestAlternate].Name, wlen); Buffer[wlen]='\0';
			}
			_tcscpy(BufferTitle,Buffer);
  			//wsprintf(BufferTitle, TEXT("%S"),Buffer);
			showunit=false;
		} else {
  			wsprintf(BufferTitle, TEXT("BstAlt"));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
		}
*/
d1085 2
a1086 1
		showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d1091 1
a1091 1
		showunit=LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
a1096 22
/*
  SelectObject(hdc, LK8ValueFont);
  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
  rcy=rc.bottom-(TextSize.cy/2);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  /TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   // FIRST value

  if (showunit==true && !HideUnits) {
#if (WINDOWSPC>0)
  	SelectObject(hdc, LK8UnitFont);
#else
  	SelectObject(hdc, LK8UnitFont);
#endif
	  TextDisplayMode.AsFlag.AlligneCenter = 0;
	  /TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   // FIRST value unit
  }

  SelectObject(hdc, LK8TitleFont);
  GetTextExtentPoint(hdc, BufferTitle, _tcslen(BufferTitle), &TextSize);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
*/
  // TextInBox(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);   // FIRST name
a1097 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
d1106 1
a1106 9
		showunit=LKFormatValue(LK_GNDSPEED, false, BufferValue, BufferUnit, BufferTitle);
/*
  		Value=SPEEDMODIFY*DrawInfo.Speed;
  		if (Value<0||Value>999) Value=0;
  		sprintf(text,"%d",(int)Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetHorizontalSpeedName()));
  		wsprintf(BufferTitle, TEXT("GS"));
*/
d1109 1
a1109 1
		LKFormatValue(LK_GNDSPEED, false, BufferValue, BufferUnit, BufferTitle);
a1110 7
/*
		Value = iround(LIFTMODIFY*MACCREADY*10)/10.0;
  		sprintf(text,"%.1lf",Value);
		wsprintf(BufferValue, TEXT("%S"),text);
  		wsprintf(BufferTitle, TEXT("MC"));
		showunit=false;
*/
d1113 1
a1113 8
		LKFormatValue(LK_FIN_ALTDIFF0, false, BufferValue, BufferUnit, BufferTitle);
/*
  		Value=ALTITUDEMODIFY*CALCULATED_INFO.TaskAltitudeDifference0;
  		sprintf(text,"%+d",(int)Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
 		wsprintf(BufferTitle, TEXT("Diff0"),text);
*/
d1131 1
a1131 14
/*
		if ( ValidWayPoint(BestAlternate)) {
			Value=ALTITUDEMODIFY*WayPointCalc[BestAlternate].AltArriv;
			if (Value <-9999 ||  Value >9999 ) strcpy(text,"---"); 
				else sprintf(text,"%+.0f",Value);
  			wsprintf(BufferValue, TEXT("%S"),text);
			_tcscpy(BufferTitle,_T(""));
  			wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
		} else {
  			wsprintf(BufferTitle, TEXT(""));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
		}
*/
d1136 1
a1144 22
/*
  SelectObject(hdc, LK8ValueFont);
  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
  rcy=rc.bottom-(TextSize.cy/2);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  /TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   

  if (showunit==true&& !HideUnits) {
#if (WINDOWSPC>0)
  	SelectObject(hdc,LK8UnitFont);
#else
  	SelectObject(hdc,LK8UnitFont);
#endif
  	TextDisplayMode.AsFlag.AlligneCenter = 0;
  	/TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
  }

  SelectObject(hdc, LK8TitleFont);
  GetTextExtentPoint(hdc, BufferTitle, _tcslen(BufferTitle), &TextSize);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
*/
  //TextInBox(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
a1145 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
d1156 1
a1156 8
		LKFormatValue(LK_HGPS, false, BufferValue, BufferUnit, BufferTitle);
/*
  		Value=ALTITUDEMODIFY*DerivedDrawInfo.NavAltitude;
  		sprintf(text,"%d",(int)Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
 		wsprintf(BufferTitle, TEXT("Alt"),text);
*/
d1159 1
a1159 8
		LKFormatValue(LK_HAGL, false, BufferValue, BufferUnit, BufferTitle);
/*
  		Value=ALTITUDEMODIFY*DerivedDrawInfo.AltitudeAGL;
  		sprintf(text,"%d",(int)Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
 		wsprintf(BufferTitle, TEXT("AltAgl"),text);
*/
d1162 1
a1162 1
		LKFormatValue(LK_FIN_ETE, false, BufferValue, BufferUnit, BufferTitle);
d1170 1
a1170 1
 			TextDisplayMode.AsFlag.Color = TEXTRED;
d1173 2
a1174 2
			if (Value<3)
 				TextDisplayMode.AsFlag.Color = TEXTYELLOW;
d1182 2
a1183 1
		LKFormatValue(LK_ALTERN1_GR, false, BufferValue, BufferUnit, BufferTitle);
a1184 35
/* never used
		if (OnAlternate1==false) {
  			wsprintf(BufferTitle, TEXT("Altrn1"));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
			break;
		}
*/
/*
		if ( ValidWayPoint(Alternate1)) {
			Value=WayPointCalc[Alternate1].GR;
			if (Value <1 || Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"---"); else
				{
				if (Value>99) sprintf(text,"%.0f",Value);
				else sprintf(text,"%.1f",Value);
				}

  			wsprintf(BufferValue, TEXT("%S"),text);
			wlen=wcslen(WayPointList[Alternate1].Name);
			if (wlen>8) {
				_tcsncpy(Buffer, WayPointList[Alternate1].Name, 8); Buffer[8]='\0';
			}
			else {
				_tcsncpy(Buffer, WayPointList[Alternate1].Name, wlen); Buffer[wlen]='\0';
			}
			_tcscpy(BufferTitle,Buffer);
			showunit=false;
		} else {
			// force invalid alternate
			//OnAlternate1=false;
  			wsprintf(BufferTitle, TEXT("Altrn1"));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
		}
*/
d1188 2
a1189 1
		showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d1192 1
a1192 1
		showunit=LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
a1197 22
/*
  SelectObject(hdc, LK8ValueFont);
  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
  rcy=rc.bottom-(TextSize.cy/2);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  /TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   

  if (showunit==true && !HideUnits) {
#if (WINDOWSPC>0)
  	SelectObject(hdc, LK8UnitFont);
#else
  	SelectObject(hdc, LK8UnitFont);
#endif
  	TextDisplayMode.AsFlag.AlligneCenter = 0;
  	/TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
  }

  SelectObject(hdc, LK8TitleFont);
  GetTextExtentPoint(hdc, BufferTitle, _tcslen(BufferTitle), &TextSize);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
*/
  //TextInBox(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
a1198 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
d1207 1
a1207 8
		showunit=LKFormatValue(LK_TC_GAIN, false, BufferValue, BufferUnit, BufferTitle);
/*
		Value=ALTITUDEMODIFY*DerivedDrawInfo.ThermalGain;
		sprintf(text,"%+d",(int)Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
  		wsprintf(BufferTitle, TEXT("Gain"),text);
*/
a1210 20
/*
		  if ( ValidTaskPoint(ActiveWayPoint) != false ) {
		     index = Task[ActiveWayPoint].Index;
		     if (index>=0) {
			//Value=WayPointCalc[index].Distance*DISTANCEMODIFY;
			Value=CALCULATED_INFO.WaypointDistance*DISTANCEMODIFY;
			if (Value>99)
				sprintf(text,"%.0f",Value);
			else
				sprintf(text,"%.1f",Value);
		     } else {
			strcpy(text,"----");
		     }
		  } else {
			strcpy(text,"----");
		  }
  		wsprintf(BufferValue, TEXT("%S"),text);
  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetDistanceName()));
  		wsprintf(BufferTitle, TEXT("Dist"),text);
*/
d1214 1
a1214 16
		showunit=LKFormatValue(LK_HOME_DIST, false, BufferValue, BufferUnit, BufferTitle);
/* never used
		if (HomeWaypoint>=0) {
		if ValidWayPoint(HomeWaypoint); ..
*/
/*
		Value = DISTANCEMODIFY*CALCULATED_INFO.HomeDistance ;
		if (Value>99)
			sprintf(text,"%.0f",Value);
		else
			sprintf(text,"%.1f",Value);

  		wsprintf(BufferValue, TEXT("%S"),text);
  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetDistanceName()));
  		wsprintf(BufferTitle, TEXT("Home"),text);
*/
d1217 1
a1217 11
		showunit=LKFormatValue(LK_TASK_DISTCOV, false, BufferValue, BufferUnit, BufferTitle);
/*
		Value=CALCULATED_INFO.TaskDistanceCovered*DISTANCEMODIFY;
                if (Value>99)
                	sprintf(text,"%.0f",Value);
                else
                	sprintf(text,"%.1f",Value);
                wsprintf(BufferValue, TEXT("%S"),text);
                wsprintf(BufferUnit, TEXT("%s"),(Units::GetDistanceName()));
  		wsprintf(BufferTitle, TEXT("Made"),text);
*/
d1220 1
a1220 1
		LKFormatValue(LK_TIMEFLIGHT, false, BufferValue, BufferUnit, BufferTitle);
a1221 8
/*
		if (CALCULATED_INFO.FlightTime > 0){
      			Units::TimeToText(BufferValue, (int)CALCULATED_INFO.FlightTime);
		} else
  			wsprintf(BufferValue, TEXT("--:--"));

 		wsprintf(BufferTitle, TEXT("TmFly"),text);
*/
d1224 2
a1225 23
		LKFormatValue(LK_ALTERN1_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
/* era non usato
		if (OnAlternate1==false) {
  			wsprintf(BufferTitle, TEXT(""));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
			break;
		}
*/
/*
		if ( ValidWayPoint(Alternate1)) {
			Value=ALTITUDEMODIFY*WayPointCalc[Alternate1].AltArriv;
			if (Value <-9999 ||  Value >9999 ) strcpy(text,"---"); 
				else sprintf(text,"%+.0f",Value);
  			wsprintf(BufferValue, TEXT("%S"),text);
			_tcscpy(BufferTitle,_T(""));
  			wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
		} else {
  			wsprintf(BufferTitle, TEXT(""));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
		}
*/
d1229 2
a1230 1
		showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d1233 1
a1233 1
		showunit=LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
a1239 22
/*
  SelectObject(hdc, LK8ValueFont);
  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
  rcy=rc.bottom-(TextSize.cy/2);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  /TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   

  if (showunit==true&&!HideUnits) {
#if (WINDOWSPC>0)
	  SelectObject(hdc, LK8UnitFont);
#else
	  SelectObject(hdc, LK8UnitFont);
#endif
	  TextDisplayMode.AsFlag.AlligneCenter = 0;
	  /TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
  }

  SelectObject(hdc, LK8TitleFont);
  GetTextExtentPoint(hdc, BufferTitle, _tcslen(BufferTitle), &TextSize);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
*/
  //TextInBox(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
a1240 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
d1251 1
a1251 9
		LKFormatValue(LK_TC_30S, false, BufferValue, BufferUnit, BufferTitle);
/*
		Value=LIFTMODIFY*DerivedDrawInfo.Average30s;
		if (Value<20) sprintf(text,"%+.1lf",Value);
			else sprintf(text,"%+.0lf",Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
		wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
  		wsprintf(BufferTitle, TEXT("Ther30\""));
*/
d1254 1
a1254 1
		LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
a1255 20
/*
		  if ( ValidTaskPoint(ActiveWayPoint) != false ) {
		     index = Task[ActiveWayPoint].Index;
		     if (index>=0) {
			Value=WayPointCalc[index].GR; // required efficiency
			if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"---"); else
				{
				if (Value>99) sprintf(text,"%.1f",Value);
				else sprintf(text,"%.0f",Value);
				}
		     } else {
			strcpy(text,"---");
		     }
		  } else {
			strcpy(text,"---");
		  }
  		wsprintf(BufferValue, TEXT("%S"),text);
		showunit=false;
  		wsprintf(BufferTitle, TEXT("reqE"));
*/
a1259 9
/*
		if ( CALCULATED_INFO.HomeRadial == 0 )
        	        wsprintf(BufferValue,_T("0%s"),_T(DEG));
		else
        	        wsprintf(BufferValue,_T("%1.0d%s"),(int)CALCULATED_INFO.HomeRadial,_T(DEG));

		showunit=false;
  		wsprintf(BufferTitle, TEXT("Radl"));
*/
d1274 1
a1274 19
		LKFormatValue(LK_EMPTY, false, BufferValue, BufferUnit, BufferTitle);
/*
  		wsprintf(BufferValue, TEXT(""));
		showunit=false;
  		wsprintf(BufferTitle, TEXT(""));
*/
/*
// TODO MAKE IT LKPROCESS
		// this requires some fixes so it is disabled
		if (LoggerActive) {
  			wsprintf(BufferValue, TEXT("ON"));
      		} else {
  			wsprintf(BufferValue, TEXT("OFF"));
 			TextDisplayMode.AsFlag.Color = TEXTRED;
		}

		showunit=false;
  		wsprintf(BufferTitle, TEXT("Logger"));
*/
d1277 2
a1278 1
		LKFormatValue(LK_ALTERN2_GR, false, BufferValue, BufferUnit, BufferTitle);
a1279 34
/* never used
		if (OnAlternate2==false) {
  			wsprintf(BufferTitle, TEXT("Altrn2"));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
			break;
		}
*/
/*
		if ( ValidWayPoint(Alternate2)) {
			Value=WayPointCalc[Alternate2].GR;
			if (Value <1 || Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"---"); else
				{
				if (Value>99) sprintf(text,"%.0f",Value);
				else sprintf(text,"%.1f",Value);
				}

  			wsprintf(BufferValue, TEXT("%S"),text);
			wlen=wcslen(WayPointList[Alternate2].Name);
			if (wlen>8) {
				_tcsncpy(Buffer, WayPointList[Alternate2].Name, 8); Buffer[8]='\0';
			}
			else {
				_tcsncpy(Buffer, WayPointList[Alternate2].Name, wlen); Buffer[wlen]='\0';
			}
			_tcscpy(BufferTitle,Buffer);
			showunit=false;
		} else {
			//OnAlternate2=false;
  			wsprintf(BufferTitle, TEXT("Altrn2"));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
		}
*/
d1283 2
a1284 1
		showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d1287 1
a1287 1
		showunit=LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
a1293 22
/*
  SelectObject(hdc, LK8ValueFont);
  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
  rcy=rc.bottom-(TextSize.cy/2);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  /TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   

  if (showunit==true && !HideUnits) {
#if (WINDOWSPC>0)
	  SelectObject(hdc, LK8UnitFont);
#else
	  SelectObject(hdc, LK8UnitFont);
#endif
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	/TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
  }

  SelectObject(hdc, LK8TitleFont);
  GetTextExtentPoint(hdc, BufferTitle, _tcslen(BufferTitle), &TextSize);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
*/
  //TextInBox(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy , 0, TextDisplayMode, false);  
a1294 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
d1305 1
a1305 8
		showunit=LKFormatValue(LK_VARIO, false, BufferValue, BufferUnit, BufferTitle);
/*
		Value = LIFTMODIFY*CALCULATED_INFO.Vario;
		sprintf(text,"%+.1lf",Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
		wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
	 	wsprintf(BufferTitle, TEXT("Vario"),text);
*/
d1308 1
a1308 12
		showunit=LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);
/*
	  	Value=DerivedDrawInfo.AverageLD;
	  	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"++"); else
		if (Value==0) {
			sprintf(text,"---"); 
			//sprintf(text,"%c",0xa5);
		} else sprintf(text,"%.0f",Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
		showunit=false;
 		wsprintf(BufferTitle, TEXT("E"),text);
*/
d1311 1
a1311 1
		LKFormatValue(LK_LD_CRUISE, false, BufferValue, BufferUnit, BufferTitle);
a1312 9
/*
	  	Value=DerivedDrawInfo.CruiseLD;
	  	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"++"); else
		if (Value==0) sprintf(text,"---");
		else sprintf(text,"%.0f",Value);
  		wsprintf(BufferValue, TEXT("%S"),text);
		showunit=false;
 		wsprintf(BufferTitle, TEXT("cruE"),text);
*/
a1315 11
/*
  		Value=TASKSPEEDMODIFY*CALCULATED_INFO.TaskSpeedAchieved;
		if (Value>0 && Value<999) {
  			sprintf(text,"%d",(int)Value);
  			wsprintf(BufferValue, TEXT("%S"),text);
		} else {
  			wsprintf(BufferValue, TEXT("---"));
		}
  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetHorizontalSpeedName()));
  		wsprintf(BufferTitle, TEXT("Speed"));
*/
d1323 1
a1323 1
 			TextDisplayMode.AsFlag.Color = TEXTRED;
a1324 2

		showunit=false;
d1329 2
a1330 23
		LKFormatValue(LK_ALTERN2_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
/* non usato
		if (OnAlternate2==false) {
  			wsprintf(BufferTitle, TEXT(""));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
			break;
		}
*/
/*
		if ( ValidWayPoint(Alternate2)) {
			Value=ALTITUDEMODIFY*WayPointCalc[Alternate2].AltArriv;
			if (Value <-9999 ||  Value >9999 ) strcpy(text,"---"); 
				else sprintf(text,"%+.0f",Value);
  			wsprintf(BufferValue, TEXT("%S"),text);
			_tcscpy(BufferTitle,_T(""));
  			wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
		} else {
  			wsprintf(BufferTitle, TEXT(""));
  			wsprintf(BufferValue, TEXT("---"));
			showunit=false;
		}
*/
d1334 2
a1335 1
		showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
d1338 1
a1338 1
		showunit=LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
a1344 21
/*
  SelectObject(hdc, LK8ValueFont);
  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
  rcy=rc.bottom-(TextSize.cy/2);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  /TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   

  if (showunit==true && !HideUnits) {
#if (WINDOWSPC>0)
	  SelectObject(hdc, LK8UnitFont);
#else
	  SelectObject(hdc, LK8UnitFont);
#endif
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	/TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(1) , 0, TextDisplayMode, false);   
  }
  SelectObject(hdc, LK8TitleFont);
  GetTextExtentPoint(hdc, BufferTitle, _tcslen(BufferTitle), &TextSize);
  TextDisplayMode.AsFlag.AlligneCenter = 1;
*/
  //TextInBox(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy , 0, TextDisplayMode, false);  
a1345 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
a1368 6
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  //TextDisplayMode.AsFlag.AlligneRight = 0;
  //TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextDisplayMode.AsFlag.WhiteBold = 1;
a1371 11
/* REMOVE
  if (DerivedDrawInfo.WindSpeed>0) { 
	  Value = DerivedDrawInfo.WindBearing;
	  if (Value==360) Value=0; 
	  _stprintf(Buffer,TEXT("%1.0f")_T(DEG)_T("/%1.0f"), Value, SPEEDMODIFY*DerivedDrawInfo.WindSpeed );
  } else
  {
	  _stprintf(Buffer,TEXT("--/--"));
  }
*/
// GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
a1375 1
//  	TextInBox(hdc, Buffer, rc.left+IBLSCALE(5), rc.bottom - BottomSize- rcy-IBLSCALE(2), 0, TextDisplayMode, false);
a1377 1
//  	TextInBox(hdc, BufferValue, rc.left+IBLSCALE(5), rc.bottom - rcy - IBLSCALE(5), 0, TextDisplayMode, false);
a1381 1
  	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
a1382 1
  	TextDisplayMode.AsFlag.AlligneCenter = 1;
a1384 1
  		//TextInBox(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, TextDisplayMode, false);
a1386 1
  	//	TextInBox(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, TextDisplayMode, false);
a1392 1
  	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
a1393 1
  	TextDisplayMode.AsFlag.AlligneCenter = 1;
a1394 1
  	//TextInBox(hdc, Buffer, rc.right - (TextSize.cx)-IBLSCALE(20) ,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, TextDisplayMode, false);
a1404 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
a1411 8
///: Relies on MapSpaceMode content:
///:	0= welcome screen
///:	1= moving map
///:	2= nearest landables
///:	3= nearest airports
///:	4= recent waypoints
///:	...
///:
d1432 1
a1432 5

  //short bottomlines;
  //short middlex=(rc.right-rc.left)/2;
  //short left=rc.left+IBLSCALE(5);
  //short contenttop=rc.top+IBLSCALE(50);
a1458 12
//  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[8], p[9], RGB_ORANGE, rc);
/*
  POINT p1,p2;
  p1.x=0; p1.y=rc.bottom-BottomSize-IBLSCALE(2); p2.x=rc.right; p2.y=p1.y;
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
  p1.x=0; p1.y=0; p2.x=rc.right; p2.y=0;
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
  p1.x=0; p1.y=0; p2.x=0; p2.y=rc.bottom-BottomSize-IBLSCALE(2);
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
  p1.x=rc.right; p1.y=0; p2.x=rc.right; p2.y=rc.bottom-BottomSize-IBLSCALE(2);
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
*/
d1516 1
a1524 1
  TextInBoxMode_t TextDisplayMode;
a1531 6
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  //TextDisplayMode.AsFlag.AlligneRight = 0;
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  TextDisplayMode.AsFlag.WhiteBold = 0;
a1548 1
  //TextInBox(hdc, Buffer, middlex, (TextSize.cy/2)+IBLSCALE(2) , 0, TextDisplayMode, false);
a1551 1
  //TextInBox(hdc, Buffer, middlex, (TextSize.cy/2)+TextSize.cy-IBLSCALE(4) , 0, TextDisplayMode, false);
a1553 5
  //TextDisplayMode.AsFlag.AlligneCenter = 0;


  //TextDisplayMode.AsFlag.Color = TEXTWHITE;

a1588 2
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  TextDisplayMode.AsFlag.WhiteBold = 0;
a1590 1
  //TextInBox(hdc, Buffer, middlex, contenttop+(TextSize.cy*1) , 0, TextDisplayMode, false);
a1592 1
  TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
a1593 2
  //TextInBox(hdc, Buffer, middlex, contenttop+(TextSize.cy*4) , 0, TextDisplayMode, false);
  //TextInBox(hdc, Buffer, middlex, ((rc.bottom-rc.top)-BottomSize)/2 , 0, TextDisplayMode, false);
a1596 2
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.AlligneCenter = 1;
a1599 1
  //TextInBox(hdc, Buffer, middlex, bottomlines , 0, TextDisplayMode, false);
a1601 1
  //TextInBox(hdc, Buffer, middlex, bottomlines+TextSize.cy , 0, TextDisplayMode, false);
a1617 1
  TextInBoxMode_t TextDisplayMode;
d1619 1
a1619 1
  static RECT SortBox[6]; 
d1645 2
a1646 2
  HPEN hpen;
  HPEN oldpen;
d1649 1
d1654 5
a1658 2
  	sortbrush=CreateSolidBrush(RGB_LIGHTGREEN);
	hpen=(HPEN)CreatePen(PS_SOLID,2,RGB_DARKGREEN);
d1661 1
a1661 1
	hpen=(HPEN)CreatePen(PS_SOLID,2,RGB_BLACK);
d1755 6
a1760 6
  SortBox[0].left=Column0; // FIX 090925 era solo 0
  if ( ScreenSize < (ScreenSize_t)sslandscape ) SortBox[0].right=left+WPTextSize.cx-IBLSCALE(2);
  else SortBox[0].right=left+WPTextSize.cx-IBLSCALE(10);
  SortBox[0].top=2;
  SortBox[0].bottom=p1.y;
  SortBoxX[0]=SortBox[0].right;
d1763 6
a1768 6
  if ( ScreenSize < (ScreenSize_t)sslandscape ) SortBox[1].left=Column1+afterwpname-INTERBOX;
  else SortBox[1].left=Column1+afterwpname-INTERBOX-IBLSCALE(2);
  SortBox[1].right=Column2+INTERBOX;
  SortBox[1].top=2;
  SortBox[1].bottom=p1.y;
  SortBoxX[1]=SortBox[1].right;
d1771 5
a1775 5
  SortBox[2].left=Column2+INTERBOX;
  SortBox[2].right=Column3+INTERBOX;
  SortBox[2].top=2;
  SortBox[2].bottom=p1.y;
  SortBoxX[2]=SortBox[2].right;
d1778 5
a1782 5
  SortBox[3].left=Column3+INTERBOX;
  SortBox[3].right=Column4+INTERBOX;
  SortBox[3].top=2;
  SortBox[3].bottom=p1.y;
  SortBoxX[3]=SortBox[3].right;
d1785 6
a1790 6
  SortBox[4].left=Column4+INTERBOX;
  //SortBox[4].right=Column5+INTERBOX;
  SortBox[4].right=rc.right-1;
  SortBox[4].top=2;
  SortBox[4].bottom=p1.y;
  SortBoxX[4]=SortBox[4].right;
a1812 5
/*
  Numpages=(short)ceil( (float)SortedNumber / (float)Numraws );
  if (Numpages>MAXNUMPAGES) Numpages=MAXNUMPAGES;
  else if (Numpages<1) Numpages=1;
*/
a1849 1
//		MapSpaceMode=MSM_MAP; //FIX REMOVE NOW
a1888 7
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  //TextDisplayMode.AsFlag.AlligneRight = 0;
  //TextDisplayMode.AsFlag.AlligneCenter = 0;
  //TextDisplayMode.AsFlag.WhiteBold = 0;

d1898 1
a1898 1
  TextDisplayMode.AsFlag.AlligneRight = 0;
d1900 1
a1900 1
  short cursortbox=SortedMode[MapSpaceMode];
d1903 3
a1905 3
	FillRect(hdc,&SortBox[cursortbox], sortbrush); 
	oldpen=(HPEN)SelectObject(hdc,hpen);
	Rectangle(hdc,SortBox[cursortbox].left, SortBox[cursortbox].top, SortBox[cursortbox].right, SortBox[cursortbox].bottom); //QUIQUI
a1909 1
//	TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
a1914 1
// 		_stprintf(Buffer,TEXT("Landabl %d-%d"), curpage+1,Numpages); 
a1916 1
// 	 	_stprintf(Buffer,TEXT("Airport %d-%d"), curpage+1, Numpages); 
a1917 3
	//if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
 	//TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
a1922 1
	TextDisplayMode.AsFlag.AlligneRight = 1;
a1923 3
//	if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
//	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
a1929 3
	//if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
a1935 3
	//if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
a1941 3
	//if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
d1949 3
a1951 3
	FillRect(hdc,&SortBox[cursortbox], sortbrush);  
	oldpen=(HPEN)SelectObject(hdc,hpen);
	Rectangle(hdc,SortBox[cursortbox].left, SortBox[cursortbox].top, SortBox[cursortbox].right, SortBox[cursortbox].bottom); //QUIQUI
a1957 1
		//TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
a1961 1
//			_stprintf(Buffer,TEXT("Landables %d-%d"), curpage+1,Numpages); 
a1963 1
//			_stprintf(Buffer,TEXT("Airports %d-%d"), curpage+1, Numpages); 
a1964 3
		//if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		//TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false); // WAS Column1 FIX CHECK VENTA
a1969 1
		TextDisplayMode.AsFlag.AlligneRight = 1;
a1970 3
		//if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
a1976 3
		//if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
a1982 3
		//if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
a1988 3
		//if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
a1996 1
		//TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
a2000 1
//			_stprintf(Buffer,TEXT("Landables %d-%d"), curpage+1,Numpages); 
a2002 1
//			_stprintf(Buffer,TEXT("Airports %d-%d"), curpage+1, Numpages); 
a2003 3
		//if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		//TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
a2008 1
		TextDisplayMode.AsFlag.AlligneRight = 1;
a2009 3
		//if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
a2015 3
		//if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
a2021 3
		//if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
a2027 3
	//	if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//	TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
a2036 2
 //// GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &HLTextSize);

a2040 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
a2075 3
		//wlen=wcslen(Buffer); // TODO FIX REMOVE
		//if (wlen>MAXNLNAME) DoStatusMessage(Buffer);
		//wsprintf(Buffer, _T("MMMMMMM")); // TEST
d2147 1
a2147 2
		if ( ((WayPointList[rli].Flags & AIRPORT) == AIRPORT) ) ///&& 
		//( (WayPointList[rli].Flags & LANDPOINT) != LANDPOINT) ) // BUGGGGG FIX CHECK HERE rli not i VENTA TODO
a2148 1
			TextDisplayMode.AsFlag.Color = TEXTWHITE;
a2151 1
			TextDisplayMode.AsFlag.Color = TEXTLIGHTYELLOW;
a2156 1
			//TextDisplayMode.AsFlag.Color = TEXTLIGHTRED;
a2158 1
			//TextDisplayMode.AsFlag.Color = TEXTGREY;
a2159 1
	TextDisplayMode.AsFlag.AlligneRight = 0;
a2160 1
	//TextInBox(hdc, Buffer1[i][curpage], Column1, iRaw , 0, TextDisplayMode, false);
a2164 1
	TextDisplayMode.AsFlag.AlligneRight = 1;
a2165 1
	//TextInBox(hdc, Buffer2[i][curpage], Column2, iRaw , 0, TextDisplayMode, false);
a2168 1
	//TextInBox(hdc, Buffer3[i][curpage], Column3, iRaw , 0, TextDisplayMode, false);
a2171 1
	//TextInBox(hdc, Buffer4[i][curpage], Column4, iRaw , 0, TextDisplayMode, false);
a2174 1
	//TextInBox(hdc, Buffer5[i][curpage], Column5, iRaw , 0, TextDisplayMode, false);
a2188 1
  //if (ValidWayPoint(rli) ) { bug
a2207 20
//	POINT sp1, sp2;
/*
	sp1.x=left-1;
	sp1.y=TopSize+(rawspace*SelectedRaw[MapSpaceMode])+IBLSCALE(2);
	sp2.x=right+1;
	sp2.y=sp1.y;


	if (INVERTCOLORS)
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
	else
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_DARKGREEN, rc);

	sp1.y=TopSize+(rawspace*(SelectedRaw[MapSpaceMode]+1))-IBLSCALE(1);
	sp2.y=sp1.y;
	if (INVERTCOLORS)
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
	else
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_DARKGREEN, rc);
*/
d2214 1
a2214 1
	Rectangle(hdc,invsel.left-1,invsel.top-1,invsel.right+1,invsel.bottom+1);
d2219 2
a2220 1
  SelectObject(hdc,oldpen);
d2222 1
a2222 1
  DeleteObject(hpen);
a2288 1
  TextInBoxMode_t TextDisplayMode;
d2290 1
a2290 1
  static RECT SortBox[6]; 
a2312 1
  HBRUSH sortbrushl;
d2314 2
a2315 2
  HPEN selpen;
  HPEN oldpen;
d2321 1
a2321 1
	selpen=(HPEN)CreatePen(PS_SOLID,2,RGB_DARKGREEN);
d2324 1
a2324 1
	selpen=(HPEN)CreatePen(PS_SOLID,2,RGB_BLACK);
a2380 2
  ///: limit intercolumn to something reasonable..
  //if (intercolumn>IBLSCALE(35)) intercolumn=IBLSCALE(35);
d2415 6
a2420 6
  SortBox[0].left=0;
  if ( ScreenSize < (ScreenSize_t)sslandscape ) SortBox[0].right=left+WPTextSize.cx-IBLSCALE(2);
  else SortBox[0].right=left+WPTextSize.cx-IBLSCALE(10);
  SortBox[0].top=0;
  SortBox[0].bottom=p1.y;
  SortBoxX[0]=SortBox[0].right;
d2423 6
a2428 6
  if ( ScreenSize < (ScreenSize_t)sslandscape ) SortBox[1].left=Column1+afterwpname-INTERBOX;
  else SortBox[1].left=Column1+afterwpname-INTERBOX-IBLSCALE(2);
  SortBox[1].right=Column2+INTERBOX;
  SortBox[1].top=0;
  SortBox[1].bottom=p1.y;
  SortBoxX[1]=SortBox[1].right;
d2431 5
a2435 5
  SortBox[2].left=Column2+INTERBOX;
  SortBox[2].right=Column3+INTERBOX;
  SortBox[2].top=0;
  SortBox[2].bottom=p1.y;
  SortBoxX[2]=SortBox[2].right;
d2438 5
a2442 5
  SortBox[3].left=Column3+INTERBOX;
  SortBox[3].right=Column4+INTERBOX;
  SortBox[3].top=0;
  SortBox[3].bottom=p1.y;
  SortBoxX[3]=SortBox[3].right;
d2445 5
a2449 5
  SortBox[4].left=Column4+INTERBOX;
  SortBox[4].right=Column5+INTERBOX;
  SortBox[4].top=0;
  SortBox[4].bottom=p1.y;
  SortBoxX[4]=SortBox[4].right;
a2520 1
//		MapSpaceMode=MSM_MAP;
a2557 7
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  //TextDisplayMode.AsFlag.AlligneRight = 0;
  //TextDisplayMode.AsFlag.AlligneCenter = 0;
  //TextDisplayMode.AsFlag.WhiteBold = 0;

a2566 1
  TextDisplayMode.AsFlag.AlligneRight = 0;
d2572 1
a2577 1
	//TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
a2581 1
//  		_stprintf(Buffer,TEXT("Commons %d-%d"), curpage+1, CommonNumpages); 
a2583 1
//  		_stprintf(Buffer,TEXT("Recent %d-%d"), curpage+1, CommonNumpages); 
d2585 1
a2585 7
//	if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
//	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
 //	TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
///	if (cursortbox==0)
///		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK);
///	else
		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
a2587 1
	TextDisplayMode.AsFlag.AlligneRight = 1;
a2588 2
	//if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
a2589 2
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
a2592 3
	//if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
a2595 3
	//if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
a2598 3
	//if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
a2602 1
	//FillRect(hdc,&SortBox[cursortbox], sortbrush); 
a2606 1
	//TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
a2611 1
//			_stprintf(Buffer,TEXT("Commons %d-%d"), curpage+1,CommonNumpages); 
a2613 1
//			_stprintf(Buffer,TEXT("Recent %d-%d"), curpage+1,CommonNumpages); 
a2614 3
		//if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		//TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
a2616 1
		TextDisplayMode.AsFlag.AlligneRight = 1;
a2617 2
		//if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
a2618 1
		TextDisplayMode.AsFlag.Color = TEXTWHITE;
a2622 3
		//if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
a2625 3
		//if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
a2628 3
		//if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
a2631 1
//			_stprintf(Buffer,TEXT("Commons %d-%d"), curpage+1,CommonNumpages); 
a2633 1
//			_stprintf(Buffer,TEXT("Recent %d-%d"), curpage+1,CommonNumpages); 
a2634 3
		//if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		//TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
a2636 1
		TextDisplayMode.AsFlag.AlligneRight = 1;
a2637 4
		//if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
a2640 3
		//if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
a2643 3
		//if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
a2646 3
		//if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		//else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		//TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
a2652 3
 //// GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &HLTextSize);


a2655 1
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
a2682 1
	//rli=CommonIndex[curraw]; OLD
a2696 3
		//wlen=wcslen(Buffer);
		//if (wlen>MAXNLNAME) DoStatusMessage(Buffer);
		//wsprintf(Buffer, _T("MMMMMMM")); // TEST
a2764 1
		TextDisplayMode.AsFlag.Color = TEXTWHITE;
a2771 1
	TextDisplayMode.AsFlag.AlligneRight = 0;
a2772 1
	//TextInBox(hdc, Buffer1[i][curpage], Column1, iRaw , 0, TextDisplayMode, false);
a2776 1
	TextDisplayMode.AsFlag.AlligneRight = 1;
a2777 1
	//TextInBox(hdc, Buffer2[i][curpage], Column2, iRaw , 0, TextDisplayMode, false);
a2780 1
	//TextInBox(hdc, Buffer3[i][curpage], Column3, iRaw , 0, TextDisplayMode, false);
a2783 1
	//TextInBox(hdc, Buffer4[i][curpage], Column4, iRaw , 0, TextDisplayMode, false);
a2786 1
	//TextInBox(hdc, Buffer5[i][curpage], Column5, iRaw , 0, TextDisplayMode, false);
d2801 1
a2801 2
//  if (ValidWayPoint(rli) ) { bug
    if (drawn_items_onpage>0) {
a2820 18
/*
	POINT sp1, sp2;
	sp1.x=left;
	sp1.y=TopSize+(rawspace*SelectedRaw[MapSpaceMode])+IBLSCALE(2);
	sp2.x=right;
	sp2.y=sp1.y;
	if (INVERTCOLORS)
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
	else
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_DARKGREEN, rc);

	sp1.y=TopSize+(rawspace*(SelectedRaw[MapSpaceMode]+1))-IBLSCALE(1);
	sp2.y=sp1.y;
	if (INVERTCOLORS)
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
	else
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_DARKGREEN, rc);
*/
d2826 3
a2828 3
	oldpen=(HPEN)SelectObject(hdc,selpen);
	Rectangle(hdc,invsel.left-1,invsel.top-1,invsel.right+1,invsel.bottom+1);
  	SelectObject(hdc,oldpen);
d2831 1
a2831 1
  DeleteObject(selpen);
a2861 1
  TextInBoxMode_t TextDisplayMode;
a2992 7
	TextDisplayMode.AsInt = 0;
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextDisplayMode.AsFlag.WhiteBold = 0; // outlined 
	TextDisplayMode.AsFlag.NoSetFont = 1; 
	TextDisplayMode.AsFlag.AlligneRight = 0;
	TextDisplayMode.AsFlag.AlligneCenter = 1;

a3015 7
	///: Start painting values 
	///:

	TextDisplayMode.AsInt = 0;
	TextDisplayMode.AsFlag.NoSetFont = 1; 

	///:
a3018 1
        TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
a3038 1
        //TextInBox(hdc, Buffer, qcolumn[0],qrow[0], 0, TextDisplayMode, false);
a3065 3
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
        TextDisplayMode.AsFlag.AlligneCenter = 1;
        //TextInBox(hdc, Buffer, qcolumn[8],qrow[1], 0, TextDisplayMode, false);
a3071 3
        TextDisplayMode.AsFlag.AlligneCenter = 0;
        TextDisplayMode.AsFlag.AlligneRight = 1;
        //TextInBox(hdc, BufferValue, qcolumn[16],qrow[0], 0, TextDisplayMode, false);
a3500 6
        TextDisplayMode.AsInt = 0;
        TextDisplayMode.AsFlag.Color = TEXTORANGE;
        TextDisplayMode.AsFlag.WhiteBold = 1; // outlined
        TextDisplayMode.AsFlag.NoSetFont = 1;
        TextDisplayMode.AsFlag.AlligneCenter = 1;
	//TextInBox(hdc, BufferTitle, qcolumn[8],qrow[12], 0, TextDisplayMode, false);   // NAME
a3511 4
	TextInBoxMode_t TextDisplayMode;
        TextDisplayMode.AsInt = 0;
	TextDisplayMode.AsFlag.NoSetFont = 1;

a3512 3
        TextDisplayMode.AsFlag.Color = TEXTWHITE;
        TextDisplayMode.AsFlag.AlligneRight = 1;
        //TextInBox(hdc, BufferValue, *columnvalue,*row1, 0, TextDisplayMode, false);
a3516 2
	        TextDisplayMode.AsFlag.AlligneRight = 0;
	        //TextInBox(hdc, BufferUnit, *columnvalue,*row2, 0, TextDisplayMode, false);
a3518 3
        TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
        TextDisplayMode.AsFlag.AlligneRight = 1;
        //TextInBox(hdc, BufferTitle, *columntitle,*row3, 0, TextDisplayMode, false);
a3732 1
  //TextInBox(hDC, Buffer, Start.x , bankindy, 0, Mode, false);
a3872 1
			SetBkMode(hDC,TRANSPARENT);
a3919 1
//			SetBkMode(hDC,TRANSPARENT);
d3976 3
a3978 3
  HPEN hpen;
  HPEN oldpen;
  HPEN selpen;
d3985 2
a3986 2
	hpen=(HPEN)CreatePen(PS_SOLID,2,RGB_DARKGREEN);
	selpen=(HPEN)CreatePen(PS_SOLID,2,RGB_DARKGREEN);
d3989 2
a3990 2
	hpen=(HPEN)CreatePen(PS_SOLID,2,RGB_BLACK);
	selpen=(HPEN)CreatePen(PS_SOLID,2,RGB_BLACK);
d4218 2
a4219 2
	SelectObject(hdc,hpen);
	Rectangle(hdc,s_sortBox[cursortbox].left, s_sortBox[cursortbox].top, s_sortBox[cursortbox].right, s_sortBox[cursortbox].bottom); //QUIQUI
d4260 2
a4261 2
	SelectObject(hdc,hpen);
	Rectangle(hdc,s_sortBox[cursortbox].left, s_sortBox[cursortbox].top, s_sortBox[cursortbox].right, s_sortBox[cursortbox].bottom); //QUIQUI
a4479 1
  //if (ValidWayPoint(rli) ) { bug
a4497 18
/*
	POINT sp1, sp2;
	sp1.x=left;
	sp1.y=TopSize+(s_rawspace*SelectedRaw[MapSpaceMode])+IBLSCALE(2);
	sp2.x=right;
	sp2.y=sp1.y;
	if (INVERTCOLORS)
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
	else
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_DARKGREEN, rc);

	sp1.y=TopSize+(s_rawspace*(SelectedRaw[MapSpaceMode]+1))-IBLSCALE(1);
	sp2.y=sp1.y;
	if (INVERTCOLORS)
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
	else
		_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_DARKGREEN, rc);
*/
d4503 4
a4506 4
	oldpen=(HPEN)SelectObject(hdc,selpen);
	Rectangle(hdc,invsel.left-1,invsel.top-1,invsel.right+1,invsel.bottom+1);
  	SelectObject(hdc,oldpen);
	DeleteObject(selpen);
d4512 1
a4512 1
  DeleteObject(hpen);
@


8.25
log
@pre tunrpoi
m
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.24 2009/09/21 08:58:36 root Exp root $
d40 1
a1149 2
#if (WINDOWSPC>0)

d1151 3
a1153 3
  HBRUSH hB,bB;

  if ( INVERTCOLORS )
d1155 2
a1156 1
  else
d1158 2
d1161 1
a1174 6
  // static HBRUSH hB= CreateSolidBrush(RGB_VDARKGREY); // dark grey (previous 0x26) 
  HBRUSH hB;
  if ( INVERTCOLORS )
  	hB= CreateSolidBrush(RGB_NDARK); // dark grey (previous 0x26) 
  else
	hB= CreateSolidBrush(RGB_NLIGHT); 
d2024 2
a2025 1

a2026 1
  DeleteObject(hB);
a2028 2
#else
  DeleteObject(hB); // CHECK BUGFIX 090922
d2030 1
a2030 1
  ;  
d2207 3
d2391 3
d2398 1
a2398 1
  if (INVERTCOLORS)
d2400 2
a2401 1
  else
d2403 2
d2449 1
a2449 1
  SelectObject(hdc, LK8InfoNormalFont); // Heading line  was MapWindow QUI
d2497 1
a2497 1
  SortBox[0].left=0;
d2500 1
a2500 1
  SortBox[0].top=0;
d2508 1
a2508 1
  SortBox[1].top=0;
d2515 1
a2515 1
  SortBox[2].top=0;
d2522 1
a2522 1
  SortBox[3].top=0;
d2528 3
a2530 2
  SortBox[4].right=Column5+INTERBOX;
  SortBox[4].top=0;
d2554 1
a2554 1
  ///: Recalculate real number of pages... BUG FIX QUI
d2591 2
a2592 2
			///:if (SortedNumber)
			DoStatusMessage(_T("Invalid selection")); // 090912 TODO FIX this happening
d2659 2
d2666 1
d2679 2
a2680 3
	///: TODO we can disable this
	if (cursortbox==0)
 		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_BLACK);
d2682 1
a2682 1
 		LKWriteText(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, WTMODE_NORMAL, WTALIGN_LEFT, RGB_LIGHTGREEN);
d2723 3
a2725 1
	FillRect(hdc,&SortBox[cursortbox], sortbrush); 
d2750 1
a2750 1
		TextDisplayMode.AsFlag.AlligneRight = 1; //QUIQUI
d2891 1
a2891 1
		//wlen=wcslen(Buffer); // TODO FIX QUI REMOVE
d3039 3
a3041 2
	POINT sp1, sp2;
	sp1.x=left;
d3043 1
a3043 1
	sp2.x=right;
d3045 2
d3058 9
d3070 1
d3072 1
d3080 2
d3165 4
a3168 1

d3171 1
a3171 1
  if (INVERTCOLORS)
d3173 2
a3174 1
  else
d3176 2
d3222 1
a3222 1
  SelectObject(hdc, LK8InfoNormalFont); // Heading line  was MapWindow QUI
d3369 1
a3369 1
				DoStatusMessage(_T("Invalid selection"));
d3626 1
a3626 1
		//wlen=wcslen(Buffer); // TODO FIX QUI REMOVE
d3762 1
a3762 1

d3779 9
d3790 1
d4940 598
@


8.24
log
@t1
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.23 2009/09/20 20:28:35 root Exp root $
a24 16
//#include "Terrain.h"
//#include "Task.h"
//#include "AATDistance.h"
//#include "GaugeVarioAltA.h"
//#include "GaugeCDI.h"
//#include "GaugeFLARM.h"
//#include "OnLineContest.h"
//#include "Utils.h"
//#include "Logger.h"
//#include "Airspace.h"
//#include "Waypointparser.h"
//#include "Dialogs.h"
//#include "VarioSound.h"
//#include <assert.h>
//#include "RasterTerrain.h"

d27 1
a32 3
//int misc_tick_count=0;
//int VisualGlide = 0;

a50 3
//#define NUMSNAILRAMP 6
//static const COLORREF taskcolor = RGB(0,120,0); // was 255
//bool timestats_dirty=false;
d71 3
a73 8
extern HFONT  TitleWindowFont;
extern HFONT  TitleSmallWindowFont;
extern HFONT  MapWindowFont;
extern HFONT  MapWindowBoldFont;
extern HFONT  InfoWindowFont;
extern HFONT  CDIWindowFont;
extern HFONT  StatisticsFont;
extern HFONT  MapLabelFont;
a74 1
//short NewMapDeclutter=0; // 0=none 1=
a103 1
  // hopefully the time we spend here is compensated by the time saved painting unnecessary outlandings
d643 2
a644 1
  oldfont = (HFONT)SelectObject(hdc, MapWindowBoldFont);
d652 2
a653 1
/* uncomment to make it toggling colors
d661 1
a661 1
*/
a683 1
    //		if (count > 0) {
a686 19
    /*
      switch (count) {
      case 1:
      case 3:
      case 5:
      case 7:
      oldcolor=SetTextColor(hdc, RGB(0xff,0xff,0xff)); // white
      break;
      case 2:
      case 4:
      case 6:
      case 8:
      oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x20));
      break;
      default:
      oldcolor=SetTextColor(hdc, RGB(0x00,0x00,0xff)); // blue
      break;
      }
    */
a693 2
    //		}
    //		if (count >0) {
a695 17
    /*
      switch (count) {
      case 1:
      case 3:
      case 5:
      oldcolor=SetTextColor(hdc, RGB(0x00,0x00,0xff)); // blue
      break;
      case 2:
      case 4:
      case 6:
      oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x20));
      break;
      default:
      oldcolor=SetTextColor(hdc, RGB(0x00,0x00,0xff)); // blue
      break;
      }
    */
a715 1
    //		}
a719 41

/*
  if (NewMap&&OutlinedTp)
    oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); // dark grey 0x50
  else {
    if (turn>0||true) 
      oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); // dark grey 0x50
    else 
      oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x00)); // red
  }
  wsprintf(gtext,_T("L/D:%d"),(int)cruise);

  //ExtTextOut( hdc, Orig.x+30, Orig.y +20 , 0, NULL, gtext , _tcslen(gtext), NULL );
  //ExtTextOut( hdc, Orig.x-30, Orig_Aircraft.y +50 , 0, NULL, gtext , _tcslen(gtext), NULL );
  //ExtTextOut( hdc, (rc.left+rc.right)/2, rc.top+rc.bottom-20 , 0, NULL, gtext , _tcslen(gtext), NULL );

  if (NewMap&&OutlinedTp) {
    ExtTextOut( hdc, rcx+2, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx+1, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx-1, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx-2, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy+1 , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy-1 , 0, NULL, gtext , _tcslen(gtext), NULL );

#ifdef PNA
    if (GlobalModelType == MODELTYPE_PNA_HP31X ) {
	    ExtTextOut( hdc, rcx+3, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
	    ExtTextOut( hdc, rcx-3, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
	    ExtTextOut( hdc, rcx, rcy+2 , 0, NULL, gtext , _tcslen(gtext), NULL );
	    ExtTextOut( hdc, rcx, rcy-2 , 0, NULL, gtext , _tcslen(gtext), NULL );
	    ExtTextOut( hdc, rcx, rcy+3 , 0, NULL, gtext , _tcslen(gtext), NULL );
	    ExtTextOut( hdc, rcx, rcy-3 , 0, NULL, gtext , _tcslen(gtext), NULL );
    }
#endif

    SetTextColor(hdc,RGB(0xff,0xff,0xff));
  }
  ExtTextOut( hdc, rcx, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
*/


d764 1
a764 1
	oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // save font
a833 2
//  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));

a851 1
	//SelectObject(hdc, StatisticsFont); // FIX ORIG
d855 1
a855 1
#ifdef DISABLED
d867 1
d876 2
a877 1
 	 TextInBox(hdc, Buffer, rcx+IBLSCALE(2),rcy, 0, TextDisplayMode, false);   // NAME
d880 11
d893 1
a893 14
/*
		 Value=CALCULATED_INFO.WaypointDistance*DISTANCEMODIFY; 
		 if ( Units::GetUserDistanceUnit() == unKiloMeter )  {
			if (Value > 100) sprintf(text,"%.0lf km",Value);
			else sprintf(text,"%.1lf km",Value);
		 } else {
			if (Value > 100) sprintf(text,"%.0lf m",Value);
			else sprintf(text,"%.1lf m",Value);
			//  sprintf(text,"%0.1f m",WayPointCalc[index].Distance*DISTANCEMODIFY); // good for both nautical and statute miles
		 }
	//	 wsprintf(Buffer, TEXT("%S"), text);
*/

	 TextInBox(hdc, Buffer, rcx+IBLSCALE(2),rcy+TextSize.cy, 0, TextDisplayMode, false); 
d898 2
a899 2
	 SelectObject(hdc, MapWindowFont);
	 TextInBox(hdc, BufferUnit, rcx+IBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-IBLSCALE(1), 0, TextDisplayMode, false); 
d901 1
d907 2
d932 1
a933 1
  	  // SelectObject(hdc, InfoWindowFont); // FIX ORIG
d941 2
a942 1
	  TextInBox(hdc, Buffer, (rc.right+rc.left)/2, rc.top+ IBLSCALE(15), 0, TextDisplayMode, false);
a949 1
	  //SelectObject(hdc, InfoWindowFont); // use this font for big values
d957 11
a967 1
	  //if ( AircraftCategory == (AircraftCategory_t)umParaglider ) 
d982 2
a983 1
	  TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  // GR
d987 5
a991 2
	  _stprintf(Buffer,TEXT("%+1.0f"), ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
	  TextInBox(hdc, Buffer, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, TextDisplayMode, false);   // ALT
a996 1
  //if ( (Look8000=(Look8000_t)lxcAdvanced) || (AircraftCategory == (AircraftCategory_t)umParaglider)) { BUG HERE
d1007 2
d1015 1
a1015 9

//		GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
//		rcx=rc.left+IBLSCALE(1);
//		rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);

		//TextInBox(hdc, Buffer, rcx, rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
		//wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
		//SelectObject(hdc, MapWindowFont); 
		//TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
d1017 2
d1024 1
a1024 10

//		GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
//		rcx=rc.left+IBLSCALE(1); 
//		rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);

		//TextInBox(hdc, Buffer, rcx+IBLSCALE(9), rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
		//wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
		//SelectObject(hdc, MapWindowFont); 
		//TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   

d1026 2
a1027 2

	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1032 3
a1034 1
		TextInBox(hdc, Buffer, rcx, rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
d1036 4
a1039 3
			wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
			SelectObject(hdc, MapWindowFont); 
			TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
d1043 3
a1045 1
		TextInBox(hdc, Buffer, rcx+IBLSCALE(9), rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
d1051 3
a1053 2
		Value= ALTITUDEMODIFY*GPS_INFO.Altitude;
		_stprintf(Buffer,TEXT("%0.0f"),Value);
d1055 2
a1056 1
		GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1058 2
a1059 1
		TextInBox(hdc, Buffer, rcx,rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
d1061 4
a1064 3
			wsprintf(BufferUnit, TEXT("%s"),Units::GetAltitudeName());
			SelectObject(hdc, MapWindowFont); 
			TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
d1068 3
a1070 2
	Value=  SPEEDMODIFY*GPS_INFO.Speed;
	_stprintf(Buffer,TEXT("%0.0f"),Value);
d1072 2
a1073 1
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1075 3
a1077 1
	TextInBox(hdc, Buffer, rcx,rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
d1079 4
a1082 3
		wsprintf(BufferUnit, TEXT("%s"),Units::GetHorizontalSpeedName());
		SelectObject(hdc, MapWindowFont); 
		TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
d1085 2
d1105 1
d1112 2
a1113 1
			TextInBox(hdc, Buffer, rc.right-IBLSCALE(10),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
d1116 2
a1117 1
			TextInBox(hdc, Buffer, rc.right-IBLSCALE(27),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
d1122 2
a1123 1
			TextInBox(hdc, Buffer, rc.right-IBLSCALE(30),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
d1126 2
a1127 1
			TextInBox(hdc, Buffer, rc.right-IBLSCALE(28),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
a1152 1
  COLORREF customcolor = RGB(0x0f, 0x0f, 0x0f);
d1154 5
a1158 1
  hB = (HBRUSH)CreateSolidBrush(customcolor);
a1159 3
//  int iWidth=GetSystemMetrics(SM_CXSCREEN) / 10; FIX REMOVE
//  int iHeight=GetSystemMetrics(SM_CYSCREEN) / 10;
  
d1172 6
a1177 1
  static HBRUSH hB= CreateSolidBrush(RGB_VDARKGREY); // dark grey (previous 0x26)
a1180 1
  // InfoLX boxes
d1182 3
a1184 17
  // CRUISE:
  //
  // Thermal = last thermal average
  // GS	     = Ground Speed
  // Alt     = QNH altitude
  // Dis     = Next waypoint distance
  // reqE    = required Efficiency to next WP: WayPointCalc[].GR
  // E       = Average efficiency over configured period (default 2 minutes as in 8000)
  //
  // CIRCLING:   TCAVG GS Alt  TCGAIN TC30S Turnrate
  // 1TaskDistanceToGo
  // 2TaskAltitudeDifference0
  // 3Final ETE TaskTimeToGo

  // 5 StartAltitude
  // 6 TaskSpeed  opp TaskSpeedAchieved
  // FinalAltitudeDifference
d1320 1
a1320 3
  		wsprintf(BufferValue, TEXT("1234"));
		wsprintf(BufferUnit, TEXT("."));
  		wsprintf(BufferTitle, TEXT("Error"));
d1331 1
a1331 1
  TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   // FIRST value
a1334 1
  	//SelectObject(hdc, MapLabelFont);
a1336 1
  	//SelectObject(hdc, TitleSmallWindowFont);
d1340 1
a1340 1
	  TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   // FIRST value unit
a1342 1
  //SelectObject(hdc, MapWindowFont);
d1347 2
a1348 1
  TextInBox(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);   // FIRST name
d1425 1
a1425 3
  		wsprintf(BufferValue, TEXT("1234"));
		wsprintf(BufferUnit, TEXT("."));
  		wsprintf(BufferTitle, TEXT("Error"));
d1436 1
a1436 1
  TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   
d1440 1
a1440 2
  	//SelectObject(hdc, MapLabelFont);
  	SelectObject(hdc,LK8UnitFont); // FIX REMOVE
a1441 1
  	//SelectObject(hdc, TitleSmallWindowFont);
d1445 1
a1445 1
  	TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1452 2
a1453 1
  TextInBox(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d1548 1
a1548 3
  		wsprintf(BufferValue, TEXT("1234"));
		wsprintf(BufferUnit, TEXT("."));
  		wsprintf(BufferTitle, TEXT("Error"));
d1559 1
a1559 1
  TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   
a1562 1
  	//SelectObject(hdc, MapLabelFont); // FIX 
d1568 1
a1568 1
  	TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1575 2
a1576 1
  TextInBox(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d1692 1
a1692 3
  		wsprintf(BufferValue, TEXT("1234"));
		wsprintf(BufferUnit, TEXT("."));
  		wsprintf(BufferTitle, TEXT("Error"));
d1704 1
a1704 1
  TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   
a1707 1
	  // SelectObject(hdc, MapLabelFont); FIX
d1713 1
a1713 1
	  TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1720 2
a1721 1
  TextInBox(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d1856 1
a1856 3
  		wsprintf(BufferValue, TEXT("1234"));
		wsprintf(BufferUnit, TEXT("."));
  		wsprintf(BufferTitle, TEXT("Error"));
d1868 1
a1868 1
  TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   
a1871 1
	  // SelectObject(hdc, MapLabelFont); FIX
d1877 1
a1877 1
	TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1884 2
a1885 1
  TextInBox(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d1990 1
a1990 3
  		wsprintf(BufferValue, TEXT("1234"));
		wsprintf(BufferUnit, TEXT("."));
  		wsprintf(BufferTitle, TEXT("Error"));
d2002 1
a2002 1
  TextInBox(hdc, BufferValue, rcx, rcy , 0, TextDisplayMode, false);   
a2005 1
	  // SelectObject(hdc, MapLabelFont); FIX
d2011 1
a2011 1
	TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(1) , 0, TextDisplayMode, false);   
d2017 2
a2018 1
  TextInBox(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d2032 2
d2053 2
d2063 3
a2065 1
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d2069 2
a2070 1
  	TextInBox(hdc, Buffer, rc.left+IBLSCALE(5), rc.bottom - BottomSize- rcy-IBLSCALE(2), 0, TextDisplayMode, false);
d2072 2
a2073 1
  	TextInBox(hdc, Buffer, rc.left+IBLSCALE(5), rc.bottom - rcy - IBLSCALE(5), 0, TextDisplayMode, false);
d2078 1
a2078 1
  	SelectObject(hdc, MapWindowFont);
d2082 2
a2083 1
  		TextInBox(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, TextDisplayMode, false);
d2085 2
a2086 1
  		TextInBox(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, TextDisplayMode, false);
d2093 1
a2093 1
  	SelectObject(hdc, MapWindowFont);
d2096 2
a2097 1
  	TextInBox(hdc, Buffer, rc.right - (TextSize.cx)-IBLSCALE(20) ,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, TextDisplayMode, false);
d2126 2
a2127 1
  static HBRUSH hB= CreateSolidBrush(RGB_BLACK);
d2136 5
a2140 1
  oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // save font
d2142 1
d2162 11
a2172 4
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[2], p[3], RGB_GREEN, rc);
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[4], p[5], RGB_GREEN, rc);
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[6], p[7], RGB_GREEN, rc);
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p[0], p[1], RGB_GREEN, rc);
a2250 3
  //HFONT oldfont;
  //oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // save font

d2277 1
a2277 1
  _stprintf(Buffer,TEXT("XCSoar LK 8000"));
d2279 3
a2281 2
  TextInBox(hdc, Buffer, middlex, (TextSize.cy/2)+IBLSCALE(2) , 0, TextDisplayMode, false);
  _stprintf(Buffer,TEXT("tactical glide computer"));
d2283 2
a2284 1
  TextInBox(hdc, Buffer, middlex, (TextSize.cy/2)+TextSize.cy-IBLSCALE(4) , 0, TextDisplayMode, false);
d2297 1
a2297 1
  TextInBox(hdc, Buffer, left, contenttop , 0, TextDisplayMode, false);
d2303 1
a2303 1
  TextInBox(hdc, Buffer, left, contenttop+TextSize.cy , 0, TextDisplayMode, false);
d2311 1
a2311 1
  TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*2) , 0, TextDisplayMode, false);
d2315 1
a2315 1
  TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*3) , 0, TextDisplayMode, false);
d2318 1
a2318 1
  TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*4) , 0, TextDisplayMode, false);
d2322 1
a2322 1
  TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*5) , 0, TextDisplayMode, false);
d2330 2
a2331 1
  TextInBox(hdc, Buffer, middlex, contenttop+(TextSize.cy*1) , 0, TextDisplayMode, false);
d2336 2
a2337 1
  TextInBox(hdc, Buffer, middlex, ((rc.bottom-rc.top)-BottomSize)/2 , 0, TextDisplayMode, false);
d2345 5
a2349 3
  TextInBox(hdc, Buffer, middlex, bottomlines , 0, TextDisplayMode, false);
  _stprintf(Buffer,TEXT("Experimental version by Paolo Ventafridda (venta@@bware.it)"));
  TextInBox(hdc, Buffer, middlex, bottomlines+TextSize.cy , 0, TextDisplayMode, false);
d2375 1
d2392 1
a2392 1
  static HBRUSH sortbrush= CreateSolidBrush(RGB_LIGHTGREEN);
a2393 3
  //HFONT oldfont;  VENTA REMOVE
  //oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // save font
  //short bottomlines;
d2397 5
d2641 4
a2644 1
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
d2658 2
a2659 1
	TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
d2668 8
a2675 3
	if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
 	TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
d2679 7
a2685 3
	if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
d2688 7
a2694 3
	if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
d2697 7
a2703 3
	if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
d2706 7
a2712 3
	if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
d2723 2
a2724 1
		TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
d2733 7
a2739 3
		if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false); // WAS Column1 FIX CHECK VENTA
d2741 1
a2741 1
		TextDisplayMode.AsFlag.AlligneRight = 1;
d2743 7
a2749 3
		if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
d2752 7
a2758 3
		if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
d2761 7
a2767 3
		if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
d2770 7
a2776 3
		if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
d2781 2
a2782 1
		TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
d2791 7
a2797 3
		if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
d2801 7
a2807 3
		if (cursortbox==1) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
d2810 7
a2816 3
		if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
d2819 7
a2825 3
		if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
d2828 7
a2834 3
		if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
d2960 1
d2964 1
d2968 2
a2969 1
			TextDisplayMode.AsFlag.Color = TEXTLIGHTRED;
d2971 2
a2972 1
			TextDisplayMode.AsFlag.Color = TEXTGREY;
d2976 2
a2977 1
	TextInBox(hdc, Buffer1[i][curpage], Column1, iRaw , 0, TextDisplayMode, false);
d2983 2
a2984 1
	TextInBox(hdc, Buffer2[i][curpage], Column2, iRaw , 0, TextDisplayMode, false);
d2987 2
a2988 1
	TextInBox(hdc, Buffer3[i][curpage], Column3, iRaw , 0, TextDisplayMode, false);
d2991 2
a2992 1
	TextInBox(hdc, Buffer4[i][curpage], Column4, iRaw , 0, TextDisplayMode, false);
d2995 2
a2996 1
	TextInBox(hdc, Buffer5[i][curpage], Column5, iRaw , 0, TextDisplayMode, false);
d3035 5
a3039 1
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
d3042 4
a3045 1
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
d3049 1
d3124 2
d3139 1
a3139 1
  static HBRUSH sortbrush= CreateSolidBrush(RGB_LIGHTGREEN);
a3140 3
  //HFONT oldfont;  VENTA REMOVE
  //oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // save font
  //short bottomlines;
d3143 4
d3391 4
a3394 1
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB_GREEN, rc);
d3409 2
a3410 1
	TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
d3419 8
a3426 3
	if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
 	TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
d3434 2
a3435 1
	TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
d3438 4
a3441 3
	if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
d3444 4
a3447 3
	if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
d3450 4
a3453 3
	if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
	else TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
d3462 2
a3463 1
	TextInBox(hdc, Buffer, LEFTLIMITER, rc.top+TOPLIMITER , 0, TextDisplayMode, false);
d3473 4
a3476 3
		if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
d3484 2
a3485 1
		TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
d3488 4
a3491 3
		if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
d3494 4
a3497 3
		if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
d3500 4
a3503 3
		if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
d3511 4
a3514 3
		if (cursortbox==0) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
		TextInBox(hdc, Buffer, Column0, HEADRAW-IBLSCALE(1) , 0, TextDisplayMode, false);
d3521 2
a3522 1
		TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
d3525 4
a3528 3
		if (cursortbox==2) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
d3531 4
a3534 3
		if (cursortbox==3) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
d3537 4
a3540 3
		if (cursortbox==4) TextDisplayMode.AsFlag.Color = TEXTBLACK;
		else TextDisplayMode.AsFlag.Color = TEXTWHITE;
		TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
d3669 1
d3671 2
a3672 1
			TextDisplayMode.AsFlag.Color = TEXTGREY;
d3676 2
a3677 1
	TextInBox(hdc, Buffer1[i][curpage], Column1, iRaw , 0, TextDisplayMode, false);
d3683 2
a3684 1
	TextInBox(hdc, Buffer2[i][curpage], Column2, iRaw , 0, TextDisplayMode, false);
d3687 2
a3688 1
	TextInBox(hdc, Buffer3[i][curpage], Column3, iRaw , 0, TextDisplayMode, false);
d3691 2
a3692 1
	TextInBox(hdc, Buffer4[i][curpage], Column4, iRaw , 0, TextDisplayMode, false);
d3695 2
a3696 1
	TextInBox(hdc, Buffer5[i][curpage], Column5, iRaw , 0, TextDisplayMode, false);
d3737 5
a3741 1
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
d3744 4
a3747 1
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB_LIGHTGREEN, rc);
d3799 1
a3799 1
	oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // save font
d3973 2
a3974 1
        TextInBox(hdc, Buffer, qcolumn[0],qrow[0], 0, TextDisplayMode, false);
d4003 2
a4004 1
        TextInBox(hdc, Buffer, qcolumn[8],qrow[1], 0, TextDisplayMode, false);
d4012 2
a4013 1
        TextInBox(hdc, BufferValue, qcolumn[16],qrow[0], 0, TextDisplayMode, false);
d4447 2
a4448 1
	TextInBox(hdc, BufferTitle, qcolumn[8],qrow[12], 0, TextDisplayMode, false);   // NAME
d4466 2
a4467 1
        TextInBox(hdc, BufferValue, *columnvalue,*row1, 0, TextDisplayMode, false);
d4472 2
a4473 1
	        TextInBox(hdc, BufferUnit, *columnvalue,*row2, 0, TextDisplayMode, false);
d4477 2
a4478 1
        TextInBox(hdc, BufferTitle, *columntitle,*row3, 0, TextDisplayMode, false);
d4692 2
a4693 1
  TextInBox(hDC, Buffer, Start.x , bankindy, 0, Mode, false);
d4730 1
a4730 1
  HFONT oldfont=(HFONT)SelectObject(hdc, LK8PanelBigFont);
d4748 1
a4748 1
  SelectObject(hdc, oldfont);
d4753 146
@


8.23
log
@10d
10e
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.22 2009/09/19 01:07:31 root Exp root $
d1422 3
a1424 2

  //SelectObject(hdc, StatisticsFont);
a1426 1
  rcx=rc.left+(rc.right/(splitter*2))-IBLSCALE(5); // FIX make it static in doinit
d1447 1
d1531 3
a1535 1
  rcx+=(rc.right/splitter); 
d1555 1
d1657 3
a1661 1
  rcx+=(rc.right/splitter); 
d1680 1
d1804 3
a1808 1
  rcx+=(rc.right/splitter); 
d1827 1
d1970 3
a1974 1
  rcx+=(rc.right/splitter)-IBLSCALE(7);  // shorter value
d1993 1
d2106 3
a2110 1
  rcx+=(rc.right/splitter)-IBLSCALE(11); 
d2128 1
@


8.22
log
@ok
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.21 2009/09/16 10:56:39 root Exp $
d1364 1
a1364 1
		showunit=LKFormatValue(LK_BATTERY, false, BufferValue, BufferUnit, BufferTitle);
@


8.21
log
@ok
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.20 2009/09/09 22:59:39 root Exp root $
d1135 1
a1135 1
	rcx=rc.left+IBLSCALE(1)+GlideBarOffset;  // QUIQUI
d1317 2
d1325 1
d1328 2
d1336 1
d1339 2
d1347 1
d1350 2
d1360 1
d1364 2
d1374 1
d1378 2
d1406 1
d1426 1
a1426 1
  rcx=rc.left+(rc.right/(splitter*2))-IBLSCALE(5);
d1457 2
d1465 1
d1468 3
d1474 1
d1476 1
a1476 1
  		wsprintf(BufferTitle, TEXT("MC"));
d1479 2
d1486 1
d1489 1
d1503 2
d1517 1
d1564 2
d1571 1
d1574 2
d1581 1
d1584 1
a1584 5
		if (CALCULATED_INFO.TaskTimeToGo > 0){
      			Units::TimeToText(BufferValue, (int)CALCULATED_INFO.TaskTimeToGo);
		} else
  			wsprintf(BufferValue, TEXT("--:--"));

a1585 1
 		wsprintf(BufferTitle, TEXT("ETE"),text);
d1588 1
d1604 3
a1606 1
/*
d1614 1
d1640 1
d1684 2
d1691 1
d1694 2
d1714 1
d1718 2
a1719 2
		Value = DISTANCEMODIFY*CALCULATED_INFO.HomeDistance ;
/*
d1723 2
d1733 1
d1736 2
d1746 1
d1749 3
a1756 1
		showunit=false;
d1758 1
d1761 2
a1762 1
/*
d1770 1
d1783 1
d1830 2
d1838 1
d1840 4
a1843 1
	case BM_CRU:
d1862 1
d1865 3
d1875 1
d1878 1
d1890 2
d1895 1
d1897 1
d1911 3
a1913 1
/*
d1921 1
d1946 1
d1993 2
d2000 1
d2003 2
d2014 1
d2017 3
d2027 1
d2030 2
d2041 1
d2044 1
d2057 2
a2058 1
/*
d2066 1
d2079 1
d3963 1
a3963 1
			showunit=LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
d3968 1
a3968 1
			showunit=LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
d3988 1
a3988 1
			LKFormatValue(LK_BRG, false, BufferValue, BufferUnit, BufferTitle);
d3993 1
a3993 1
			LKFormatValue(LK_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
d4095 1
a4095 1
			LKFormatValue(LK_BRG, false, BufferValue, BufferUnit, BufferTitle);
d4187 1
a4187 1
			LKFormatValue(LK_TRACK, false, BufferValue, BufferUnit, BufferTitle);
d4325 1
a4325 1
			LKFormatValue(LK_SPEEDTASK_ACH, false, BufferValue, BufferUnit, BufferTitle); 
d4349 1
a4349 1
			LKFormatValue(LK_MC, false, BufferValue, BufferUnit, BufferTitle); 
@


8.20
log
@ok
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.19 2009/09/07 19:08:20 root Exp root $
d712 2
a713 2
    if (turn>0||true) oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); 
    else oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x00)); // red
d742 2
a743 2
    if (turn>0||true) oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); // dark grey
    else oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x00)); // red
d843 1
a843 1
   _DrawLine(hdc, PS_SOLID, IBLSCALE(1), Orig, p2, RGB(0,0,0), rc);
d884 1
a884 1
		doinit=false;
d1258 1
a1258 1
  static HBRUSH hB= CreateSolidBrush(RGB(0xd,0xd,0xd)); // dark grey (previous 0x26)
d1293 1
a1293 1
  static short OldBottomMode=1;  // init to cruise
d1299 1
a1299 1
	BottomMode=0;
d1316 1
a1316 1
	case 0:
d1324 1
a1324 1
	case 1:
d1332 1
a1332 1
	case 2:
d1340 1
a1340 1
	case 3:
d1351 1
a1351 1
	case 4:
d1362 1
a1362 1
	case 5:
d1390 6
d1437 2
a1438 2
	case 0:
	case 1:
d1446 1
a1446 1
	case 2:
d1453 1
a1453 1
	case 3:
d1460 1
a1460 1
	case 4:
d1473 1
a1473 1
	case 5:
d1487 4
d1530 2
a1531 2
	case 0:
	case 1:
d1538 1
a1538 1
	case 2:
d1545 1
a1545 1
	case 3:
d1554 1
a1554 1
	case 4:
d1569 1
a1569 1
	case 5:
d1604 4
d1645 1
a1645 1
	case 0:
d1652 1
a1652 1
	case 1:
d1672 1
a1672 1
	case 2:  
d1688 1
a1688 1
	case 3:
d1698 1
a1698 1
	case 4:
d1707 1
a1707 1
	case 5:
d1729 4
d1773 1
a1773 1
	case 0:
d1781 1
a1781 1
	case 1:
d1801 1
a1801 1
	case 2:
d1810 1
a1810 1
	case 3:
d1821 1
a1821 1
	case 4:
d1838 1
a1838 1
	case 5:
d1872 4
d1916 1
a1916 1
	case 0:
d1923 1
a1923 1
	case 1:
d1934 1
a1934 1
	case 2:
d1943 1
a1943 1
	case 3:
d1954 1
a1954 1
	case 4:
d1966 1
a1966 1
	case 5:
d1988 4
d2117 1
a2117 2
  static HBRUSH hB= CreateSolidBrush(RGB(0x00,0x00, 0x00));
  //SIZE TextSize;
d2123 2
d2134 20
d2156 1
a2156 1
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB(0,0xff,0), rc);
d2158 1
a2158 1
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB(0,0xff,0), rc);
d2160 1
a2160 1
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB(0,0xff,0), rc);
d2162 2
a2163 1
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB(0,0xff,0), rc);
a2180 1
//			MapSpaceMode=MSM_MAP;
d2198 3
a2200 1
	case MSM_INFO_HORIZON:
a2208 1
		//TextDisplayMode.AsFlag.WhiteBold = 0;
d2339 1
a2339 1
  SIZE WPTextSize, DSTextSize, BETextSize, RETextSize, AATextSize, HLTextSize;
d2351 2
d2366 1
a2366 1
  static HBRUSH sortbrush= CreateSolidBrush(RGB(0xc2,0xff, 0xc2));
d2421 4
d2431 2
d2538 4
a2541 1
	DoStatusMessage(_T("ERROR curpage invalid!"));
d2558 2
a2559 2
			if (SortedNumber)
			DoStatusMessage(_T("Invalid selection"));
d2613 1
a2613 1
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB(0,0xff,0), rc);
d2624 6
d2632 1
a2632 1
 		_stprintf(Buffer,TEXT("%d:Landb %d/%d"), CURTYPE+1, curpage+1,Numpages); 
d2635 1
a2635 1
 	 	_stprintf(Buffer,TEXT("%d:Airpt %d-%d"), CURTYPE+1, curpage+1, Numpages); 
d2638 1
a2638 1
 	TextInBox(hdc, Buffer, Column1, HEADRAW , 0, TextDisplayMode, false);
d2643 1
a2643 1
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2648 1
a2648 1
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2653 1
a2653 1
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2658 1
a2658 1
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2666 7
d2675 1
a2675 1
			_stprintf(Buffer,TEXT("%d:Landabl %d/%d"), CURTYPE+1,curpage+1,Numpages); 
d2678 1
a2678 1
			_stprintf(Buffer,TEXT("%d:Airpts %d/%d"), CURTYPE+1,curpage+1, Numpages); 
d2681 1
a2681 1
		TextInBox(hdc, Buffer, Column1, HEADRAW , 0, TextDisplayMode, false);
d2686 1
a2686 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2691 1
a2691 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2696 1
a2696 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2701 1
a2701 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2704 6
d2712 1
a2712 1
			_stprintf(Buffer,TEXT("%d:Landbl %d/%d"), CURTYPE+1, curpage+1,Numpages); 
d2715 1
a2715 1
			_stprintf(Buffer,TEXT("%d:Airpt %d/%d"), CURTYPE+1,curpage+1, Numpages); 
d2718 1
a2718 1
		TextInBox(hdc, Buffer, Column1, HEADRAW , 0, TextDisplayMode, false);
d2723 1
a2723 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2728 1
a2728 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2733 1
a2733 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2738 1
a2738 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2931 1
a2931 1
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB(0xc2,0xff,0xc2), rc);
d2934 1
a2934 1
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB(0xc2,0xff,0xc2), rc);
d3001 1
a3001 1
  SIZE WPTextSize, DSTextSize, BETextSize, RETextSize, AATextSize, HLTextSize;
d3013 1
a3013 1
  static short Column1, Column2, Column3, Column4, Column5;
d3025 1
a3025 1
  static HBRUSH sortbrush= CreateSolidBrush(RGB(0xc2,0xff, 0xc2));
d3080 4
d3090 1
d3164 1
a3164 1
  if (CommonNumpages>MAXCOMMONNUMPAGES) CommonNumpages=MAXCOMMONNUMPAGES;
d3203 3
a3205 1
	DoStatusMessage(_T("ERROR current page invalid!"));
d3210 1
a3210 1
  if (curpage>CommonNumpages) curpage=0;
d3276 1
a3276 1
  _DrawLine(hdc, PS_SOLID, IBLSCALE(1), p1, p2, RGB(0,0xff,0), rc);
d3288 6
d3296 1
a3296 1
  		_stprintf(Buffer,TEXT("%d:Commn %d/%d"), CURTYPE+1, curpage+1, CommonNumpages); 
d3299 1
a3299 1
  		_stprintf(Buffer,TEXT("%d:Rcnt %d/%d"), CURTYPE+1,curpage+1, CommonNumpages); 
d3302 1
a3302 1
 	TextInBox(hdc, Buffer, Column1, HEADRAW , 0, TextDisplayMode, false);
d3309 1
a3309 1
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3314 1
a3314 1
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3319 1
a3319 1
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3324 1
a3324 1
	else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3331 6
d3340 1
a3340 1
			_stprintf(Buffer,TEXT("%d:Commn %d/%d"), CURTYPE+1,curpage+1,CommonNumpages); 
d3343 1
a3343 1
			_stprintf(Buffer,TEXT("%d:Rcnt %d/%d"), CURTYPE+1, curpage+1,CommonNumpages); 
d3346 1
a3346 1
		TextInBox(hdc, Buffer, Column1, HEADRAW , 0, TextDisplayMode, false);
d3353 1
a3353 1
		TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3358 1
a3358 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3363 1
a3363 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3368 1
a3368 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3373 1
a3373 1
			_stprintf(Buffer,TEXT("%d:Commn %d/%d"), CURTYPE+1,curpage+1,CommonNumpages); 
d3376 1
a3376 1
			_stprintf(Buffer,TEXT("%d:Recn %d/%d"), CURTYPE+1,curpage+1,CommonNumpages); 
d3379 1
a3379 1
		TextInBox(hdc, Buffer, Column1, HEADRAW , 0, TextDisplayMode, false);
d3385 1
a3385 1
		TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3390 1
a3390 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3395 1
a3395 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3400 1
a3400 1
		else TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d3591 1
a3591 1
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB(0xc2,0xff,0xc2), rc);
d3594 1
a3594 1
	_DrawLine(hdc, PS_SOLID, IBLSCALE(1), sp1, sp2, RGB(0xc2,0xff,0xc2), rc);
d3802 1
a3802 1
			wsprintf(Buffer,_T("2: Thermal"));
d3805 4
a3808 1
			wsprintf(Buffer,_T("1: Cruise")); // FIX HERE
d3810 5
a3814 2
		case IM_HORIZON:
			wsprintf(Buffer,_T("3: Turn"));
d3828 2
d3840 1
a3840 1
		case IM_HORIZON:
d3859 1
a3859 1
	if (CURTYPE == IM_HORIZON) goto label_InfoTest;
d3861 2
a3862 2
	VDrawLine(hdc,rc, qcolumn[0],qrow[2],qcolumn[16],qrow[2],RGB(40,80,40));
	VDrawLine(hdc,rc, qcolumn[0],qrow[8],qcolumn[16],qrow[8],RGB(40,80,40));
d3874 1
d3878 5
d3899 1
d3903 5
d3921 1
a3921 1
			showunit=LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
d3925 1
d3929 5
d3951 1
d3956 6
d3978 6
a3983 1
			showunit=LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
d4001 1
d4005 5
d4025 1
d4028 4
d4047 1
d4050 4
d4071 7
d4097 9
d4123 7
d4148 7
d4169 1
d4173 10
d4186 1
a4188 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[5], &qcolumn[4],&qrow[12],&qrow[13],&qrow[11]);
d4191 1
a4191 1
	///: R4  C2	= Thermal last
d4197 1
d4201 10
d4214 1
a4216 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[9],&qrow[12],&qrow[13],&qrow[11]);
d4219 1
a4219 1
	///: R4  C3	= Thermal Aver
d4225 1
d4228 11
a4238 1
			LKFormatValue(LK_TC_AVG, false, BufferValue, BufferUnit, BufferTitle);
d4242 1
a4244 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[13], &qcolumn[13],&qrow[12],&qrow[13],&qrow[11]);
d4247 1
a4247 1
	///: R4  C4	=  MC
d4255 6
a4260 1
			LKFormatValue(LK_MC, false, BufferValue, BufferUnit, BufferTitle);
d4271 1
a4271 1
	VDrawLine(hdc,rc, qcolumn[0],qrow[2],qcolumn[16],qrow[2],RGB(40,80,40));
d4440 2
a4441 1
  if (GPS_INFO.Speed <20) disabled=true;
@


8.19
log
@ok
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.18 2009/09/02 20:28:34 root Exp root $
d22 1
d2095 3
a2115 1
 
d2117 3
d2152 1
d2166 4
a2169 2

  // restore font and return
d3671 19
d3711 1
a3711 1
			wsprintf(Buffer,_T("3: Horizon"));
d4053 1
a4053 1
	DrawHorizon(hdc, rc);
a4054 12
        wsprintf(BufferTitle, TEXT("Bank"));
	_stprintf(BufferValue,TEXT("%1.0f")_T(DEG), DerivedDrawInfo.BankAngle );
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[3],&qrow[4],&qrow[2]);
        wsprintf(BufferTitle, TEXT("Pitch"));
	_stprintf(BufferValue,TEXT("%1.0f")_T(DEG), DerivedDrawInfo.PitchAngle );
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[14], &qcolumn[14],&qrow[3],&qrow[4],&qrow[2]);
        wsprintf(BufferTitle, TEXT("TurnRate"));
	_stprintf(BufferValue,TEXT("%1.1f"), DerivedDrawInfo.TurnRate );
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[6],&qrow[7],&qrow[5]);
        wsprintf(BufferTitle, TEXT("Gload"));
	_stprintf(BufferValue,TEXT("%1.1f"), DerivedDrawInfo.Gload );
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4],&qrow[9],&qrow[10],&qrow[8]);
d4056 8
a4063 13
	showunit=true;
        wsprintf(BufferTitle, TEXT("GPSVario"));
	_stprintf(BufferValue,TEXT("%1.1f"), DerivedDrawInfo.GPSVario);
	wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[14], &qcolumn[14],&qrow[9],&qrow[10],&qrow[8]);

	Value=SPEEDMODIFY*DrawInfo.Speed;
        if (Value<0||Value>999) Value=0;
        sprintf(text,"%d",(int)Value);
        wsprintf(BufferValue, TEXT("%S"),text);
        wsprintf(BufferUnit, TEXT("%s"),(Units::GetHorizontalSpeedName()));
        wsprintf(BufferTitle, TEXT("GrSpeed"));
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[14], &qcolumn[14],&qrow[6],&qrow[7],&qrow[5]);
d4068 1
a4068 1
        TextDisplayMode.AsFlag.Color = TEXTRED;
a4070 1
        TextDisplayMode.AsFlag.AlligneRight = 0;
d4103 269
@


8.18
log
@lk values
@
text
@d2 1
a2 1
  $Id: MapWindow3.cpp,v 8.17 2009/07/30 13:38:07 root Exp root $
d22 1
d41 1
d62 3
d2012 1
a2012 1
  if (DrawBottom && MapSpaceMode != 1) goto TheEnd;
d2117 1
a2117 1

d2119 2
a2120 1
#ifdef _SIM_
d2122 1
a2122 1
#else
d2124 4
a2127 2
#endif
			MapSpaceMode=MSM_MAP;
d2130 1
d2143 1
d2145 1
d2156 1
a2156 5
		TextInBox(hdc, Buffer, IBLSCALE(50), IBLSCALE(50) , 0, TextDisplayMode, false);
		break;

		// impossible
		DoStatusMessage(_T("ERROR: INVALID MAPSPACEMODE!"));
d2192 3
a2194 2
		MapSpaceMode=MSM_MAP;
		LKevent=LKEVENT_NONE;
d2466 3
a2468 3
  //TCHAR vbuf[100]; // REMOVE VENTA
  //wsprintf(vbuf,_T("Numpages=%d sortednum=%d numraws=%d"),Numpages, SortedNumber, Numraws );
  //DoStatusMessage(vbuf);
d2496 4
a2499 1
		MapSpaceMode=MSM_MAP;
d2557 2
a2558 1
 		_stprintf(Buffer,TEXT("Landabl %d-%d"), curpage+1,Numpages); 
d2560 2
a2561 1
 	 	_stprintf(Buffer,TEXT("Airport %d-%d"), curpage+1, Numpages); 
d2593 2
a2594 1
			_stprintf(Buffer,TEXT("Landables %d-%d"), curpage+1,Numpages); 
d2596 2
a2597 1
			_stprintf(Buffer,TEXT("Airports %d-%d"), curpage+1, Numpages); 
d2624 2
a2625 1
			_stprintf(Buffer,TEXT("Landables %d-%d"), curpage+1,Numpages); 
d2627 2
a2628 1
			_stprintf(Buffer,TEXT("Airports %d-%d"), curpage+1, Numpages); 
d2680 1
a2680 1
	if (MapSpaceMode==2) {
d2687 3
a2689 1
	if (!ndr) goto KeepOldValues;
d2886 17
d3134 3
a3136 2
		MapSpaceMode=MSM_MAP;
		LKevent=LKEVENT_NONE;
d3195 2
a3196 1
  		_stprintf(Buffer,TEXT("Commons %d-%d"), curpage+1, CommonNumpages); 
d3198 2
a3199 1
  		_stprintf(Buffer,TEXT("Recent %d-%d"), curpage+1, CommonNumpages); 
d3233 2
a3234 1
			_stprintf(Buffer,TEXT("Commons %d-%d"), curpage+1,CommonNumpages); 
d3236 2
a3237 1
			_stprintf(Buffer,TEXT("Recent %d-%d"), curpage+1,CommonNumpages); 
d3266 2
a3267 1
			_stprintf(Buffer,TEXT("Commons %d-%d"), curpage+1,CommonNumpages); 
d3269 2
a3270 1
			_stprintf(Buffer,TEXT("Recent %d-%d"), curpage+1,CommonNumpages); 
d3513 1
a3513 6
#define PANELCOLUMNS	4
#define PANELROWS	4
#define RIGHTLIMITER	IBLSCALE(3)
#define LEFTLIMITER	IBLSCALE(3)
#define TOPLIMITER	IBLSCALE(1)
#define BOTTOMLIMITER	IBLSCALE(2)
d3520 1
a3520 1
  SIZE TextSize, TextSize2;
d3527 1
a3527 1
  int index=-1, value;
a3528 11
  short rcx, rcy;
  short wlen;

/*
  int d;
  bool negative;
  int dd;
  int thours;
  int tmins;
  int tseconds;
*/
a3529 2
  ///: position of wind text
//  static short windnameX=0, windnameY=0, windvalueX=0, windvalueY=0;
d3533 2
a3534 2
static short	column[PANELCOLUMNS+1], hcolumn[(PANELCOLUMNS*2)+1], qcolumn[(PANELCOLUMNS*4)+1];
static short	row[PANELROWS+1], hrow[(PANELCOLUMNS*2)+1], qrow[(PANELROWS*4)+1];
a3569 19
	///: 
	///: Preload Wind coordinates
	///:
/*
	SelectObject(hdc, LK8PanelBigFont);
	_stprintf(Buffer,TEXT("359/14"));
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	windvalueY=rc.bottom-BottomSize-TextSize.cy-IBLSCALE(2);
	windvalueX=rc.left+IBLSCALE(5);
	///: center of wind value X
	windnameX=windvalueX+(TextSize.cx/2);
	SelectObject(hdc, LK8InfoSmallFont);
	_stprintf(Buffer,TEXT("wind"));
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	windnameY=windvalueY-(TextSize.cy/2)+IBLSCALE(2);
*/
//	SelectObject(hdc, LK8PanelBigFont);
//	_stprintf(Buffer,TEXT("99999"));
//	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d3650 1
a3650 24
/*	DEMO COORDINATES
//  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
VDrawLine(hdc,rc, column[0],row[0],column[4],row[0],RGB(50,50,50));
VDrawLine(hdc,rc, column[0],row[1],column[4],row[1],RGB(50,50,50));
VDrawLine(hdc,rc, column[0],row[2],column[4],row[2],RGB(50,50,50));
VDrawLine(hdc,rc, column[0],row[3],column[4],row[3],RGB(50,50,50));
VDrawLine(hdc,rc, column[0],row[4],column[4],row[4],RGB(50,50,50));

VDrawLine(hdc,rc, column[0],row[0],column[0],row[4],RGB(50,50,50));
VDrawLine(hdc,rc, column[1],row[0],column[1],row[4],RGB(50,50,50));
VDrawLine(hdc,rc, column[2],row[0],column[2],row[4],RGB(50,50,50));
VDrawLine(hdc,rc, column[3],row[0],column[3],row[4],RGB(50,50,50));
VDrawLine(hdc,rc, column[4],row[0],column[4],row[4],RGB(50,50,50));

VDrawLine(hdc,rc, hcolumn[1],hrow[1],hcolumn[8],hrow[1],RGB(30,200,30));
VDrawLine(hdc,rc, hcolumn[1],hrow[2],hcolumn[8],hrow[2],RGB(30,200,30));
VDrawLine(hdc,rc, hcolumn[1],hrow[3],hcolumn[8],hrow[3],RGB(30,200,30));
VDrawLine(hdc,rc, hcolumn[1],hrow[4],hcolumn[8],hrow[4],RGB(30,200,30));

VDrawLine(hdc,rc, hcolumn[1],hrow[1],hcolumn[1],hrow[8],RGB(30,200,30));
VDrawLine(hdc,rc, hcolumn[2],hrow[1],hcolumn[2],hrow[8],RGB(30,200,30));
VDrawLine(hdc,rc, hcolumn[3],hrow[1],hcolumn[3],hrow[8],RGB(30,200,30));
VDrawLine(hdc,rc, hcolumn[4],hrow[1],hcolumn[4],hrow[8],RGB(30,200,30));
*/
d3660 1
a3661 287
/*	DEMO SCREENSHOT
	// **** LINE ZERO

	SelectObject(hdc, LK8PanelMediumFont);
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	wsprintf(Buffer,_T("1-3 cruise"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 0;
	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
 	TextInBox(hdc, Buffer, qcolumn[0],qrow[0], 0, TextDisplayMode, false);

	SelectObject(hdc, LK8PanelMediumFont);
	wsprintf(Buffer,_T("Calcinate"));
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextDisplayMode.AsFlag.AlligneCenter = 1;
 	TextInBox(hdc, Buffer, qcolumn[8],qrow[1], 0, TextDisplayMode, false);

	SelectObject(hdc, LK8PanelMediumFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	wsprintf(Buffer,_T("15:04:26"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[0], 0, TextDisplayMode, false);

	// **** LINE 1  qrow: 3,4,2 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("185.2"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[3], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("Km"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 0;
	TextDisplayMode.AsFlag.WhiteBold = 0;
	///: 6: differenza tra altezza char Big e Small, /2
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[4], 0, TextDisplayMode, false);
	_stprintf(Buffer, TEXT("Distance"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[2], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//_stprintf(Buffer, TEXT("Â«123Â°"));
	_stprintf(Buffer, TEXT("123Â°Â»"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[9],qrow[3], 0, TextDisplayMode, false); 
	_stprintf(Buffer, TEXT("TO"));
	SelectObject(hdc, LK8PanelSmallFont);
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[8],qrow[2], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("32.7"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[12],qrow[3], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("Req.EFF"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[12],qrow[2], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("41"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[3], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("Avr.EFF"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[2], 0, TextDisplayMode, false); 

	// **** LINE 2
	

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("+5679"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[6], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("ft"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 0;
	TextDisplayMode.AsFlag.WhiteBold = 0;
	///: 6: differenza tra altezza char Big e Small, /2
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[7], 0, TextDisplayMode, false);
	_stprintf(Buffer, TEXT("Alt.Arriv"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[5], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//_stprintf(Buffer, TEXT("Â«123Â°"));
	_stprintf(Buffer, TEXT("056Â°"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[9],qrow[6], 0, TextDisplayMode, false); 
	_stprintf(Buffer, TEXT("Bearing"));
	SelectObject(hdc, LK8PanelSmallFont);
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[8],qrow[5], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("23"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[6], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("Inst.EFF"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[5], 0, TextDisplayMode, false); 

	// **** LINE 3

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("10402"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[9], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("ft"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 0;
	TextDisplayMode.AsFlag.WhiteBold = 0;
	///: 6: differenza tra altezza char Big e Small, /2
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[10], 0, TextDisplayMode, false);
	_stprintf(Buffer, TEXT("Altitude"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[8], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	//_stprintf(Buffer, TEXT("Â«123Â°"));
	_stprintf(Buffer, TEXT("251Â°"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[9],qrow[9], 0, TextDisplayMode, false); 
	_stprintf(Buffer, TEXT("Track"));
	SelectObject(hdc, LK8PanelSmallFont);
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[8],qrow[8], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("148"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[12],qrow[9], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("Km/h"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 0;
	TextDisplayMode.AsFlag.WhiteBold = 0;
	///: 6: differenza tra altezza char Big e Small, /2
 	TextInBox(hdc, Buffer, qcolumn[12],qrow[10], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("GrSpeed"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[12],qrow[8], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("104"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[9], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("FL"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[8], 0, TextDisplayMode, false); 

	// ***** LINE 4

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer,TEXT("268")_T(DEG)_T("/14"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[5],qrow[12], 0, TextDisplayMode, false);
	_stprintf(Buffer, TEXT("Wind"));
	SelectObject(hdc, LK8PanelSmallFont);
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[4],qrow[11], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("2.3"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[8],qrow[12], 0, TextDisplayMode, false); 
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("m/s"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[9],qrow[13], 0, TextDisplayMode, false);
	_stprintf(Buffer, TEXT("Thermal"));
	SelectObject(hdc, LK8PanelSmallFont);
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[8],qrow[11], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("0.9"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[12],qrow[12], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("m/s"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 0;
	TextDisplayMode.AsFlag.WhiteBold = 0;
	///: 6: differenza tra altezza char Big e Small, /2
 	TextInBox(hdc, Buffer, qcolumn[12],qrow[13], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("AvTherm"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[12],qrow[11], 0, TextDisplayMode, false); 

	SelectObject(hdc, LK8PanelBigFont);
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	_stprintf(Buffer, TEXT("1.2"));
	TextDisplayMode.AsFlag.AlligneCenter = 0;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.WhiteBold = 0;
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[12], 0, TextDisplayMode, false);
	SelectObject(hdc, LK8PanelSmallFont);
	_stprintf(Buffer, TEXT("MacCready"));
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.AlligneCenter = 0;
 	TextInBox(hdc, Buffer, qcolumn[16],qrow[11], 0, TextDisplayMode, false); 
*/

	
d3675 1
a3675 1
	switch(InfoMode) {
d3677 1
a3677 1
			wsprintf(Buffer,_T("0: Thermal"));
d3680 1
a3680 1
			wsprintf(Buffer,_T("1: Cruise"));
d3682 2
a3683 2
		case IM_TEST:
			wsprintf(Buffer,_T("X: Horizon"));
d3694 1
a3694 1
	switch(InfoMode) {
d3707 1
a3707 1
		case IM_TEST:
a3720 19
/*
	d=DetectCurrentTime();
        negative = (d<0);
        dd = abs(d) % (3600*24);
        thours = (dd/3600);
        tmins = (dd/60-thours*60);
        tseconds = (dd-tmins*60-thours*3600);
        thours = thours % 24;
        if (negative) {
                if (thours>0) {
                        thours = -thours;
                } else if (tmins>0) {
                        tmins = -tmins;
                } else {
                        tseconds = -tseconds;
                }
        }
        _stprintf(Buffer,TEXT("%d:%02d:%02d"),thours, tmins, tseconds);
*/
d3726 1
a3726 1
	if (InfoMode == IM_TEST) goto label_InfoTest;
d3735 1
a3735 1
	switch(InfoMode) {
d3737 3
a3740 20
/*
			if ( ValidTaskPoint(ActiveWayPoint) != false ) {
                	     index = Task[ActiveWayPoint].Index;
                	     if (index>=0) {
	                        Value=CALCULATED_INFO.WaypointDistance*DISTANCEMODIFY;
				showunit=true;
	                        if (Value>99)
	                                sprintf(text,"%.0f",Value);
	                        else
	                                sprintf(text,"%.1f",Value);
	                     } else {
	                        strcpy(text,"----");
	                     }
	                  } else {
	                        strcpy(text,"----");
	                  }
			wsprintf(BufferValue, TEXT("%S"),text);
			wsprintf(BufferUnit, TEXT("%s"),(Units::GetDistanceName()));
			wsprintf(BufferTitle, TEXT("Dist"),text);
*/
d3742 1
a3744 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3746 1
a3748 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[4], &qcolumn[4], &qrow[3],&qrow[4],&qrow[2]);
d3751 1
a3751 1
	///: R1 C2	= TO bearing
d3754 1
a3754 1
	switch(InfoMode) {
a3755 28
/*
			wsprintf(BufferValue,_T("----"));
        		_stprintf(BufferTitle, TEXT("Brg"));
			if ( ValidTaskPoint(ActiveWayPoint) != false ) {
                	     index = Task[ActiveWayPoint].Index;
                	     if (index>=0) {
			       if (DisplayMode != dmCircling)
        			{
				    Value = CALCULATED_INFO.WaypointBearing;
#ifndef __MINGW32__
				    if (Value > 1)
				      _stprintf(BufferValue, TEXT("%2.0f°»"), Value);
				    else if (Value < -1)
				      _stprintf(BufferValue, TEXT("«%2.0f°"), -Value);
				    else
				      _tcscpy(BufferValue, TEXT("«»"));
#else
				    if (Value > 1)
				      _stprintf(BufferValue, TEXT("%2.0fÂ°Â»"), Value);
				    else if (Value < -1)
				      _stprintf(BufferValue, TEXT("Â«%2.0fÂ°"), -Value);
				    else
				      _tcscpy(BufferValue, TEXT("Â«Â»"));
				}
#endif
			      }
		       }
*/
d3757 1
a3759 33
/*
			wsprintf(BufferValue,_T("----"));
        		_stprintf(BufferTitle, TEXT("Dir"));
			if ( ValidTaskPoint(ActiveWayPoint) != false ) {
                	     index = Task[ActiveWayPoint].Index;
                	     if (index>=0) {
			       if (DisplayMode != dmCircling)
        			{
				    Value = CALCULATED_INFO.WaypointBearing -  GPS_INFO.TrackBearing;
				    if (Value < -180.0)
				      Value += 360.0;
				    else
				    if (Value > 180.0)
				      Value -= 360.0;
#ifndef __MINGW32__
				    if (Value > 1)
				      _stprintf(BufferValue, TEXT("%2.0f°»"), Value);
				    else if (Value < -1)
				      _stprintf(BufferValue, TEXT("«%2.0f°"), -Value);
				    else
				      _tcscpy(BufferValue, TEXT("«»"));
#else
				    if (Value > 1)
				      _stprintf(BufferValue, TEXT("%2.0fÂ°Â»"), Value);
				    else if (Value < -1)
				      _stprintf(BufferValue, TEXT("Â«%2.0fÂ°"), -Value);
				    else
				      _tcscpy(BufferValue, TEXT("Â«Â»"));
				}
#endif
			      }
		       }
*/
d3761 1
a3763 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3765 1
a3767 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9],&qcolumn[8], &qrow[3],&qrow[4],&qrow[2]);
d3771 1
a3771 1
	///: R1 C3	= Req EFF
d3774 1
a3774 1
	switch(InfoMode) {
d3776 3
a3779 16
/*
			wsprintf(BufferValue,_T("----"));
        		_stprintf(BufferTitle, TEXT("Req.EFF"));
			if ( ValidTaskPoint(ActiveWayPoint) != false ) {
                	     index = Task[ActiveWayPoint].Index;
                	     if (index>=0) {
				   Value=WayPointCalc[index].GR;
      				   if (Value <1 || Value >=ALTERNATE_MAXVALIDGR )
						strcpy(text,"---");
          				else
                				if (Value >= 100) sprintf(text,"%.0lf",Value);
                				else sprintf(text,"%.1lf",Value);
				   wsprintf(BufferValue, TEXT("%S"),text);
			     }
			}
*/
d3781 1
a3783 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3785 1
a3787 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[12], &qcolumn[12], &qrow[3],&qrow[4],&qrow[2]);
d3790 1
a3790 1
	///: R1 C4	= Avr EFF
d3793 1
a3793 1
	switch(InfoMode) {
d3795 3
a3799 10
/*
			wsprintf(BufferValue,_T("----"));
        		_stprintf(BufferTitle, TEXT("Avr.EFF"));
			Value=CALCULATED_INFO.AverageLD;
			if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"++"); else
                 	       if (Value==0) sprintf(text,"---");
                 	               else sprintf(text,"%.0f",Value);
                	wsprintf(BufferValue, TEXT("%S"),text);
			WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[16],&qcolumn[16], &qrow[3],&qrow[4],&qrow[2]);
*/
a3804 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3815 4
a3818 1
	switch(InfoMode) {
a3819 12
/*
			wsprintf(BufferValue,_T("----"));
        		_stprintf(BufferTitle, TEXT("Alt.Arriv"));
			if ( ValidTaskPoint(ActiveWayPoint) != false ) {
                	     index = Task[ActiveWayPoint].Index;
                	     if (index>=0) {
				showunit=true;
				_stprintf(BufferValue,TEXT("%+1.0f"), ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
			     }
			}
			wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
*/
a3822 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3832 5
a3836 1
	switch(InfoMode) {
a3837 27
/*
			wsprintf(BufferValue,_T("----"));
        		_stprintf(BufferTitle, TEXT("Brg"));

			if ( ValidTaskPoint(ActiveWayPoint) != false ) {
                	     index = Task[ActiveWayPoint].Index;
                	     if (index>=0) {
				    Value = CALCULATED_INFO.WaypointBearing;
#ifndef __MINGW32__
				    if (Value > 1)
				      _stprintf(BufferValue, TEXT("%2.0f°"), Value);
				    else if (Value < -1)
				      _stprintf(BufferValue, TEXT("%2.0f°"), -Value);
				    else
				      _stprintf(BufferValue, TEXT("0°"));
#else
				    if (Value > 1)
				      _stprintf(BufferValue, TEXT("%2.0fÂ°"), Value);
				    else if (Value < -1)
				      _stprintf(BufferValue, TEXT("%2.0fÂ°"), -Value);
				    else
				      _stprintf(BufferValue, TEXT("0Â°"), -Value);
#endif

			      }
			}
*/
d3839 1
a3841 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3843 1
a3845 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[8], &qrow[6],&qrow[7],&qrow[5]);
d3851 4
a3854 1
	switch(InfoMode) {
a3855 8
/*
        		_stprintf(BufferTitle, TEXT("Cru.EFF"));
			Value=DerivedDrawInfo.CruiseLD;
                	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"++"); else
                	if (Value==0) sprintf(text,"---");
                	else sprintf(text,"%.0f",Value);
                	wsprintf(BufferValue, TEXT("%S"),text);
*/
a3858 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3868 4
a3871 1
	switch(InfoMode) {
a3872 10
/*
			wsprintf(BufferValue,_T("----"));
        		_stprintf(BufferTitle, TEXT("Ins.EFF"));

			Value=CALCULATED_INFO.LD;
			if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"++"); else
                 	       if (Value==0) sprintf(text,"---");
                 	               else sprintf(text,"%.0f",Value);
                	wsprintf(BufferValue, TEXT("%S"),text);
*/
a3875 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3884 5
a3888 2
	showunit=true;
	switch(InfoMode) {
d3890 1
a3890 8
/*
			Value=ALTITUDEMODIFY*DerivedDrawInfo.NavAltitude;
			sprintf(text,"%d",(int)Value);
			wsprintf(BufferValue, TEXT("%S"),text);
			wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
			wsprintf(BufferTitle, TEXT("Alt"),text);
*/
			LKFormatValue(LK_HGPS, false, BufferValue, BufferUnit, BufferTitle);
a3892 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3902 5
a3906 1
	switch(InfoMode) {
a3907 25
/*
        		_stprintf(BufferTitle, TEXT("Trk"));

				    Value = GPS_INFO.TrackBearing;
				    if (Value < -180.0)
				      Value += 360.0;
				    else
				    if (Value > 180.0)
				      Value -= 360.0;
#ifndef __MINGW32__
				    if (Value > 1)
				      _stprintf(BufferValue, TEXT("%2.0f°"), Value);
				    else if (Value < -1)
				      _stprintf(BufferValue, TEXT("%2.0f°"), -Value);
				    else
				      _stprintf(BufferValue, TEXT("0°"));
#else
				    if (Value > 1)
				      _stprintf(BufferValue, TEXT("%2.0fÂ°"), Value);
				    else if (Value < -1)
				      _stprintf(BufferValue, TEXT("%2.0fÂ°"), -Value);
				    else
				      _stprintf(BufferValue, TEXT("0Â°"), -Value);
#endif
*/
d3909 1
a3911 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3913 1
a3915 1
	WriteInfo(hdc, &showunit, BufferValue, BufferUnit, BufferTitle, &qcolumn[9], &qcolumn[8],&qrow[9],&qrow[10],&qrow[8]);
d3920 5
a3924 2
	showunit=true;
	switch(InfoMode) {
a3925 8
/*
			Value=SPEEDMODIFY*DrawInfo.Speed;
                	if (Value<0||Value>999) Value=0;
                	sprintf(text,"%d",(int)Value);
                	wsprintf(BufferValue, TEXT("%S"),text);
                	wsprintf(BufferUnit, TEXT("%s"),(Units::GetHorizontalSpeedName()));
                	wsprintf(BufferTitle, TEXT("GS"));
*/
a3928 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3939 4
a3942 1
	switch(InfoMode) {
a3943 6
/*
        		_stprintf(BufferTitle, TEXT("FL"));
			Value=(TOFEET*DerivedDrawInfo.NavAltitude)/100.0;
			sprintf(text,"%d",(int)Value);
			wsprintf(BufferValue, TEXT("%S"),text);
*/
a3946 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3957 4
a3960 1
	switch(InfoMode) {
a3961 11
/*
        		_stprintf(BufferTitle, TEXT("Wind"));
			if (DerivedDrawInfo.WindSpeed>0) {
				Value = DerivedDrawInfo.WindBearing;
				if (Value==360) Value=0;
				_stprintf(BufferValue,TEXT("%1.0f")_T(DEG)_T("/%1.0f"), Value, SPEEDMODIFY*DerivedDrawInfo.WindSpeed );
			} else
			{
				_stprintf(BufferValue,TEXT("--/--"));
			}
*/
a3964 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3974 4
a3977 1
	switch(InfoMode) {
a3978 8
/*
			Value= LIFTMODIFY*CALCULATED_INFO.LastThermalAverage;
                	if (Value<20) sprintf(text,"%+.1lf",Value);
                          else sprintf(text,"%+.0lf",Value);
			wsprintf(BufferValue, TEXT("%S"),text);
			wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
			wsprintf(BufferTitle, TEXT("ThLast"),text);
*/
a3981 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d3991 4
a3994 1
	switch(InfoMode) {
a3995 8
/*
			Value= LIFTMODIFY*CALCULATED_INFO.AverageThermal;
                	if (Value<20) sprintf(text,"%+.1lf",Value);
                          else sprintf(text,"%+.0lf",Value);
			wsprintf(BufferValue, TEXT("%S"),text);
			wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
			wsprintf(BufferTitle, TEXT("ThAll"),text);
*/
a3998 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
d4008 4
a4011 1
	switch(InfoMode) {
a4012 9
/*
			Value = iround(LIFTMODIFY*MACCREADY*10)/10.0;
			sprintf(text,"%.1lf",Value);
			wsprintf(BufferValue, TEXT("%S"),text);
			if (!ValidTaskPoint(ActiveWayPoint) && ((AutoMcMode==0) || (AutoMcMode==2)))
				wsprintf(BufferTitle, TEXT("MC"));
			else
				wsprintf(BufferTitle, TEXT("autoMC"));
*/
a4015 5
/*
			wsprintf(BufferValue, TEXT("1234"));
                	wsprintf(BufferUnit, TEXT("."));
                	wsprintf(BufferTitle, TEXT("Error"));
*/
a4063 272


  ///: First we draw flight related values such as instant efficiency, altitude, new infoboxes etc.
/*
  if ( ValidTaskPoint(ActiveWayPoint) != false ) {
     index = Task[ActiveWayPoint].Index;
     if ( index >0 )
     {
	rcx=rc.left+IBLSCALE(1);
	rcy=rc.top+IBLSCALE(1);

	// Waypoint name and distance

	SelectObject(hdc, LK8PanelBigFont);

	TextDisplayMode.AsInt = 0;
#ifdef DISABLED
	// Active colours
	if (WayPointList[index].Reachable) {
	TextDisplayMode.AsFlag.Color = TEXTGREEN; 
	} else {
		TextDisplayMode.AsFlag.Color = TEXTRED;
	}
#endif
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	TextDisplayMode.AsFlag.NoSetFont = 1; 
	TextDisplayMode.AsFlag.AlligneRight = 0;
	wlen=wcslen(WayPointList[index].Name);
 	if (wlen>tlen) {
 	 	_tcsncpy(Buffer, WayPointList[index].Name, tlen); Buffer[tlen]='\0';
	} else {
 	 	_tcsncpy(Buffer, WayPointList[index].Name, wlen); Buffer[wlen]='\0';
	}

 	 ConvToUpper(Buffer);
 	 TextInBox(hdc, Buffer, column[0],row[0], 0, TextDisplayMode, false);   // NAME
 	 GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);

  	 Value=CALCULATED_INFO.WaypointDistance*DISTANCEMODIFY; 
	 _stprintf(Buffer,TEXT("%0.1lf"),Value);
	TextDisplayMode.AsFlag.WhiteBold = 0; // outlined 
	TextDisplayMode.AsFlag.NoSetFont = 1; 
	TextDisplayMode.AsFlag.AlligneRight = 1;
	 TextInBox(hdc, Buffer, column[1],row[1], 0, TextDisplayMode, false); 

 	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize2);
	if (!HideUnits) {
	 wsprintf(BufferUnit, TEXT("%s"),Units::GetDistanceName());
	 SelectObject(hdc, MapWindowFont);
	 TextInBox(hdc, BufferUnit, column[1]+TextSize2.cx,row[1]+TextSize.cy+(TextSize.cy/3)-IBLSCALE(1), 0, TextDisplayMode, false); 
	}

	   // Bearing 
  	if (DisplayMode != dmCircling) 
	{

	    Value = CALCULATED_INFO.WaypointBearing -  GPS_INFO.TrackBearing;

	    if (Value < -180.0)
	      Value += 360.0;
	    else
	    if (Value > 180.0)
	      Value -= 360.0;

#ifndef __MINGW32__
	    if (Value > 1)
	      _stprintf(Buffer, TEXT("%2.0f°»"), Value);
	    else if (Value < -1)
	      _stprintf(Buffer, TEXT("«%2.0f°"), -Value);
	    else
	      _tcscpy(Buffer, TEXT("«»"));
#else
	    if (Value > 1)
	      _stprintf(Buffer, TEXT("%2.0fÂ°Â»"), Value);
	    else if (Value < -1)
	      _stprintf(Buffer, TEXT("Â«%2.0fÂ°"), -Value);
	    else
	      _tcscpy(Buffer, TEXT("Â«Â»"));
#endif

  	  // SelectObject(hdc, InfoWindowFont); // FIX ORIG
  	  SelectObject(hdc, LK8PanelBigFont);
	  TextDisplayMode.AsInt = 0;
	  TextDisplayMode.AsFlag.Color = TEXTWHITE;
	  TextDisplayMode.AsFlag.NoSetFont = 1; 
	  TextDisplayMode.AsFlag.WhiteBold = 1;
	  TextDisplayMode.AsFlag.AlligneRight = 0;
	  TextDisplayMode.AsFlag.AlligneCenter = 1;
	  TextInBox(hdc, Buffer, (rc.right+rc.left)/2, rc.top+ IBLSCALE(15), 0, TextDisplayMode, false);

       }


 	 // Draw efficiency required and altitude arrival for destination waypoint
	 // For paragliders, average efficiency and arrival destination

	  SelectObject(hdc, LK8PanelBigFont); // use this font for big values
	  TextDisplayMode.AsInt = 0;
	  TextDisplayMode.AsFlag.NoSetFont = 1; 
	  TextDisplayMode.AsFlag.Color = TEXTWHITE;
	  TextDisplayMode.AsFlag.WhiteBold = 1;
	  TextDisplayMode.AsFlag.AlligneRight = 1;

	  if ( ISPARAGLIDER )
		Value=CALCULATED_INFO.AverageLD;
	  else
		Value=WayPointCalc[index].GR;

	  if (Value <1 || Value >=ALTERNATE_MAXVALIDGR )
		strcpy(text,"---");
	  else 
		if (Value >= 100) sprintf(text,"%.0lf",Value);
		else sprintf(text,"%.1lf",Value);
	  wsprintf(Buffer, TEXT("%S"),text);
	  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	  rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
	  rcx=rc.right-IBLSCALE(10);
	  TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  // GR


	  // Altitude difference with current MC
	  _stprintf(Buffer,TEXT("%+1.0f"), ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
	  TextInBox(hdc, Buffer, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, TextDisplayMode, false);   // ALT


	} // index>0
    } // valid taskpoint

  if ( (Look8000==(Look8000_t)lxcAdvanced) || ISPARAGLIDER ) {

	TextDisplayMode.AsInt = 0;
	TextDisplayMode.AsFlag.NoSetFont = 1; 
	TextDisplayMode.AsFlag.Color = TEXTWHITE;
	TextDisplayMode.AsFlag.WhiteBold = 1;
	TextDisplayMode.AsFlag.AlligneRight = 0;

	SelectObject(hdc, LK8PanelBigFont); 
	if (ISPARAGLIDER) {
		if (GPS_INFO.VarioAvailable) {
		      Value = LIFTMODIFY*GPS_INFO.Vario;
		    } else {
		      Value = LIFTMODIFY*CALCULATED_INFO.Vario;
		    }
		_stprintf(Buffer,TEXT("%+0.1f"),Value);

	} else {
	  	Value=DerivedDrawInfo.AverageLD;
	  	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"++"); else
			if (Value==0) sprintf(text,"---"); 
				else sprintf(text,"%.0f",Value);
  		wsprintf(Buffer, TEXT("%S"),text);

	}

	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	rcx=rc.left+IBLSCALE(1); // no GlideBarOffset
	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);


	if (ISPARAGLIDER) {
		TextInBox(hdc, Buffer, rcx, rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
		if (!HideUnits) {
			wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
			SelectObject(hdc, MapWindowFont);  // FIX BUG !!
			TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
		}

	} else {
		TextInBox(hdc, Buffer, rcx+IBLSCALE(9), rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
		wsprintf(Buffer,_T("Avr.EFF"));
		SelectObject(hdc, LK8PanelSmallFont); 
		GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  		TextDisplayMode.AsFlag.Color = TEXTGREEN;
		TextInBox(hdc, Buffer, rcx+IBLSCALE(9), rcy-IBLSCALE(2)-TextSize.cy, 0, TextDisplayMode, false);   
		
	}
  	TextDisplayMode.AsFlag.Color = TEXTWHITE;

	rcx+=IBLSCALE(9);

	//if (ISPARAGLIDER) {
	if (1) {
		Value= ALTITUDEMODIFY*GPS_INFO.Altitude;
		_stprintf(Buffer,TEXT("%0.0f"),Value);
		SelectObject(hdc, LK8PanelBigFont); 
		GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
		rcy+=TextSize.cy;
		TextInBox(hdc, Buffer, rcx,rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
		if (!HideUnits) {
			wsprintf(BufferUnit, TEXT("%s"),Units::GetAltitudeName());
			SelectObject(hdc, MapWindowFont); 
			TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
		}
	}

	Value=  SPEEDMODIFY*GPS_INFO.Speed;
	_stprintf(Buffer,TEXT("%0.0f"),Value);
	SelectObject(hdc, LK8PanelBigFont); 
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	rcy+=TextSize.cy;
	TextInBox(hdc, Buffer, rcx,rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
	if (!HideUnits) {
		wsprintf(BufferUnit, TEXT("%s"),Units::GetHorizontalSpeedName());
		SelectObject(hdc, MapWindowFont); 
		TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
	}

	int d=DetectCurrentTime();
	bool negative = (d<0);
  	int dd = abs(d) % (3600*24);

	int thours = (dd/3600);
	int tmins = (dd/60-thours*60);
	int tseconds = (dd-tmins*60-thours*3600);
	thours = thours % 24;
	if (negative) {
		if (thours>0) {
			thours = -thours;
		} else if (tmins>0) {
			tmins = -tmins;
		} else {
			tseconds = -tseconds;
		}
	}
	_stprintf(Buffer,TEXT("%d:%02d:%02d"),thours, tmins, tseconds);
	TextDisplayMode.AsFlag.AlligneRight = 1;
	TextDisplayMode.AsFlag.Color = TEXTWHITE; 


	if ( ScreenSize < (ScreenSize_t)sslandscape ) {
			SelectObject(hdc, LK8MediumFont); 
			TextInBox(hdc, Buffer, rc.right-IBLSCALE(3),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
	} else {
			SelectObject(hdc, LK8PanelBigFont); 
			TextInBox(hdc, Buffer, rc.right-IBLSCALE(3),rc.top+IBLSCALE(1), 0, TextDisplayMode, false);   
	}
	TextDisplayMode.AsFlag.Color = TEXTWHITE; 

  }




  ///:
  ///: Draw wind 
  ///:
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  //TextDisplayMode.AsFlag.AlligneRight = 0;
  //TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextDisplayMode.AsFlag.WhiteBold = 1;
  SelectObject(hdc, LK8PanelBigFont);

  if (DerivedDrawInfo.WindSpeed>0) { 
	  Value = DerivedDrawInfo.WindBearing;
	  if (Value==360) Value=0; 
	  _stprintf(Buffer,TEXT("%1.0f")_T(DEG)_T("/%1.0f"), Value, SPEEDMODIFY*DerivedDrawInfo.WindSpeed );
  } else
  {
	  _stprintf(Buffer,TEXT("--/--"));
  }
  TextInBox(hdc, Buffer, windvalueX, windvalueY, 0, TextDisplayMode, false);

  SelectObject(hdc, LK8PanelSmallFont);
  TextDisplayMode.AsFlag.Color = TEXTGREEN;
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  _stprintf(Buffer,TEXT("WIND"));
  TextInBox(hdc, Buffer, windnameX, windnameY, 0, TextDisplayMode, false);
*/

a4067 1

a4092 111

void MapWindow::DrawHorizon(HDC hDC, const RECT rc)
{
  POINT Start;

  
  static short top=(((rc.bottom-BottomSize-(rc.top+TOPLIMITER)-BOTTOMLIMITER)/PANELROWS)+rc.top+TOPLIMITER)- (rc.top+TOPLIMITER);


  Start.y = ((rc.bottom-BottomSize-top)/2)+top-IBLSCALE(10);
  Start.x = (rc.right - rc.left)/2;

  HPEN   hpHorizonSky;
  HBRUSH hbHorizonSky;
  HPEN   hpHorizonGround;
  HBRUSH hbHorizonGround;
  HPEN   hpOld;
  HBRUSH hbOld;

  hpHorizonSky = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
                                 RGB(0x40,0x40,0xff));
  hbHorizonSky = (HBRUSH)CreateSolidBrush(RGB(0xA0,0xA0,0xff));

  hpHorizonGround = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
                                    RGB(106,55,12));
  hbHorizonGround = (HBRUSH)CreateSolidBrush(
                                             RGB(157,101,60));

  int radius = IBLSCALE(65);
  double phi = max(-89,min(89,DerivedDrawInfo.BankAngle));
  double alpha = RAD_TO_DEG
    *acos(max(-1.0,min(1.0,DerivedDrawInfo.PitchAngle/50.0)));
  double alpha1 = 180-alpha-phi;
  double alpha2 = 180+alpha-phi;

  hpOld = (HPEN)SelectObject(hDC, hpHorizonSky);
  hbOld = (HBRUSH)SelectObject(hDC, hbHorizonSky);

  Segment(hDC, Start.x, Start.y, radius, rc, 
          alpha2, alpha1, true);

  SelectObject(hDC, hpHorizonGround);
  SelectObject(hDC, hbHorizonGround);

  Segment(hDC, Start.x, Start.y, radius, rc, 
          alpha1, alpha2, true);

  POINT a1, a2;

 // 
 // a1.x = Start.x + fastsine(alpha1)*radius;
 // a1.y = Start.y - fastcosine(alpha1)*radius;
 // a2.x = Start.x + fastsine(alpha2)*radius;
 // a2.y = Start.y - fastcosine(alpha2)*radius;
 //
 // _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
 //           a1, a2, RGB(0,0,0));
 // 

  a1.x = Start.x+radius/2;
  a1.y = Start.y;
  a2.x = Start.x-radius/2;
  a2.y = Start.y;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, a2, RGB(0,0,0), rc);

  a1.x = Start.x;
  a1.y = Start.y-radius/4;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, Start, RGB(0,0,0), rc);

  //

#define ROOT2 0.70711

  int rr2p = lround(radius*ROOT2+IBLSCALE(1));
  int rr2n = lround(radius*ROOT2);

  a1.x = Start.x+rr2p;
  a1.y = Start.y-rr2p;
  a2.x = Start.x+rr2n;
  a2.y = Start.y-rr2n;

  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
            a1, a2, RGB(0,0,0), rc);

  a1.x = Start.x-rr2p;
  a1.y = Start.y-rr2p;
  a2.x = Start.x-rr2n;
  a2.y = Start.y-rr2n;

  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
            a1, a2, RGB(0,0,0), rc);

  // JMW experimental, display stall sensor
  double s = max(0.0,min(1.0,DrawInfo.StallRatio));
  long m = (long)((rc.bottom-rc.top)*s*s);
  a1.x = rc.right-1;
  a1.y = rc.bottom-m;
  a2.x = a1.x-10;
  a2.y = a1.y;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, a2, RGB(0xff,0,0), rc);

  SelectObject(hDC, hbOld);
  SelectObject(hDC, hpOld);
  DeleteObject((HPEN)hpHorizonSky);
  DeleteObject((HBRUSH)hbHorizonSky);
  DeleteObject((HPEN)hpHorizonGround);
  DeleteObject((HBRUSH)hbHorizonGround);
}
@


8.17
log
@9i
@
text
@d2 1
a2 34
Copyright_License {

  XCSoar Glide Computer - http://xcsoar.sourceforge.net/
  Copyright (C) 2000 - 2008  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  $Id: MapWindow3.cpp,v 8.16 2009/07/24 14:32:15 root Exp root $
}
d7 1
a40 1

d55 1
a55 1
extern void DrawRecent(HDC hdc, RECT rc);
d57 3
d61 2
d107 3
a109 3
  TCHAR Buffer[32];
  TCHAR Buffer2[32];
  TCHAR sAltUnit[4];
d635 2
a636 2
  TCHAR gtext[100];
  char text[20]; // TODO size it 
d850 5
a854 5
  TCHAR Buffer[100];
  TCHAR BufferValue[20];
  TCHAR BufferUnit[20];
  TCHAR BufferTitle[20];
  char text[30];
d858 4
a861 1
  short wlen, tlen;
d872 1
a872 1
        if (DrawBottom && MapSpaceMode!= 1) {
d877 3
a879 1

d883 1
a883 1
		if ( IsMapFullScreen() ) {
d903 1
a903 1
		if ( IsMapFullScreen() ) {
d912 3
d925 1
a934 1

d1112 1
a1112 1
	  	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"+++"); else
d1897 1
a1897 1
	  	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"+++"); else
d1908 1
a1908 1
	  	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"+++"); else
d2088 1
a2088 1
  TCHAR Buffer[100];
d2111 1
a2111 1
	case 0:
d2124 2
a2125 2
	case 2:
	case 3:
d2128 10
a2137 1
	case 4:
a2147 3
	case 1:
		break;
	default:
d2163 1
a2163 1
  TCHAR Buffer[100];
d2276 1
a2276 1
  TCHAR Buffer[100];
d2283 1
a2283 1
  short i, k, iRaw, wlen, rli=0, curpage;
d2431 2
a2432 1
  Numpages=(short)ceil( (float)MAXNEAREST / (float)Numraws );
d2434 1
d2437 1
a2437 1
  SelectedRaw[2]=0; SelectedRaw[3]=0;
d2439 1
a2439 1
  SelectedPage[2]=0; SelectedPage[3]=0;
d2448 14
d2464 1
a2464 1
  if (curpage<0||curpage>=MAXNUMPAGES) {
d2481 3
a2483 1
			DoStatusMessage(_T("ERROR Invalid selected waypoint"));
d2491 8
d2659 1
a2659 1
  for (i=0; i<Numraws; i++) {
d2752 3
d2799 3
a2801 2
  ///: check that at least the last one was good, and we don't have an empty list
  if (ValidWayPoint(rli) ) {
d2807 12
d2831 1
a2834 1
void MapWindow::DrawRecent(HDC hdc, RECT rc) {
d2836 209
d3046 2025
@


8.16
log
@9g
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.15 2009/07/24 08:38:15 root Exp root $
d1104 1
a1104 1
  //if ( (Look8000=(Look8000_t)lxcAdvanced) || (AircraftCategory == (AircraftCategory_t)umParaglider)) {
d2291 1
d2301 1
d2310 4
a2313 1
  #define HEADRAW	3
d2332 2
a2333 2
	maxnlname=MAXNLNAME-4;
  	_stprintf(Buffer,TEXT("MilMalMK"));  // a dirty hack
d2381 1
d2384 2
a2385 1
  	TopSize=rc.top+(HEADRAW*3)+HLTextSize.cy;
d2387 2
a2388 1
  	TopSize+=(WPTextSize.cy);
d2393 2
a2394 1
  	TopSize=rc.top+HEADRAW+HLTextSize.cy;
d2396 2
a2397 1
  	TopSize+=(WPTextSize.cy/4);
d2403 41
d2484 1
d2528 2
d2531 1
d2537 2
a2541 1
	TextDisplayMode.AsFlag.Color = TEXTLIGHTYELLOW;
d2543 2
a2546 1
	TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2548 2
d2553 2
d2558 2
d2562 1
d2564 1
a2564 1

d2571 2
a2574 1
		TextDisplayMode.AsFlag.Color = TEXTLIGHTYELLOW;
d2577 2
a2580 1
		TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2582 2
d2587 2
d2592 2
d2600 2
a2603 1
		TextDisplayMode.AsFlag.Color = TEXTLIGHTYELLOW;
d2606 2
a2609 1
		TextDisplayMode.AsFlag.Color = TEXTLIGHTGREEN;
d2611 2
d2616 2
d2621 2
d2671 1
d2742 1
d2744 2
a2745 1
		else
d2747 2
a2748 1

d2758 2
@


8.15
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.14 2009/07/22 18:53:58 root Exp root $
d2135 1
a2135 1
		if ( GPS_INFO.Time > (firsttime+10.0) ) { // timeout
d2195 11
d2214 2
a2215 3
  SelectObject(hdc, MapWindowFont);
  TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
d2217 1
d2219 1
d2256 4
d2261 3
a2263 3
  SelectObject(hdc, LK8TitleFont);
  _stprintf(Buffer,TEXT("%s"),XCSoar_Version);
  TextInBox(hdc, Buffer, middlex, contenttop+(TextSize.cy*3) , 0, TextDisplayMode, false);
d2294 1
d2327 2
d2333 2
d2339 1
a2339 1
  SelectObject(hdc, LK8TitleFont); // Text font for Nearest
a2340 1
  _stprintf(Buffer,TEXT("MMMMMMMMMMMM")); 
d2356 1
a2356 1
  _stprintf(Buffer,TEXT("+99999")); 
d2359 1
a2359 1
  SelectObject(hdc, MapWindowFont); // Heading line
d2363 3
a2365 1
  short intercolumn=(right-left-WPTextSize.cx-DSTextSize.cx-BETextSize.cx-RETextSize.cx-AATextSize.cx)/3; // era 4 FIX
d2367 1
a2367 1
  if (intercolumn>IBLSCALE(35)) intercolumn=IBLSCALE(35);
d2370 2
a2371 2
//  Column2=Column1+WPTextSize.cx+intercolumn+DSTextSize.cx;	// DS align right
  Column2=Column1+WPTextSize.cx+intercolumn;	// DS align right
d2378 1
a2378 1
  	TopSize=rc.top+(HEADRAW*4)+HLTextSize.cy;
d2385 1
a2385 1
  	TopSize=rc.top+HEADRAW+HLTextSize.cy+HEADRAW;
d2387 1
a2387 1
  	TopSize+=(WPTextSize.cy/2);
d2422 1
a2422 1
		if (MapSpaceMode==2) 
d2472 1
a2472 1
  SelectObject(hdc, MapWindowFont); // Heading line
a2474 5
  if (MapSpaceMode==2) 
  	_stprintf(Buffer,TEXT("Landables %d-%d"), curpage+1,Numpages); 
  else
  	_stprintf(Buffer,TEXT("Airports %d-%d"), curpage+1, Numpages); 
  TextInBox(hdc, Buffer, Column1, HEADRAW , 0, TextDisplayMode, false);
d2476 62
a2537 6
  TextDisplayMode.AsFlag.AlligneRight = 1;
  if ( ScreenSize < (ScreenSize_t)sslandscape ) 
	  _stprintf(Buffer,TEXT("Dist.")); 
  else
	  _stprintf(Buffer,TEXT("Distance")); 
  TextInBox(hdc, Buffer, Column2, HEADRAW , 0, TextDisplayMode, false);
d2539 2
a2540 5
  if ( ScreenSize < (ScreenSize_t)sslandscape ) 
  	_stprintf(Buffer,TEXT("Dir.")); 
  else
  	_stprintf(Buffer,TEXT("Direction")); 
  TextInBox(hdc, Buffer, Column3, HEADRAW , 0, TextDisplayMode, false);
d2542 4
a2545 5
  if ( ScreenSize < (ScreenSize_t)sslandscape ) 
  	_stprintf(Buffer,TEXT("ReqE")); 
  else
  	_stprintf(Buffer,TEXT("ReqEff")); 
  TextInBox(hdc, Buffer, Column4, HEADRAW , 0, TextDisplayMode, false);
d2547 1
a2547 5
  if ( ScreenSize < (ScreenSize_t)sslandscape ) 
  	_stprintf(Buffer,TEXT("AltA")); 
  else
  	_stprintf(Buffer,TEXT("AltArr")); 
  TextInBox(hdc, Buffer, Column5, HEADRAW , 0, TextDisplayMode, false);
d2554 1
a2554 1
  SelectObject(hdc, LK8TitleFont); // Text font for Nearest
d2583 2
a2584 2
		if (wlen>MAXNLNAME) {
			_tcsncpy(Buffer, WayPointList[rli].Name, MAXNLNAME); Buffer[MAXNLNAME]='\0';
@


8.14
log
@wip
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.13 2009/07/22 17:53:03 root Exp root $
d859 1
a859 1
   double tmp = 10000*ResMapScaleOverDistanceModify;
d1211 1
a1211 1
	TextDisplayMode.AsFlag.Color = TEXTWHITE; 
d1369 2
a1370 2
		if (Value<15 ) TextDisplayMode.AsFlag.Color = TEXTRED;
		else if (Value<30 ) TextDisplayMode.AsFlag.Color = TEXTYELLOW;
d1386 1
a1386 1
				TextDisplayMode.AsFlag.Color = TEXTRED;
d1574 1
d1581 1
d1602 1
a1602 1
			OnAlternate1=false;
d1708 1
d1715 1
d1835 1
d1842 1
d1862 1
a1862 1
			OnAlternate2=false;
d1936 1
a1936 1
  		Value=SPEEDMODIFY*CALCULATED_INFO.TaskSpeed;
d1959 1
d1966 1
d2059 1
a2059 1
  	TextDisplayMode.AsFlag.Color = TEXTCYAN;
d2072 1
a2072 1
  	TextDisplayMode.AsFlag.Color = TEXTCYAN;;
d2134 1
d2136 4
a2139 1
			MapSpaceMode=1;
d2196 1
a2196 1
  _stprintf(Buffer,TEXT("LK 8000"));
a2208 1
  TextInBox(hdc, Buffer, left, contenttop , 0, TextDisplayMode, false);
d2211 3
d2241 8
d2252 1
a2252 1
  _stprintf(Buffer,TEXT("LK8000 %s"), XCSoar_Version);
d2256 1
a2256 1
  _stprintf(Buffer,TEXT("LK8000 (C) 2009 Paolo Ventafridda  venta@@bware.it"));
d2276 2
a2277 2
  static TCHAR Buffer1[24][MAXNEAREST], Buffer2[10][MAXNEAREST], Buffer3[10][MAXNEAREST];
  static TCHAR Buffer4[12][MAXNEAREST], Buffer5[12][MAXNEAREST];
d2279 1
a2279 1
  short i, iRaw, wlen, rli=0;
a2288 1
  //// #define MAXNEAREST 15
d2293 1
a2293 1
  //HFONT oldfont;
d2387 8
a2398 1
		///: first we clear event!
d2401 1
a2401 1
			i=SortedLandableIndex[SelectedRaw[MapSpaceMode]+(SelectedPage[MapSpaceMode]*Numraws)];
d2403 1
a2403 1
			i=SortedAirportIndex[SelectedRaw[MapSpaceMode] + (SelectedPage[MapSpaceMode]*Numraws)];
d2419 15
d2454 1
a2454 1
  	_stprintf(Buffer,TEXT("Landfields %d/%d"), SelectedPage[2]+1,Numpages); 
d2456 1
a2456 1
  	_stprintf(Buffer,TEXT("Airports %d/%d"), SelectedPage[3]+1, Numpages); 
d2497 1
a2497 1
  //TCHAR vbuf[100];
d2499 1
a2499 3
  //DoStatusMessage(vbuf); //QUI


d2504 1
a2504 1
	short curraw=(SelectedPage[MapSpaceMode]*Numraws)+i;
a2515 12
/*
		Value=WayPointCalc[Alternate2].GR;
		if (Value <1 || Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"---"); else
			{
			if (Value>99) sprintf(text,"%.0f",Value);
			else sprintf(text,"%.1f",Value);
			}

		wsprintf(BufferValue, TEXT("%S"),text);
*/


d2524 3
a2526 1
		_tcscpy(Buffer1[i],Buffer);
d2530 1
a2530 1
         	_stprintf(Buffer2[i],TEXT("%0.1lf"),Value);
d2545 1
a2545 1
				_stprintf(Buffer3[i], TEXT("%2.0f°»"), Value);
d2548 1
a2548 1
					_stprintf(Buffer3[i], TEXT("«%2.0f°"), -Value);
d2550 1
a2550 1
					_tcscpy(Buffer3[i], TEXT("«»"));
d2553 1
a2553 1
				_stprintf(Buffer3[i], TEXT("%2.0fÂ°Â»"), Value);
d2556 1
a2556 1
					_stprintf(Buffer3[i], TEXT("Â«%2.0fÂ°"), -Value);
d2558 1
a2558 1
					_tcscpy(Buffer3[i], TEXT("Â«Â»"));
d2561 1
a2561 1
			_stprintf(Buffer3[i],_T("---"));
d2566 1
a2566 1
			_stprintf(Buffer4[i],_T("---"));
d2570 1
a2570 1
			_stprintf(Buffer4[i],_T("%S"),text);
d2579 1
a2579 1
		wsprintf(Buffer5[i], TEXT("%S"),text);
d2583 5
a2587 5
		_stprintf(Buffer1[i],_T("------------"));
		_stprintf(Buffer2[i],_T("---"));
		_stprintf(Buffer3[i],_T("---"));
		_stprintf(Buffer4[i],_T("---"));
		_stprintf(Buffer5[i],_T("---"));
d2607 1
a2607 1
	TextInBox(hdc, Buffer1[i], Column1, iRaw , 0, TextDisplayMode, false);
d2611 1
a2611 1
	TextInBox(hdc, Buffer2[i], Column2, iRaw , 0, TextDisplayMode, false);
d2614 1
a2614 1
	TextInBox(hdc, Buffer3[i], Column3, iRaw , 0, TextDisplayMode, false);
d2617 1
a2617 1
	TextInBox(hdc, Buffer4[i], Column4, iRaw , 0, TextDisplayMode, false);
d2620 1
a2620 1
	TextInBox(hdc, Buffer5[i], Column5, iRaw , 0, TextDisplayMode, false);
d2625 8
a2632 1
  ///: BOXOUT SELECTED ITEm
@


8.13
log
@wip
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.12 2009/07/22 10:54:02 root Exp root $
a2245 1
#define DNBUFSIZE 50
d2253 3
a2255 2
  static TCHAR Buffer1[DNBUFSIZE][MAXNEAREST], Buffer2[DNBUFSIZE][MAXNEAREST], Buffer3[DNBUFSIZE][MAXNEAREST];
  static TCHAR Buffer4[DNBUFSIZE][MAXNEAREST], Buffer5[DNBUFSIZE][MAXNEAREST];
d2352 1
@


8.12
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.11 2009/07/21 13:14:10 root Exp root $
d2350 3
d2355 2
d2372 1
a2372 1
			i=SortedLandableIndex[SelectedRaw[MapSpaceMode]];
d2374 1
a2374 1
			i=SortedAirportIndex[SelectedRaw[MapSpaceMode]];
d2410 1
a2410 1
  	_stprintf(Buffer,TEXT("Landfields")); 
d2412 1
a2412 1
  	_stprintf(Buffer,TEXT("Airports")); 
d2448 2
a2449 1
  ///: try to reduce conflicts
d2453 6
d2462 8
a2469 2
	if (MapSpaceMode==2) rli=SortedLandableIndex[i];
		else rli=SortedAirportIndex[i];
d2590 2
a2591 1
  }
d2593 1
@


8.11
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.10 2009/07/17 15:25:21 root Exp root $
a889 1

d2257 1
a2257 1
  short i, iRaw, wlen;
d2262 1
a2262 1
  static short numraws, rawspace;
d2264 2
a2265 1
  static short left,right,top,bottom;
d2311 1
a2311 1
  _stprintf(Buffer,TEXT("199")); 
d2315 1
a2315 1
  _stprintf(Buffer,TEXT("+9999")); 
d2322 1
a2322 1
  short intercolumn=(right-left-WPTextSize.cx-DSTextSize.cx-BETextSize.cx-RETextSize.cx-AATextSize.cx)/4;
d2327 2
a2328 1
  Column2=Column1+WPTextSize.cx+intercolumn+DSTextSize.cx;	// DS align right
d2335 5
a2339 5
  	top=rc.top+(HEADRAW*4)+HLTextSize.cy;
  	p1.x=0; p1.y=top; p2.x=rc.right; p2.y=p1.y;
  	top+=(WPTextSize.cy);
  	numraws=(bottom - top) / (WPTextSize.cy+(INTERRAW*2));
  	if (numraws>MAXNEAREST) numraws=MAXNEAREST;
d2342 5
a2346 5
  	top=rc.top+HEADRAW+HLTextSize.cy+HEADRAW;
  	p1.x=0; p1.y=top; p2.x=rc.right; p2.y=p1.y;
  	top+=(WPTextSize.cy/2);
  	numraws=(bottom - top) / (WPTextSize.cy+INTERRAW);
  	if (numraws>MAXNEAREST) numraws=MAXNEAREST;
d2350 2
a2351 1

d2354 1
a2354 1

d2360 30
d2411 4
a2414 1
  _stprintf(Buffer,TEXT("Distance")); 
d2417 4
a2420 1
  _stprintf(Buffer,TEXT("Direction")); 
d2423 4
a2426 1
  _stprintf(Buffer,TEXT("ReqE")); 
d2429 4
a2432 1
  _stprintf(Buffer,TEXT("AltA")); 
d2448 2
a2449 3
  for (i=0; i<numraws; i++) {
	iRaw=top+(rawspace*i);
	short rli;
d2573 19
a2591 1
 
@


8.10
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.9 2009/07/14 19:50:56 root Exp root $
d856 2
a857 3
   if (MapScale>4) return;
   if ( !((DisplayOrientation == TRACKUP) || (DisplayOrientation == NORTHCIRCLE) || (DisplayOrientation == TRACKCIRCLE)
         && (DisplayMode != dmCircling))    ) return;
d1273 1
a1273 1
  static HBRUSH hB= CreateSolidBrush(RGB(0x26,0x26,0x26)); // dark grey
a1288 1
  // QUI
d2091 2
a2092 1
///:	3= recent waypoints
d2112 1
a2112 1
  p1.x=0; p1.y=rc.bottom-BottomSize-IBLSCALE(1); p2.x=rc.right; p2.y=p1.y;
d2116 1
a2116 1
  p1.x=0; p1.y=0; p2.x=0; p2.y=rc.bottom-BottomSize-IBLSCALE(1);
d2118 1
a2118 1
  p1.x=rc.right; p1.y=0; p2.x=rc.right; p2.y=rc.bottom-BottomSize-IBLSCALE(1);
d2134 1
d2137 1
a2137 1
	case 3:
d2149 1
d2210 1
a2210 1
  else
d2213 1
d2225 1
a2225 1
  TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*6) , 0, TextDisplayMode, false);
d2242 1
a2242 1
///:
d2359 1
a2359 1
  TextDisplayMode.AsFlag.Color = TEXTGREEN;
d2372 4
a2375 1
  _stprintf(Buffer,TEXT("Landfields")); 
d2406 3
a2408 1
	short rli=SortedLandableIndex[i];
a2487 1
//QUI
d2501 2
a2502 2
		if ( ((WayPointList[rli].Flags & AIRPORT) == AIRPORT) && 
		( (WayPointList[i].Flags & LANDPOINT) != LANDPOINT) )
d2505 1
a2505 1
			TextDisplayMode.AsFlag.Color = TEXTYELLOW;
d2508 1
a2508 1
			TextDisplayMode.AsFlag.Color = TEXTRED;
@


8.9
log
@funzionante beta mokup
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.8 2009/07/13 21:59:03 root Exp root $
d2128 1
a2128 1
		if ( GPS_INFO.Time > (firsttime+10.0) ) {
d2176 1
a2176 1
  TextDisplayMode.AsFlag.Color = TEXTGREEN;
d2187 1
a2187 1
  _stprintf(Buffer,TEXT("Tactical Glide Computer"));
d2217 1
a2217 1
  _stprintf(Buffer,TEXT("Airspace points=%d areas=%d circles=%d"), NumberOfAirspacePoints,NumberOfAirspaceAreas,
d2221 5
d2239 3
d2244 6
d2253 5
a2257 1
  short i, iRaw;
d2265 1
a2265 1
  #define MAXNEAREST 15
d2296 1
a2296 1
  ///: Size waypoint name to 12 characters
d2370 1
a2370 1
  _stprintf(Buffer,TEXT("Landfield")); 
d2393 6
d2401 104
d2507 2
a2508 2
  	_stprintf(Buffer,TEXT("MMMMMMMMMMMM")); 
	TextInBox(hdc, Buffer, Column1, iRaw , 0, TextDisplayMode, false);
d2511 2
a2512 2
  	_stprintf(Buffer,TEXT("000.0")); 
	TextInBox(hdc, Buffer, Column2, iRaw , 0, TextDisplayMode, false);
d2514 2
a2515 2
  	_stprintf(Buffer,TEXT("<<123")); 
	TextInBox(hdc, Buffer, Column3, iRaw , 0, TextDisplayMode, false);
d2517 2
a2518 2
  	_stprintf(Buffer,TEXT("123")); 
	TextInBox(hdc, Buffer, Column4, iRaw , 0, TextDisplayMode, false);
d2520 2
a2521 2
  	_stprintf(Buffer,TEXT("+9999")); 
	TextInBox(hdc, Buffer, Column5, iRaw , 0, TextDisplayMode, false);
@


8.8
log
@temp
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.7 2009/07/05 22:57:54 root Exp root $
d73 1
d2090 1
a2090 1
///:	0= splash screen (unused)
d2100 1
a2100 1
  SIZE TextSize;
d2105 1
a2105 6
  RECT nrc;
  nrc.left=0;
  nrc.top=0;
  nrc.right=rc.right;
  nrc.bottom=rc.bottom-BottomSize;
  FillRect(hdc,&rc, hB);  // nrc FIX
d2107 4
a2110 4
  short bottomlines;
  short middlex=(rc.right-rc.left)/2;
  short left=rc.left+IBLSCALE(5);
  short contenttop=rc.top+IBLSCALE(50);
d2128 1
a2128 1
		if ( GPS_INFO.Time > (firsttime+30.0) ) {
d2132 1
a2132 57

  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTGREEN;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  //TextDisplayMode.AsFlag.AlligneRight = 0;
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  TextDisplayMode.AsFlag.WhiteBold = 0;
  SelectObject(hdc, LK8TargetFont);

  
  _stprintf(Buffer,TEXT("LK 8000"));
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  TextInBox(hdc, Buffer, middlex, (TextSize.cy/2)+IBLSCALE(2) , 0, TextDisplayMode, false);
  _stprintf(Buffer,TEXT("Tactical Glide Computer"));
  SelectObject(hdc, LK8MediumFont);
  TextInBox(hdc, Buffer, middlex, (TextSize.cy/2)+TextSize.cy-IBLSCALE(4) , 0, TextDisplayMode, false);

  SelectObject(hdc, MapWindowFont);
  TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;


  _stprintf(Buffer,TEXT("ScreenSize: %d x %d"),rc.right, rc.bottom);
  TextInBox(hdc, Buffer, left, contenttop , 0, TextDisplayMode, false);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);

#if (WINDOWSPC>0)
  _stprintf(Buffer,TEXT("WindowsPC version"));
#else
  _stprintf(Buffer,TEXT("Configuration: %s%S"), gmfpathname(),XCSDATADIR);
#endif
  TextInBox(hdc, Buffer, left, contenttop+TextSize.cy , 0, TextDisplayMode, false);

  if (LoggerGActive()) 
  	_stprintf(Buffer,TEXT("Grecord DLL: Ok"));
  else
  	TextDisplayMode.AsFlag.Color = TEXTRED;
  	_stprintf(Buffer,TEXT("Grecord DLL: NO"));
  TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*2) , 0, TextDisplayMode, false);

  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  _stprintf(Buffer,TEXT("Waypoints loaded: %d"), NumberOfWayPoints);
  TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*3) , 0, TextDisplayMode, false);
  _stprintf(Buffer,TEXT("Airspace points=%d areas=%d circles=%d"), NumberOfAirspacePoints,NumberOfAirspaceAreas,
		NumberOfAirspaceCircles);
  TextInBox(hdc, Buffer, left, contenttop+(TextSize.cy*4) , 0, TextDisplayMode, false);

  SelectObject(hdc, LK8UnitFont);
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  _stprintf(Buffer,TEXT("LK8000 %s"), XCSoar_Version);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  bottomlines=rc.bottom-BottomSize-(TextSize.cy*3);
  TextInBox(hdc, Buffer, middlex, bottomlines , 0, TextDisplayMode, false);
  _stprintf(Buffer,TEXT("LK8000 (C) 2009 Paolo Ventafridda  venta@@bware.it"));
  TextInBox(hdc, Buffer, middlex, bottomlines+TextSize.cy , 0, TextDisplayMode, false);

a2133 4

	//
	// Nearest landings
	//
d2145 1
a2145 1
		TextInBox(hdc, Buffer, middlex, IBLSCALE(50) , 0, TextDisplayMode, false);
d2151 1
d2159 15
a2173 1
void DrawWelcome8000(HDC hdc, RECT rc) {
d2235 162
a2396 1
void DrawNearest(HDC hdc, RECT rc) {
d2401 1
a2401 1
void DrawRecent(HDC hdc, RECT rc) {
@


8.7
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.6 2009/07/01 22:26:20 root Exp root $
d85 5
d654 1
a654 1
 * Sort of a Stockmar dynamic chart!
d852 18
d898 6
d1212 1
a1212 1
	TextDisplayMode.AsFlag.Color = TEXTGREEN; 
d1240 1
d1273 1
a1273 1
  static HBRUSH hB= CreateSolidBrush(RGB(0x26,0x26,0x26));
d2020 4
d2053 1
a2053 1
  	TextDisplayMode.AsFlag.Color = TEXTBLUE;
d2066 1
a2066 1
  	TextDisplayMode.AsFlag.Color = TEXTBLUE;;
d2073 1
a2073 1
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK")); // no, does it every second! FIX
d2078 2
a2084 11
/*
 int iWidth=GetSystemMetrics(SM_CXSCREEN);
  int iHeight=GetSystemMetrics(SM_CYSCREEN);
  HDC dc;
  dc = ::GetDC(NULL);
  int dpix = ::GetDeviceCaps(dc,LOGPIXELSX);
  int dpiy = ::GetDeviceCaps(dc,LOGPIXELSY);
  //  96=QVGA 240x320
  // 144=HVGA 360x480
  // 192= VGA 480x640
  //
d2086 75
a2160 7
// VENTA FIX REMOVE
char ventabuffer[200];
FILE *fp;
 sprintf(ventabuffer,"screensize get =%d %d dpix=%d dpiy=%d\r\n",iWidth,iHeight,dpix,dpiy);
       if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
                    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
*/
d2162 6
a2167 1
}
d2169 6
d2176 6
a2181 1
void DrawLandPage(HDC hdc,  RECT rc ) {
d2183 9
a2191 1
 HFONT oldfont;
d2193 1
a2193 1
 oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // save font
d2195 16
d2212 5
d2221 72
@


8.6
log
@wip ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.5 2009/06/30 14:47:48 root Exp root $
a863 2
  #define SPLITTER 6 // do not touch. Number of values per line
	splitter=5;
d902 1
a902 1
					tlen=11;
d908 1
a908 1
					tlen=10;
d920 1
a920 1
					tlen=8;
d1243 1
a1243 1
  static HBRUSH hB= CreateSolidBrush(RGB(0x33,0x33,0x33));
d2019 1
a2019 1
  	TextDisplayMode.AsFlag.Color = TEXTMAGENTA;
a2027 1

d2032 1
a2032 1
  	TextDisplayMode.AsFlag.Color = TEXTMAGENTA;;
d2037 7
a2043 2

   }
@


8.5
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.4 2009/06/28 21:30:41 root Exp root $
d848 1
a848 1
 * Cool new LK8000 by Paolo
d865 1
a865 1
  short splitter;
d1209 2
a1210 1
   * Experimental cool look 8000
d1230 2
a1231 2
  int iWidth=GetSystemMetrics(SM_CXSCREEN) / 10;
  int iHeight=GetSystemMetrics(SM_CYSCREEN) / 10;
d1390 1
a1390 1
  rcx=rc.left+(rc.right/(SPLITTER*2))-IBLSCALE(5);
d1478 1
a1478 1
  rcx+=(rc.right/SPLITTER); 
d1589 1
a1589 1
  rcx+=(rc.right/SPLITTER); 
d1709 1
a1709 1
  rcx+=(rc.right/SPLITTER); 
d1736 1
d1846 1
a1846 1
  rcx+=(rc.right/SPLITTER)-IBLSCALE(7);  // shorter value
d1873 1
d1956 1
a1956 1
  rcx+=(rc.right/SPLITTER)-IBLSCALE(11); 
d1982 2
d1989 1
a1989 1
  
d2021 1
a2021 1
  	TextDisplayMode.AsFlag.Color = TEXTWHITE;
d2035 1
a2035 1
  	TextDisplayMode.AsFlag.Color = TEXTWHITE;;
d2046 21
@


8.4
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.3 2009/06/27 17:18:37 root Exp root $
d853 1
a853 1
  SIZE TextSize;
d865 1
d976 4
a979 1
		 Value=CALCULATED_INFO.WaypointDistance*DISTANCEMODIFY; // FIX AAT
d987 3
d991 1
a991 1
		 }
d993 6
a998 2
		 wsprintf(Buffer, TEXT("%S"), text);
		 TextInBox(hdc, Buffer, rcx+IBLSCALE(2),rcy+TextSize.cy, 0, TextDisplayMode, false); 
d1128 5
a1132 3
		wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
		SelectObject(hdc, MapWindowFont); 
		TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
d1141 11
a1151 9
	Value= ALTITUDEMODIFY*GPS_INFO.Altitude;
	_stprintf(Buffer,TEXT("%0.0f"),Value);
	SelectObject(hdc, LK8BigFont); 
	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	rcy+=TextSize.cy;
	TextInBox(hdc, Buffer, rcx,rcy-IBLSCALE(2), 0, TextDisplayMode, false);   
	wsprintf(BufferUnit, TEXT("%s"),Units::GetAltitudeName());
	SelectObject(hdc, MapWindowFont); 
	TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
d1160 5
a1164 3
	wsprintf(BufferUnit, TEXT("%s"),Units::GetHorizontalSpeedName());
	SelectObject(hdc, MapWindowFont); 
	TextInBox(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, TextDisplayMode, false);   
d2021 1
a2021 1
  		TextInBox(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2) , 0, TextDisplayMode, false);
d2023 1
a2023 1
  		TextInBox(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2) , 0, TextDisplayMode, false);
d2034 1
a2034 1
  	TextInBox(hdc, Buffer, rc.right - (TextSize.cx)-IBLSCALE(20) ,  rc.bottom - TextSize.cy , 0, TextDisplayMode, false);
@


8.3
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.2 2009/06/24 10:03:57 root Exp root $
d1112 1
a1112 1
	rcx=rc.left+IBLSCALE(1); 
d1168 1
d1187 1
d1999 1
a1999 1
  	TextDisplayMode.AsFlag.Color = TEXTGREEN;
d2004 1
a2004 1
  		TextInBox(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- TextSize.cy , 0, TextDisplayMode, false);
d2006 5
a2010 1
  		TextInBox(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - TextSize.cy , 0, TextDisplayMode, false);
d2012 6
a2017 1
  	TextDisplayMode.AsFlag.Color = TEXTWHITE;
d2020 1
@


8.2
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 8.1 2009/06/19 20:28:25 venta Exp root $
d53 1
d71 1
d660 1
a660 4
  double cruise= CALCULATED_INFO.CruiseLD;
  // VENTA3 TODO: use maxcruise with tail wind with a better checking. Otherwise use only bestLD for safety
  // VENTA3 TODO: make maxcruise dynamic 
  // static double maxcruise=(GlidePolar::bestld*1.2); // max bestLD + 20% (max tail wind benefit) 
d802 2
a811 2

  //wsprintf(gtext,_T("scaL/D:%d"),(int)cruise);
a812 1
//QUI
d840 1
d848 1
a848 5
 * Work in progress by P.V.
 * TODO: fix fonts and outline shades for PDAs. (DONE)
 * TODO: add units other than metrics (DONE)
 * Currently best used with PNA with geometry 5box right.
 * Doesn't look bad on portrait 640x480 full screen PDA, too!
d863 2
a864 1
  short wlen;
d866 1
a866 1
  if (NewMap==false) return;
a867 1
#define SPLITTER 6 // do not touch. Number of values per line
d869 57
a925 3
  oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // save font
  if ( InfoBoxLayout::landscape && IsMapFullScreen() && !EnablePan ) DrawBottom=true;
	else DrawBottom=false;
d946 1
a946 1
	  // Waypoint name and distance
d948 2
a949 2
//	  SelectObject(hdc, StatisticsFont); // FIX ORIG
	  SelectObject(hdc, LK8TargetFont);
d951 1
a951 1
	  TextDisplayMode.AsInt = 0;
d953 6
a958 6
	  // Active colours
	  if (WayPointList[index].Reachable) {
		  TextDisplayMode.AsFlag.Color = TEXTGREEN; 
	  } else {
		  TextDisplayMode.AsFlag.Color = TEXTRED;
	  }
d960 11
a970 19
	  TextDisplayMode.AsFlag.Color = TEXTWHITE;
	  TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
	  TextDisplayMode.AsFlag.NoSetFont = 1; 
	  TextDisplayMode.AsFlag.AlligneRight = 0;
	 wlen=wcslen(WayPointList[index].Name);
	 if ( (ScreenSize < (ScreenSize_t)sslandscape) || (ScreenSize == (ScreenSize_t)ss320x240) ) {
	 	if (wlen>6) {
 	 		_tcsncpy(Buffer, WayPointList[index].Name, 6); Buffer[6]='\0';
	 	} else {
 	 		_tcsncpy(Buffer, WayPointList[index].Name, wlen); Buffer[wlen]='\0';
	 	}
	 } else
	 {
	 	if (wlen>9) {
 	 		_tcsncpy(Buffer, WayPointList[index].Name, 9); Buffer[9]='\0';
	 	} else {
 	 		_tcsncpy(Buffer, WayPointList[index].Name, wlen); Buffer[wlen]='\0';
	 	}
	 }
d1031 1
d1041 6
a1046 1
	  Value=WayPointCalc[index].GR;
d1067 121
d1977 1
a1977 2
  //SelectObject(hdc, StatisticsFont);
  SelectObject(hdc, LK8ValueFont);
d1999 1
a2000 1
	rcy+=TextSize.cy; // used as an offset here
d2002 1
a2002 1
  		TextInBox(hdc, Buffer, rc.left+IBLSCALE(5), rc.bottom - BottomSize- rcy -IBLSCALE(4), 0, TextDisplayMode, false);
d2004 1
a2004 1
  		TextInBox(hdc, Buffer, rc.left+IBLSCALE(5), rc.bottom - rcy - IBLSCALE(7), 0, TextDisplayMode, false);
@


8.1
log
@beta8
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.13 2009/06/16 14:07:36 root Exp $
d814 1
d868 2
a869 2
  //if (!InfoBoxLayout::landscape) return;
  //if (!IsMapFullScreen()) return;
d872 1
a872 1
#define SPLITTER 6
d875 1
a875 1
  if ( InfoBoxLayout::landscape && IsMapFullScreen() ) DrawBottom=true;
d915 1
a915 1
	 short wlen=wcslen(WayPointList[index].Name);
d934 1
a934 2
	 //if (!DrawBottom) { // Rob's suggestion
		 Value= WayPointCalc[index].Distance*DISTANCEMODIFY;
a946 1
	 //}
d1161 29
d1207 1
a1207 1
  if (showunit==true) {
d1224 1
d1266 15
d1295 1
a1295 1
  if (showunit==true) {
d1311 1
d1359 33
d1406 1
a1406 1
  if (showunit==true) {
d1421 1
d1440 2
a1441 1
			Value=WayPointCalc[index].Distance*DISTANCEMODIFY;
d1491 20
d1526 1
a1526 1
  if (showunit==true) {
d1541 1
a1541 1

d1615 32
d1662 1
a1662 1
  if (showunit==true) {
d1679 1
d1696 4
a1699 2
		if (Value==0) sprintf(text,"---");
		else sprintf(text,"%.0f",Value);
d1736 20
d1771 1
a1771 1
  if (showunit==true ) {
d1821 2
d1824 1
a1824 1
  	TextInBox(hdc, Buffer, rc.left+IBLSCALE(5), rc.bottom - BottomSize- TextSize.cy-IBLSCALE(2), 0, TextDisplayMode, false);
d1826 16
a1841 1
  	TextInBox(hdc, Buffer, rc.left+IBLSCALE(5), rc.bottom - TextSize.cy - IBLSCALE(5), 0, TextDisplayMode, false);
d1847 12
@


1.13
log
@incorso
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.12 2009/06/15 09:32:09 root Exp root $
d1219 1
a1219 1
  		Value=CALCULATED_INFO.TaskAltitudeDifference0;
d1277 1
a1277 1
  		Value=DerivedDrawInfo.NavAltitude;
d1284 1
a1284 1
  		Value=DerivedDrawInfo.AltitudeAGL;
d1351 1
a1351 1
		Value=DerivedDrawInfo.ThermalGain;
d1451 1
a1451 1
		Value=DerivedDrawInfo.Average30s;
d1488 1
a1488 1
  		Value=CALCULATED_INFO.TaskStartAltitude;
@


1.12
log
@prima di TL
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.11 2009/06/14 11:28:43 root Exp root $
d154 1
a154 1
      if ( (WayPointList[i].Flags & LANDPOINT) != LANDPOINT) continue;
d167 6
a172 1
      } else { // outlanding
d182 1
a182 1
      }
a895 3
  //	  oldfont = (HFONT)SelectObject(hdc, MapWindowBoldFont);
  //	  oldfont = (HFONT)SelectObject(hdc, InfoWindowFont);

d898 2
a899 1
	  SelectObject(hdc, StatisticsFont);
d915 14
a928 1
 	 _tcsncpy(Buffer, WayPointList[index].Name, wlen); Buffer[wlen]='\0';
d977 2
a978 1
  	  SelectObject(hdc, InfoWindowFont);
d992 2
a993 1
	  SelectObject(hdc, InfoWindowFont); // use this font for big values
a1091 4
  //SelectObject(hdc, MapWindowBoldFont);  // fat
  //SelectObject(hdc, InfoWindowFont); // big
  //SelectObject(hdc, MapWindowFont);

d1156 2
d1160 1
a1160 1
  		wsprintf(BufferTitle, TEXT("Battery"),text);
d1171 2
a1172 1
  SelectObject(hdc, StatisticsFont);
d1181 2
a1182 1
  	SelectObject(hdc, MapLabelFont);
d1184 2
a1185 1
  	SelectObject(hdc, TitleSmallWindowFont);
d1191 2
a1192 1
  SelectObject(hdc, MapWindowFont);
d1223 1
a1223 1
 		wsprintf(BufferTitle, TEXT("DiffMc0"),text);
d1235 1
a1235 1
  		wsprintf(BufferTitle, TEXT("B.Temp"),text);
d1244 1
a1244 1
  SelectObject(hdc, StatisticsFont);
d1253 2
a1254 1
  	SelectObject(hdc, MapLabelFont);
d1256 2
a1257 1
  	SelectObject(hdc, TitleSmallWindowFont);
d1263 1
a1263 1
  SelectObject(hdc, MapWindowFont);
d1288 1
a1288 1
 		wsprintf(BufferTitle, TEXT("AltAGL"),text);
d1321 1
a1321 1
  SelectObject(hdc, StatisticsFont);
d1330 2
a1331 1
  	SelectObject(hdc, MapLabelFont);
d1333 1
a1333 1
  	SelectObject(hdc, TitleSmallWindowFont);
d1339 1
a1339 1
  SelectObject(hdc, MapWindowFont);
d1409 1
a1409 1
 		wsprintf(BufferTitle, TEXT("Flying"),text);
d1419 1
a1419 1
  SelectObject(hdc, StatisticsFont);
d1428 2
a1429 1
	  SelectObject(hdc, MapLabelFont);
d1431 1
a1431 1
	  SelectObject(hdc, TitleSmallWindowFont);
d1437 1
a1437 1
  SelectObject(hdc, MapWindowFont);
d1485 1
a1485 1
  		wsprintf(BufferTitle, TEXT("Radial"));
d1496 1
a1496 1
 		wsprintf(BufferTitle, TEXT("StartAlt"),text);
d1499 5
d1513 1
d1523 1
a1523 1
  SelectObject(hdc, StatisticsFont);
d1532 2
a1533 1
	  SelectObject(hdc, MapLabelFont);
d1535 1
a1535 1
	  SelectObject(hdc, TitleSmallWindowFont);
d1541 1
a1541 1
  SelectObject(hdc, MapWindowFont);
d1545 1
a1545 1

a1582 1
  			wsprintf(BufferUnit, TEXT("%s"),(Units::GetHorizontalSpeedName()));
d1586 2
a1587 1
  		wsprintf(BufferTitle, TEXT("AvgSpeed"));
d1591 1
a1591 1
  			wsprintf(BufferValue, TEXT("ON"));
d1593 1
a1593 1
  			wsprintf(BufferValue, TEXT("OFF"));
d1598 1
a1598 1
  		wsprintf(BufferTitle, TEXT("G-Record"));
d1609 1
a1609 1
  SelectObject(hdc, StatisticsFont);
d1618 2
a1619 1
	  SelectObject(hdc, MapLabelFont);
d1621 1
a1621 1
	  SelectObject(hdc, TitleSmallWindowFont);
d1626 1
a1626 1
  SelectObject(hdc, MapWindowFont);
d1630 1
a1631 1
  //TextDisplayMode.AsFlag.Color = TEXTWHITE;
d1654 2
a1655 1
  SelectObject(hdc, StatisticsFont);
@



1.11
log
@provvisorio ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.10 2009/06/11 19:50:42 root Exp $
d52 1
a883 3
	
	  // Waypoint name and distance

d886 4
d894 2
d934 2
d970 1
a970 1
       } 
d1056 7
a1062 3
  //
  // TASK:
  // task speed  SpeedTaskAverage
a1063 2
  // TaskDistanceToGo
  // Final ETE
d1128 11
d1199 7
d1269 9
d1279 4
a1282 1
		if (Value<0 || Value>30) wsprintf(BufferValue,TEXT("---"));
d1284 2
d1370 10
d1464 18
a1481 1
  		wsprintf(BufferValue, TEXT(""));
d1483 1
a1483 1
  		wsprintf(BufferTitle, TEXT(""));
d1523 1
a1523 2
		if (CALCULATED_INFO.timeCircling <=0) Value=0; else
		Value = LIFTMODIFY*CALCULATED_INFO.TotalHeightClimb /CALCULATED_INFO.timeCircling;
d1526 2
a1527 2
		wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
	 	wsprintf(BufferTitle, TEXT("AvgAll"),text);
d1548 20
a1567 1
  		wsprintf(BufferValue, TEXT(""));
a1568 1
  		wsprintf(BufferTitle, TEXT(""));
d1599 1
@


1.10
log
@alfa
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.9 2009/06/11 10:00:03 root Exp root $
a866 5
  // Careful here: Utils2 is using the same formula, so if you change here also change there.
  // Should make it global, maybe when I am done with final version.
  static short BOTTOMSIZE= Appearance.StatisticsFont.Height + Appearance.MapWindowFont.Height;


a876 4


  // Then we draw task related informations

d895 1
a895 1
/* 
d902 1
a902 1
*/
d913 1
a913 1
	 if (!DrawBottom) {
d927 1
a927 1
	 }
d1007 1
a1007 1
    nrc.top=rc.bottom-BOTTOMSIZE;
d1032 1
a1032 1
  AlphaBlend(hdc,0,rc.bottom-BOTTOMSIZE,rc.right,BOTTOMSIZE,hdc2,0,rc.bottom-BOTTOMSIZE,rc.right,BOTTOMSIZE,bs);
d1116 1
a1116 1
		wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
d1185 1
a1185 1
			sprintf(text,"%.0lf%%",Value);
d1549 1
a1549 1
  	TextInBox(hdc, Buffer, rc.left+IBLSCALE(5), rc.bottom - BOTTOMSIZE- TextSize.cy-IBLSCALE(2), 0, TextDisplayMode, false);
@


1.9
log
@switch so BottomMode ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.8 2009/06/10 22:49:40 root Exp root $
d86 2
d1061 2
a1062 1
  //
a1063 2
  // FinalAltitudeDifference
  // TaskSpeed
a1064 1
  // Thermal All
a1065 5
  // QFE GPS
  // Distance Home / Radial
  // 

  // Battery, FlightTime, 
d1082 1
d1100 3
d1105 1
a1105 2
	case 2:
	  	Value= LIFTMODIFY*CALCULATED_INFO.LastThermalAverage;
d1113 1
a1113 1
	  	Value= LIFTMODIFY*CALCULATED_INFO.AverageThermal;
d1120 17
d1152 1
d1154 1
a1154 1
  SelectObject(hdc, MapLabelFont);
d1156 1
a1156 1
  SelectObject(hdc, TitleSmallWindowFont);
d1158 3
a1160 2
  TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   // FIRST value unit
d1170 1
a1170 1

a1173 1
	case 2:
d1181 19
d1214 1
d1216 1
a1216 1
  SelectObject(hdc, MapLabelFont);
d1218 1
a1218 1
  SelectObject(hdc, TitleSmallWindowFont);
d1220 3
a1222 2
  TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1234 1
a1237 1
	case 2:
d1244 17
d1275 1
d1277 1
a1277 1
  SelectObject(hdc, MapLabelFont);
d1279 1
a1279 1
  SelectObject(hdc, TitleSmallWindowFont);
d1281 3
a1283 2
  TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1294 1
a1296 1
	case 2:
d1308 4
a1311 1
			sprintf(text,"%.1f",Value);
d1322 25
d1362 1
d1364 1
a1364 1
  SelectObject(hdc, MapLabelFont);
d1366 1
a1366 1
  SelectObject(hdc, TitleSmallWindowFont);
d1368 3
a1370 3

  TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextInBox(hdc, BufferUnit, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1383 1
a1385 1
	case 2:
d1410 1
d1413 14
d1442 6
a1447 2
  if (BottomMode == 0 ) {
	SelectObject(hdc, MapLabelFont);
d1462 1
a1464 1
	case 2:
d1473 2
a1474 2
	  Value=DerivedDrawInfo.AverageLD;
	  if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"+++"); else
d1478 1
a1478 1
		wsprintf(BufferUnit, TEXT("%s"),Units::GetVerticalSpeedName());
d1481 14
d1510 6
a1515 2
  if (BottomMode == 0 ) {
	SelectObject(hdc, MapLabelFont);
@


1.8
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.7 2009/06/08 11:33:21 root Exp root $
d852 3
d1085 15
d1104 25
a1128 4
  if (DisplayMode != dmCircling ) 
  	Value= LIFTMODIFY*CALCULATED_INFO.LastThermalAverage;
  else
  	Value= LIFTMODIFY*CALCULATED_INFO.AverageThermal;
a1129 2
  if (Value<20) sprintf(text,"%+.1lf",Value);
	  else sprintf(text,"%+.0lf",Value);
d1131 1
a1131 2
  wsprintf(Buffer, TEXT("%S"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1135 1
a1135 1
  TextInBox(hdc, Buffer, rcx, rcy , 0, TextDisplayMode, false);   // FIRST value
a1141 2
  
  wsprintf(Buffer, TEXT("%s"),Units::GetVerticalSpeedName());
d1143 1
a1143 1
  TextInBox(hdc, Buffer, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   // FIRST value unit
d1146 1
a1146 2
  wsprintf(Buffer, TEXT("Thermal"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1148 1
a1148 1
  TextInBox(hdc, Buffer, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);   // FIRST name
d1154 18
a1171 3
  Value=SPEEDMODIFY*DrawInfo.Speed;
  if (Value<0||Value>999) Value=0;
  sprintf(text,"%d",(int)Value);
d1173 1
a1173 2
  wsprintf(Buffer, TEXT("%S"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1177 1
a1177 1
  TextInBox(hdc, Buffer, rcx, rcy , 0, TextDisplayMode, false);   
a1183 2
  //wsprintf(Buffer, TEXT("km/h"),text);
  wsprintf(Buffer, TEXT("%s"),(Units::GetHorizontalSpeedName()));
d1185 1
a1185 1
  TextInBox(hdc, Buffer, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1188 1
a1188 2
  wsprintf(Buffer, TEXT("GS"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1190 1
a1190 1
  TextInBox(hdc, Buffer, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d1197 17
a1213 2
  Value=DerivedDrawInfo.NavAltitude;
  sprintf(text,"%d",(int)Value);
d1215 1
a1215 2
  wsprintf(Buffer, TEXT("%S"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1219 1
a1219 1
  TextInBox(hdc, Buffer, rcx, rcy , 0, TextDisplayMode, false);   
a1225 1
  wsprintf(Buffer, TEXT("%s"),(Units::GetAltitudeName()));
d1227 1
a1227 1
  TextInBox(hdc, Buffer, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1230 1
a1230 2
  wsprintf(Buffer, TEXT("Alt"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1232 1
a1232 1
  TextInBox(hdc, Buffer, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d1238 30
a1267 14
  if (DisplayMode == dmCircling ) {
	  Value=DerivedDrawInfo.ThermalGain;
	  sprintf(text,"%+d",(int)Value);
  } else
  if ( ValidTaskPoint(ActiveWayPoint) != false ) {
     index = Task[ActiveWayPoint].Index;
     if (index>=0) {
  	Value=WayPointCalc[index].Distance*DISTANCEMODIFY;
  	sprintf(text,"%.1f",Value);
     } else {
  	strcpy(text,"----");
     }
  } else {
  	strcpy(text,"----");
d1270 1
d1272 1
a1272 2
  wsprintf(Buffer, TEXT("%S"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1276 1
a1276 1
  TextInBox(hdc, Buffer, rcx, rcy , 0, TextDisplayMode, false);   
a1277 1
  //SelectObject(hdc, MapLabelFont);
d1283 1
a1283 4
  if (DisplayMode == dmCircling )
  	wsprintf(Buffer, TEXT("%s"),(Units::GetAltitudeName()));
  else
  	wsprintf(Buffer, TEXT("%s"),(Units::GetDistanceName()));
d1285 1
a1285 1
  TextInBox(hdc, Buffer, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1288 1
a1288 5
  if (DisplayMode == dmCircling )
  	wsprintf(Buffer, TEXT("Gain"),text);
  else
  	wsprintf(Buffer, TEXT("Dist"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1290 1
a1290 1
  TextInBox(hdc, Buffer, rcx+IBLSCALE(7), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d1298 34
a1331 19
  if (DisplayMode == dmCircling ) {
	  Value=DerivedDrawInfo.Average30s;
	  if (Value<20) sprintf(text,"%+.1lf",Value);
		  else sprintf(text,"%+.0lf",Value);
  } else 
  if ( ValidTaskPoint(ActiveWayPoint) != false ) {
     index = Task[ActiveWayPoint].Index;
     if (index>=0) {
  	Value=WayPointCalc[index].GR; // required efficiency
	if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"---"); else
		{
		if (Value>99) sprintf(text,"%.1f",Value);
		else sprintf(text,"%.0f",Value);
		}
     } else {
  	strcpy(text,"---");
     }
  } else {
  	strcpy(text,"---");
d1333 2
d1336 1
a1336 2
  wsprintf(Buffer, TEXT("%S"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1340 6
a1345 6
  TextInBox(hdc, Buffer, rcx, rcy , 0, TextDisplayMode, false);   
  if (DisplayMode == dmCircling ) {
	  SelectObject(hdc, MapLabelFont);
	  wsprintf(Buffer, TEXT(""),text);
	  TextDisplayMode.AsFlag.AlligneCenter = 0;
	  TextInBox(hdc, Buffer, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
d1347 1
d1349 1
a1349 5
  if (DisplayMode == dmCircling )
  	wsprintf(Buffer, TEXT("Ther30\""),text);
  else
  	wsprintf(Buffer, TEXT("reqE"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1351 1
a1351 1
  TextInBox(hdc, Buffer, rcx+IBLSCALE(3), rcy-TextSize.cy , 0, TextDisplayMode, false);  
d1358 11
a1368 4
  if (DisplayMode == dmCircling ) {
 	  Value = LIFTMODIFY*CALCULATED_INFO.TotalHeightClimb /CALCULATED_INFO.timeCircling;
	  sprintf(text,"%+.1lf",Value);
  } else {
d1373 9
d1384 1
d1386 1
a1386 2
  wsprintf(Buffer, TEXT("%S"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1390 1
a1390 1
  TextInBox(hdc, Buffer, rcx, rcy , 0, TextDisplayMode, false);   
d1392 1
a1392 1
  if (DisplayMode == dmCircling ) {
a1393 1
	wsprintf(Buffer, TEXT("%s"),(Units::GetAltitudeName()));
d1395 1
a1395 1
	TextInBox(hdc, Buffer, rcx+(TextSize.cx/2), rcy-IBLSCALE(1) , 0, TextDisplayMode, false);   
d1398 1
a1398 5
  if (DisplayMode == dmCircling )
 	 wsprintf(Buffer, TEXT("AvgAll"),text);
  else
 	 wsprintf(Buffer, TEXT("E"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d1400 1
a1400 1
  TextInBox(hdc, Buffer, rcx+IBLSCALE(3), rcy-TextSize.cy , 0, TextDisplayMode, false);  
@


1.7
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.6 2009/06/07 11:38:58 root Exp root $
d861 5
a865 1
  short BOTTOMSIZE=rc.bottom/SPLITTER;
d911 2
a912 2

 	 _tcsncpy(Buffer, WayPointList[index].Name, 9);
d933 1
a933 1
	   // Bearing if not circling
d968 1
a968 1
       } // not circling
d1044 2
a1045 1

d1048 1
a1049 1
  // Alt     = QNH altitude
d1052 16
d1081 1
d1086 6
a1091 3
  //Value=DerivedDrawInfo.AverageLD;
  Value= LIFTMODIFY*CALCULATED_INFO.LastThermalAverage;
  if (Value<10) sprintf(text,"%+.1lf",Value);
a1095 1
  //rcx=rc.left+IBLSCALE(18); 
d1153 2
a1154 11
  if ( ValidTaskPoint(ActiveWayPoint) != false ) {
     index = Task[ActiveWayPoint].Index;
     if (index>=0) {
  	Value=WayPointCalc[index].Distance*DISTANCEMODIFY;
  	sprintf(text,"%.1f",Value);
     } else {
  	strcpy(text,"----");
     }
  } else {
  	strcpy(text,"----");
  }
a1162 1
  //SelectObject(hdc, MapLabelFont);
d1168 1
a1168 1
  wsprintf(Buffer, TEXT("%s"),(Units::GetDistanceName()));
d1173 1
a1173 1
  wsprintf(Buffer, TEXT("Dis"),text);
a1177 1

d1182 16
a1197 2
  Value=DerivedDrawInfo.NavAltitude;
  sprintf(text,"%d",(int)Value);
d1206 1
d1212 4
a1215 1
  wsprintf(Buffer, TEXT("%s"),(Units::GetAltitudeName()));
d1220 4
a1223 1
  wsprintf(Buffer, TEXT("Alt"),text);
d1228 2
d1234 5
d1261 6
a1266 6
/*
  SelectObject(hdc, MapLabelFont);
  wsprintf(Buffer, TEXT(""),text);
  TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextInBox(hdc, Buffer, rcx+(TextSize.cx/2), rcy-IBLSCALE(2) , 0, TextDisplayMode, false);   
*/
d1268 4
a1271 1
  wsprintf(Buffer, TEXT("reqE"),text);
d1281 9
a1289 3
  Value=DerivedDrawInfo.AverageLD;
  if (Value <-99 ||  Value >=ALTERNATE_MAXVALIDGR ) strcpy(text,"+++"); else
	sprintf(text,"%.0f",Value);
d1298 7
a1304 6
/*
  SelectObject(hdc, MapLabelFont);
  wsprintf(Buffer, TEXT(""),text);
  TextDisplayMode.AsFlag.AlligneCenter = 0;
  TextInBox(hdc, Buffer, rcx+(TextSize.cx/2), rcy-IBLSCALE(1) , 0, TextDisplayMode, false);   
*/
d1306 4
a1309 1
  wsprintf(Buffer, TEXT("E"),text);
@


1.6
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.5 2009/06/06 12:21:38 root Exp root $
a52 2
#include <wingdi.h>

d104 1
d110 1
a110 1
extern HFONT  InfoWindowFont;
d853 1
a853 1
  int index, value;
d855 1
a855 1

d860 6
a872 21
  // Draw wind 
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  TextDisplayMode.AsFlag.WhiteBold = 1;
  //TextDisplayMode.AsFlag.AlligneRight = 0;
  //TextDisplayMode.AsFlag.AlligneCenter = 0;
  oldfont=(HFONT)SelectObject(hdc, StatisticsFont);
  if (DerivedDrawInfo.WindSpeed>0) { 

	  Value = DerivedDrawInfo.WindBearing;
	  if (Value==360) Value=0; 
	  _stprintf(Buffer,TEXT("%1.0f")_T(DEG)_T("/%1.0f"), Value, SPEEDMODIFY*DerivedDrawInfo.WindSpeed );
	  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	  TextInBox(hdc, Buffer, rc.left+IBLSCALE(1), rc.bottom - TextSize.cy - IBLSCALE(15), 0, TextDisplayMode, false);
  } else
  {
	  _stprintf(Buffer,TEXT("--/--"));
	  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	  TextInBox(hdc, Buffer, rc.left+IBLSCALE(1), rc.bottom - TextSize.cy - IBLSCALE(15), 0, TextDisplayMode, false);
  }
a873 1
  if (DisplayMode == dmCircling) return; // TODO pan mode too? need those other cases
d877 8
a884 4
  if ( ValidTaskPoint(ActiveWayPoint)== false ) return;
  index = Task[ActiveWayPoint].Index;
  if ( index <0 ) return;

d886 2
d889 2
a890 1
  // Waypoint name and distance
d892 1
a892 2
  short rcx=rc.left+IBLSCALE(1);
  short rcy=rc.top+IBLSCALE(1);
d894 1
a894 6
  //	oldfont = (HFONT)SelectObject(hdc, MapWindowBoldFont);
  //	oldfont = (HFONT)SelectObject(hdc, InfoWindowFont);

  SelectObject(hdc, StatisticsFont);

  TextDisplayMode.AsInt = 0;
d896 6
a901 6
  // Active colours
  if (WayPointList[index].Reachable) {
	  TextDisplayMode.AsFlag.Color = TEXTGREEN; 
  } else {
	  TextDisplayMode.AsFlag.Color = TEXTRED;
  }
d903 35
a937 4
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  TextDisplayMode.AsFlag.AlligneRight = 0;
d939 15
a953 4
  _tcsncpy(Buffer, WayPointList[index].Name, 9);
  ConvToUpper(Buffer);
  TextInBox(hdc, Buffer, rcx+IBLSCALE(2),rcy, 0, TextDisplayMode, false);  
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
d955 32
a986 13
  Value= WayPointCalc[index].Distance*DISTANCEMODIFY;
  if ( Units::GetUserDistanceUnit() == unKiloMeter )  {
	if (Value > 100) sprintf(text,"%.0lf km",Value);
	else sprintf(text,"%.1lf km",Value);
  } else {
	if (Value > 100) sprintf(text,"%.0lf m",Value);
	else sprintf(text,"%.1lf m",Value);
	//  sprintf(text,"%0.1f m",WayPointCalc[index].Distance*DISTANCEMODIFY); // good for both nautical and statute miles

  }

  wsprintf(Buffer, TEXT("%S"), text);
  TextInBox(hdc, Buffer, rcx+IBLSCALE(2),rcy+TextSize.cy, 0, TextDisplayMode, false); 
d989 3
a991 1
  // Draw efficiency required and altitude arrival for destination waypoint
a992 6
  SelectObject(hdc, InfoWindowFont); // use this font for big values
  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.WhiteBold = 1;
  TextDisplayMode.AsFlag.AlligneRight = 1;
d994 2
a995 57
  // GR 13.4
  // MC 0.3
  // LD 23
  // Arriv +1234


  Value=WayPointCalc[index].GR;
  if (Value <1 || Value >=ALTERNATE_MAXVALIDGR )
	strcpy(text,"---");
  else 
	if (Value >= 100) sprintf(text,"%.0lf",Value);
	else sprintf(text,"%.1lf",Value);
  wsprintf(Buffer, TEXT("%S"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  rcy=(rc.bottom + rc.top)/2-TextSize.cy;
  rcx=rc.right-IBLSCALE(3);
  TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  // GR


  // Altitude difference with current MC
  _stprintf(Buffer,TEXT("%+1.0f"), ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
  TextInBox(hdc, Buffer, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, TextDisplayMode, false);   // ALT

  // Draw bearing


    Value = CALCULATED_INFO.WaypointBearing -  GPS_INFO.TrackBearing;

    if (Value < -180.0)
      Value += 360.0;
    else
    if (Value > 180.0)
      Value -= 360.0;

#ifndef __MINGW32__
    if (Value > 1)
      _stprintf(Buffer, TEXT("%2.0f°»"), Value);
    else if (Value < -1)
      _stprintf(Buffer, TEXT("«%2.0f°"), -Value);
    else
      _tcscpy(Buffer, TEXT("«»"));
#else
    if (Value > 1)
      _stprintf(Buffer, TEXT("%2.0fÂ°Â»"), Value);
    else if (Value < -1)
      _stprintf(Buffer, TEXT("Â«%2.0fÂ°"), -Value);
    else
      _tcscpy(Buffer, TEXT("Â«Â»"));
#endif

  TextDisplayMode.AsInt = 0;
  TextDisplayMode.AsFlag.Color = TEXTWHITE;
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  TextDisplayMode.AsFlag.WhiteBold = 1;
  TextDisplayMode.AsFlag.AlligneRight = 0;
  TextDisplayMode.AsFlag.AlligneCenter = 1;
  TextInBox(hdc, Buffer, (rc.right+rc.left)/2, rc.top+ IBLSCALE(15), 0, TextDisplayMode, false);
d1002 8
a1009 5
  // See http://www.pbm.com/~lindahl/real.programmers.html
  if ( !InfoBoxLayout::landscape || !IsMapFullScreen() ) {
  	SelectObject(hdc, oldfont); 
	return;
  }
d1011 1
a1014 1
  RECT nrc;
a1016 5
  nrc.left=0;
  nrc.top=420;
  nrc.right=800;
  nrc.bottom=480;

d1022 1
a1022 1
  HBITMAP bitmapnew=CreateCompatibleBitmap(hdc,800,480);
d1029 1
a1029 1
  bs.SourceConstantAlpha=200;
d1032 5
a1036 1
  AlphaBlend(hdc,0,420,800,60,hdc2,0,420,800,60,bs);
d1038 1
a1039 1
  // InfoLX boxes
d1041 6
d1051 1
a1051 1
  TextDisplayMode.AsFlag.WhiteBold = 1;
d1054 131
a1184 1
  //TextDisplayMode.AsFlag.AlligneRight = 0;
d1186 7
d1194 3
a1196 4
  // SelectObject(hdc, MapWindowBoldFont);  // fat
  //oldfont = (HFONT)SelectObject(hdc, InfoWindowFont); // big
  // oldfont=(HFONT)SelectObject(hdc, StatisticsFont);
  oldfont=(HFONT)SelectObject(hdc, MapWindowFont);
d1198 22
a1219 3
  Value=DerivedDrawInfo.AverageLD;
  Value=1234;
  sprintf(text,"%.0lf",Value);
d1221 4
a1224 3
  if (Value>ALTERNATE_MAXVALIDGR) strcpy(text,"---"); 
  if (Value <1) strcpy(text,"---"); 
  if (Value ==0) strcpy(text,"---"); 
d1226 6
a1231 1
  wsprintf(Buffer, TEXT("%S"),text);
d1233 3
a1235 2
  rcx=rc.left+IBLSCALE(40); // make it static and preformatted with an init8000
  rcy=rc.bottom-IBLSCALE(20);
d1237 3
a1239 1
  TextInBox(hdc, Buffer, rcx, rcy , 0, TextDisplayMode, false);   // AverageLD
d1241 18
d1261 3
d1265 1
d1269 1
d1271 1
d1273 24
@


1.5
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.4 2009/06/04 16:02:47 root Exp root $
d53 2
d314 1
d366 1
d374 1
d399 1
d405 1
d427 1
d432 1
d461 1
d467 1
d500 1
d506 1
d533 1
d841 1
a841 1
 * Work in progress
d843 1
a843 1
 * TODO: add units other than metrics
d870 1
a870 1
  //TextDisplayMode.AsFlag.Color = 0;
d882 1
a882 1
	  TextInBox(hdc, Buffer, rc.left+IBLSCALE(1), rc.bottom - TextSize.cy - IBLSCALE(20), 0, TextDisplayMode, false);
d887 1
a887 1
	  TextInBox(hdc, Buffer, rc.left+IBLSCALE(1), rc.bottom - TextSize.cy - IBLSCALE(20), 0, TextDisplayMode, false);
d911 2
a912 1
/*
d914 1
a914 1
	  TextDisplayMode.AsFlag.Color = 1; // 1 green 2 red 0 none
d916 1
a916 1
	  TextDisplayMode.AsFlag.Color = 2;
d919 1
a919 1
  TextDisplayMode.AsFlag.Color = 0;
d949 1
a949 1
  TextDisplayMode.AsFlag.Color = 0;
a957 8
  Value=MACCREADY;
  sprintf(text,"%.1lf",Value);
  wsprintf(Buffer, TEXT("%S"),text);
  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  rcy=(rc.bottom + rc.top)/2 - IBLSCALE(TextSize.cy);
  rcx=rc.right-IBLSCALE(3);

  TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);   // MC
d966 4
a969 1
  TextInBox(hdc, Buffer, rcx,rc.top+IBLSCALE(1), 0, TextDisplayMode, false);  // GR
d974 1
a974 21
  TextInBox(hdc, Buffer, rcx,rcy+TextSize.cy, 0, TextDisplayMode, false);   // ALT

  // LD with current MC
  Value=DerivedDrawInfo.LDNext;
  if (Value <1 || Value >=ALTERNATE_MAXVALIDGR )
	strcpy(text,"---");
  else 
	sprintf(text,"%.0lf",Value);
  wsprintf(Buffer, TEXT("%S"),text);
//  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  TextInBox(hdc, Buffer, rcx,rcy+(TextSize.cy*2), 0, TextDisplayMode, false);   // LD

  Value=DerivedDrawInfo.AverageLD;
  sprintf(text,"%.0lf",Value);
  if (Value>ALTERNATE_MAXVALIDGR) strcpy(text,"^^^"); 
  if (Value <1) strcpy(text,"+++"); 
  if (Value ==0) strcpy(text,"---"); 
  wsprintf(Buffer, TEXT("%S"),text);
  TextInBox(hdc, Buffer, (rc.right+rc.left)/2,rc.bottom-IBLSCALE(1)-TextSize.cy, 0, TextDisplayMode, false);   // AverageLD


d1004 1
a1004 1
  TextDisplayMode.AsFlag.Color = 0;
d1011 12
a1022 1
/*
d1026 1
a1026 1
  COLORREF customcolor = RGB(0x27, 0x27, 0x27);
d1029 1
a1029 1
  nrc.top=450;
d1034 50
a1084 1
  FillRect(hdc,&nrc, hB); 
d1087 4
a1090 1
*/
@


1.4
log
@nuova versione ok
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.3 2009/06/01 21:16:28 root Exp root $
a834 1
//  COLORREF	oldcolor=0;
a847 1
  if (DisplayMode == dmCircling) return; // TODO pan mode too? need those other cases
d853 24
a876 1
  // ... currently none ... (save oldfont here...)
d894 1
a894 1
  oldfont = (HFONT)SelectObject(hdc, StatisticsFont);
d909 1
a909 1
  wsprintf(Buffer, TEXT(" %s"),  WayPointList[index].Name);
d911 1
a911 1
  TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  
d913 11
a923 4
  if ( Units::GetUserDistanceUnit() == unKiloMeter ) 
	  sprintf(text," %0.1f km",WayPointCalc[index].Distance*DISTANCEMODIFY);
  else
	  sprintf(text," %0.1f m",WayPointCalc[index].Distance*DISTANCEMODIFY); // good for both nautical and statute miles
d926 1
a926 1
  TextInBox(hdc, Buffer, rcx,rcy+TextSize.cy, 0, TextDisplayMode, false); 
d938 4
a941 5
  value=(int)WayPointCalc[index].GR;
  if (value <1 || value >=ALTERNATE_MAXVALIDGR )
	strcpy(text,"---");
  else 
  	sprintf(text,"%3d",value);
d943 2
d947 1
a947 1
  rcy=(rc.bottom + rc.top)/2 - IBLSCALE( TextSize.cy/2 );
a948 1
  TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  
d950 13
d964 19
a982 1
  TextInBox(hdc, Buffer, rcx,rcy+TextSize.cy, 0, TextDisplayMode, false);  
d1019 1
a1019 1
  TextInBox(hdc, Buffer, (rc.right+rc.left)/2 - IBLSCALE(5), rc.top+ IBLSCALE(15), 0, TextDisplayMode, false);
d1021 5
a1025 1
  // Draw wind 
d1027 4
a1030 4
  if (DerivedDrawInfo.WindSpeed>-1) {   // FIX TEST ALWAYS SHOW
	  TextDisplayMode.AsFlag.AlligneRight = 0;
	  TextDisplayMode.AsFlag.AlligneCenter = 0;
	  SelectObject(hdc, StatisticsFont);
d1032 1
a1032 6
	  Value = DerivedDrawInfo.WindBearing;
	  if (Value==360) Value=0; 
	  _stprintf(Buffer,TEXT("%1.0f")_T(DEG)_T("/%1.0f"), Value, SPEEDMODIFY*DerivedDrawInfo.WindSpeed );
	  GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	  // TextInBox(hdc, Buffer, rc.left+IBLSCALE(40), rc.bottom - TextSize.cy - IBLSCALE(2), 0, TextDisplayMode, false);
	  TextInBox(hdc, Buffer, rc.left+IBLSCALE(1), rc.bottom - TextSize.cy - IBLSCALE(25), 0, TextDisplayMode, false);
d1034 1
a1034 1
  }
d1036 2
@


1.3
log
@funziona
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.2 2009/05/28 20:18:51 root Exp root $
d117 1
d310 1
a310 1
	    if (intask||OutlinedTp) { 
d313 1
d315 1
d337 1
a337 1
	      case DISPLAYNAMEIFINTASK:
d341 23
a363 4
		    wsprintf(Buffer, TEXT("%s:%d%s"),
			     WayPointList[i].Name, 
			     (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			     sAltUnit);
d367 4
d374 1
a374 1
// FIX VENTA6 completare
d380 6
a385 3
		  if ( ArrivalValue == (ArrivalValue_t) avAltitude )
		  	wsprintf(Buffer, TEXT("%s:%d%s"), WayPointList[i].Name, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), sAltUnit);
		  else 
d389 5
a393 2
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
d408 12
a419 3
		  wsprintf(Buffer, TEXT("%d:%d%s"), WayPointList[i].Number, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), sAltUnit);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
d432 20
a451 6
		  wsprintf(Buffer, TEXT("%s:%d%s"),
			   Buffer2, 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
d467 22
a488 6
		  wsprintf(Buffer, TEXT("%s:%d%s"),
			   Buffer2, 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
d503 17
a519 5
		  wsprintf(Buffer, TEXT("%d%s"), 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
d782 1
a782 1
  if (NewMap||OutlinedTp)
d791 1
d798 1
a798 2
  if (NewMap||OutlinedTp) {
    ExtTextOut( hdc, rcx+3, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
a802 1
    ExtTextOut( hdc, rcx-3, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
a803 2
    ExtTextOut( hdc, rcx, rcy+2 , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy+3 , 0, NULL, gtext , _tcslen(gtext), NULL );
d805 12
a816 2
    ExtTextOut( hdc, rcx, rcy-2 , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy-3 , 0, NULL, gtext , _tcslen(gtext), NULL );
d828 2
a829 1
 * TODO: fix fonts and outline shades for PDAs.
d831 1
d835 1
a835 4
//  TCHAR gtext[100];
  char text[30];
  TCHAR Buffer[100];
  COLORREF	oldcolor=0;
d837 1
d839 2
d842 1
d846 1
a847 1
  TextDisplayMode.AsInt = 0;
d849 1
a849 4
  //static short rcx=rc.left+IBLSCALE(50);
  //static short rcy=rc.top+rc.bottom-IBLSCALE(10);
  short rcx=rc.left+IBLSCALE(1);
  short rcy=rc.top+IBLSCALE(1);
d851 1
a851 1
  if (DisplayMode == dmCircling) return; // TODO pan mode too? need those other cases
d854 2
a855 1
  if (ValidTaskPoint(ActiveWayPoint)) {
d857 1
a857 9
      index = Task[ActiveWayPoint].Index;
      if ( index >=0 ) {
/*
	if (WayPointList[index].Reachable) {
	  TextDisplayMode.AsFlag.Color = 1; // 1 green 2 red 0 none
	} else {
	  TextDisplayMode.AsFlag.Color = 2;
	}
*/
d859 3
a861 1
  	oldfont = (HFONT)SelectObject(hdc, MapWindowBoldFont);
a862 7
	wsprintf(Buffer, TEXT("> %s"),  WayPointList[index].Name);
	ConvToUpper(Buffer);
	TextDisplayMode.AsFlag.WhiteBold = 1; 
	TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  
	sprintf(text,"> %0.1f km",WayPointCalc[index].Distance/1000);
	wsprintf(Buffer, TEXT("%S"), text);
	TextInBox(hdc, Buffer, rcx,rcy+IBLSCALE(12), 0, TextDisplayMode, false);  
a863 3
  	SelectObject(hdc, oldfont); 
      }
  }
d865 1
d867 2
a868 2
   value=CALCULATED_INFO.AverageLD;
  //value=FilterFast(&rotaryLD,1,100);
d870 2
a871 8
  if (value==0)
	strcpy(text,"C ___");
  else if (value <0)
	strcpy(text,"C ^^^");
  else if (value>=999)
	strcpy(text,"C +++");
  else
  	sprintf(text,"C %3d",value);
d873 1
a873 1
  wsprintf(Buffer, TEXT("%S"),text);
d875 8
a886 6
  //oldfont = (HFONT)SelectObject(hdc, StatisticsFont);
  oldfont = (HFONT)SelectObject(hdc, InfoWindowFont);
  rcx=rc.right-IBLSCALE(65);
  rcy=rc.top+ IBLSCALE(80);
  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
  TextInBox(hdc, Buffer, rcx,rcy+IBLSCALE(25), 0, TextDisplayMode, false); 
d888 8
d897 2
a899 1
  if (ValidTaskPoint(ActiveWayPoint) && CALCULATED_INFO.WaypointDistance > 10.0 ) {
d901 1
a901 9
  //TextDisplayMode.AsFlag.Color = 0;
  //rcx=rc.right-IBLSCALE(90);
  //rcy=rc.top+ IBLSCALE(80);

  //if (EnableVarioGauge && MapRectBig.right == rc.right)  rcx -= InfoBoxLayout::ControlWidth;


  //SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
  // SetBkMode(hdc,TRANSPARENT);
d903 6
d910 3
a912 10
 // TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
 // TextDisplayMode.AsFlag.NoSetFont = 1; 
 // TextDisplayMode.AsFlag.AlligneRight = 0;
  //oldfont = (HFONT)SelectObject(hdc, StatisticsFont);
 // oldfont = (HFONT)SelectObject(hdc, InfoWindowFont);

  //sprintf(text,"%2d",(int)CALCULATED_INFO.GRFinish); // TODO FIX GRFinish to make it GRNext or create new IB
  value=(int)WayPointCalc[Task[ActiveWayPoint].Index].GR;
  if (value <1 || value >INVALID_GR )
	strcpy(text,"R ---");
d914 1
a914 1
  	sprintf(text,"R %3d",value);
d917 3
a919 1
	
d922 3
d927 1
a927 4
  //rcx=(rc.right-rc.left)/2 - IBLSCALE(10);
  //rcy=rc.top+ IBLSCALE(15);
  TextDisplayMode.AsFlag.AlligneRight = 0;
  TextDisplayMode.AsFlag.AlligneCenter = 1;
d930 1
a930 1
    double Value = CALCULATED_INFO.WaypointBearing -  GPS_INFO.TrackBearing;
d954 9
a962 2
  TextInBox(hdc, Buffer, (rc.right-rc.left)/2 - IBLSCALE(10),rc.top+IBLSCALE(15), 0, TextDisplayMode, false);
} 
d964 16
d982 1
@


1.2
log
@sperimentale
@
text
@d34 1
a34 1
  $Id: MapWindow3.cpp,v 1.1 2009/05/27 11:27:14 root Exp root $
d40 2
a41 1
#include "Defines.h"
d738 2
d749 1
a749 1
  int index;
d791 13
a803 1
  if (ValidTaskPoint(ActiveWayPoint) && CALCULATED_INFO.WaypointDistance > 10.0 && IsMapFullScreen()) {
d806 6
a811 1
  rcx=rc.right-IBLSCALE(90);
d813 10
d827 1
a827 1
  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
d831 3
a833 3
  TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  TextDisplayMode.AsFlag.AlligneRight = 0;
d835 1
a835 1
  oldfont = (HFONT)SelectObject(hdc, InfoWindowFont);
d838 1
a838 1
  int value=(int)WayPointCalc[Task[ActiveWayPoint].Index].GR;
a847 8
  value=(int)CALCULATED_INFO.CruiseLD;
  if (value <0 || value>999)
	strcpy(text,"C ---");
  else
  	sprintf(text,"C %3d",(int)CALCULATED_INFO.CruiseLD);
  wsprintf(Buffer, TEXT("%S"),text);

  TextInBox(hdc, Buffer, rcx,rcy+IBLSCALE(25), 0, TextDisplayMode, false); 
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.1 2009/05/25 09:47:57 root Exp root $
d86 1
d110 1
a110 1

a237 1

d312 12
d736 1
a736 1
 * Had no time to even try to complete this part. Maybe in the next few days...
a742 1
  int wpgoto=-1;
d746 1
a746 1

a759 1
  wpgoto=ActiveWayPoint;
d761 3
a763 2
    if (ValidTaskPoint(wpgoto)) {
      int index = Task[wpgoto].Index;
d765 1
d771 1
d773 4
a776 3
	wsprintf(Buffer, TEXT("XX: %s"),  WayPointList[index].Name);
	// JMW undefined...	ConvToUpper(Buffer);
	// VNT it's really inside Utils.cpp ...but only for PNA or fivv... I'll fix it when it becomes usable
d779 5
d785 1
a785 1
    }
d788 1
a788 1
  if (ValidTaskPoint(ActiveWayPoint) && CALCULATED_INFO.WaypointDistance > 10.0) {
d791 1
a791 1
  rcx=rc.right-IBLSCALE(15);
d803 1
a803 1
  TextDisplayMode.AsFlag.AlligneRight = 1;
d810 1
a810 1
	strcpy(text,"---");
d812 1
a812 1
  	sprintf(text,"%3d",value);
d820 1
a820 1
	strcpy(text,"+++");
d822 1
a822 1
  	sprintf(text,"%3d",(int)CALCULATED_INFO.CruiseLD);
@
