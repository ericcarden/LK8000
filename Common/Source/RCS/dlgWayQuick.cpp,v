head	1.1;
access;
symbols;
locks
	root:1.1; strict;
comment	@// @;


1.1
date	2010.12.13.16.54.49;	author root;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id$
*/

#include "StdAfx.h"
#include <aygshell.h>

#include "XCSoar.h"

//#include "Statistics.h"
#include "externs.h"
#include "Dialogs.h"
//#include "Logger.h"
//#include "McReady.h"
//#include "dlgTools.h"
#include "InfoBoxLayout.h"


static WndForm *wf=NULL;
#define WPLSEL WayPointList[SelectedWaypoint]


bool needDetails;

static void OnCancelClicked(WindowControl * Sender){
(void)Sender;
        wf->SetModalResult(mrOK);
}

static void OnSetAlt1Clicked(WindowControl * Sender){
  (void)Sender;
  LockTaskData();
  Alternate1 = SelectedWaypoint;
  SetToRegistry(szRegistryAlternate1, Alternate1);
  RefreshTask();
  UnlockTaskData();
  wf->SetModalResult(mrOK);
}

static void OnSetAlt2Clicked(WindowControl * Sender){
  (void)Sender;
  LockTaskData();
  Alternate2 = SelectedWaypoint;
  SetToRegistry(szRegistryAlternate2, Alternate2);
  RefreshTask();
  UnlockTaskData();
  wf->SetModalResult(mrOK);
}

static void OnGotoClicked(WindowControl * Sender){
  (void)Sender;
  GotoWaypoint(SelectedWaypoint);
  wf->SetModalResult(mrOK);
}

static void OnDetailsClicked(WindowControl * Sender){
  (void)Sender;
  needDetails=true;
  wf->SetModalResult(mrOK);
}

static CallBackTableEntry_t CallBackTable[]={
  DeclareCallBackEntry(OnGotoClicked),
  DeclareCallBackEntry(OnSetAlt1Clicked),
  DeclareCallBackEntry(OnSetAlt2Clicked),
  DeclareCallBackEntry(OnCancelClicked),
  DeclareCallBackEntry(NULL)
};

// Will return true if details needed
bool dlgWayQuickShowModal(void){

  wf = NULL;

  char filename[MAX_PATH];
  TCHAR sTmp[128];

  LocalPathS(filename, TEXT("dlgWayQuick.xml"));
  wf = dlgLoadFromXML(CallBackTable, filename, hWndMainWindow, TEXT("IDR_XML_WAYPOINTQUICK"));

  if (!wf) return false;

  ASSERT(wf!=NULL);

  ((WndButton *)wf->FindByName(TEXT("cmdGoto"))) ->SetOnClickNotify(OnGotoClicked);
  ((WndButton *)wf->FindByName(TEXT("cmdSetAlt1"))) ->SetOnClickNotify(OnSetAlt1Clicked);
  ((WndButton *)wf->FindByName(TEXT("cmdSetAlt2"))) ->SetOnClickNotify(OnSetAlt2Clicked);
  ((WndButton *)wf->FindByName(TEXT("cmdDetails"))) ->SetOnClickNotify(OnDetailsClicked);
  ((WndButton *)wf->FindByName(TEXT("cmdCancel"))) ->SetOnClickNotify(OnCancelClicked);

  needDetails=false;
  if (WPLSEL.Format == LKW_CUP) {
        TCHAR ttmp[50];
        // and it is landable
        if ((WPLSEL.Style>1) && (WPLSEL.Style<6) ) {

                _stprintf(sTmp, TEXT("%s "), WPLSEL.Name);
		if (_tcslen(sTmp)>9) {
			sTmp[9]='\0';
			_tcscat(sTmp, _T(" "));
		}

                if ( _tcslen(WPLSEL.Freq)>0 )  {
                        _stprintf(ttmp,_T("%s "),WPLSEL.Freq);
                        _tcscat(sTmp, ttmp);
                }

                if ( WPLSEL.RunwayDir>=0 )  {
                        _stprintf(ttmp,_T("RW %d "),WPLSEL.RunwayDir);
                        _tcscat(sTmp, ttmp);
                }
                if ( WPLSEL.RunwayLen>0 )  {
                        // we use Altitude instead of distance, to keep meters and feet
                        _stprintf(ttmp,_T("%.0f%s"),Units::ToUserAltitude((double)WPLSEL.RunwayLen), Units::GetAltitudeName());
                        _tcscat(sTmp, ttmp);
                }

        } else {
		_stprintf(sTmp, _T(" %s"),WayPointList[SelectedWaypoint].Name);
        }
  } else {
	_stprintf(sTmp, _T(" %s"),WayPointList[SelectedWaypoint].Name);
  }
  wf->SetCaption(sTmp);
  wf->SetLeft((ScreenSizeX-IBLSCALE(230))/2);

  wf->ShowModal();

  delete wf;

  wf = NULL;

  return needDetails;

}
@
