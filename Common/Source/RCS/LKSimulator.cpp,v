head	1.2;
access;
symbols;
locks
	root:1.2; strict;
comment	@// @;


1.2
date	2010.12.11.19.34.01;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2010.11.04.22.18.57;	author root;	state Exp;
branches;
next	;


desc
@@


1.2
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: LKSimulator.cpp,v 1.1 2010/11/04 22:18:57 root Exp root $
*/

// #ifdef _SIM_
#include "StdAfx.h"
#include "options.h"
#include "XCSoar.h"
#include "Cpustats.h"
#include "MapWindow.h"
#include "Calculations.h"
#include "Calculations2.h"
#include "Dialogs.h"

#include "Process.h"

#include "Utils.h"
#include "Utils2.h"
#include "Logger.h"
#include "McReady.h"

#include <commctrl.h>
#include <aygshell.h>
#if (WINDOWSPC<1)
#include <sipapi.h>
#endif

#include "Terrain.h"
#include "device.h"

#include "externs.h"
#include "Units.h"

#define ISPARAGLIDER	(AircraftCategory == (AircraftCategory_t)umParaglider)
#define IASMS		CALCULATED_INFO.IndicatedAirspeedEstimated
#define IAS		CALCULATED_INFO.IndicatedAirspeedEstimated*TOKPH
#define BEARING		GPS_INFO.TrackBearing
#define ALTITUDE	GPS_INFO.Altitude
#define GS		GPS_INFO.Speed*TOKPH
#define FLYING		CALCULATED_INFO.Flying
#define THERMALLING	CALCULATED_INFO.Circling
#define MINSPEED	GlidePolar::Vminsink*TOKPH
#define STALLSPEED	GlidePolar::Vminsink*TOKPH*0.85

// WE DONT USE LANDING, CRASHING AND FULL STALL SIMULATION NOW
// #define SIMLANDING	1

//
// LK8000 SS1 = Soaring Simulator V1 by Paolo Ventafridda
// Still basic, but usable
//
void LKSimulator(void) {

  LockFlightData();

  // 
  GPS_INFO.NAVWarning = FALSE;
  GPS_INFO.SatellitesUsed = 6;
  // Even on ground, we can turn the glider in the hangar
  BEARING += SimTurn; 
  if (BEARING<0) BEARING+=360;
  else if (BEARING>359) BEARING-=360;

  #if SIMLANDING
  static bool crashed=false, landedwarn=true;
  #endif
  static bool doinit=true, landing=false, stallwarn=true, circling=false;
  static short counter=0;

  double tdistance, tbearing;
  double thermalstrength=0, sinkstrength=0;

  if (doinit||!CALCULATED_INFO.TerrainValid) {
	if (counter++<3) {
		UnlockFlightData();
		return;
	}
	if (CALCULATED_INFO.TerrainValid) ALTITUDE= CALCULATED_INFO.TerrainAlt;
	doinit=false;
  }
 
  // SetBallast is calculating sinkratecache for values starting from 4 to MAXSPEED, in m/s .
  // ONLY during flight, we will sink in the air
  if (FLYING && (IASMS>3) && (IASMS<MAXSPEED) ) {

	double sinkias=-1*(GlidePolar::sinkratecache[(int)IASMS]);
	if (sinkias>10) sinkias=10; // set a limiter for sink rate
	// StartupStore(_T(".... ias=%.0f sinkias=%.3f oldAlt=%.3f newAlt=%.3f\n"), 
	// CALCULATED_INFO.IndicatedAirspeedEstimated*TOKPH, sinkias, GPS_INFO.Altitude, GPS_INFO.Altitude+sinkias);
	double simlift=0;
	if (THERMALLING == TRUE) {
		// entering the thermal mode right now
		if (!circling) {
			circling=true;
			
			DistanceBearing(GPS_INFO.Latitude,GPS_INFO.Longitude,ThLatitude,ThLongitude,&tdistance,&tbearing);
			if (tdistance>1000) {
				// a new thermal
				ThLatitude=GPS_INFO.Latitude; // we mark the new thermal
				ThLongitude=GPS_INFO.Longitude;
				ALTITUDE+=simlift; // sink rate adjusted later
			} else {
				// start circling near the old thermal
			}
		} else {
			// already thermalling
		}
		// ALTITUDE+=simlift+GlidePolar::minsink;
	} else {
		if (circling) {
			// we were circling, now leaving the thermal
			circling=false;
		} else {
			// not circling, already cruising
		}
	}

	// Are we near the thermal?
	DistanceBearing(GPS_INFO.Latitude,GPS_INFO.Longitude,ThLatitude,ThLongitude,&tdistance,&tbearing);
	thermalstrength=4; // m/s
	ThermalRadius=200; // we assume a perfect thermal, a circle of this diameter. Stronger in the center.
	// thermalbase
	sinkstrength=2; //  how intense is the fallout of the thermal
	SinkRadius=150; //  circular ring of the fallout

	if (tdistance>=ThermalRadius && tdistance<(ThermalRadius+SinkRadius) ) {
		// we are in the sinking zone of the thermal..
		simlift= sinkstrength- ((tdistance-ThermalRadius)/SinkRadius)*sinkstrength;
		simlift+=0.1; // adjust rounding errors
		simlift*=-1;
		//StartupStore(_T(".. sinking zone:  dist=%.1f  sink=%.1f\n"), tdistance,simlift);
	}
	if (tdistance<ThermalRadius) {
		// we are in the lift zone
		simlift= thermalstrength- (tdistance/ThermalRadius)*thermalstrength;
		simlift+=0.1; // adjust rounding errors
		//StartupStore(_T(".. climbing zone:  dist=%.1f  climb=%.1f\n"), tdistance,simlift);
	}
	// Update altitude with the lift or sink, 
	ALTITUDE+=simlift;
	// Update the new altitude with the natural sink, but not going lower than 0
	ALTITUDE-=(sinkias+0.1); // rounding errors require a correction
	if (ALTITUDE<=0) ALTITUDE=0;

	#if SIMLANDING
	if (CALCULATED_INFO.TerrainValid && (CALCULATED_INFO.AltitudeAGL <=20) ) {
		if (IAS <= (MINSPEED+3)) landing=true;
		else {
			// we dont simulate crashing. LK8000 pilots never crash. 
			crashed=true;
		}
	} 
	if (CALCULATED_INFO.TerrainValid && (CALCULATED_INFO.AltitudeAGL >100) ) {
		landing=false;
	}

	if (!landing && CALCULATED_INFO.TerrainValid && (CALCULATED_INFO.AltitudeAGL <=0) ) {
		GPS_INFO.Speed=0;
		landing=true;
		if (landedwarn) {
			DoStatusMessage(_T("YOU HAVE LANDED"));
			landedwarn=false;
		}
	} else landedwarn=true;
	#endif
		
  } 

  if (FLYING) {
	// simple stall at 1 G
	if (!landing && (IAS<=STALLSPEED && IASMS>3)) {
		if (stallwarn) {
			DoStatusMessage(_T("STALLING"));
			stallwarn=false;
		}
		#if 0 // DO NOT SIMULATE STALLING NOW
		// GPS_INFO.Speed= (GlidePolar::Vminsink*0.85)+1;
		ALTITUDE-=20;
		if (ALTITUDE<=0) ALTITUDE=0;
		#endif
	} else stallwarn=true;
	#if SIMLANDING
	if (landing || IASMS<4) {
		GPS_INFO.Speed-=GPS_INFO.Speed*0.2;
	}
	if (crashed) {
		GPS_INFO.Speed=0;
	}
	#endif

	if (GS<0) {
		GPS_INFO.Speed=0;
	}
  }


  FindLatitudeLongitude(GPS_INFO.Latitude, GPS_INFO.Longitude, 
                          GPS_INFO.TrackBearing, GPS_INFO.Speed*1.0,
                          &GPS_INFO.Latitude,
                          &GPS_INFO.Longitude);
  GPS_INFO.Time+= 1.0;
  long tsec = (long)GPS_INFO.Time;
  GPS_INFO.Hour = tsec/3600;
  GPS_INFO.Minute = (tsec-GPS_INFO.Hour*3600)/60;
  GPS_INFO.Second = (tsec-GPS_INFO.Hour*3600-GPS_INFO.Minute*60);

  UnlockFlightData();
  }

// #endif
@


1.1
log
@Initial revision
@
text
@d1 4
a4 2
/*  
Copyright_License {
d6 2
a7 29
  XCSoar Glide Computer - http://xcsoar.sourceforge.net/
  Copyright (C) 2000 - 2008  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
d9 1
a9 4
  $Id$
}
*/
#ifdef _SIM_
d49 3
d53 2
a54 1
// Flight Simulator for LK8000 by Paolo, very basic very minimal
d68 4
a71 2
  bool landing=false, crashed=false;
  static bool doinit=true;
d74 3
d86 2
a87 2
  // SetBallast is calculating sinkratecache for values starting from 4 to MAXSPEED, in m/s
  // ONLY during flight, we sink
d92 2
a93 2
	///: StartupStore(_T(".... ias=%.0f sinkias=%.3f oldAlt=%.3f newAlt=%.3f\n"), 
	///: CALCULATED_INFO.IndicatedAirspeedEstimated*TOKPH, sinkias, GPS_INFO.Altitude, GPS_INFO.Altitude+sinkias);
d96 23
a118 14

		// Thermal strength and lift according to banking.. very primitive
		simlift=ALTITUDE/600;
		if (ALTITUDE<2000) simlift=ALTITUDE/700;
		if (ALTITUDE<1500) simlift=ALTITUDE/800;
		if (ALTITUDE<1000) {
			if (SimTurn==5) simlift=(ALTITUDE/1300)*0.7;
			if (SimTurn==10) simlift=(ALTITUDE/1200)*0.8;
			if (SimTurn==15) simlift=(ALTITUDE/1100)*0.9;
			if (SimTurn==20) simlift=ALTITUDE/1000;
			if (SimTurn==25) simlift=(ALTITUDE/1000)*0.9;
			if (SimTurn==30) simlift=(ALTITUDE/1000)*0.8;
			if (SimTurn==35) simlift=(ALTITUDE/1000)*0.7;
			if (SimTurn>=40) simlift=(ALTITUDE/1000)*0.6;
a119 1
		ALTITUDE+=simlift+GlidePolar::minsink;
d122 24
a145 1
	// Now update the new altitude with the natural sink, but not going lower than 0
d148 2
a151 1
		/*
d153 1
a155 1
		*/
d157 4
d164 6
a169 1
	}
d176 6
a181 2
		DoStatusMessage(_T("STALLING"));
		GPS_INFO.Speed= (GlidePolar::Vminsink*0.85)+1;
d184 3
a186 1
	} 
d193 1
d214 1
a214 1
#endif
@
