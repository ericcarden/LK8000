head	8.28;
access;
symbols
	beta8:8.1;
locks
	root:8.28; strict;
comment	@// @;


8.28
date	2010.12.12.13.50.25;	author root;	state Exp;
branches;
next	8.27;

8.27
date	2010.11.19.12.31.06;	author root;	state Exp;
branches;
next	8.26;

8.26
date	2010.11.03.11.31.44;	author root;	state Exp;
branches;
next	8.25;

8.25
date	2010.09.20.15.19.59;	author root;	state Exp;
branches;
next	8.24;

8.24
date	2010.05.07.17.03.45;	author root;	state Exp;
branches;
next	8.23;

8.23
date	2010.03.18.15.57.10;	author root;	state Exp;
branches;
next	8.22;

8.22
date	2010.03.16.13.46.27;	author root;	state Exp;
branches;
next	8.21;

8.21
date	2010.03.09.23.00.49;	author root;	state Exp;
branches;
next	8.20;

8.20
date	2010.02.16.23.43.48;	author root;	state Exp;
branches;
next	8.19;

8.19
date	2009.12.17.23.50.02;	author root;	state Exp;
branches;
next	8.18;

8.18
date	2009.12.16.10.55.20;	author root;	state Exp;
branches;
next	8.17;

8.17
date	2009.12.11.23.55.35;	author root;	state Exp;
branches;
next	8.16;

8.16
date	2009.11.09.22.24.04;	author root;	state Exp;
branches;
next	8.15;

8.15
date	2009.10.24.19.21.58;	author root;	state Exp;
branches;
next	8.14;

8.14
date	2009.10.23.16.42.47;	author root;	state Exp;
branches;
next	8.13;

8.13
date	2009.10.19.15.17.12;	author root;	state Exp;
branches;
next	8.12;

8.12
date	2009.10.12.13.25.30;	author root;	state Exp;
branches;
next	8.11;

8.11
date	2009.09.30.13.24.26;	author root;	state Exp;
branches;
next	8.10;

8.10
date	2009.09.16.10.57.42;	author root;	state Exp;
branches;
next	8.9;

8.9
date	2009.07.22.10.53.36;	author root;	state Exp;
branches;
next	8.8;

8.8
date	2009.07.20.21.18.57;	author root;	state Exp;
branches;
next	8.7;

8.7
date	2009.07.17.15.25.30;	author root;	state Exp;
branches;
next	8.6;

8.6
date	2009.07.14.19.52.40;	author root;	state Exp;
branches;
next	8.5;

8.5
date	2009.07.05.22.54.31;	author root;	state Exp;
branches;
next	8.4;

8.4
date	2009.07.01.22.27.31;	author root;	state Exp;
branches;
next	8.3;

8.3
date	2009.06.27.17.17.55;	author root;	state Exp;
branches;
next	8.2;

8.2
date	2009.06.24.10.03.24;	author root;	state Exp;
branches;
next	8.1;

8.1
date	2009.06.19.20.28.25;	author venta;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.14.11.28.52;	author root;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.11.19.50.04;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.09.16.44.11;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.07.11.38.07;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.04.16.02.57;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.01.22.14.03;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.27.09.56.06;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.25.09.47.57;	author root;	state Exp;
branches;
next	;


desc
@@

8.28
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: MapWindow.cpp,v 8.27 2010/11/19 12:31:06 root Exp root $
*/

#include "StdAfx.h"
#include "compatibility.h"
#include "Defines.h"
#include "LKUtils.h"
#include "options.h"
#include "Cpustats.h"
#include "MapWindow.h"
#include "LKMapWindow.h"
#include "OnLineContest.h"
#include "Utils.h"
#include "Units.h"
#include "Logger.h"
#include "McReady.h"
#include "Airspace.h"
#include "Waypointparser.h"
#include "Dialogs.h"
#include "externs.h"
#include "VarioSound.h"
#include "InputEvents.h"
// #include <assert.h>
#include <windows.h>
#include <math.h>
#include <Message.h> // 091112

#include <tchar.h>

#include "Terrain.h"
#include "Task.h"
#include "AATDistance.h"
#include "LKObjects.h"

#ifndef NOVARIOGAUGE
#include "GaugeVarioAltA.h"
#endif
#ifndef NOCDIGAUGE
#include "GaugeCDI.h"
#endif
#ifndef NOFLARMGAUGE
#include "GaugeFLARM.h"
#endif
#include "InfoBoxLayout.h"
#include "RasterTerrain.h"
#include "Utils2.h"
#include "externs.h" // 091110

#if (WINDOWSPC>0)
#include <wingdi.h>
#endif

#include "LKGeneralAviation.h"


#ifdef GTCFIX
DWORD misc_tick_count=0;
#else
int misc_tick_count=0;
#endif

#ifdef DEBUG
#define DRAWLOAD
#define DEBUG_VIRTUALKEYS
#endif

#define INVERTCOLORS  (Appearance.InverseInfoBox)


int TrailActive = TRUE;
int VisualGlide = 0;

extern void DrawGlideCircle(HDC hdc, POINT Orig, RECT rc );
#ifdef CPUSTATS
extern void DrawCpuStats(HDC hdc, RECT rc );
#endif
#ifdef DRAWDEBUG
extern void DrawDebug(HDC hdc, RECT rc );
#endif

#define NUMSNAILRAMP 6

#ifdef LKPMODE
#define DONTDRAWTHEMAP NewMap&&Look8000&&!EnablePan&&MapSpaceMode!=MSM_MAP
#define MAPMODE8000    IsMapFullScreen()&&NewMap&&Look8000&&!EnablePan&&MapSpaceMode==MSM_MAP
#else
#define DONTDRAWTHEMAP IsMapFullScreen()&&NewMap&&Look8000&&!EnablePan&&MapSpaceMode!=MSM_MAP
#define MAPMODE8000    IsMapFullScreen()&&NewMap&&Look8000&&!EnablePan&&MapSpaceMode==MSM_MAP
#endif

//#define ISPARAGLIDER (AircraftCategory == (AircraftCategory_t)umParaglider) REMOVE

#ifdef OVERTARGET
extern int GetOvertargetIndex(void);
#endif

static const COLORREF taskcolor = RGB_TASKLINECOL; // 091216
static bool ignorenext=false;

const COLORRAMP snail_colors[] = {
  {0,         0xff, 0x3e, 0x00},
  {50,        0xcd, 0x4f, 0x27},
  {100,       0x8f, 0x8f, 0x8f},
  {150,       0x27, 0xcd, 0x4f},
  {201,       0x00, 0xff, 0x3e},
  {501,       0x00, 0xff, 0x3e}
};


DisplayMode_t UserForceDisplayMode = dmNone;
DisplayMode_t DisplayMode = dmCruise;

HBITMAP MapWindow::hBmpAirportReachable;
HBITMAP MapWindow::hBmpAirportUnReachable;
HBITMAP MapWindow::hBmpFieldReachable;
HBITMAP MapWindow::hBmpFieldUnReachable;
HBITMAP MapWindow::hBmpThermalSource;
HBITMAP MapWindow::hBmpTarget;
HBITMAP MapWindow::hBmpTeammatePosition;
HBITMAP MapWindow::hAboveTerrainBitmap;
HBRUSH  MapWindow::hAboveTerrainBrush;

HPEN    MapWindow::hpCompassBorder;
HBRUSH  MapWindow::hBrushFlyingModeAbort;
int MapWindow::SnailWidthScale = 16;

HBITMAP MapWindow::hBmpUnitKm;
HBITMAP MapWindow::hBmpUnitSm;
HBITMAP MapWindow::hBmpUnitNm;
HBITMAP MapWindow::hBmpUnitM;
HBITMAP MapWindow::hBmpUnitFt;
HBITMAP MapWindow::hBmpUnitMpS;

int MapWindow::ScaleListCount = 0;
double MapWindow::ScaleList[];
int MapWindow::ScaleCurrent;
HBITMAP MapWindow::hBmpCompassBg = NULL;
HBITMAP MapWindow::hBmpClimbeAbort = NULL;
HBITMAP MapWindow::hBmpMapScale=NULL;

POINT MapWindow::Orig_Screen;

RECT MapWindow::MapRect;
RECT MapWindow::MapRectBig;
RECT MapWindow::MapRectSmall;

HBITMAP MapWindow::hDrawBitMap = NULL;
HBITMAP MapWindow::hDrawBitMapTmp = NULL;
HBITMAP MapWindow::hMaskBitMap = NULL;
HDC MapWindow::hdcDrawWindow = NULL;
HDC MapWindow::hdcScreen = NULL;
HDC MapWindow::hDCTemp = NULL;
HDC MapWindow::hDCMask = NULL;

rectObj MapWindow::screenbounds_latlon;

double MapWindow::PanLatitude = 0.0;
double MapWindow::PanLongitude = 0.0;

int MapWindow::TargetDrag_State = 0;
double MapWindow::TargetDrag_Latitude = 0;
double MapWindow::TargetDrag_Longitude = 0;

bool MapWindow::EnablePan = false;
bool MapWindow::TargetPan = false;
int MapWindow::TargetPanIndex = 0;
double MapWindow::TargetZoomDistance = 500.0;
bool MapWindow::EnableTrailDrift=false;
int MapWindow::GliderScreenPosition = 40; // 20% from bottom
int MapWindow::GliderScreenPositionX = 50;  // 100216
int MapWindow::GliderScreenPositionY = 40;
int MapWindow::WindArrowStyle = 0;

BOOL MapWindow::CLOSETHREAD = FALSE;
BOOL MapWindow::THREADRUNNING = TRUE;
BOOL MapWindow::THREADEXIT = FALSE;
BOOL MapWindow::Initialised = FALSE;

bool MapWindow::BigZoom = true;
unsigned char MapWindow::DeclutterLabels = MAPLABELS_ALLON;

DWORD  MapWindow::dwDrawThreadID;
HANDLE MapWindow::hDrawThread;

double MapWindow::RequestMapScale; // VENTA9 = 5; 
double MapWindow::MapScale; // VENTA9 = 5; 
double MapWindow::MapScaleOverDistanceModify; // VENTA9  = 5/DISTANCEMODIFY;
double MapWindow::ResMapScaleOverDistanceModify = 0.0;
double MapWindow::DisplayAngle = 0.0;
double MapWindow::DisplayAircraftAngle = 0.0;
double MapWindow::DrawScale;
double MapWindow::InvDrawScale;

bool MapWindow::AutoZoom = false;
bool MapWindow::LandableReachable = false;

HBITMAP MapWindow::hTurnPoint;
HBITMAP MapWindow::hInvTurnPoint;
HBITMAP MapWindow::hSmall;
HBITMAP MapWindow::hInvSmall;
HBITMAP MapWindow::hCruise;
HBITMAP MapWindow::hClimb;
HBITMAP MapWindow::hFinalGlide;
HBITMAP MapWindow::hAutoMacCready;
HBITMAP MapWindow::hTerrainWarning;
HBITMAP MapWindow::hFLARMTraffic;
HBITMAP MapWindow::hGPSStatus1;
HBITMAP MapWindow::hGPSStatus2;
HBITMAP MapWindow::hAbort;
HBITMAP MapWindow::hLogger;
HBITMAP MapWindow::hLoggerOff;

HPEN MapWindow::hSnailPens[NUMSNAILCOLORS];
COLORREF MapWindow::hSnailColours[NUMSNAILCOLORS];

POINT MapWindow::Groundline[NUMTERRAINSWEEPS+1];

// 12 is number of airspace types
int      MapWindow::iAirspaceBrush[AIRSPACECLASSCOUNT] = 
  {2,0,0,0,3,3,3,3,0,3,2,3,3,3};
int      MapWindow::iAirspaceColour[AIRSPACECLASSCOUNT] = 
  {5,0,0,10,0,0,10,2,0,10,9,3,7,7};
int      MapWindow::iAirspaceMode[AIRSPACECLASSCOUNT] =
  {0,0,0,0,0,0,0,0,0,0,0,1,1,0};

HPEN MapWindow::hAirspacePens[AIRSPACECLASSCOUNT];
bool MapWindow::bAirspaceBlackOutline = false;

HBRUSH  MapWindow::hBackgroundBrush;
HBRUSH  MapWindow::hInvBackgroundBrush[LKMAXBACKGROUNDS];

HBRUSH  MapWindow::hAirspaceBrushes[NUMAIRSPACEBRUSHES];
HBITMAP MapWindow::hAirspaceBitmap[NUMAIRSPACEBRUSHES];

COLORREF MapWindow::Colours[NUMAIRSPACECOLORS] =
  {RGB(0xFF,0x00,0x00), RGB(0x00,0xFF,0x00),
   RGB(0x00,0x00,0xFF), RGB(0xFF,0xFF,0x00),
   RGB(0xFF,0x00,0xFF), RGB(0x00,0xFF,0xFF),
   RGB(0x7F,0x00,0x00), RGB(0x00,0x7F,0x00),
   RGB(0x00,0x00,0x7F), RGB(0x7F,0x7F,0x00),
   RGB(0x7F,0x00,0x7F), RGB(0x00,0x7F,0x7F),
   RGB(0xFF,0xFF,0xFF), RGB(0xC0,0xC0,0xC0),
   RGB(0x7F,0x7F,0x7F), RGB(0x00,0x00,0x00)};


HBRUSH MapWindow::hbCompass;
HBRUSH MapWindow::hbThermalBand;
HBRUSH MapWindow::hbBestCruiseTrack;
HBRUSH MapWindow::hbFinalGlideBelow;
HBRUSH MapWindow::hbFinalGlideBelowLandable;
HBRUSH MapWindow::hbFinalGlideAbove;
HBRUSH MapWindow::hbWind;


HPEN MapWindow::hpAircraft;
HPEN MapWindow::hpAircraftBorder;
HPEN MapWindow::hpWind;
HPEN MapWindow::hpWindThick;
HPEN MapWindow::hpBearing;
HPEN MapWindow::hpBestCruiseTrack;
HPEN MapWindow::hpCompass;

HPEN MapWindow::hpThermalCircle;
/*
#if OVERTARGET
HPEN MapWindow::hpOvertarget;
#endif
*/
HPEN MapWindow::hpThermalBand;
HPEN MapWindow::hpThermalBandGlider;
HPEN MapWindow::hpFinalGlideAbove;
HPEN MapWindow::hpFinalGlideBelow;
HPEN MapWindow::hpFinalGlideBelowLandable;
HPEN MapWindow::hpMapScale;
HPEN MapWindow::hpMapScale2;
HPEN MapWindow::hpTerrainLine;
HPEN MapWindow::hpTerrainLineBg;
HPEN MapWindow::hpSpeedSlow;
HPEN MapWindow::hpSpeedFast;
HPEN MapWindow::hpStartFinishThick;
HPEN MapWindow::hpStartFinishThin;
HPEN MapWindow::hpVisualGlideLightBlack; // VENTA3
HPEN MapWindow::hpVisualGlideHeavyBlack; // VENTA3
HPEN MapWindow::hpVisualGlideLightRed; // VENTA3
HPEN MapWindow::hpVisualGlideHeavyRed; // VENTA3

  
COLORREF MapWindow::BackgroundColor = RGB_WHITE;

bool MapWindow::MapDirty = true;
DWORD MapWindow::fpsTime0 = 0;
bool MapWindow::MapFullScreen = false;
bool MapWindow::RequestFullScreen = false;
bool MapWindow::ForceVisibilityScan = false;


extern int DisplayTimeOut;

NMEA_INFO MapWindow::DrawInfo;
DERIVED_INFO MapWindow::DerivedDrawInfo;

int SelectedWaypoint = -1;
bool EnableCDICruise = false;
bool EnableCDICircling = false;

extern HWND hWndCDIWindow;
extern int iround(double i);
extern void ShowMenu();

extern HFONT  TitleWindowFont;
extern HFONT  MapWindowFont;
extern HFONT  MapWindowBoldFont;
extern HFONT  InfoWindowFont;
extern HFONT  CDIWindowFont;
extern HFONT  StatisticsFont;
extern HFONT  MapLabelFont; // VENTA6
extern HFONT  TitleSmallWindowFont; // VENTA6



#ifdef DRAWLOAD
#ifdef GTCFIX
DWORD timestats_av = 0;
#else
int timestats_av = 0;
#endif
#endif

DWORD MapWindow::timestamp_newdata=0;
//#ifdef (DEBUG_MEM) 100211
#if defined DRAWLOAD || defined DEBUG_MEM
int cpuload=0;
#endif

bool timestats_dirty=false;

void MapWindow::UpdateTimeStats(bool start) {
#ifdef DRAWLOAD
  #ifdef GTCFIX
  static DWORD tottime=0;
  #else
  static long tottime=0;
  #endif
#endif
  if (start) {
    timestamp_newdata = ::GetTickCount();
    timestats_dirty = false;
  } else {
#ifdef DRAWLOAD
    if (!timestats_dirty) {
      DWORD time = ::GetTickCount();
      tottime = (2*tottime+(time-timestamp_newdata))/3;
      timestats_av = tottime;
      cpuload=0;
#ifdef DEBUG_MEM
      cpuload= MeasureCPULoad();
      DebugStore("%d # mem\n%d # latency\n", CheckFreeRam()/1024, timestats_av);
#endif
    }
#endif
    timestats_dirty = false;
  }
}



bool MapWindow::Event_NearestWaypointDetails(double lon, double lat, 
                                             double range,
                                             bool pan) {
  /*
    if (!pan) {
    dlgWayPointSelect(lon, lat, 0, 1);
    } else {
    dlgWayPointSelect(PanLongitude, PanLatitude, 0, 1);
    }
  */

  int i;
  if (!pan || !EnablePan) {
    i=FindNearestWayPoint(lon, lat, range);
  } else {
    // nearest to center of screen if in pan mode
    i=FindNearestWayPoint(PanLongitude, PanLatitude, range);
  }
  if(i != -1)
    {
      SelectedWaypoint = i;
      PopupWaypointDetails();
      return true;
    }

  return false;
}


bool MapWindow::Event_InteriorAirspaceDetails(double lon, double lat) {
  unsigned int i;
  bool found=false;
  bool inside;

  if (AirspaceCircle) {
    for (i=0; i<NumberOfAirspaceCircles; i++) {
      inside = false;
      if (AirspaceCircle[i].Visible) {
        inside = InsideAirspaceCircle(lon, lat, i);
      }
      if (inside) {
	dlgAirspaceDetails(i, -1);

	/*
	  DisplayAirspaceWarning(AirspaceCircle[i].Type , 
	  AirspaceCircle[i].Name , 
	  AirspaceCircle[i].Base, 
	  AirspaceCircle[i].Top );
	*/
        found = true;
      }
    }
  }
  if (AirspaceArea) {
    for (i=0; i<NumberOfAirspaceAreas; i++) {
      inside = false;
      if (AirspaceArea[i].Visible) {
        inside = InsideAirspaceArea(lon, lat, i);
      }
      if (inside) {
	dlgAirspaceDetails(-1, i);

	/*
	  DisplayAirspaceWarning(AirspaceArea[i].Type , 
	  AirspaceArea[i].Name , 
	  AirspaceArea[i].Base, 
	  AirspaceArea[i].Top );
	*/
        found = true;
      }
    }
  }

  return found; // nothing found..
}


void MapWindow::SwitchZoomClimb(void) {

  static bool doinit=true;
  static bool last_isclimb = false;
  static bool last_targetpan = false;

  bool isclimb = (DisplayMode == dmCircling);

  if (doinit) {
	SetMapScales();
	doinit=false;
  }

  if (TargetPan != last_targetpan) {
    if (TargetPan) {
      // save starting values
      if (isclimb) {
        ClimbMapScale = MapScale;
      } else {
        CruiseMapScale = MapScale;
      }
    } else {
      // restore scales
      if (isclimb) {
        RequestMapScale = LimitMapScale(ClimbMapScale);
      } else {
        RequestMapScale = LimitMapScale(CruiseMapScale);
      }
      BigZoom = true;
    }
    last_targetpan = TargetPan;
    return;
  }
  if (!TargetPan && CircleZoom) {
    if (isclimb != last_isclimb) {
      if (isclimb) {
        // save cruise scale
        CruiseMapScale = MapScale;
        // switch to climb scale
        RequestMapScale = LimitMapScale(ClimbMapScale);
      } else {
        // leaving climb
        // save cruise scale
        ClimbMapScale = MapScale;
        RequestMapScale = LimitMapScale(CruiseMapScale);
        // switch to climb scale
      }
      BigZoom = true;
      last_isclimb = isclimb;
    } else {
      // nothing to do.
    }
  }

}

bool MapWindow::isAutoZoom() {
  return AutoZoom;
}

bool TextInBoxMoveInView(POINT *offset, RECT *brect){

  bool res = false;

  int LabelMargin = 4;

  offset->x = 0;
  offset->y = 0;

  if (MapWindow::MapRect.top > brect->top){
    int d = MapWindow::MapRect.top - brect->top;
    brect->top += d;
    brect->bottom += d;
    offset->y += d;
    brect->bottom -= d;
    brect->left -= d;
    offset->x -= d;
    res = true;
  }

  if (MapWindow::MapRect.right < brect->right){
    int d = MapWindow::MapRect.right - brect->right;

    if (offset->y < LabelMargin){
      int dy;

      if (d > -LabelMargin){
        dy = LabelMargin-offset->y;
        if (d > -dy)
          dy = -d;
      } else {
        int x = d + (brect->right - brect->left) + 10;

        dy = x - offset->y;

        if (dy < 0)
          dy = 0;

        if (dy > LabelMargin)
          dy = LabelMargin;
      }

      brect->top += dy;
      brect->bottom += dy;
      offset->y += dy;

    }

    brect->right += d;
    brect->left += d;
    offset->x += d;

    res = true;
  }

  if (MapWindow::MapRect.bottom < brect->bottom){
    if (offset->x == 0){
      int d = MapWindow::MapRect.bottom - brect->bottom;
      brect->top += d;
      brect->bottom += d;
      offset->y += d;
    } else
      if (offset->x < -LabelMargin){
	int d = -(brect->bottom - brect->top) - 10;
	brect->top += d;
	brect->bottom += d;
	offset->y += d;
      } else {
	int d = -(2*offset->x + (brect->bottom - brect->top));
	brect->top += d;
	brect->bottom += d;
	offset->y += d;
      }

    res = true;
  }

  if (MapWindow::MapRect.left > brect->left){
    int d = MapWindow::MapRect.left - brect->left;
    brect->right+= d;
    brect->left += d;
    offset->x += d;
    res = true;
  }

  return(res);

}

// VENTA5 now returns true if really wrote something 
bool MapWindow::TextInBox(HDC hDC, TCHAR* Value, int x, int y, 
                          int size, TextInBoxMode_t Mode, bool noOverlap) {

#define WPCIRCLESIZE        2

  SIZE tsize;
  RECT brect;
  HFONT oldFont=0;
  POINT org;
  bool drawn=false;

  if ((x<MapRect.left-WPCIRCLESIZE) || 
      (x>MapRect.right+(WPCIRCLESIZE*3)) || 
      (y<MapRect.top-WPCIRCLESIZE) ||
      (y>MapRect.bottom+WPCIRCLESIZE)) {
    return drawn; // FIX Not drawn really
  }

  org.x = x;
  org.y = y;

  if (size==0) {
    size = _tcslen(Value);
  }
  
  HBRUSH hbOld;
  hbOld = (HBRUSH)SelectObject(hDC, GetStockObject(WHITE_BRUSH));

  if (Mode.AsFlag.Reachable){
    if (Appearance.IndLandable == wpLandableDefault){
      x += 5;  // make space for the green circle
    }else
      if (Appearance.IndLandable == wpLandableAltA){
	x += 0;
      }
  }

  // landable waypoint label inside white box 
  if (!Mode.AsFlag.NoSetFont) {  // VENTA5 predefined font from calling function
    if (Mode.AsFlag.Border){
      oldFont = (HFONT)SelectObject(hDC, MapWindowBoldFont);
    } else {
      oldFont = (HFONT)SelectObject(hDC, MapWindowFont);
    }
  }
  
  GetTextExtentPoint(hDC, Value, size, &tsize);

  if (Mode.AsFlag.AlligneRight){
    x -= tsize.cx;
  } else 
    if (Mode.AsFlag.AlligneCenter){
      x -= tsize.cx/2;
      y -= tsize.cy/2;
    }

  bool notoverlapping = true;

  if (Mode.AsFlag.Border || Mode.AsFlag.WhiteBorder){

    POINT offset;

    brect.left = x-2;
    brect.right = brect.left+tsize.cx+4;
    brect.top = y+((tsize.cy+4)>>3)-2;
    brect.bottom = brect.top+3+tsize.cy-((tsize.cy+4)>>3);

    if (Mode.AsFlag.AlligneRight)
      x -= 3;

    if (TextInBoxMoveInView(&offset, &brect)){
      x += offset.x;
      y += offset.y;
    }

	#if TOPOFASTLABEL
	notoverlapping = checkLabelBlock(&brect); 
	#else
    notoverlapping = checkLabelBlock(brect); 
	#endif

  
    if (!noOverlap || notoverlapping) {
      HPEN oldPen;
      if (Mode.AsFlag.Border) {
        oldPen = (HPEN)SelectObject(hDC, hpMapScale);
      } else {
        oldPen = (HPEN)SelectObject(hDC, GetStockObject(WHITE_PEN));
      }
      RoundRect(hDC, brect.left, brect.top, brect.right, brect.bottom, 
                NIBLSCALE(8), NIBLSCALE(8));
      SelectObject(hDC, oldPen);
#if (WINDOWSPC>0)
      SetBkMode(hDC,TRANSPARENT);
      ExtTextOut(hDC, x, y, 0, NULL, Value, size, NULL);
#else
      ExtTextOut(hDC, x, y, ETO_OPAQUE, NULL, Value, size, NULL);
#endif
      drawn=true;
    }


  } else if (Mode.AsFlag.FillBackground) {

    POINT offset;

    brect.left = x-1;
    brect.right = brect.left+tsize.cx+1;  
    brect.top = y+((tsize.cy+4)>>3);
    brect.bottom = brect.top+tsize.cy-((tsize.cy+4)>>3);

    if (Mode.AsFlag.AlligneRight)
      x -= 2;

    if (TextInBoxMoveInView(&offset, &brect)){
      x += offset.x;
      y += offset.y;
    }

	#if TOPOFASTLABEL
	notoverlapping = checkLabelBlock(&brect); 
	#else
    notoverlapping = checkLabelBlock(brect); 
	#endif
  
    if (!noOverlap || notoverlapping) {
      COLORREF oldColor = SetBkColor(hDC, RGB_WHITE);
      ExtTextOut(hDC, x, y, ETO_OPAQUE, &brect, Value, size, NULL);
      SetBkColor(hDC, oldColor);
      drawn=true;
    }

  } else if (Mode.AsFlag.WhiteBold) {

    switch (DeclutterMode) {
	// This is duplicated later on!
	case (DeclutterMode_t)dmVeryHigh:
	    brect.left = x-NIBLSCALE(10);
	    brect.right = brect.left+tsize.cx+NIBLSCALE(10);
	    brect.top = y+((tsize.cy+NIBLSCALE(12))>>3)-NIBLSCALE(12);
	    brect.bottom = brect.top+NIBLSCALE(12)+tsize.cy-((tsize.cy+NIBLSCALE(12))>>3);
	    break;
	case (DeclutterMode_t)dmHigh:
	    brect.left = x-NIBLSCALE(5);
	    brect.right = brect.left+tsize.cx+NIBLSCALE(5);
	    brect.top = y+((tsize.cy+NIBLSCALE(6))>>3)-NIBLSCALE(6);
	    brect.bottom = brect.top+NIBLSCALE(6)+tsize.cy-((tsize.cy+NIBLSCALE(6))>>3);
	    break;
	case (DeclutterMode_t)dmMedium:
	    brect.left = x-NIBLSCALE(2);
	    brect.right = brect.left+tsize.cx+NIBLSCALE(3);
	    brect.top = y+((tsize.cy+NIBLSCALE(3))>>3)-NIBLSCALE(3);
	    brect.bottom = brect.top+NIBLSCALE(3)+tsize.cy-((tsize.cy+NIBLSCALE(3))>>3);
	    break;
	case (DeclutterMode_t)dmLow:
	case (DeclutterMode_t)dmDisabled: // BUGFIX 100909
	    brect.left = x;
	    brect.right = brect.left+tsize.cx;
	    brect.top = y+((tsize.cy)>>3);
	    brect.bottom = brect.top+tsize.cy-((tsize.cy)>>3);
	    break;
	default:
	    break;

    }

	#if TOPOFASTLABEL
	notoverlapping = checkLabelBlock(&brect); 
	#else
    notoverlapping = checkLabelBlock(brect); 
	#endif
  
    if (!noOverlap || notoverlapping) { 
      if (NewMap&&OutlinedTp)
	SetTextColor(hDC,RGB_BLACK);
      else
	SetTextColor(hDC,RGB_WHITE); 

//#if (WINDOWSPC>0) 091115 do not use custom things for PC in textinbox
#if (0)
      SetBkMode(hDC,TRANSPARENT);
      ExtTextOut(hDC, x+1, y, 0, NULL, Value, size, NULL);
      ExtTextOut(hDC, x+2, y, 0, NULL, Value, size, NULL);
      ExtTextOut(hDC, x-1, y, 0, NULL, Value, size, NULL);
      ExtTextOut(hDC, x-2, y, 0, NULL, Value, size, NULL);
      ExtTextOut(hDC, x, y+1, 0, NULL, Value, size, NULL);
      ExtTextOut(hDC, x, y-1, 0, NULL, Value, size, NULL);
      if (NewMap&&OutlinedTp) {
	if (ScreenSize == (ScreenSize_t)ss800x480) {
		ExtTextOut(hDC, x, y+2, 0, NULL, Value, size, NULL); 
		ExtTextOut(hDC, x, y-2, 0, NULL, Value, size, NULL); 
		ExtTextOut(hDC, x-3, y, 0, NULL, Value, size, NULL); 
		ExtTextOut(hDC, x+3, y, 0, NULL, Value, size, NULL); 
		ExtTextOut(hDC, x, y+3, 0, NULL, Value, size, NULL); 
		ExtTextOut(hDC, x, y-3, 0, NULL, Value, size, NULL); 
	}
	TextColor(hDC,Mode.AsFlag.Color);
      } else
	SetTextColor(hDC,RGB_BLACK); 

      ExtTextOut(hDC, x, y, 0, NULL, Value, size, NULL);
      if (NewMap&&OutlinedTp)
	SetTextColor(hDC,RGB_BLACK); // TODO somewhere else text color is not set correctly

#else
      ExtTextOut(hDC, x+2, y, ETO_OPAQUE, NULL, Value, size, NULL);
      ExtTextOut(hDC, x+1, y, ETO_OPAQUE, NULL, Value, size, NULL);
      ExtTextOut(hDC, x-1, y, ETO_OPAQUE, NULL, Value, size, NULL);
      ExtTextOut(hDC, x-2, y, ETO_OPAQUE, NULL, Value, size, NULL);
      ExtTextOut(hDC, x, y+1, ETO_OPAQUE, NULL, Value, size, NULL);
      ExtTextOut(hDC, x, y-1, ETO_OPAQUE, NULL, Value, size, NULL);
//#ifdef PNA 091115 no more big outlining for 314
#if (0)
	// On 800x480 resolution the following additional outlining is very nice.
	// But on 640x480 and lower resolutions it is bad.. Maybe we should work
	// something out for 640x480 devices in landscape mode, when there's nothing else to do. --paolo
      if (NewMap&&OutlinedTp) {
      	if (GlobalModelType == MODELTYPE_PNA_HP31X ) {
	      ExtTextOut(hDC, x+3, y, ETO_OPAQUE, NULL, Value, size, NULL);
	      ExtTextOut(hDC, x-3, y, ETO_OPAQUE, NULL, Value, size, NULL);
	      ExtTextOut(hDC, x, y+2, ETO_OPAQUE, NULL, Value, size, NULL);
	      ExtTextOut(hDC, x, y-2, ETO_OPAQUE, NULL, Value, size, NULL);
	      ExtTextOut(hDC, x, y+3, ETO_OPAQUE, NULL, Value, size, NULL);
	      ExtTextOut(hDC, x, y-3, ETO_OPAQUE, NULL, Value, size, NULL);
      	}
      }
#endif
      if (NewMap&&OutlinedTp) {
	TextColor(hDC,Mode.AsFlag.Color);
      } else
	SetTextColor(hDC,RGB_BLACK); 

      ExtTextOut(hDC, x, y, ETO_OPAQUE, NULL, Value, size, NULL);
      if (NewMap&&OutlinedTp)
	SetTextColor(hDC,RGB_BLACK); // TODO somewhere else text color is not set correctly
#endif
      drawn=true;
    }

  } else {

    switch (DeclutterMode) {
	// This is duplicated before!
	case (DeclutterMode_t)dmVeryHigh:
	    brect.left = x-NIBLSCALE(10);
	    brect.right = brect.left+tsize.cx+NIBLSCALE(10);
	    brect.top = y+((tsize.cy+NIBLSCALE(12))>>3)-NIBLSCALE(12);
	    brect.bottom = brect.top+NIBLSCALE(12)+tsize.cy-((tsize.cy+NIBLSCALE(12))>>3);
	    break;
	case (DeclutterMode_t)dmHigh:
	    brect.left = x-NIBLSCALE(5);
	    brect.right = brect.left+tsize.cx+NIBLSCALE(5);
	    brect.top = y+((tsize.cy+NIBLSCALE(6))>>3)-NIBLSCALE(6);
	    brect.bottom = brect.top+NIBLSCALE(6)+tsize.cy-((tsize.cy+NIBLSCALE(6))>>3);
	    break;
	case (DeclutterMode_t)dmMedium:
	    brect.left = x-NIBLSCALE(2);
	    brect.right = brect.left+tsize.cx+NIBLSCALE(3);
	    brect.top = y+((tsize.cy+NIBLSCALE(3))>>3)-NIBLSCALE(3);
	    brect.bottom = brect.top+NIBLSCALE(3)+tsize.cy-((tsize.cy+NIBLSCALE(3))>>3);
	    break;
	case (DeclutterMode_t)dmLow:
	case (DeclutterMode_t)dmDisabled: // BUGFIX 100909
	    brect.left = x;
	    brect.right = brect.left+tsize.cx;
	    brect.top = y+((tsize.cy)>>3);
	    brect.bottom = brect.top+tsize.cy-((tsize.cy)>>3);
	    break;
	default:
	    break;

    }

	#if TOPOFASTLABEL
	notoverlapping = checkLabelBlock(&brect); 
	#else
    notoverlapping = checkLabelBlock(brect); 
	#endif
  
    if (!noOverlap || notoverlapping) {
#if (WINDOWSPC>0)
      SetBkMode(hDC,TRANSPARENT);
	if (NewMap) {
		TextColor(hDC,Mode.AsFlag.Color);
      		ExtTextOut(hDC, x, y, 0, NULL, Value, size, NULL);
		SetTextColor(hDC,RGB_BLACK); 
	} else
      		ExtTextOut(hDC, x, y, 0, NULL, Value, size, NULL);
#else
	if (NewMap) {
		TextColor(hDC,Mode.AsFlag.Color);
      		ExtTextOut(hDC, x, y, ETO_OPAQUE, NULL, Value, size, NULL);
		SetTextColor(hDC,RGB_BLACK); 
	} else
      		ExtTextOut(hDC, x, y, ETO_OPAQUE, NULL, Value, size, NULL);
#endif
      drawn=true;
    }

  }
 
  if (!Mode.AsFlag.NoSetFont) SelectObject(hDC, oldFont); // VENTA5
  SelectObject(hDC, hbOld);

  return drawn;

}

bool userasked = false;

void MapWindow::RequestFastRefresh() {
  SetEvent(drawTriggerEvent);
}

void MapWindow::RefreshMap() {
  MapDirty = true;
  userasked = true;
  timestats_dirty = true;
  SetEvent(drawTriggerEvent);
}

bool MapWindow::IsMapFullScreen() {
  // SDP - Seems that RequestFullScreen
  // is always more accurate (MapFullSCreen is delayed)
  return RequestFullScreen;
  // return  MapFullScreen;
}


void MapWindow::ToggleFullScreenStart() {

  // ok, save the state.
  MapFullScreen = RequestFullScreen;

  // show infoboxes immediately

  if (MapFullScreen) {
    MapRect = MapRectBig;
    HideInfoBoxes();    
    DefocusInfoBox(); // BUGFIX 091115 BgColor
  } else {
    MapRect = MapRectSmall;
    ShowInfoBoxes(); // VENTA FIX QUI
  }
  #ifndef NOVARIOGAUGE
  GaugeVario::Show(!MapFullScreen);
  #endif
}


void MapWindow::RequestToggleFullScreen() {
  RequestFullScreen = !RequestFullScreen;
  RefreshMap();
}

void MapWindow::RequestOnFullScreen() {
  RequestFullScreen = true;
  RefreshMap();
}

void MapWindow::RequestOffFullScreen() {
  RequestFullScreen = false;
  RefreshMap();
}



extern BOOL extGPSCONNECT;
extern bool DialogActive;



void MapWindow::Event_AutoZoom(int vswitch) {
  if (vswitch== -1) {
    AutoZoom = !AutoZoom;
  } else {
    AutoZoom = (vswitch != 0); // 0 off, 1 on
  }
  
  if (AutoZoom) {
    if (EnablePan) {
      EnablePan = false;
      InputEvents::setMode(TEXT("default"));
      StoreRestoreFullscreen(false);
    }
  }
  RefreshMap();
}


void MapWindow::Event_PanCursor(int dx, int dy) {
  int X= (MapRect.right+MapRect.left)/2;
  int Y= (MapRect.bottom+MapRect.top)/2;
  double Xstart, Ystart, Xnew, Ynew;

  Screen2LatLon(X, Y, Xstart, Ystart);

  X+= (MapRect.right-MapRect.left)*dx/4;
  Y+= (MapRect.bottom-MapRect.top)*dy/4;
  Screen2LatLon(X, Y, Xnew, Ynew);

  if (EnablePan) {
    PanLongitude += Xstart-Xnew;
    PanLatitude += Ystart-Ynew;
  }
  RefreshMap();
}

bool MapWindow::isPan() {
  return EnablePan;
}

/* Event_TerrainToplogy Changes
   0       Show
   1       Toplogy = ON
   2       Toplogy = OFF
   3       Terrain = ON
   4       Terrain = OFF
   -1      Toggle through 4 stages (off/off, off/on, on/off, on/on)
   -2      Toggle terrain
   -3      Toggle toplogy
*/
void MapWindow::Event_TerrainTopology(int vswitch) {
  char val;

  if (vswitch== -1) { // toggle through 4 possible options
    val = 0;
    if (EnableTopology) val++;
    if (EnableTerrain) val += (char)2;
    val++;
    if (val>3) val=0;
    EnableTopology = ((val & 0x01) == 0x01);
    EnableTerrain  = ((val & 0x02) == 0x02);
    RefreshMap();

  } else if (vswitch == -2) { // toggle terrain
    EnableTerrain = !EnableTerrain;
    RefreshMap();

  } else if (vswitch == -3) { // toggle topology
    EnableTopology = !EnableTopology;
    RefreshMap();

  } else if (vswitch == 1) { // Turn on toplogy
    EnableTopology = true;
    RefreshMap();

  } else if (vswitch == 2) { // Turn off toplogy
    EnableTopology = false;
    RefreshMap();

  } else if (vswitch == 3) { // Turn on terrain 
    EnableTerrain = true;
    RefreshMap();

  } else if (vswitch == 4) { // Turn off terrain
    EnableTerrain = false;
    RefreshMap();

  } else if (vswitch == 0) { // Show terrain/Topology
    // ARH Let user know what's happening
    TCHAR buf[128];
    if (EnableTopology) {
	if (EnableTerrain)
		_stprintf(buf, _T("Topo:ON   Terra:ON"));
	else
		_stprintf(buf, _T("Topo:ON   Terra:OFF"));
    } else {
	if (EnableTerrain)
		_stprintf(buf, _T("Topo:OFF   Terra:ON"));
	else
		_stprintf(buf, _T("Topo:OFF   Terra:OFF"));
    }

    Message::Lock(); // 091211
    Message::AddMessage(500, 3, buf); // 091125
    Message::Unlock();
    // DoStatusMessage(TEXT("Topology / Terrain"), buf);
  }
}


void MapWindow::StoreRestoreFullscreen(bool store) {
  static bool oldfullscreen = 0;
  static bool SuperPan = false;
  if (store) {
    // pan not active on entry, save fullscreen status
    SuperPan = true;
    oldfullscreen = MapWindow::IsMapFullScreen();
  } else {
    if (SuperPan) {
      // pan is active, need to restore
      if (!oldfullscreen) {
        // change it if necessary
        RequestFullScreen = false;
      }
      SuperPan = false;
    }
  }
}


void MapWindow::Event_Pan(int vswitch) {
  //  static bool oldfullscreen = 0;  never assigned!
  bool oldPan = EnablePan;
  if (vswitch == -2) { // superpan, toggles fullscreen also

    if (!EnablePan) {
      StoreRestoreFullscreen(true);
    } else {
      StoreRestoreFullscreen(false);
    }
    // new mode
    EnablePan = !EnablePan;
    if (EnablePan) { // pan now on, so go fullscreen
      RequestFullScreen = true;
    }

  } else if (vswitch == -1) {
    EnablePan = !EnablePan;
  } else {
    EnablePan = (vswitch != 0); // 0 off, 1 on
  }

  if (EnablePan != oldPan) {
    if (EnablePan) {
      PanLongitude = DrawInfo.Longitude;
      PanLatitude = DrawInfo.Latitude;
      InputEvents::setMode(TEXT("pan"));
    } else 
      InputEvents::setMode(TEXT("default"));
  }
  RefreshMap();
}

double MapWindow::LimitMapScale(double value) {

  double minreasonable;

  if ( ISPARAGLIDER ) 
    minreasonable = 0.005;  // 091017 5m resolution for Para
  else
    minreasonable = 0.05; 

  if (AutoZoom && DisplayMode != dmCircling) {
    if (AATEnabled && (ActiveWayPoint>0)) {
      if ( ISPARAGLIDER ) minreasonable = 0.005; 
      else minreasonable = 0.88;
    } else {
      if ( ISPARAGLIDER ) minreasonable = 0.005; // 091016 0.01
      else minreasonable = 0.44; 
    }
  }

  if (ScaleListCount>0) {
    return FindMapScale(max(minreasonable,min(160.0,value)));
  } else {
    return max(minreasonable,min(160.0,value));
  }
}


void MapWindow::Event_SetZoom(double value) {


/* 091023 TEST REMOVE
//  static bool doinit_climb=true;
//  static bool doinit_cruise=true;
//
//  if (!CALCULATED_INFO.Circling && doinit_cruise) {
//	RequestMapScale=8.0;
//	doinit_cruise=false;
//  }
//  if (CALCULATED_INFO.Circling && doinit_climb) {
//	RequestMapScale=0.70;
//	doinit_climb=false;
//  }
*/


  static double lastRequestMapScale = RequestMapScale;

  RequestMapScale = LimitMapScale(value);
  if (lastRequestMapScale != RequestMapScale){
    lastRequestMapScale = RequestMapScale;
    BigZoom = true;
    RefreshMap();
  }
}


void MapWindow::Event_ScaleZoom(int vswitch) {

  static double lastRequestMapScale = RequestMapScale;
  double value = RequestMapScale;
  static int nslow=0;

  if (isAutoZoom()) {
	DoStatusMessage(_T("Autozoom OFF"));
	AutoZoom=0;
  }

  // For best results, zooms should be multiples or roots of 2

  if (ScaleListCount > 0){
    value = FindMapScale(RequestMapScale);
    value = StepMapScale(-vswitch);
  } else {

    if (abs(vswitch)>=4) {
      nslow++;
      if (nslow %2 != 0) {
        // JMW disabled        return;
      }
      if (vswitch==4) {
        vswitch = 1;
      }
      if (vswitch==-4) {
        vswitch = -1;
      }
    }
    if (vswitch==1) { // zoom in a little
      value /= 1.414;
    }
    if (vswitch== -1) { // zoom out a little
      value *= 1.414;
    }
    if (vswitch==2) { // zoom in a lot
      value /= 2.0;
    }
    if (vswitch== -2) { // zoom out a lot
      value *= 2.0;
    } 

  }
  RequestMapScale = LimitMapScale(value);

  if (lastRequestMapScale != RequestMapScale){
    lastRequestMapScale = RequestMapScale;
    BigZoom = true;

    RefreshMap();

    //    DrawMapScale(hdcScreen, MapRect, true);
    // JMW this is bad, happening from wrong thread.
  }
}


int MapWindow::GetMapResolutionFactor(void) { // TESTFIX 091017 CHECKFIX
  static int retglider=NIBLSCALE(30);
  //static int retpara=IBLSCALE(30);
/*
  if (ISPARAGLIDER)
	return IBLSCALE(3); // 091017 30 TESTFIX QUIQUI
  else
	return IBLSCALE(30);
*/
  //if (ISPARAGLIDER) return retpara; else return retglider;

  return retglider;
}

double MapWindow::StepMapScale(int Step){
  static int nslow=0;
  if (abs(Step)>=4) {
    nslow++;
    //    if (nslow %2 == 0) {
    ScaleCurrent += Step/4;
    //    }
  } else {
    ScaleCurrent += Step;
  }
  ScaleCurrent = max(0,min(ScaleListCount-1, ScaleCurrent));
  return((ScaleList[ScaleCurrent]*GetMapResolutionFactor())
         /(IBLSCALE(/*Appearance.DefaultMapWidth*/ MapRect.right)));
}

double MapWindow::FindMapScale(double Value){

  int    i;
  double BestFit = 99999;
  int    BestFitIdx=-1;
  double DesiredScale = 
    (Value*IBLSCALE(/*Appearance.DefaultMapWidth*/ MapRect.right))/GetMapResolutionFactor();

  for (i=0; i<ScaleListCount; i++){
    double err = fabs(DesiredScale - ScaleList[i])/DesiredScale;
    if (err < BestFit){
      BestFit = err;
      BestFitIdx = i;
    }
  }

  if (BestFitIdx != -1){
    ScaleCurrent = BestFitIdx;
    return((ScaleList[ScaleCurrent]*GetMapResolutionFactor())
           /IBLSCALE(/*Appearance.DefaultMapWidth*/ MapRect.right));
  }
  return(Value);
}


static void SetFontInfo(HDC hDC, FontHeightInfo_t *FontHeightInfo){
  TEXTMETRIC tm;
  int x,y=0;
  RECT  rec;
  int top, bottom;

  GetTextMetrics(hDC, &tm);
  FontHeightInfo->Height = tm.tmHeight;
  FontHeightInfo->AscentHeight = tm.tmAscent;
  FontHeightInfo->CapitalHeight = 0;

  SetBkMode(hDC, OPAQUE);
  SetBkColor(hDC,RGB_WHITE);
  SetTextColor(hDC,RGB_BLACK);
  rec.left = 0;
  rec.top = 0;
  rec.right = tm.tmAveCharWidth;
  rec.bottom = tm.tmHeight;
  ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rec, TEXT("M"), _tcslen(TEXT("M")), NULL);

  top = tm.tmHeight;
  bottom = 0;

  FontHeightInfo->CapitalHeight = 0;
  for (x=0; x<tm.tmAveCharWidth; x++){
    for (y=0; y<tm.tmHeight; y++){
      if ((GetPixel(hDC, x, y)) != RGB_WHITE){
        if (top > y)
          top = y;
        if (bottom < y)
          bottom = y;
      }
    }
  }

#ifdef GNAV
  // JMW: don't know why we need this in GNAV, but we do.
  if (FontHeightInfo->CapitalHeight<y)
    FontHeightInfo->CapitalHeight = bottom - top + 1;
#endif
  // This works for PPC
  if (FontHeightInfo->CapitalHeight <= 0)
    FontHeightInfo->CapitalHeight = tm.tmAscent - 1 -(tm.tmHeight/10);

  //  int lx = GetDeviceCaps(hDC,LOGPIXELSX);
  // dpi
}


LRESULT CALLBACK MapWindow::MapWndProc (HWND hWnd, UINT uMsg, WPARAM wParam,
                                        LPARAM lParam)
{
  int i;
  static double Xstart, Ystart;
  static int XstartScreen, YstartScreen;
  int X,Y;
  int gestX, gestY, gestDir=LKGESTURE_NONE, gestDist=-1;
  double Xlat, Ylat;
  double distance;
  int width = (int) LOWORD(lParam);
  int height = (int) HIWORD(lParam);
  
  static DWORD dwDownTime= 0L, dwUpTime= 0L, dwInterval= 0L;

  #if LKPMODE
  bool dontdrawthemap=(DONTDRAWTHEMAP);
  bool mapmode8000=(MAPMODE8000);
  #else
  bool dontdrawthemap=(DONTDRAWTHEMAP);
  bool mapmode8000=(MAPMODE8000);
  #endif

  static short navboxesY;
  // Attention... this is duplicated inside Utils2, I am lazy 
  // apparently only #include is duplicated, so no problems
  static bool doinit=true;
  static int AIRCRAFTMENUSIZE=0, COMPASSMENUSIZE=0;

  navboxesY=(MapWindow::MapRect.bottom-MapWindow::MapRect.top)-BottomSize-NIBLSCALE(2); // BUGFIX 091125


  switch (uMsg)
    {
      /* JMW THIS IS BAD!  Now done with GCE_AIRSPACE
	 case WM_USER+1:
	 dlgAirspaceWarningShowDlg(false);
	 return(0);
      */
    case WM_ERASEBKGND:
      // JMW trying to reduce flickering
      /*
	if (first || MapDirty) {
	first = false;
	MapDirty = true;
	return (DefWindowProc (hWnd, uMsg, wParam, lParam));
	} else
	return TRUE;
      */
      return TRUE;
    case WM_SIZE:

      hDrawBitMap = CreateCompatibleBitmap (hdcScreen, width, height);
      SelectObject(hdcDrawWindow, (HBITMAP)hDrawBitMap);

      hDrawBitMapTmp = CreateCompatibleBitmap (hdcScreen, width, height);
      SelectObject(hDCTemp, (HBITMAP)hDrawBitMapTmp);

      hMaskBitMap = CreateBitmap(width+1, height+1, 1, 1, NULL);
      SelectObject(hDCMask, (HBITMAP)hMaskBitMap);

      {
	HFONT      oldFont;

	oldFont = (HFONT)SelectObject(hDCTemp, TitleWindowFont);
	SetFontInfo(hDCTemp, &Appearance.TitleWindowFont);

	SelectObject(hDCTemp, MapWindowFont);
	SetFontInfo(hDCTemp, &Appearance.MapWindowFont);

	SelectObject(hDCTemp, MapWindowBoldFont);
	SetFontInfo(hDCTemp, &Appearance.MapWindowBoldFont);

	SelectObject(hDCTemp, InfoWindowFont);
	SetFontInfo(hDCTemp, &Appearance.InfoWindowFont);

	SelectObject(hDCTemp, CDIWindowFont);
	SetFontInfo(hDCTemp, &Appearance.CDIWindowFont);
//VENTA6
	SelectObject(hDCTemp, StatisticsFont);
	SetFontInfo(hDCTemp, &Appearance.StatisticsFont);

	SelectObject(hDCTemp, MapLabelFont);
	SetFontInfo(hDCTemp, &Appearance.MapLabelFont);

	SelectObject(hDCTemp, TitleSmallWindowFont);
	SetFontInfo(hDCTemp, &Appearance.TitleSmallWindowFont);

	SelectObject(hDCTemp, oldFont);
      }

      break;

    case WM_CREATE:

      hdcScreen = GetDC(hWnd);
      hdcDrawWindow = CreateCompatibleDC(hdcScreen);
      hDCTemp = CreateCompatibleDC(hdcDrawWindow);
      hDCMask = CreateCompatibleDC(hdcDrawWindow);

      #if LKOBJ
      hBackgroundBrush = LKBrush_White;
      hInvBackgroundBrush[0] = LKBrush_White;
      hInvBackgroundBrush[1] = LKBrush_LightGrey;
      hInvBackgroundBrush[2] = LKBrush_LcdGreen;
      hInvBackgroundBrush[3] = LKBrush_LcdDarkGreen;
      hInvBackgroundBrush[4] = LKBrush_Grey; 
      hInvBackgroundBrush[5] = LKBrush_Lake;
      hInvBackgroundBrush[6] = LKBrush_Emerald;
      hInvBackgroundBrush[7] = LKBrush_DarkSlate;
      hInvBackgroundBrush[8] = LKBrush_RifleGrey;
      hInvBackgroundBrush[9] = LKBrush_Black;
      #else
      hBackgroundBrush = CreateSolidBrush(BackgroundColor);
      hInvBackgroundBrush[0] = CreateSolidBrush(COLORREF RGB_WHITE);	 // black text required
      hInvBackgroundBrush[1] = CreateSolidBrush(COLORREF RGB_LIGHTGREY); // black  light grey
      hInvBackgroundBrush[2] = CreateSolidBrush(COLORREF RGB_LCDGREEN);	// black   lcd green 
      hInvBackgroundBrush[3] = CreateSolidBrush(COLORREF RGB_LCDDARKGREEN); // lcd green dark
      hInvBackgroundBrush[4] = CreateSolidBrush(COLORREF RGB_GREY);	// 
      hInvBackgroundBrush[5] = CreateSolidBrush(COLORREF RGB_LAKE);	// bianco , ok con topology
      hInvBackgroundBrush[6] = CreateSolidBrush(COLORREF RGB_EMERALD);   // slategreen
      // BlackScreen requested for white waypoints, no topology working
      hInvBackgroundBrush[7] = CreateSolidBrush(COLORREF RGB_DARKSLATE); // senza topo, richiede wp bianchi
      hInvBackgroundBrush[8] = CreateSolidBrush(COLORREF RGB_RIFLEGREY);  // dark grey
      hInvBackgroundBrush[9] = CreateSolidBrush(COLORREF RGB_BLACK); // richiede blackscreen
      #endif

      hFLARMTraffic=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FLARMTRAFFIC));
      hTerrainWarning=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_TERRAINWARNING));
      hTurnPoint=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_TURNPOINT));
      hInvTurnPoint=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_INVTURNPOINT));
      hSmall=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_SMALL));
      hInvSmall=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_INVSMALL));
      hAutoMacCready=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AUTOMCREADY));
      hGPSStatus1=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_GPSSTATUS1));
      hGPSStatus2=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_GPSSTATUS2));
      hLogger=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_LOGGER));
      hLoggerOff=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_LOGGEROFF));
      hBmpTeammatePosition = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_TEAMMATE_POS));

      if ( ISPARAGLIDER ) {
	hCruise=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_CRUISEPARA));
	hClimb=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_CLIMBPARA));
	hFinalGlide=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FINALGLIDEPARA));
	hAbort=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_ABORT));
      } else {
	hCruise=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_CRUISE));
	hClimb=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_CLIMB));
	hFinalGlide=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FINALGLIDE));
	hAbort=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_ABORT));
      }

      //hBmpCompassBg = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_COMPASSBG));


      // airspace brushes and colours

      hAirspaceBitmap[0]=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRSPACE0));
      hAirspaceBitmap[1]=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRSPACE1));
      hAirspaceBitmap[2]=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRSPACE2));
      hAirspaceBitmap[3]=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRSPACE3));
      hAirspaceBitmap[4]=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRSPACE4));
      hAirspaceBitmap[5]=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRSPACE5));
      hAirspaceBitmap[6]=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRSPACE6));
      hAirspaceBitmap[7]=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRSPACE7));

      hAboveTerrainBitmap = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_ABOVETERRAIN));

      for (i=0; i<NUMAIRSPACEBRUSHES; i++) {
	hAirspaceBrushes[i] =
	  CreatePatternBrush((HBITMAP)hAirspaceBitmap[i]);
      }
      hAboveTerrainBrush = CreatePatternBrush((HBITMAP)hAboveTerrainBitmap);

	int iwidth;
#ifndef NEWTRAIL
      // normal colours
      BYTE Red,Green,Blue;
      int minwidth;
      minwidth = max(NIBLSCALE(2),IBLSCALE(SnailWidthScale)/16);
      for (i=0; i<NUMSNAILCOLORS; i++) {
	short ih = i*200/(NUMSNAILCOLORS-1);
	ColorRampLookup(ih, 
			Red, Green, Blue,
			snail_colors, NUMSNAILRAMP, 6);      
	if (i<NUMSNAILCOLORS/2) {
	  iwidth= minwidth;
	} else {
	  iwidth = max(minwidth,
		       (i-NUMSNAILCOLORS/2)
		       *IBLSCALE(SnailWidthScale)/NUMSNAILCOLORS);
	}

	hSnailColours[i] = RGB((BYTE)Red,(BYTE)Green,(BYTE)Blue);
	hSnailPens[i] = (HPEN)CreatePen(PS_SOLID, iwidth, hSnailColours[i]);

      }
#else
	iwidth=IBLSCALE(SnailWidthScale);
	hSnailColours[0] = RGB_BLACK;
	hSnailColours[1] = RGB_INDIGO;
	hSnailColours[2] = RGB_INDIGO;
	hSnailColours[3] = RGB_BLUE;
	hSnailColours[4] = RGB_BLUE;
	hSnailColours[5] = RGB_LAKE;
	hSnailColours[6] = RGB_LAKE;
	hSnailColours[7] = RGB_GREY;
	hSnailColours[8] = RGB_GREEN;
	hSnailColours[9] = RGB_GREEN;
	hSnailColours[10] = RGB_ORANGE;
	hSnailColours[11] = RGB_ORANGE;
	hSnailColours[12] = RGB_RED;
	hSnailColours[13] = RGB_RED;
	hSnailColours[14] = RGB_DARKRED;

	hSnailPens[0] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[0]);
	hSnailPens[1] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[1]);
	hSnailPens[2] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[2]);
	hSnailPens[3] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[3]);
	hSnailPens[4] = (HPEN)CreatePen(PS_SOLID,  iwidth/NIBLSCALE(2), hSnailColours[4]);
	hSnailPens[5] = (HPEN)CreatePen(PS_SOLID,  iwidth/NIBLSCALE(4), hSnailColours[5]);
	hSnailPens[6] = (HPEN)CreatePen(PS_SOLID,  iwidth/NIBLSCALE(4), hSnailColours[6]);
	hSnailPens[7] = (HPEN)CreatePen(PS_SOLID,  iwidth/NIBLSCALE(6), hSnailColours[7]);
	hSnailPens[8] = (HPEN)CreatePen(PS_SOLID,  iwidth/NIBLSCALE(4), hSnailColours[8]);
	hSnailPens[9] = (HPEN)CreatePen(PS_SOLID,  iwidth/NIBLSCALE(4), hSnailColours[9]);
	hSnailPens[10] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[10]);
	hSnailPens[11] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[11]);
	hSnailPens[12] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[12]);
	hSnailPens[13] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[13]);
	hSnailPens[14] = (HPEN)CreatePen(PS_SOLID, iwidth/NIBLSCALE(2), hSnailColours[14]);
#endif

      /* JMW created all re-used pens here */


      // testing only    Appearance.InverseAircraft = true;

	#if LKOBJ
      hpCompassBorder = LKPen_Black_N2;
      if (Appearance.InverseAircraft) {
	hpAircraft = LKPen_Black_N3;
	hpAircraftBorder = LKPen_White_N1;
      } else {
	hpAircraft = LKPen_White_N3;
	hpAircraftBorder = LKPen_Black_N1;
      }
	hpThermalCircle = LKPen_White_N3;

	#else
      hpCompassBorder = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB_BLACK); 
      if (Appearance.InverseAircraft) {
	hpAircraft = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(3), RGB_BLACK);
	hpAircraftBorder = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_WHITE);
      } else {
	hpAircraft = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(3), RGB_WHITE);
	hpAircraftBorder = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_BLACK);
      }
	hpThermalCircle = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(3), RGB_WHITE);
	#endif

	#if LKOBJ
#if (MONOCHROME_SCREEN > 0)
      hpWind = LKPen_Black_N2;
#else
      hpWind = LKPen_Red_N2;
#endif
	#else
#if (MONOCHROME_SCREEN > 0)
      hpWind = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB_BLACK);
#else
      hpWind = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB_RED);
#endif
	#endif

      hpWindThick = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(4), RGB(255,220,220));

	#if LKOBJ
      hpBearing = LKPen_Black_N2;
      hpBestCruiseTrack = LKPen_Blue_N1;
	#else
      hpBearing = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB_BLACK);
      hpBestCruiseTrack = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_BLUE);
	#endif
#if (MONOCHROME_SCREEN > 0)
      hpCompass = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_BLACK);
#else
      hpCompass = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB(0xcf,0xcf,0xFF));
#endif
      hpThermalBand = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB(0x40,0x40,0xFF));
      hpThermalBandGlider = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB(0x00,0x00,0x30));

      hpFinalGlideBelow = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB(0xFF,0xA0,0xA0));
      hpFinalGlideBelowLandable = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB(255,196,0));

      // TODO enhancement: support red/green Color blind
      hpFinalGlideAbove = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB(0xA0,0xFF,0xA0));

	#if LKOBJ
      hpSpeedSlow=LKPen_Red_N1;
      hpSpeedFast=LKPen_Green_N1;
      hpStartFinishThin=LKPen_Red_N1;
      hpMapScale = LKPen_Black_N1;

	#else
      hpSpeedSlow=(HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_RED);
      hpSpeedFast=(HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_GREEN);
      hpStartFinishThin=(HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB_RED);
      hpMapScale = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1),  RGB_BLACK);
	#endif

      hpStartFinishThick=(HPEN)CreatePen(PS_SOLID, NIBLSCALE(5), taskcolor);
      hpMapScale2 = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1)+1, RGB_BLACK);
      // TerrainLine is for shade, Bg is for perimeter
      hpTerrainLine = (HPEN)CreatePen(PS_DASH, (1), RGB(0x30,0x30,0x30));
      hpTerrainLineBg = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB_LCDDARKGREEN);
      hpVisualGlideLightBlack = (HPEN)CreatePen(PS_DASH, (1), RGB_BLACK);
      hpVisualGlideHeavyBlack = (HPEN)CreatePen(PS_DASH, (2), RGB_BLACK);
      hpVisualGlideLightRed = (HPEN)CreatePen(PS_DASH, (1), RGB_RED);
      hpVisualGlideHeavyRed = (HPEN)CreatePen(PS_DASH, (2), RGB_RED);

      #if LKOBJ

      hbThermalBand=LKBrush_Emerald;
	#if (MONOCHROME_SCREEN > 0)
      hbCompass=LKBrush_White;
	#else
      hbCompass=LKBrush_Cyan;
	#endif
      hbBestCruiseTrack=LKBrush_Blue;
      hbFinalGlideBelow=LKBrush_Red;
      hbFinalGlideAbove=LKBrush_Green;
      hbFinalGlideBelowLandable=LKBrush_Orange;
	#if (MONOCHROME_SCREEN > 0)
      hbWind=LKBrush_Grey;
	#else
      hbWind=LKBrush_Grey;
	#endif
      #else

      hbThermalBand=(HBRUSH)CreateSolidBrush(RGB(0x80,0x80,0xFF));
	#if (MONOCHROME_SCREEN > 0)
      hbCompass=(HBRUSH)CreateSolidBrush(RGB_WHITE);
	#else
      hbCompass=(HBRUSH)CreateSolidBrush(RGB(0x40,0x40,0xFF));
	#endif
      hbBestCruiseTrack=(HBRUSH)CreateSolidBrush(RGB_BLUE);
      hbFinalGlideBelow=(HBRUSH)CreateSolidBrush(RGB_RED);
      hbFinalGlideAbove=(HBRUSH)CreateSolidBrush(RGB_GREEN);
      hbFinalGlideBelowLandable=(HBRUSH)CreateSolidBrush(RGB(0xFF,180,0x00));
	#if (MONOCHROME_SCREEN > 0)
      hbWind=(HBRUSH)CreateSolidBrush(RGB_MIDDLEGREY);
	#else
      hbWind=(HBRUSH)CreateSolidBrush(RGB_MIDDLEGREY);
	#endif

      #endif


      ScaleListCount = propGetScaleList(ScaleList, sizeof(ScaleList)/sizeof(ScaleList[0]));
      RequestMapScale = LimitMapScale(RequestMapScale);

      hBmpMapScale = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_MAPSCALE_A));

      #if LKOBJ
      hBrushFlyingModeAbort = LKBrush_Red;
      #else
      hBrushFlyingModeAbort = (HBRUSH)CreateSolidBrush(RGB_RED);
      #endif

      if (Appearance.IndLandable == wpLandableDefault){
	hBmpAirportReachable = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_REACHABLE));
	hBmpAirportUnReachable = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_LANDABLE));
	hBmpFieldReachable = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_REACHABLE));
	hBmpFieldUnReachable = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_LANDABLE));
      }else
	if (Appearance.IndLandable == wpLandableAltA){
	  hBmpAirportReachable = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRPORT_REACHABLE));
	  hBmpAirportUnReachable = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_AIRPORT_UNREACHABLE));
	  hBmpFieldReachable = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_OUTFILED_REACHABLE));
	  hBmpFieldUnReachable = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_OUTFILED_UNREACHABLE));
	}

      hBmpThermalSource = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_THERMALSOURCE));
      hBmpTarget = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_TARGET));

      // Signal that draw thread can run now
      Initialised = TRUE;

      break;

    case WM_DESTROY:

      ReleaseDC(hWnd, hdcScreen);
      DeleteDC(hdcDrawWindow);
      DeleteDC(hDCTemp);
      DeleteDC(hDCMask);
      DeleteObject(hDrawBitMap);
      DeleteObject(hMaskBitMap);

      DeleteObject(hTurnPoint);
      DeleteObject(hSmall);
      DeleteObject(hInvTurnPoint);
      DeleteObject(hInvSmall);
      DeleteObject(hCruise);
      DeleteObject(hClimb);
      DeleteObject(hFinalGlide);
      DeleteObject(hAutoMacCready);
      DeleteObject(hFLARMTraffic);
      DeleteObject(hTerrainWarning);
      DeleteObject(hGPSStatus1);
      DeleteObject(hGPSStatus2);
      DeleteObject(hAbort);
      DeleteObject(hLogger);
      DeleteObject(hLoggerOff);
    
      DeleteObject((HPEN)hpWindThick);

	#ifndef LKOBJ
      DeleteObject((HPEN)hpBestCruiseTrack);
      DeleteObject((HPEN)hpBearing);
      DeleteObject((HPEN)hpWind);
      DeleteObject((HPEN)hpAircraft); 
      DeleteObject((HPEN)hpAircraftBorder); 
      DeleteObject((HPEN)hpCompass); 
      DeleteObject((HPEN)hpThermalCircle);
      DeleteObject((HPEN)hpSpeedSlow);
      DeleteObject((HPEN)hpSpeedFast);
      DeleteObject((HPEN)hpStartFinishThin);
      DeleteObject((HPEN)hpMapScale);
	#endif
/*
#if OVERTARGET
      DeleteObject((HPEN)hpOvertarget);
#endif
*/
      DeleteObject((HPEN)hpThermalBand);
      DeleteObject((HPEN)hpThermalBandGlider);
      DeleteObject((HPEN)hpFinalGlideAbove);
      DeleteObject((HPEN)hpFinalGlideBelow);
      DeleteObject((HPEN)hpTerrainLine);
      DeleteObject((HPEN)hpTerrainLineBg);
      DeleteObject((HPEN)hpStartFinishThick);

      DeleteObject((HPEN)hpVisualGlideLightBlack); // VENTA3
      DeleteObject((HPEN)hpVisualGlideLightRed); // VENTA3
      DeleteObject((HPEN)hpVisualGlideHeavyRed); // VENTA3
      DeleteObject((HPEN)hpVisualGlideHeavyBlack); // VENTA3
      DeleteObject((HPEN)hpFinalGlideBelowLandable);

      #ifndef LKOBJ
      DeleteObject((HBRUSH)hbCompass);
      DeleteObject((HBRUSH)hbThermalBand);
      DeleteObject((HBRUSH)hbBestCruiseTrack);
      DeleteObject((HBRUSH)hbFinalGlideBelow);
      DeleteObject((HBRUSH)hbFinalGlideAbove);
      DeleteObject((HBRUSH)hbWind);
      #endif

      DeleteObject(hBmpMapScale);
      DeleteObject(hBmpCompassBg);
      #ifndef LKOBJ
      DeleteObject((HBRUSH)hbFinalGlideBelowLandable);
      DeleteObject(hBackgroundBrush);
      DeleteObject(hInvBackgroundBrush[0]); // 091110
      DeleteObject(hInvBackgroundBrush[1]); // 091110
      DeleteObject(hInvBackgroundBrush[2]); // 091110
      DeleteObject(hInvBackgroundBrush[3]); // 091110
      DeleteObject(hInvBackgroundBrush[4]); // 091110
      DeleteObject(hInvBackgroundBrush[5]); // 091110
      DeleteObject(hInvBackgroundBrush[6]); // 091110
      DeleteObject(hInvBackgroundBrush[7]); // 091110
      DeleteObject(hInvBackgroundBrush[8]); // 091110
      DeleteObject(hInvBackgroundBrush[9]); // 091110
      DeleteObject((HBRUSH)hBrushFlyingModeAbort);
      #endif
      DeleteObject(hBmpClimbeAbort);

      DeleteObject((HPEN)hpCompassBorder);

      DeleteObject(hBmpAirportReachable);
      DeleteObject(hBmpAirportUnReachable);
      DeleteObject(hBmpFieldReachable);
      DeleteObject(hBmpFieldUnReachable);
      DeleteObject(hBmpThermalSource);
      DeleteObject(hBmpTarget);
      DeleteObject(hBmpTeammatePosition);

      for(i=0;i<NUMAIRSPACEBRUSHES;i++)
	{
	  DeleteObject(hAirspaceBrushes[i]);
	  DeleteObject(hAirspaceBitmap[i]);
	}

      DeleteObject(hAboveTerrainBitmap);
      DeleteObject(hAboveTerrainBrush);

      for (i=0; i<AIRSPACECLASSCOUNT; i++) {
	DeleteObject(hAirspacePens[i]);
      }

      for (i=0; i<NUMSNAILCOLORS; i++) {
	DeleteObject(hSnailPens[i]);
      }
    
      PostQuitMessage (0);

      break;

    case WM_LBUTTONDBLCLK: 
      // VNT TODO: do not handle this event and remove CS_DBLCLKS in register class.
      // Only handle timed clicks in BUTTONDOWN with no proximity. 
      //
      // Attention please: a DBLCLK is followed by a simple BUTTONUP with NO buttondown.

      dwDownTime = GetTickCount();  
      XstartScreen = LOWORD(lParam); YstartScreen = HIWORD(lParam);

      // Careful! If you ignorenext, any event timed as double click of course will be affected.
      // and this means also fast clicking on bottombar!!
      // so first lets see if we are in lk8000 text screens.. 
      if (dontdrawthemap || (mapmode8000 && (YstartScreen >=navboxesY))) {  
		// do not ignore next, let buttonup get the signal
		break;
      }

      if (UseMapLock&&NewMap) {
        // ignorenext=true; 100318
	if (MapLock)
	{
		// ignorenext only when expecting a double click when map is locked! 
        	ignorenext=true; 
		if (DrawBottom) { 
	      		Y = HIWORD(lParam); 
		        // Unlock map only if double clicking on real map, not on navboxes!
			if ( Y < (MapWindow::MapRect.bottom-MapWindow::MapRect.top-BottomSize-NIBLSCALE(15)) ) {
				  dwDownTime= 0L;
				  DefocusInfoBox();
				  SetFocus(hWnd);
				  iboxtoclick=true; 
	  			  UnlockMap();
	  			  break;
			} 
		// old screen mode, dblclk on real map, unlock..
		} else {
			  dwDownTime= 0L;
			  DefocusInfoBox();
			  iboxtoclick=true; 
			  SetFocus(hWnd);
			  UnlockMap();
			  break;
		}

        }
      }

#if 100318
	// only when activemap (which means newmap is on) is off
      if (ActiveMap) ignorenext=true;
      if (NewMap) break;
#else

      ignorenext=true;
      // VENTA 090721 doubleclick no more used in lk8000
      if (NewMap) break;
#endif
      #ifndef DISABLEAUDIO
      if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
      #endif
      ShowMenu();
      break;

    case WM_LBUTTONDOWN:
      #ifdef DEBUG_DBLCLK
      DoStatusMessage(_T("BUTTONDOWN MapWindow")); 
      #endif
      DisplayTimeOut = 0;
      dwDownTime = GetTickCount();
      // After calling a menu, on exit as we touch the screen we fall back here
      if (ignorenext) {
#ifdef DEBUG_MAPINPUT
		DoStatusMessage(TEXT("DBG-055 BUTTONDOWN with ignorenext"));
#endif
		break;
      }
      XstartScreen = LOWORD(lParam); YstartScreen = HIWORD(lParam);
      // TODO VNT move Screen2LatLon in LBUTTONUP after making sure we really need Xstart and Ystart
      // so we save precious milliseconds waiting for BUTTONUP GetTickCount
      Screen2LatLon(XstartScreen, YstartScreen, Xstart, Ystart);

      LKevent=LKEVENT_NONE; // CHECK FIX TODO VENTA10  probably useless 090915

      LockTaskData();
      if (AATEnabled && TargetPan) {
	if (ValidTaskPoint(TargetPanIndex)) {
	  POINT tscreen;
	  LatLon2Screen(Task[TargetPanIndex].AATTargetLon, 
			Task[TargetPanIndex].AATTargetLat, 
			tscreen);
	  distance = isqrt4((long)((XstartScreen-tscreen.x)
				   *(XstartScreen-tscreen.x)+
				   (YstartScreen-tscreen.y)
				   *(YstartScreen-tscreen.y)))
	    /InfoBoxLayout::scale;

	  if (distance<10) {
	    TargetDrag_State = 1;
	  }
	}
      }
      UnlockTaskData();

      FullScreen();
      break;

    case WM_LBUTTONUP:
	if (ignorenext||dwDownTime==0) { 
#ifdef DEBUG_MAPINPUT
		if (ignorenext && (dwDownTime==0) )
			DoStatusMessage(_T("DBG-098 ignorenext&&dwDownTime0"));
		else if (dwDownTime==0)
			DoStatusMessage(_T("DBG-099 dwDownTime0"));
		else
			DoStatusMessage(_T("DBG-097 ignorenext"));
#endif
		ignorenext=false;
		break;
	}
      RECT rc;
      dwUpTime = GetTickCount(); 
      dwInterval=dwUpTime-dwDownTime;
      dwDownTime=0; // do it once forever

      GetClientRect(hWnd,&rc);

      X = LOWORD(lParam); Y = HIWORD(lParam); 

	gestY=YstartScreen-Y;
	gestX=XstartScreen-X;

	if (  dontdrawthemap && (Y <(rc.bottom-BottomSize)) ) { 

		gestDist=isqrt4((long)((gestX*gestX) + (gestY*gestY)));

		// GESTURE DETECTION
		// if gestX >0 gesture from right to left , gestX <0 gesture from left to right
		// if gestY >0 gesture from down to up ,    gestY <0 gesture from up to down
		if (gestDist<GestureSize) { 	// TODO FIX tune this GestureSize, maybe 100?
			gestDir=LKGESTURE_NONE;
		} else {
			// horizontal includes also perfectly diagonal gestures
			if (abs(gestX) >= abs(gestY) ) {
				// we use LKGESTURE definition, but they have nothing to do with those used in other part of source code
				if (gestX>0)
					gestDir=IphoneGestures?LKGESTURE_RIGHT:LKGESTURE_LEFT;
				else
					gestDir=IphoneGestures?LKGESTURE_LEFT:LKGESTURE_RIGHT;
			} else { 
				if (gestY>0)
					gestDir=IphoneGestures?LKGESTURE_DOWN:LKGESTURE_UP;
				else
					gestDir=IphoneGestures?LKGESTURE_UP:LKGESTURE_DOWN;
			}
		}
		// end dontdrawthemap and inside mapscreen looking for a gesture
	} 

      // Process Active Icons
	if (doinit) {
		#include "./LKinclude_menusize.cpp"
		doinit=false;
	}
      if (NewMap)  {

	short topicon;
	if (DrawBottom) topicon=MapRect.bottom-MapRect.top-BottomSize-14; // 100305
		else
			topicon=MapRect.bottom-MapRect.top-AIRCRAFTMENUSIZE;

if ( (X > ((MapRect.right-MapRect.left)- AIRCRAFTMENUSIZE)) &&
   (Y > topicon) ) {

	/*
	 * Available for future usage: short click on aircraft icon.
	 * Remember there's already a normal click and a long click on the same icon!
	   090720 short click replacing doubleclick forever!
	 */
	
		// short click on aircraft icon
		//
		if ( dwInterval <= (DOUBLECLICKINTERVAL)) {
goto_menu:
			#ifndef DISABLEAUDIO
                	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
			ShowMenu();
			break;
		} else
		// Long click on aircraft icon, toggle thermal mode
		//
		if ( dwInterval >=VKLONGCLICK) { // in Defines.h
			if (DisplayMode == dmCircling) {
				UserForceDisplayMode=dmCruise;
				#ifndef DISABLEAUDIO
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
				#endif
				break;
			} else 
			if (DisplayMode == dmCruise) {
				UserForceDisplayMode=dmNone;
				#ifndef DISABLEAUDIO
				if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
				#endif
				break;
			}
		} else {
			// We are here in any case only when dwInterval is <VKLONGCLICK
			if (dwInterval >=(unsigned)CustomKeyTime) {
				if (!CustomKeyHandler(CKI_BOTTOMICON)) goto goto_menu;
			}
			break;
		}

      // end aircraft icon check				
      } 
	if (mapmode8000) { 
	if ( (X <= (MapRect.left + COMPASSMENUSIZE)) && (Y <= (MapRect.top+COMPASSMENUSIZE)) ) {
		if (!CustomKeyHandler(CKI_TOPLEFT)) {
			#ifndef DISABLEAUDIO
         		 if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
			wParam = 0x26; 
			// we can have problems if fast double clicks?
			// zoom in
			InputEvents::processKey(wParam);
			return TRUE;
		}
		MapWindow::RefreshMap();
		break;
	}

      if (ISPARAGLIDER) {
	// Use the compass to pullup UTM informations to paragliders
	if ( (X > ((MapRect.right-MapRect.left)- COMPASSMENUSIZE)) && (Y <= MapRect.top+COMPASSMENUSIZE) ) {

		if ((dwInterval >= DOUBLECLICKINTERVAL) ) {

extern void LatLonToUtmWGS84 (int& utmXZone, char& utmYZone, double& easting, double& northing, double lat, double lon);

			// if we are running a real task, with gates, and we could still start
			// if only 1 time gate, and we passed valid start, no reason to resettask
			int acceptreset=2;
			if (PGNumberOfGates==1) acceptreset=1;
			if (UseGates() && ValidTaskPoint(1) && ActiveWayPoint<acceptreset) { // 100507 101110
				InputEvents::eventResetTask(_T(""));
			} else {
			int utmzone; char utmchar;
			double easting, northing;
			TCHAR mbuf[80];
			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
			LatLonToUtmWGS84 ( utmzone, utmchar, easting, northing, GPS_INFO.Latitude, GPS_INFO.Longitude );
			_stprintf(mbuf,_T("UTM %d%c  %.0f  %.0f"), utmzone, utmchar, easting, northing);
			Message::Lock(); // 091211
			Message::AddMessage(60000, 1, mbuf);
			TCHAR sLongitude[16];
			TCHAR sLatitude[16];
			Units::LongitudeToString(GPS_INFO.Longitude, sLongitude, sizeof(sLongitude)-1);
			Units::LatitudeToString(GPS_INFO.Latitude, sLatitude, sizeof(sLatitude)-1);
			_stprintf(mbuf,_T("%s %s"), sLatitude, sLongitude);
			Message::AddMessage(60000, 1, mbuf);
			Message::Unlock();

			break;

			} // real UTM, no reset task
		}

	} // End compass icon check
      } // PARAGLIDERs special buttons
	// else not a paraglider key, process it for gliders
	else { 
		if ( (X > ((MapRect.right-MapRect.left)- COMPASSMENUSIZE)) && (Y <= MapRect.top+COMPASSMENUSIZE) ) {
			if (!CustomKeyHandler(CKI_TOPRIGHT)) {
				#ifndef DISABLEAUDIO
         			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
				#endif
				wParam = 0x26; 
				// we can have problems if fast double clicks?
				InputEvents::processKey(wParam);
				return TRUE;
			}
			MapWindow::RefreshMap();
			break;
		}
		// if not topright, continue
	}
	// do all of this only if !dontdrawthemap = we are in fullscreen and not PAN etc.
	// indentation is wrong here
	} 


	// "fast virtual keys" are handled locally and not passed to event handler.
	// they are processed even when virtual keys are disabled, because they concern special lk8000 menus.

	// First case: for mapspacemodes we manage gestures as well
	if (dontdrawthemap) {

		if ( gestDir == LKGESTURE_UP) {
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_UP);
			break;
		}
		if ( gestDir == LKGESTURE_DOWN) {
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_DOWN);
			break;
		}
		if ( gestDir == LKGESTURE_LEFT) {
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_LEFT);
			break;
		}
		if ( gestDir == LKGESTURE_RIGHT) {
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_RIGHT);
			break;
		}


		// We are here when lk8000, and NO moving map displayed: virtual enter, virtual up/down, or 
		// navbox operations including center key.
		wParam=ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
#ifdef DEBUG_MAPINPUT
		DoStatusMessage(_T("DBG-035 navboxes")); 
#endif
		// we could use a single ProcessVirtual for all above, and check that wParam on return
		// is really correct for gestures as well... since we do not want to go to wirth with gestures!
		if (wParam!=0) {
			DoStatusMessage(_T("ERR-033 Invalid Virtual Key")); 
			break;
		}
		break;

	}
      
	// if clicking on navboxes, process fast virtual keys
	// maybe check LK8000 active?
	// This point is selected when in MapSpaceMode==MSM_MAP, i.e. lk8000 with moving map on.
	if (  DrawBottom && IsMapFullScreen() && (Y >= (rc.bottom-BottomSize)) && !MapWindow::EnablePan ) {
		wParam=ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
#ifdef DEBUG_MAPINPUT
		DoStatusMessage(_T("DBG-034 navboxes")); 
#endif
		if (wParam!=0) {
			DoStatusMessage(_T("ERR-034 Invalid Virtual Key")); 
			break;
		}
		break;
	}



      } // end newmap preliminar checks

      if(NewMap&&UseMapLock&&MapLock&&!EnablePan&&!(dontdrawthemap)) 
      {
		// With LOCKED map...
		// When you single click on the map, here you come.
		// When you press double click to release lock, you fall here, also.

	      if ((VirtualKeys==(VirtualKeys_t)vkEnabled) && (dwInterval>= DOUBLECLICKINTERVAL)) {   
			wParam=ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
			if (wParam==0) {
				// Here we fall when you press for example long center map or do a gesture
				// DoStatusMessage(_T("ERR-035 Invalid Virtual Key"));
				break;
			}
			// Otherwise its a vk up/down/enter and must be handled, passing vk code down
			goto Wirth; 
	      }

	  // while locked, any keypress on the map which is not a virtual key will unfocus infoboxes
	  // but first check if it was already unfocused so you will not play a click 
	  if (InfoFocus>=0) {
	  	DefocusInfoBox();
	  	SetFocus(hWnd);
		#ifndef DISABLEAUDIO
         	 if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
		#endif
		 iboxtoclick=true; 
		 // DoStatusMessage(_T("Map is locked, defocus ibox")); 
	  } else {
		// newmap on, maplock on, NO VK, special case 
		if (  DrawBottom && IsMapFullScreen() && (Y >= (rc.bottom-BottomSize)) ) {
			goto Escamotage; 
		}
		// DoStatusMessage(_T("Map is locked, skipping")); 
	  }
	  break;
      }

      if (dwInterval == 0) {
		break; // should be impossible
      }

	// we need to calculate it here only if needed
	if (gestDist>=0)
		distance = gestDist /InfoBoxLayout::scale;
	else
		distance = isqrt4((long)((XstartScreen-X)*(XstartScreen-X)+ (YstartScreen-Y)*(YstartScreen-Y))) /InfoBoxLayout::scale;

	#ifdef DEBUG_VIRTUALKEYS
	TCHAR buf[80]; char sbuf[80];
	sprintf(sbuf,"%.0f",distance);
	wsprintf(buf,_T("XY=%d,%d dist=%S Up=%ld Down=%ld Int=%ld"),X,Y,sbuf,dwUpTime,dwDownTime,dwInterval);
        DoStatusMessage(buf);
	#endif

	// Handling double click passthrough
	// Caution, timed clicks from PC with a mouse are different from real touchscreen devices

      // On PC a single click is around 80ms, and a doubleclick is around 150ms. 
      // CHECK TODO FIX if only for NewMap when enabled.. VK work only with new map...so no need?

	// This is called when long press in center map i.e. for inverting colors, 
	// and for Virtual keys zoom in/out
      if ((VirtualKeys==(VirtualKeys_t)vkEnabled) && distance<50 && (dwInterval>= DOUBLECLICKINTERVAL)) { 
		wParam=ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
		if (wParam==0) {
			#ifdef DEBUG_VIRTUALKEYS
			DoStatusMessage(_T("DBG-095 invalid Virtual Key!")); 
			#endif
			break;
		}
		//break; // TESTFIX 090930
		goto Wirth; 
      }


      // Process faster clicks here and no precision, but let DBLCLK pass through
      // VK are used in the bottom line in this case, forced on for this situation.
      if (  DrawBottom && IsMapFullScreen() && (Y >= (rc.bottom-BottomSize)) ) {
Escamotage:
		// DoStatusMessage(_T("Click on hidden map ignored")); 

		// do not process virtual key if it is timed as a DBLCLK
		// we want users to get used to double clicking only on infoboxes
		// and avoid triggering unwanted waypoints details
		if (dwInterval >= ( (DOUBLECLICKINTERVAL/2-30) )) { // fast dblclk required here.
			#ifdef DEBUG_VIRTUALKEYS // 100320
			wParam=ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
			if (wParam==0) {
				DoStatusMessage(_T("P00 Virtual Key 0")); 
				break;
			}
			#else
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
			#endif
			break; 
		}
		// do not process click on the underneath window
		break;
      }
      if (dontdrawthemap) break;

      Screen2LatLon(X, Y, Xlat, Ylat);
    
      if (AATEnabled && TargetPan && (TargetDrag_State>0)) {
	LockTaskData();
	TargetDrag_State = 2;
	TargetDrag_Latitude = Ylat;
	TargetDrag_Longitude = Xlat;
	UnlockTaskData();
	break;
      } else if (!TargetPan && EnablePan && (distance>36)) { // TODO FIX should be IBLSCALE 36 instead?
	PanLongitude += Xstart-Xlat;
	PanLatitude  += Ystart-Ylat;
	RefreshMap();
	// disable picking when in pan mode
	break; 
      } 
#if NOSIM
      else if (SIMMODE && (!TargetPan && (distance>NIBLSCALE(36)))) {
	// This drag moves the aircraft (changes speed and direction)
	double newbearing;
	double oldbearing = GPS_INFO.TrackBearing;
	double minspeed = 1.1*GlidePolar::Vminsink;
	DistanceBearing(Ystart, Xstart, Ylat, Xlat, NULL, &newbearing);
	if ((fabs(AngleLimit180(newbearing-oldbearing))<30) || (GPS_INFO.Speed<minspeed)) {
		// sink we shall be sinking, lets raise the altitude when using old simulator interface
		if ( (CALCULATED_INFO.TerrainValid) && ( CALCULATED_INFO.AltitudeAGL <0 ))
			GPS_INFO.Altitude=CALCULATED_INFO.TerrainAlt;
		GPS_INFO.Altitude+=200;
		GPS_INFO.Speed = min(100.0,max(minspeed,distance/3));
	} 
	GPS_INFO.TrackBearing = newbearing;
	TriggerGPSUpdate();
      
	break;
      }

#else
#ifdef _SIM_
      else if (!TargetPan && (distance>NIBLSCALE(36))) {
	// This drag moves the aircraft (changes speed and direction)
	double newbearing;
	double oldbearing = GPS_INFO.TrackBearing;
	double minspeed = 1.1*GlidePolar::Vminsink;
	DistanceBearing(Ystart, Xstart, Ylat, Xlat, NULL, &newbearing);
	if ((fabs(AngleLimit180(newbearing-oldbearing))<30) || (GPS_INFO.Speed<minspeed)) {
		GPS_INFO.Speed = min(100.0,max(minspeed,distance/3));
	} 
	GPS_INFO.TrackBearing = newbearing;
	TriggerGPSUpdate();
      
	break;
      }
#endif
#endif
      if (!TargetPan) {
		// if map is locked and we are here, then if infobox are under focus accept the click
		// as an order to defocus. Otherwise since we are under lock condition we simply
		// ignore the click and break out.
		//
		if (NewMap&&UseMapLock&&MapLock) { 
			if (InfoFocus>=0) {
				// DoStatusMessage(_T("Map is locked, defocus ibox")); 
				DefocusInfoBox();
				SetFocus(hWnd);
				#ifndef DISABLEAUDIO
				 if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
				#endif
				iboxtoclick=true; 
			} else {
				// ignore click
				// DoStatusMessage(_T("PAN map is locked, skipping")); 
			}
			break;
		}
		//
		// We need to defocus infoboxes on demand here.  
		// Probably should be a good idea to use it also for standard old map with no VK
		// We do it also for old standard map with no VK.
		//
		if ( InfoFocus>=0) { // 
			// DoStatusMessage(_T("Defocus ibox")); 
			DefocusInfoBox();
			SetFocus(hWnd);
			#ifndef DISABLEAUDIO
			 if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif
			iboxtoclick=true; 
			break;
		}
		
		//
		// Finally process normally a click on the moving map.
		// Virtual keys have been processed earlier, so we are now looking for a map selection.
		// However, timings are different if virtual keys are enabled, for this operation.
		//
		if (VirtualKeys==(VirtualKeys_t)vkEnabled) {
			// Shorter the time needed to trigger a WP select, solving also the annoying problem
			// of unwanted wp selection while double clicking too slow!
			// And at the same time let this action pass transparently to virtual keys.
			//
			if(dwInterval < VKSHORTCLICK) { //100ms is NOT  enough for a short click since GetTickCount is OEM custom!
#if 100318 
			if (ActiveMap) {
				if (Event_NearestWaypointDetails(Xstart, Ystart, 500*MapScale, false)) {
					break;
				}
			} else {
savecodesize1:
			int yup, ydown, ytmp;
			ytmp=(int)((MapWindow::MapRect.bottom-MapWindow::MapRect.top-BottomSize)/2);
			yup=ytmp+MapWindow::MapRect.top;
                	ydown=MapWindow::MapRect.bottom-BottomSize-ytmp;

			if (Y<yup) {
				// pg UP = zoom in
				wParam = 0x26;
			} else {
				if (Y>ydown) {
					// pg DOWN = zoom out
					wParam = 0x28;
				} 
				else {
					// process center key, do nothing 
					break;
				}
			}
			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
			#endif

			InputEvents::processKey(wParam);
			dwDownTime= 0L;
			return TRUE; 
			}
#else
				if (Event_NearestWaypointDetails(Xstart, Ystart, 500*MapScale, false)) {
					break;
				}
#endif
			} else {
				// in pan mode and SIM mode, click to center current position
				#if NOSIM
				if (SIMMODE) {
					if (EnablePan) {
						// match only center screen
						if (  (abs(X-((rc.left+rc.right)/2)) <NIBLSCALE(12)) && 
						      (abs(Y-((rc.bottom+rc.top)/2)) <NIBLSCALE(12)) ) {
							DoStatusMessage(_T("Current position updated"));
							GPS_INFO.Latitude=PanLatitude;
							GPS_INFO.Longitude=PanLongitude;
							break;
						}
					}
				}
				#else
				#if _SIM_
				if (EnablePan) {
					// match only center screen
					if (  (abs(X-((rc.left+rc.right)/2)) <NIBLSCALE(5)) && 
					      (abs(Y-((rc.bottom+rc.top)/2)) <NIBLSCALE(5)) ) {
						DoStatusMessage(_T("Current position updated"));
						GPS_INFO.Latitude=PanLatitude;
						GPS_INFO.Longitude=PanLongitude;
						break;
					}
				}
				#endif
				#endif
				// If we are here,  (DCI/2)+30 < dwDownTime < DOUBLECLICKINTERVAL
				// SO this is a tight interval. DCI should not be set too low. See Defines.h
				// NO: VKSHORTCLICK-DCI  150-350 ?
				if (!OnAirSpace) break; // 100119
				if (Event_InteriorAirspaceDetails(Xstart, Ystart)) {
					break;
				}
			}
		} else {
			if(dwInterval < AIRSPACECLICK) { // original and untouched interval
#if 100318
				if (ActiveMap) {
					if (Event_NearestWaypointDetails(Xstart, Ystart, 500*MapScale, false)) {
						break;
					}
				} else
					goto savecodesize1;
#else
				if (Event_NearestWaypointDetails(Xstart, Ystart, 500*MapScale, false)) {
					break;
				}
#endif
			} else {
				#if NOSIM
				if (SIMMODE) {
					if (EnablePan) {
						// match only center screen
						if (  (abs(X-((rc.left+rc.right)/2)) <NIBLSCALE(5)) && 
						      (abs(Y-((rc.bottom+rc.top)/2)) <NIBLSCALE(5)) ) {
							DoStatusMessage(gettext(TEXT("Current position updated")));
							GPS_INFO.Latitude=PanLatitude;
							GPS_INFO.Longitude=PanLongitude;
							break;
						}
					}
				}
				#else
				#if _SIM_
				if (EnablePan) {
					// match only center screen
					if (  (abs(X-((rc.left+rc.right)/2)) <NIBLSCALE(5)) && 
					      (abs(Y-((rc.bottom+rc.top)/2)) <NIBLSCALE(5)) ) {
						DoStatusMessage(_T("Current position updated"));
						GPS_INFO.Latitude=PanLatitude;
						GPS_INFO.Longitude=PanLongitude;
						break;
					}
				}
				#endif
				#endif
				if (!OnAirSpace) break; // 100119
				if (Event_InteriorAirspaceDetails(Xstart, Ystart)) {
					break;
				}
			}
		} // VK enabled
      } // !TargetPan

      break;
      /*
	case WM_PAINT:
	if ((hWnd == hWndMapWindow) && (ProgramStarted==3)) {
	//    RequestFastRefresh();
	return TRUE;
	} else {
	break;
	}
      */




#if defined(GNAV) || defined(PNA) // VENTA FIXED PNA SCROLL WHEEL 
    case WM_KEYDOWN: // JMW was keyup
#else
    case WM_KEYUP: // JMW was keyup
#endif
      // VENTA-TODO careful here, keyup no more trapped for PNA. 
      // Forbidden usage of keypress timing.

#ifdef VENTA_DEBUG_KEY
      TCHAR ventabuffer[80];
      wsprintf(ventabuffer,TEXT("WMKEY uMsg=%d wParam=%ld lParam=%ld"), uMsg, wParam,lParam);
      DoStatusMessage(ventabuffer);
#endif
      DisplayTimeOut = 0;
      InterfaceTimeoutReset();

#if defined(PNA) // VENTA-ADDON HARDWARE KEYS TRANSCODING

      if ( GlobalModelType == MODELTYPE_PNA_HP31X )
	{
	  //		if (wParam == 0x7b) wParam=0xc1;  // VK_APP1 	
	  if (wParam == 0x7b) wParam=0x1b;  // VK_ESCAPE
	  //		if (wParam == 0x7b) wParam=0x27;  // VK_RIGHT
	  //		if (wParam == 0x7b) wParam=0x25;  // VK_LEFT
	} else
	if ( GlobalModelType == MODELTYPE_PNA_PN6000 )
	  {
	    switch(wParam) {
	    case 0x79:					// Upper Silver key short press
	      wParam = 0xc1;	// F10 -> APP1
	      break;
	    case 0x7b:					// Lower Silver key short press
	      wParam = 0xc2;	// F12 -> APP2
	      break;
	    case 0x72:					// Back key plus
	      wParam = 0xc3;	// F3  -> APP3
	      break;
	    case 0x71:					// Back key minus
	      wParam = 0xc4;	// F2  -> APP4
	      break;
	    case 0x7a:					// Upper silver key LONG press
	      wParam = 0x70;	// F11 -> F1
	      break;
	    case 0x7c:					// Lower silver key LONG press
	      wParam = 0x71;	// F13 -> F2
	      break;
	    }
	  }
      if ( GlobalModelType == MODELTYPE_PNA_NOKIA_500 )
	{
	  switch(wParam) {
	  case 0xc1:				
	    wParam = 0x0d;	// middle key = enter
	    break;
	  case 0xc5:				
	    wParam = 0x26;	// + key = pg Up
	    break;
	  case 0xc6:				
	    wParam = 0x28;	// - key = pg Down
	    break;
	  }
	}
      if ( GlobalModelType == MODELTYPE_PNA_MEDION_P5 )
	{
	  switch(wParam) {
	  case 0x79:				
	    wParam = 0x0d;	// middle key = enter
	    break;
	  case 0x75:				
	    wParam = 0x26;	// + key = pg Up
	    break;
	  case 0x76:				
	    wParam = 0x28;	// - key = pg Down
	    break;
	  }
	}

#endif


#if defined(GNAV)
      if (wParam == 0xF5){

	if (MessageBoxX(hWnd,
			TEXT("Shutdown?"),
			TEXT("Altair system message"),
			MB_YESNO|MB_ICONQUESTION) == IDYES) {

	  SendMessage(hWnd, 
		      WM_ACTIVATE, 
		      MAKEWPARAM(WA_INACTIVE, 0), 
		      (LPARAM)hWndMainWindow);
	  SendMessage (hWndMainWindow, WM_CLOSE, 0, 0);
	}

	break;

      }
#endif
Wirth:
#ifdef DEBUG_MAPINPUT
	DoStatusMessage(_T("Wirth"));
#endif
      dwDownTime= 0L;

      if (!DialogActive) { // JMW prevent keys being trapped if dialog is active
	if (InputEvents::processKey(wParam)) {
	  // TODO code: change to debugging DoStatusMessage(TEXT("Event in default"));
	}
	// XXX Should we only do this if it IS processed above ?
	dwDownTime= 0L;
	return TRUE; // don't go to default handler
      } else {
	// TODO code: debugging DoStatusMessage(TEXT("Event in dialog"));
	if (InputEvents::processKey(wParam)) {
	}
	dwDownTime= 0L;
	return TRUE; // don't go to default handler
      }
      // break; unreachable!
    }

  return (DefWindowProc (hWnd, uMsg, wParam, lParam));
}


void MapWindow::ModifyMapScale(void) {
  // limit zoomed in so doesn't reach silly levels
  RequestMapScale = LimitMapScale(RequestMapScale); // FIX VENTA remove limit
  MapScaleOverDistanceModify = RequestMapScale/DISTANCEMODIFY;
  ResMapScaleOverDistanceModify = 
    GetMapResolutionFactor()/MapScaleOverDistanceModify;
  DrawScale = MapScaleOverDistanceModify;
  DrawScale = DrawScale/111194;
  DrawScale = GetMapResolutionFactor()/DrawScale;
  InvDrawScale = 1.0/DrawScale;
  MapScale = RequestMapScale;
}


bool MapWindow::isTargetPan(void) {
  return TargetPan;
}


void MapWindow::UpdateMapScale()
{
  static int AutoMapScaleWaypointIndex = -1;
  static double StartingAutoMapScale=0.0;
  double AutoZoomFactor;

  bool useraskedforchange = false;

  // if there is user intervention in the scale
  if(MapScale != RequestMapScale) {
	ModifyMapScale();
	useraskedforchange = true;
  }

  double wpd;
  if (TargetPan) {
	wpd = TargetZoomDistance;
  } else {
	wpd = DerivedDrawInfo.ZoomDistance; 
  }
  if (TargetPan) {
	// set scale exactly so that waypoint distance is the zoom factor across the screen
	RequestMapScale = LimitMapScale(wpd *DISTANCEMODIFY/ 4.0);
	ModifyMapScale();
	return;
  } 
  
  if (AutoZoom) {
	if(wpd > 0) {
      
		if(
		   (((DisplayOrientation == NORTHTRACK)
		     &&(DisplayMode != dmCircling))
		    ||(DisplayOrientation == NORTHUP) 
		    ||(DisplayOrientation == NORTHSMART)  // 100419
		    || 
		    (((DisplayOrientation == NORTHCIRCLE) 
		      || (DisplayOrientation == TRACKCIRCLE)) 
		     && (DisplayMode == dmCircling) ))
		   && !TargetPan
		   )
		{
	 		AutoZoomFactor = 2.5;
		} else {
			AutoZoomFactor = 4;
		}
      
		if(
		  (wpd < ( AutoZoomFactor * MapScaleOverDistanceModify))
		  || 
	  	  (StartingAutoMapScale==0.0)) 
		{
			// waypoint is too close, so zoom in
			// OR just turned waypoint

			// this is the first time this waypoint has gotten close,
			// so save original map scale

			if (StartingAutoMapScale==0.0) {
				StartingAutoMapScale = MapScale;
			}
			else { // 101007 BUGFIX XCSOAR

				// set scale exactly so that waypoint distance is the zoom factor across the screen
				RequestMapScale = LimitMapScale(wpd *DISTANCEMODIFY/ AutoZoomFactor);
				if (MapScale != RequestMapScale) { // do not loose time if same scale
					ModifyMapScale();
				}
			}
		} else {
			if (useraskedforchange) {
				// user asked for a zoom change and it was achieved, so reset starting map scale
			}

		}
      } // wpd>0
  } else { // !AutoZoom
    
	// reset starting map scale for auto zoom if momentarily switch
	// off autozoom
	// StartingAutoMapScale = RequestMapScale;
	StartingAutoMapScale=0; //@@ 101007 BUGFIX we need to reset it to let current mapscale be used on next azoom on
  }

  if (TargetPan) {
	return;
  }

  LockTaskData();  // protect from external task changes
#ifdef HAVEEXCEPTIONS
  __try{
#endif
    // if we aren't looking at a waypoint, see if we are now
    if (AutoMapScaleWaypointIndex == -1) {
	if (ValidTaskPoint(ActiveWayPoint)) {
		AutoMapScaleWaypointIndex = Task[ActiveWayPoint].Index;
	}
    }

    if (ValidTaskPoint(ActiveWayPoint)) {

	// if the current zoom focused waypoint has changed...
	if (AutoMapScaleWaypointIndex != Task[ActiveWayPoint].Index) {

		AutoMapScaleWaypointIndex = Task[ActiveWayPoint].Index;

		// zoom back out to where we were before
		if (StartingAutoMapScale> 0.0) {
			RequestMapScale = StartingAutoMapScale;
		}

		// reset search for new starting zoom level
		StartingAutoMapScale = 0.0;
	}

    }
#ifdef HAVEEXCEPTIONS
  }__finally
#endif
     {
       UnlockTaskData();
     }

}


bool MapWindow::GliderCenter=false;


void MapWindow::CalculateOrientationNormal(void) {
  double trackbearing = DrawInfo.TrackBearing;
  //  trackbearing = DerivedDrawInfo.NextTrackBearing;

  if( (DisplayOrientation == NORTHUP) 
      ||
      ((DisplayOrientation == NORTHTRACK)
       &&(DisplayMode != dmCircling))
	|| (DisplayOrientation == NORTHSMART)  // 100419
      || 
      (
       ((DisplayOrientation == NORTHCIRCLE)
        ||(DisplayOrientation==TRACKCIRCLE))
       && (DisplayMode == dmCircling) )
      ) {
#ifndef NEWMOVEICON
    GliderCenter = true;
#else
	if (DisplayMode == dmCircling)
		GliderCenter=true;
	else
		GliderCenter=false;
#endif
    
    if (DisplayOrientation == TRACKCIRCLE) {
      DisplayAngle = DerivedDrawInfo.WaypointBearing;
      DisplayAircraftAngle = trackbearing-DisplayAngle;
    } else {
      DisplayAngle = 0.0;
      DisplayAircraftAngle = trackbearing;
    }
  } else {
    // normal, glider forward
    GliderCenter = false;
    DisplayAngle = trackbearing;
    DisplayAircraftAngle = 0.0;    
  }
  DisplayAngle = AngleLimit360(DisplayAngle);
  DisplayAircraftAngle = AngleLimit360(DisplayAircraftAngle);
}


void MapWindow::CalculateOrientationTargetPan(void) {
  // Target pan mode, show track up when looking at current task point,
  // otherwise north up.  If circling, orient towards target.
  GliderCenter = true;
  if ((ActiveWayPoint==TargetPanIndex)
      &&(DisplayOrientation != NORTHUP)
      &&(DisplayOrientation != NORTHSMART) // 100419
      &&(DisplayOrientation != NORTHTRACK)
      )    {
    if (DisplayMode == dmCircling) {
      // target-up
      DisplayAngle = DerivedDrawInfo.WaypointBearing;
      DisplayAircraftAngle = 
        DrawInfo.TrackBearing-DisplayAngle;
    } else {
      // track up
      DisplayAngle = DrawInfo.TrackBearing;
      DisplayAircraftAngle = 0.0;
    }
  } else {
    // North up
    DisplayAngle = 0.0;
    DisplayAircraftAngle = DrawInfo.TrackBearing;
  }
 
}


void MapWindow::CalculateOrigin(const RECT rc, POINT *Orig)
{
  if (TargetPan) {
	CalculateOrientationTargetPan();
  } else {
	CalculateOrientationNormal();
  }
  
  if ( EnablePan || DisplayMode==dmCircling) {
	Orig->x = (rc.left + rc.right)/2;
	Orig->y = (rc.bottom + rc.top)/2;
  } else {
	#if NEWMOVEICON
	#if 100415
	// automagic northup smart
	if (DisplayOrientation == NORTHSMART) { 
		double trackbearing = DrawInfo.TrackBearing;
		int middleXY,spanxy;
		if (ScreenLandscape) {
			middleXY=((rc.bottom-BottomSize)+rc.top)/2;
			spanxy=NIBLSCALE(50);
			Orig->y= middleXY + (int)(spanxy*fastcosine(trackbearing));
			// This was moving too much the map!
			// spanx=NIBLSCALE(40);
			// Orig->x= middleX - (int)(spanx*fastsine(trackbearing));
			Orig->x = (rc.left + rc.right)/2;
		} else {
			middleXY=(rc.left+rc.right)/2;
			spanxy=NIBLSCALE(50);
			Orig->x= middleXY - (int)(spanxy*fastsine(trackbearing));
			Orig->y = ((rc.bottom-BottomSize) + rc.top)/2;
		}
/* REMOVE

		//double spany=(rc.bottom-BottomSize)-NIBLSCALE(40)- middleY;
		if (InfoBoxLayout::landscape) {
			spany=NIBLSCALE(50);
			Orig->y= middleY + (int)(spany*fastcosine(trackbearing));
			Orig->x = (rc.left + rc.right)/2;
		} else { 
			spanx=NIBLSCALE(40);
			Orig->x= middleX + (int)(spany*fastcosine(trackbearing));
			Orig->y = ((rc.bottom-BottomSize) + rc.top)/2;
		}
*/
	} else {
/*
		if (DisplayOrientation == NORTHUP) { 
			Orig->x = (rc.left + rc.right)/2;
			Orig->y = (rc.bottom + rc.top)/2;
		} else {
			Orig->x = ((rc.right - rc.left )*GliderScreenPositionX/100)+rc.left;
			Orig->y = ((rc.top - rc.bottom )*GliderScreenPositionY/100)+rc.bottom;
		}
*/
		// 100924 if we are in north up autorient, position the glider in middle screen
		if ((MapScale*1.4) >= AutoOrientScale) {
			Orig->x = (rc.left + rc.right)/2;
			Orig->y=((rc.bottom-BottomSize)+rc.top)/2;
		} else {
			// else do it normally using configuration
			Orig->x = ((rc.right - rc.left )*GliderScreenPositionX/100)+rc.left;
			Orig->y = ((rc.top - rc.bottom )*GliderScreenPositionY/100)+rc.bottom;
		}
	}
	#else // no 100415
		Orig->x = ((rc.right - rc.left )*GliderScreenPositionX/100)+rc.left;
		Orig->y = ((rc.top - rc.bottom )*GliderScreenPositionY/100)+rc.bottom;
	#endif
	#else
	Orig->x = (rc.left + rc.right)/2;
	Orig->y = ((rc.top - rc.bottom )*GliderScreenPosition/100)+rc.bottom;
	#endif
  }
}


bool MapWindow::RenderTimeAvailable() {
  DWORD fpsTime = ::GetTickCount();
  if (MapDirty) return false;

  if (fpsTime-timestamp_newdata<700) { 
    // it's been less than 700 ms since last data
    // was posted
    return true;
  } else {
    return false;
  }
}


void MapWindow::DrawThermalEstimate(HDC hdc, const RECT rc) {
  POINT screen;
  HPEN oldPen;
  #if NOSIM
  static short counter=0;
  #else
  #ifdef _SIM_
  static short counter=0;
  #endif
  #endif
  if (!EnableThermalLocator) return;

  if (DisplayMode == dmCircling) {
	if (DerivedDrawInfo.ThermalEstimate_R>0) {
		LatLon2Screen(DerivedDrawInfo.ThermalEstimate_Longitude, DerivedDrawInfo.ThermalEstimate_Latitude, screen);
		DrawBitmapIn(hdc, screen, hBmpThermalSource);

		SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
		oldPen=(HPEN)SelectObject(hdc, hpThermalCircle); // white
		if (ISPARAGLIDER) {
			Circle(hdc, screen.x, screen.y, (int)(50*ResMapScaleOverDistanceModify), rc); //@@ 101101
		} else {
			Circle(hdc, screen.x, screen.y, (int)(100*ResMapScaleOverDistanceModify), rc); //@@ 101101
			SelectObject(hdc, hpAircraftBorder); 
			Circle(hdc, screen.x, screen.y, (int)(100*ResMapScaleOverDistanceModify)+NIBLSCALE(2), rc); //@@ 101101
			Circle(hdc, screen.x, screen.y, (int)(100*ResMapScaleOverDistanceModify), rc); //@@ 101101
		}
		#if NOSIM
		if (SIMMODE && (ThLatitude>1 && ThLongitude>1)) { // there's a thermal to show
			if ((counter==5 || counter==6|| counter==7)) {
				LatLon2Screen(ThLongitude, ThLatitude, screen);
				SelectObject(hdc, hSnailPens[7]);  
				Circle(hdc, screen.x, screen.y, (int)(ThermalRadius*ResMapScaleOverDistanceModify), rc); 
				SelectObject(hdc, hSnailPens[7]); 
				Circle(hdc, screen.x, screen.y, (int)((ThermalRadius+SinkRadius)*ResMapScaleOverDistanceModify), rc); 
			}
			if (++counter>=60) counter=0;
		}
		#else
		#ifdef _SIM_	//@@ 101104
		if (ThLatitude>1 && ThLongitude>1) { // there's a thermal to show
			if (counter==5 || counter==6|| counter==7) {
				LatLon2Screen(ThLongitude, ThLatitude, screen);
				SelectObject(hdc, hSnailPens[7]);  
				Circle(hdc, screen.x, screen.y, (int)(ThermalRadius*ResMapScaleOverDistanceModify), rc); 
				SelectObject(hdc, hSnailPens[7]); 
				Circle(hdc, screen.x, screen.y, (int)((ThermalRadius+SinkRadius)*ResMapScaleOverDistanceModify), rc); 
			}
			if (++counter>=30) counter=0;
		}
		#endif
		#endif
		SelectObject(hdc,oldPen);
	}
  } else {
	if (MapScale <= 4) {
		for (int i=0; i<MAX_THERMAL_SOURCES; i++) {
			if (DerivedDrawInfo.ThermalSources[i].Visible) {
				DrawBitmapIn(hdc, DerivedDrawInfo.ThermalSources[i].Screen, hBmpThermalSource);
			}
		}
	}
  }
}


void MapWindow::RenderMapWindowBg(HDC hdc, const RECT rc,
				  const POINT &Orig,
				  const POINT &Orig_Aircraft)
{
  HFONT hfOld;


  static bool alreadyTriggered=false;
  //static double lastTrigger=0;
  static double savedMapScale=0;
  static double savedRequestMapScale=0;
  static double savedMapScaleOverDistanceModify=0;

  // do slow calculations before clearing the screen
  // to reduce flicker
#ifdef LK8000_OPTIMIZE
  #ifdef FLIPFLOP
  static bool flipflop=true;
  if (flipflop) {
	CalculateWaypointReachableNew();
	flipflop=false;
  } else flipflop=true;
  #else
  CalculateWaypointReachableNew();
  #endif
#else
  CalculateWaypointReachable();
#endif
  CalculateScreenPositionsAirspace();
  CalculateScreenPositionsThermalSources();
  CalculateScreenPositionsGroundline();

  if (PGZoomTrigger) {
	if (!alreadyTriggered) {
		alreadyTriggered=true;
		LastZoomTrigger=GPS_INFO.Time;
		savedMapScale=MapWindow::MapScale;
		savedRequestMapScale=RequestMapScale;
		savedMapScaleOverDistanceModify=MapScaleOverDistanceModify;
		// maybe todo check mode and remember where were these parameters taken from.. 
		if (ISPARAGLIDER) // 100316
			Event_SetZoom(5.0);
		else
			Event_SetZoom(7.0);
		Message::Lock(); // 091211
	        Message::AddMessage(1000, 3, _T("LANDSCAPE ZOOM for 20\""));
		Message::Unlock();
      		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_TONEUP"));
		#endif
	} else {
		// previously called, see if time has passed
		if ( GPS_INFO.Time > (LastZoomTrigger + 20.0)) {
			// time has passed, lets go back
			Event_SetZoom(savedRequestMapScale);
			LastZoomTrigger=0; // just for safety
			alreadyTriggered=false;
			PGZoomTrigger=false;
			Message::Lock(); // 091211
	        	Message::AddMessage(1500, 3, _T("BACK TO NORMAL ZOOM"));
			Message::Unlock();
      			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_TONEDOWN"));
			#endif
		}
	}
  }
	

  // let the calculations run, but dont draw anything but the look8000 when in MapSpaceMode != MSM_MAP
  if (DONTDRAWTHEMAP) 
  {
QuickRedraw: // 100318 speedup redraw
	DrawLook8000(hdc,rc);
#ifdef CPUSTATS
	DrawCpuStats(hdc,rc);
#endif
#ifdef DRAWDEBUG
	DrawDebug(hdc,rc);
#endif
	// no need to do SelectObject as at the bottom of function
	return;
  }

  // When no terrain is painted, set a background0
  // Remember that in this case we have plenty of cpu time to spend for best result
  if (!EnableTerrain || !DerivedDrawInfo.TerrainValid || !RasterTerrain::isTerrainLoaded() ) {

    // display border and fill background..
	if(InfoWindowActive) {
		SelectObject(hdc, hInvBackgroundBrush[BgMapColor]); 
		SelectObject(hdc, GetStockObject(BLACK_PEN));
	} else {
		// Here we are if no terrain is used or available
		if (INVERTCOLORS) { 
			SelectObject(hdc, hInvBackgroundBrush[BgMapColor]);
			SelectObject(hdc, GetStockObject(WHITE_PEN));
		} else {
			SelectObject(hdc, hInvBackgroundBrush[BgMapColor]);
			SelectObject(hdc, GetStockObject(WHITE_PEN));
		}
	}
	Rectangle(hdc,rc.left,rc.top,rc.right,rc.bottom);
	// We force LK painting black values on screen depending on the background color in use
	// TODO make it an array once settled
	// blackscreen would force everything to be painted white, instead
	LKTextBlack=BgMapColorTextBlack[BgMapColor];
	if (BgMapColor>6 ) BlackScreen=true; else BlackScreen=false; 
  } else {
	LKTextBlack=false;
	BlackScreen=false;
  }
  
  SelectObject(hdc, GetStockObject(BLACK_BRUSH));
  SelectObject(hdc, GetStockObject(BLACK_PEN));
  hfOld = (HFONT)SelectObject(hdc, MapWindowFont);
  
  // ground first...
  
  if (BigZoom) {
    BigZoom = false;
  }
  
  if (DONTDRAWTHEMAP) { // 100319
	SelectObject(hdcDrawWindow, hfOld);
	goto QuickRedraw;
  }

  if ((EnableTerrain && (DerivedDrawInfo.TerrainValid) 
       && RasterTerrain::isTerrainLoaded())
      || RasterTerrain::render_weather) {
	// sunelevation is never used, it is still a todo in Terrain
	double sunelevation = 40.0;
	#if 0
	double sunazimuth = DisplayAngle-DerivedDrawInfo.WindBearing;
	// draw sun from constant angle if very low wind speed
	if (DerivedDrawInfo.WindSpeed<0.5) {
		sunazimuth = DisplayAngle + 45.0;
	} 
	#else
	// 101013 XCSOAR BUGFIX SUNAZIMUTH
	double sunazimuth=GetAzimuth();
	#endif

    if (MapDirty) {
      // map has been dirtied since we started drawing, so hurry up
      BigZoom = true;
    }

    LockTerrainDataGraphics();
 	if (DONTDRAWTHEMAP) { // 100318
		UnlockTerrainDataGraphics();
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}
    DrawTerrain(hdc, rc, sunazimuth, sunelevation); // LOCKED 091105
 	if (DONTDRAWTHEMAP) { // 100318
		UnlockTerrainDataGraphics();
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}
    if ((FinalGlideTerrain==2) && DerivedDrawInfo.TerrainValid) {
      DrawTerrainAbove(hdc, rc);
    }
    UnlockTerrainDataGraphics();
  }

 	if (DONTDRAWTHEMAP) { // 100319
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}
  if (EnableTopology) {
    DrawTopology(hdc, rc); // LOCKED 091105
  }
  #if 0
  StartupStore(_T("... Experimental1=%.0f\n"),Experimental1);
  StartupStore(_T("... Experimental2=%.0f\n"),Experimental2);
  Experimental1=0.0;
  Experimental2=0.0;
  #endif

  // Topology labels are printed first, using OLD wps positions from previous run!
  // Reset for topology labels decluttering engine occurs also in another place here!

  nLabelBlocks = 0;
  #if TOPOFASTLABEL
  for (short nvi=0; nvi<SCREENVSLOTS; nvi++) nVLabelBlocks[nvi]=0;
  #endif
  
  #ifndef NOTASKABORT 
  if (!TaskIsTemporary()) {
    DrawTaskAAT(hdc, rc);
  }
  #else
  if (ValidTaskPoint(ActiveWayPoint) && ValidTaskPoint(1)) { // 100503
	DrawTaskAAT(hdc, rc);
  }
  #endif

  
 	if (DONTDRAWTHEMAP) { // 100319
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}
  if ( OnAirSpace >0 ) DrawAirSpace(hdc, rc); // VENTA3 default is true, always true at startup no regsave

 	if (DONTDRAWTHEMAP) { // 100319
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}
  
  if(TrailActive) {
    // TODO enhancement: For some reason, the shadow drawing of the 
    // trail doesn't work in portrait mode.  No idea why.

      double TrailFirstTime = 
#ifdef NEWTRAIL
	LKDrawTrail(hdc, Orig_Aircraft, rc);
#else
	DrawTrail(hdc, Orig_Aircraft, rc);
#endif
      DrawTrailFromTask(hdc, rc, TrailFirstTime);
  }

 	if (DONTDRAWTHEMAP) { // 100319
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}

  DrawThermalEstimate(hdc, rc);
 
  #ifdef NOTASKABORT 
  if (ValidTaskPoint(ActiveWayPoint) && ValidTaskPoint(1)) { // 100503
	DrawTask(hdc, rc, Orig_Aircraft);
  }
  #else
  if (TaskAborted) {
    DrawAbortedTask(hdc, rc, Orig_Aircraft);
  } else {
    DrawTask(hdc, rc, Orig_Aircraft);
  }
  #endif
  
  // draw red cross on glide through terrain marker
  if (FinalGlideTerrain && DerivedDrawInfo.TerrainValid) {
    DrawGlideThroughTerrain(hdc, rc);
  }
  
 	if (DONTDRAWTHEMAP) { // 100319
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}

  #ifdef LK8000_OPTIMIZE
  DrawWaypointsNew(hdc,rc);
  #else
  if (NewMap) DrawWaypointsNew(hdc,rc);
  else DrawWaypoints(hdc,rc);
  #endif

 	if (DONTDRAWTHEMAP) { // 100319
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}

  DrawTeammate(hdc, rc);
 
//  VENTA 090711 TEST disabled DrawSpotHeights QUI
// watchout for upcoming SSA errors in the gcc compiler if not using #if 0
#if (0)
  if ((EnableTerrain && (DerivedDrawInfo.TerrainValid))
      || RasterTerrain::render_weather) {
    DrawSpotHeights(hdc);
  } 
#endif
  
  if (extGPSCONNECT) {
    // TODO enhancement: don't draw offtrack indicator if showing spot heights
    DrawProjectedTrack(hdc, rc, Orig_Aircraft);
    #ifndef LK8000_OPTIMIZE
    DrawOffTrackIndicator(hdc, rc);
    #endif
    DrawBestCruiseTrack(hdc, Orig_Aircraft);
    DrawBearing(hdc, rc);
  }

  // draw wind vector at aircraft
  if (!EnablePan) {
    DrawWindAtAircraft2(hdc, Orig_Aircraft, rc);
  } else if (TargetPan) {
    DrawWindAtAircraft2(hdc, Orig, rc);
  }

  // VisualGlide drawn BEFORE lk8000 overlays
  if ( (!TargetPan) && (!EnablePan) && (VisualGlide>0) ) {
    DrawGlideCircle(hdc, Orig, rc); 
  }

 	if (DONTDRAWTHEMAP) { // 100319
		SelectObject(hdcDrawWindow, hfOld);
		goto QuickRedraw;
	}

  // Draw traffic and other specifix LK gauges
  if (Look8000) { // 091111
  	LKDrawFLARMTraffic(hdc, rc, Orig_Aircraft);
	if ( !EnablePan) DrawLook8000(hdc,rc); 
	if (LKVarioBar && IsMapFullScreen() && !EnablePan) // 091214 do not draw Vario when in Pan mode
		LKDrawVario(hdc,rc); // 091111
  #ifdef LK8000_OPTIMIZE
  }
  #else
  } else {
	DrawFLARMTraffic(hdc, rc, Orig_Aircraft);
  }
  #endif
  
  // finally, draw you!
  // Draw cross air for panmode, instead of aircraft icon
  if (EnablePan && !TargetPan) {
    DrawCrossHairs(hdc, Orig, rc);
  }

  // Draw glider or paraglider
  if (extGPSCONNECT) {
    DrawAircraft(hdc, Orig_Aircraft);
  }

  if ( (!TargetPan) && (!EnablePan) && (Look8000)  ) {
	if (TrackBar) DrawHeading(hdc, Orig, rc); 
  }

  // marks on top...
  DrawMarks(hdc, rc);

  if (ISGAAIRCRAFT) DrawHSI(hdc,Orig,rc); 

#ifdef CPUSTATS
  DrawCpuStats(hdc,rc);
#endif
#ifdef DRAWDEBUG
  DrawDebug(hdc,rc);
#endif
  SelectObject(hdcDrawWindow, hfOld);

}


void MapWindow::RenderMapWindow(  RECT rc)
{
  bool drawmap = false;
  HFONT hfOld;
  DWORD fpsTime = ::GetTickCount();

  // only redraw map part every 800 s unless triggered
  if (((fpsTime-fpsTime0)>800)||(fpsTime0== 0)||(userasked)) {
    fpsTime0 = fpsTime;
    drawmap = true;
    userasked = false;
  }
  MapWindow::UpdateTimeStats(true);
  
  POINT Orig, Orig_Aircraft;

  #if AUTORIENT
  SetAutoOrientation(false); // false for no reset Old values
  #endif  
  CalculateOrigin(rc, &Orig);

  // this is calculating waypoint visible, and must be executed before rendermapwindowbg which calls   
  // CalculateWayPointReachable new, setting values for visible wps!
  // This is also calculating CalculateScreenBounds 0.0  and placing it inside MapWindow::screenbounds_latlon
  CalculateScreenPositions(Orig, rc, &Orig_Aircraft);

  RenderMapWindowBg(hdcDrawWindow, rc, Orig, Orig_Aircraft);

  if (DONTDRAWTHEMAP) {
  	DrawFlightMode(hdcDrawWindow, rc);
  	DrawGPSStatus(hdcDrawWindow, rc);

	return;
  }
  // overlays
  #ifndef NOCDIGAUGE
  DrawCDI();
  #endif

  hfOld = (HFONT)SelectObject(hdcDrawWindow, MapWindowFont);
  
  DrawMapScale(hdcDrawWindow,rc, BigZoom);

  DrawCompass(hdcDrawWindow, rc);

  // JMW Experimental only! EXPERIMENTAL
#if 0
  //  #ifdef GNAV
  if (EnableAuxiliaryInfo) {
//    DrawHorizon(hdcDrawWindow, rc);
  }
  //  #endif
#endif

  DrawFlightMode(hdcDrawWindow, rc);

  // REMINDER TODO let it be configurable for not circling also, as before
  if (!(NewMap && Look8000) || (DisplayMode == dmCircling) )
	if (ThermalBar) DrawThermalBand(hdcDrawWindow, rc); // 091122


  if (!EnablePan) // 091214
  DrawFinalGlide(hdcDrawWindow,rc);

  // DrawSpeedToFly(hdcDrawWindow, rc);  // Usable

  DrawGPSStatus(hdcDrawWindow, rc);

  /*
   * This may not be the correct place for locking map. 
   * In fact we just need once in a second somewhere to check for the following:
   * 	if infobox are under focus and maplocking active then keep it locked
   */
  if ( InfoWindowActive && UseMapLock && NewMap ) {
              LockMap();
  }


  SelectObject(hdcDrawWindow, hfOld);

}


void MapWindow::UpdateInfo(NMEA_INFO *nmea_info,
                           DERIVED_INFO *derived_info) {
  LockFlightData();
  memcpy(&DrawInfo,nmea_info,sizeof(NMEA_INFO));
  memcpy(&DerivedDrawInfo,derived_info,sizeof(DERIVED_INFO));
  UpdateMapScale(); // done here to avoid double latency due to locks 
  UnlockFlightData();
}


void MapWindow::UpdateCaches(bool force) {
  // map was dirtied while we were drawing, so skip slow process
  // (unless we haven't done it for 2000 ms)
  DWORD fpsTimeThis;
  static DWORD fpsTimeMapCenter = 0;


  if (MapWindow::ForceVisibilityScan) {
    force = true;
    MapWindow::ForceVisibilityScan = false;
  }

  // have some time, do shape file cache update if necessary
  LockTerrainDataGraphics();
  SetTopologyBounds(MapRect, force);
  UnlockTerrainDataGraphics();

  // JMW experimental jpeg2000 rendering/tile management
  // Must do this even if terrain is not displayed, because
  // raster terrain is used by terrain footprint etc.

  fpsTimeThis = ::GetTickCount(); // 100115
  if (force || ( (fpsTimeThis - fpsTimeMapCenter) > 5000)) {

    fpsTimeMapCenter=fpsTimeThis; 
    RasterTerrain::ServiceTerrainCenter(DrawInfo.Latitude, 
                                        DrawInfo.Longitude);
  }
  
  fpsTimeThis = ::GetTickCount();
  static DWORD fpsTimeLast_terrain=0;


#ifdef LK8000_OPTIMIZE  	// 100115
  if (EnableTerrain) {
	if (RenderTimeAvailable() || ((fpsTimeThis-fpsTimeLast_terrain)>5000) || force) {
		fpsTimeLast_terrain = fpsTimeThis;
		RasterTerrain::ServiceCache();
	}
  }
#else
  if (RenderTimeAvailable() ||
      (fpsTimeThis-fpsTimeLast_terrain>5000) || force) {
    // have some time, do graphics terrain cache update if necessary
    if (EnableTerrain) {
      fpsTimeLast_terrain = fpsTimeThis;
      RasterTerrain::ServiceCache();
    }
  }
#endif
}


DWORD MapWindow::DrawThread (LPVOID lpvoid)
{

#ifdef CPUSTATS
  FILETIME CreationTime, ExitTime, StartKernelTime, EndKernelTime, StartUserTime, EndUserTime ;
#endif


  while ((!ProgramStarted) || (!Initialised)) {
    Sleep(100);
  }

  //  THREADRUNNING = FALSE;
  THREADEXIT = FALSE;

  // Reset for topology labels decluttering engine occurs also in another place here!
  nLabelBlocks = 0;
  #if TOPOFASTLABEL
  for (short nvi=0; nvi<SCREENVSLOTS; nvi++) nVLabelBlocks[nvi]=0;
  #endif

  GetClientRect(hWndMapWindow, &MapRectBig);

  UpdateTimeStats(true);
  
  MapRectSmall = MapRect;
  MapRect = MapRectSmall;
  
  SetBkMode(hdcDrawWindow,TRANSPARENT);
  SetBkMode(hDCTemp,OPAQUE);
  SetBkMode(hDCMask,OPAQUE);

  // paint draw window black to start
  SelectObject(hdcDrawWindow, GetStockObject(BLACK_PEN));
  Rectangle(hdcDrawWindow,MapRectBig.left,MapRectBig.top,
            MapRectBig.right,MapRectBig.bottom);

  BitBlt(hdcScreen, 0, 0, MapRectBig.right-MapRectBig.left,
         MapRectBig.bottom-MapRectBig.top, 
         hdcDrawWindow, 0, 0, SRCCOPY);

  // This is just here to give fully rendered start screen
  UpdateInfo(&GPS_INFO, &CALCULATED_INFO);
  MapDirty = true;
  UpdateTimeStats(true);
  //

  RequestMapScale = MapScale;
  ModifyMapScale();
  
  bool first = true;

  for (int i=0; i<AIRSPACECLASSCOUNT; i++) {
    hAirspacePens[i] =
      CreatePen(PS_SOLID, NIBLSCALE(2), Colours[iAirspaceColour[i]]);
  }

  while (!CLOSETHREAD) 
    {
      WaitForSingleObject(drawTriggerEvent, 5000);
      ResetEvent(drawTriggerEvent);
      if (CLOSETHREAD) break; // drop out without drawing

      if ((!THREADRUNNING) || (!GlobalRunning)) {
	Sleep(100);
	continue;
      }

#ifdef CPUSTATS
	GetThreadTimes( hDrawThread, &CreationTime, &ExitTime,&StartKernelTime,&StartUserTime);
#endif

      if (!MapDirty && !first) {
	// redraw old screen, must have been a request for fast refresh
	BitBlt(hdcScreen, 0, 0, MapRectBig.right-MapRectBig.left,
	       MapRectBig.bottom-MapRectBig.top, 
	       hdcDrawWindow, 0, 0, SRCCOPY);
	continue;
      } else {
	MapDirty = false;
      }

#ifndef LK8000_OPTIMIZE
      if (BigZoom && !NewMap) {
	// quickly draw zoom level on top
	// Messy behaviour with NewMap
	DrawMapScale(hdcScreen, MapRect, true); 
      }
#endif

      MapWindow::UpdateInfo(&GPS_INFO, &CALCULATED_INFO);

      if (RequestFullScreen != MapFullScreen) {
	ToggleFullScreenStart();
      }

      //if ( !( IsMapFullScreen() && !EnablePan && Look8000 && NewMap && MapSpaceMode==1) ) { // VENTA TODO QUI FIX CRITIC

	      #ifndef NOFLARMGAUGE
	      GaugeFLARM::Render(&DrawInfo);
	      #endif
	      RenderMapWindow(MapRect);
      //}
    
      if (!first) {
	BitBlt(hdcScreen, 0, 0, 
	       MapRectBig.right-MapRectBig.left,
	       MapRectBig.bottom-MapRectBig.top, 
	       hdcDrawWindow, 0, 0, SRCCOPY);
	InvalidateRect(hWndMapWindow, &MapRect, false);
      }
      UpdateTimeStats(false);


	#if (WINDOWSPC<1)
	LKBatteryManager();
	#endif


      // we do caching after screen update, to minimise perceived delay
      UpdateCaches(first);
      first = false;
      if (ProgramStarted==psInitDone) {
	ProgramStarted = psFirstDrawDone;

#ifndef NOVARIOGAUGE
	if ( (InfoBoxLayout::InfoBoxGeometry==6) && (InfoBoxLayout::landscape == true) )
		GaugeVario::Show(!MapFullScreen);
#endif
      }
#ifdef CPUSTATS
	if ( (GetThreadTimes( hDrawThread, &CreationTime, &ExitTime,&EndKernelTime,&EndUserTime)) == 0) {
		Cpu_Draw=9999;
	} else {
		Cpustats(&Cpu_Draw,&StartKernelTime, &EndKernelTime, &StartUserTime, &EndUserTime);
	}
#endif
    
    }
  THREADEXIT = TRUE;
  return 0;
}


void MapWindow::DrawCrossHairs(HDC hdc, const POINT Orig,
			       const RECT rc)
{
  POINT o1, o2;
  
  o1.x = Orig.x+20;
  o2.x = Orig.x-20;
  o1.y = Orig.y;
  o2.y = Orig.y;

  if (BlackScreen)
	  DrawDashLine(hdc, NIBLSCALE(1), o1, o2, RGB_INVDRAW, rc);
  else
	  DrawDashLine(hdc, NIBLSCALE(1), o1, o2, RGB_DARKGREY, rc);

  o1.x = Orig.x;
  o2.x = Orig.x;
  o1.y = Orig.y+20;
  o2.y = Orig.y-20;

  if (BlackScreen)
	  DrawDashLine(hdc, NIBLSCALE(1), o1, o2, RGB_INVDRAW, rc); // 091219
  else
	  DrawDashLine(hdc, NIBLSCALE(1), o1, o2, RGB_DARKGREY, rc); // 091219

}


void PolygonRotateShift(POINT* poly, const int n, const int xs, const int ys, const double angle) {
  static double lastangle = -1;
  static int cost=1024, sint=0;

  if(angle != lastangle) {
    lastangle = angle;
    int deg = DEG_TO_INT(AngleLimit360(angle));
    cost = ICOSTABLE[deg]*InfoBoxLayout::scale;
    sint = ISINETABLE[deg]*InfoBoxLayout::scale;
  }
  const int xxs = xs*1024+512;
  const int yys = ys*1024+512;
  POINT *p = poly;
  const POINT *pe = poly+n;

  while (p<pe) {
    int x= p->x;
    int y= p->y;
    p->x = (x*cost - y*sint + xxs)/1024;
    p->y = (y*cost + x*sint + yys)/1024;
    p++;
  }
}


void MapWindow::DrawAircraft(HDC hdc, const POINT Orig)
{

  if ( ISPARAGLIDER || ISCAR ) {

    #define NUMPARAPOINTS 3

    POINT Para[3] = {
      { 0,-5},
      {5,9},
      {-5,9}
    };

    int pi;
    HPEN hpPOld;
    HBRUSH hbPAircraftSolid; 
    HBRUSH hbPAircraftSolidBg;

    if (BlackScreen) {
	#if LKOBJ
      hbPAircraftSolid = LKBrush_LightCyan;
      hbPAircraftSolidBg = LKBrush_Blue;
    } else {
      hbPAircraftSolid = LKBrush_Blue;
      hbPAircraftSolidBg = LKBrush_Grey;
	#else
      hbPAircraftSolid = (HBRUSH) CreateSolidBrush(RGB_LIGHTCYAN);
      hbPAircraftSolidBg = (HBRUSH) CreateSolidBrush(RGB_BLUE);
    } else {
      hbPAircraftSolid = (HBRUSH) CreateSolidBrush(RGB_BLUE);
      hbPAircraftSolidBg = (HBRUSH) CreateSolidBrush(RGB_GREY);
	#endif
    }

    HBRUSH hbPOld = (HBRUSH)SelectObject(hdc, hbPAircraftSolidBg);
    hpPOld = (HPEN)SelectObject(hdc, hpAircraft);
  
    PolygonRotateShift(Para, NUMPARAPOINTS, Orig.x+1, Orig.y+1,
                       DisplayAircraftAngle+
                       (DerivedDrawInfo.Heading-DrawInfo.TrackBearing));

    Polygon(hdc, Para, NUMPARAPOINTS);

    // draw it again so can get white border
    SelectObject(hdc, hpAircraftBorder);
    SelectObject(hdc, hbPAircraftSolid);

    for(pi=0; pi<NUMPARAPOINTS; pi++)
      {
	Para[pi].x -= 1;  Para[pi].y -= 1;
      }

    Polygon(hdc, Para, NUMPARAPOINTS);

    SelectObject(hdc, hpPOld);
    SelectObject(hdc, hbPOld);

    #ifndef LKOBJ
    DeleteObject(hbPAircraftSolid);
    DeleteObject(hbPAircraftSolidBg);
    #endif
    
    return;
  }

  if (Appearance.Aircraft == afAircraftDefault){

#define NUMAIRCRAFTPOINTS 16

    POINT Aircraft[NUMAIRCRAFTPOINTS] = {
      { 1,-6},
      {2,-1},
      {15,0},
      {15,2},
      {1,2},
      {0,10},
      {4,11},
      {4,12},
      {-4,12},
      {-4,11},
      {0,10},
      {-1,2},
      {-15,2},
      {-15,0},
      {-2,-1},
      {-1,-6}
    };

    int i;
    HPEN hpOld;
    HBRUSH hbAircraftSolid; 
    HBRUSH hbAircraftSolidBg;

	#if LKOBJ
    if (Appearance.InverseAircraft) {
      hbAircraftSolid = LKBrush_White;
      hbAircraftSolidBg = LKBrush_Black;
    } else {
      hbAircraftSolid = LKBrush_Black;
      hbAircraftSolidBg = LKBrush_White;
    }
	#else
    if (Appearance.InverseAircraft) {
      hbAircraftSolid = (HBRUSH) CreateSolidBrush(RGB_WHITE);
      hbAircraftSolidBg = (HBRUSH) CreateSolidBrush(RGB_BLACK);
    } else {
      hbAircraftSolid = (HBRUSH) CreateSolidBrush(RGB_BLACK);
      hbAircraftSolidBg = (HBRUSH) CreateSolidBrush(RGB_WHITE);
    }
	#endif

    HBRUSH hbOld = (HBRUSH)SelectObject(hdc, hbAircraftSolidBg);
    hpOld = (HPEN)SelectObject(hdc, hpAircraft);
  
    PolygonRotateShift(Aircraft, NUMAIRCRAFTPOINTS, Orig.x+1, Orig.y+1,
                       DisplayAircraftAngle+
                       (DerivedDrawInfo.Heading-DrawInfo.TrackBearing));

    Polygon(hdc, Aircraft, NUMAIRCRAFTPOINTS);

    // draw it again so can get white border
    SelectObject(hdc, hpAircraftBorder);
    SelectObject(hdc, hbAircraftSolid);

    for(i=0; i<NUMAIRCRAFTPOINTS; i++)
      {
	Aircraft[i].x -= 1;  Aircraft[i].y -= 1;
      }

    Polygon(hdc, Aircraft, NUMAIRCRAFTPOINTS);

    SelectObject(hdc, hpOld);
    SelectObject(hdc, hbOld);

    #ifndef LKOBJ
    DeleteObject(hbAircraftSolid);
    DeleteObject(hbAircraftSolidBg);
    #endif
    
  } else

    if (Appearance.Aircraft == afAircraftAltA){

      HPEN oldPen;
      POINT Aircraft[] = {
	{1, -5},
	{1, 0},
	{14, 0}, 
	{14, 1}, 
	{1, 1},
	{1, 8},
	{4, 8},
	{4, 9},
	{-3, 9},
	{-3, 8},
	{0, 8},
	{0, 1},
	{-13, 1}, 
	{-13, 0}, 
	{0, 0},
	{0, -5},
	{1, -5},
      };

      /* Experiment, when turning show the high wing larger, 
	 low wing smaller
	 if (DerivedDrawInfo.TurnRate>10) {
	 Aircraft[3].y = 0;
	 Aircraft[12].y = 2;
	 } else if (DerivedDrawInfo.TurnRate<-10) {
	 Aircraft[3].y = 2;
	 Aircraft[12].y = 0;
	 }
      */

      int n = sizeof(Aircraft)/sizeof(Aircraft[0]);

      double angle = DisplayAircraftAngle+
	(DerivedDrawInfo.Heading-DrawInfo.TrackBearing);

      PolygonRotateShift(Aircraft, n,
			 Orig.x-1, Orig.y, angle);

      oldPen = (HPEN)SelectObject(hdc, hpAircraft);
      Polygon(hdc, Aircraft, n);

      HBRUSH hbOld;
      if (Appearance.InverseAircraft) {
	hbOld = (HBRUSH)SelectObject(hdc, GetStockObject(WHITE_BRUSH));
      } else {
	hbOld = (HBRUSH)SelectObject(hdc, GetStockObject(BLACK_BRUSH));
      }
      SelectObject(hdc, hpAircraftBorder); // hpBearing
      Polygon(hdc, Aircraft, n);

      SelectObject(hdc, oldPen);
      SelectObject(hdc, hbOld);

    }

}

void MapWindow::DrawBitmapX(HDC hdc, int x, int y,
                            int sizex, int sizey,
                            HDC source,
                            int offsetx, int offsety,
                            DWORD mode) {
  if (InfoBoxLayout::scale>1) {
    StretchBlt(hdc, x, y, 
               IBLSCALE(sizex), 
               IBLSCALE(sizey), 
               source,
               offsetx, offsety, sizex, sizey,
               mode);
  } else {
    BitBlt(hdc, x, y, sizex, sizey, 
           source, offsetx, offsety, mode); 
  }
}

void MapWindow::DrawBitmapIn(const HDC hdc, const POINT &sc, const HBITMAP h) {
  if (!PointVisible(sc)) return;

  SelectObject(hDCTemp, h);

  DrawBitmapX(hdc,
              sc.x-NIBLSCALE(5),
              sc.y-NIBLSCALE(5),
              10,10,
	      hDCTemp,0,0,SRCPAINT);
  DrawBitmapX(hdc,
              sc.x-NIBLSCALE(5),
              sc.y-NIBLSCALE(5),
              10,10,
              hDCTemp,10,0,SRCAND);
}


void MapWindow::DrawGPSStatus(HDC hDC, const RECT rc)
{

//StartupStore(_T("NAVWarn=%d Sats=%d\n"),DrawInfo.NAVWarning,DrawInfo.SatellitesUsed); REMOVE
#ifdef NEWWARNINGS
  HFONT oldfont=NULL;
  if ((MapSpaceMode==MSM_WELCOME)||(MapWindow::isPan()) ) return; // 100210
#endif

  if (extGPSCONNECT && !(DrawInfo.NAVWarning) && (DrawInfo.SatellitesUsed != 0)) 
    // nothing to do
    return;
#ifndef COMDIAG
  TCHAR gpswarningtext1[] = TEXT(" GPS not connected ");
#endif
  TCHAR gpswarningtext2[] = TEXT(" GPS: NO VALID FIX ");
#ifdef COMDIAG
  static bool firstrun=true;
  TCHAR gpswarningtext3[] = TEXT(" GPS: No ComPort ");
  TCHAR gpswarningtext4[] = TEXT(" GPS: No Data Rx ");
  TCHAR gpswarningtext5[] = TEXT(" GPS is missing ");
  TCHAR gpswarningtext6[] = TEXT(" GPS not connected ");
#endif
  TextInBoxMode_t TextInBoxMode = {2};

  if (!extGPSCONNECT) {

#ifndef NEWWARNINGS
    SelectObject(hDCTemp,hGPSStatus2);
    DrawBitmapX(hDC, 
                rc.left+NIBLSCALE(2),
                rc.bottom+IBLSCALE(Appearance.GPSStatusOffset.y-22),
                20, 20,
                hDCTemp, 
                0, 0, SRCAND);
    TextInBox(hDC, gettext(gpswarningtext1), 
              rc.left+NIBLSCALE(24), 
              rc.bottom+IBLSCALE(Appearance.GPSStatusOffset.y-19),
              0, TextInBoxMode);
#else
    #ifdef COMDIAG
    oldfont=(HFONT)SelectObject(hDC,LK8TargetFont);   // 100222 
    TextInBoxMode.AsInt=0;
    TextInBoxMode.AsFlag.Color = TEXTWHITE;
    TextInBoxMode.AsFlag.NoSetFont=1;
    TextInBoxMode.AsFlag.AlligneCenter = 1;
    TextInBoxMode.AsFlag.WhiteBorder = 1;
    TextInBoxMode.AsFlag.Border = 1;
    if (ComPortStatus[0]==CPS_OPENKO) 
    	TextInBox(hDC, gpswarningtext3, (rc.right-rc.left)/2, (rc.bottom-rc.top)/3, 0, TextInBoxMode);
    else {
    	if (ComPortStatus[0]==CPS_OPENOK) {
		if ((ComPortRx[0]>0) && !firstrun) {
    			TextInBox(hDC, gpswarningtext5, (rc.right-rc.left)/2, (rc.bottom-rc.top)/3, 0, TextInBoxMode);
			firstrun=false; // 100214
		} else
    			TextInBox(hDC, gpswarningtext4, (rc.right-rc.left)/2, (rc.bottom-rc.top)/3, 0, TextInBoxMode);

	} else 
    		TextInBox(hDC, gpswarningtext6, (rc.right-rc.left)/2, (rc.bottom-rc.top)/3, 0, TextInBoxMode); // 100214

    }

    #else
    oldfont=(HFONT)SelectObject(hDC,LK8TargetFont);  // 100210
    TextInBoxMode.AsInt=0;
    TextInBoxMode.AsFlag.Color = TEXTWHITE;
    TextInBoxMode.AsFlag.NoSetFont=1;
    TextInBoxMode.AsFlag.AlligneCenter = 1;
    TextInBoxMode.AsFlag.WhiteBorder = 1;
    TextInBoxMode.AsFlag.Border = 1;
    TextInBox(hDC, gpswarningtext1, (rc.right-rc.left)/2, (rc.bottom-rc.top)/3, 0, TextInBoxMode);
    #endif
#endif

  } else
    if (DrawInfo.NAVWarning || (DrawInfo.SatellitesUsed == 0)) {
#ifndef NEWWARNINGS
      SelectObject(hDCTemp,hGPSStatus1);

      DrawBitmapX(hDC, 
                  rc.left+NIBLSCALE(2),
                  rc.bottom+IBLSCALE(Appearance.GPSStatusOffset.y-22),
                  20, 20,
                  hDCTemp, 
                  0, 0, SRCAND);

      TextInBox(hDC, gettext(gpswarningtext2), 
                rc.left+NIBLSCALE(24), 
                rc.bottom+
                IBLSCALE(Appearance.GPSStatusOffset.y-19),
                0, TextInBoxMode);
#else
    oldfont=(HFONT)SelectObject(hDC,LK8TargetFont); // 100210
    TextInBoxMode.AsInt=0;
    TextInBoxMode.AsFlag.Color = TEXTWHITE;
    TextInBoxMode.AsFlag.NoSetFont=1;
    TextInBoxMode.AsFlag.AlligneCenter = 1;
    TextInBoxMode.AsFlag.WhiteBorder = 1;
    TextInBoxMode.AsFlag.Border = 1;
    TextInBox(hDC, gpswarningtext2, 
              (rc.right-rc.left)/2, 
              (rc.bottom-rc.top)/3,
              0, TextInBoxMode);
#endif

    }
#ifdef NEWWARNINGS
  SelectObject(hDC,oldfont);
#endif

}

void MapWindow::DrawFlightMode(HDC hdc, const RECT rc)
{
  static bool flip= true;
  static double LastTime = 0;
  bool drawlogger = true;
  static bool lastLoggerActive=false;
  int offset = -1;

  if (!Appearance.DontShowLoggerIndicator){

	// has GPS time advanced?
	if(DrawInfo.Time <= LastTime) {
		LastTime = DrawInfo.Time;
	} else {

		flip = !flip;
		// don't bother drawing logger if not active for more than one second
		if ((!LoggerActive)&&(!lastLoggerActive)) {
			drawlogger = false;
		}
		lastLoggerActive = LoggerActive;
	}

	if (drawlogger) {
		offset -= 7;

		if (LoggerActive && flip) {
			SelectObject(hDCTemp,hLogger);
		} else {
			SelectObject(hDCTemp,hLoggerOff);
		}

		DrawBitmapX(hdc, rc.right+IBLSCALE(offset+Appearance.FlightModeOffset.x),
                  	rc.bottom - BottomSize+NIBLSCALE(1),
			7,7, hDCTemp, 0,0,SRCPAINT);

		DrawBitmapX(hdc, rc.right+IBLSCALE(offset+Appearance.FlightModeOffset.x),
                  	rc.bottom-BottomSize+NIBLSCALE(1),
			7,7, hDCTemp, 7,0,SRCAND);

		// not really needed if we remove offset next on
		offset +=7;
	}
  }


  if (Appearance.FlightModeIcon == apFlightModeIconDefault){

    #ifndef NOTASKABORT
    if (TaskAborted) {
      SelectObject(hDCTemp,hAbort);
    } else {
    #else
      if (DisplayMode == dmCircling) {
        SelectObject(hDCTemp,hClimb);
      } else if (DisplayMode == dmFinalGlide) {
        SelectObject(hDCTemp,hFinalGlide);
      } else {
        SelectObject(hDCTemp,hCruise);
      }
    #endif
    #ifndef NOTASKABORT
    }
    #endif
    // Code already commented as of 12aug05 - redundant? -st
    //          BitBlt(hdc,rc.right-35,5,24,20,
    //                           hDCTemp,20,0,SRCAND);

    // code for pre 12aug icons - st
    //BitBlt(hdc,rc.right-24-3,rc.bottom-20-3,24,20,
    //  hDCTemp,0,0,SRCAND);

    offset -= 24;

    DrawBitmapX(hdc,
                rc.right+IBLSCALE(offset-1+Appearance.FlightModeOffset.x),
                rc.bottom+IBLSCALE(-20-1+Appearance.FlightModeOffset.y),
                24,20,
                hDCTemp,
                0,0,SRCPAINT);
    
    DrawBitmapX(hdc,
                rc.right+IBLSCALE(offset-1+Appearance.FlightModeOffset.x),
                rc.bottom+IBLSCALE(-20-1+Appearance.FlightModeOffset.y),
                24,20,
                hDCTemp,
                24,0,SRCAND);

  // FlightModeIcon is always 0, unused!
  #if 100920
  }
  #else
  } else if (Appearance.FlightModeIcon == apFlightModeIconAltA){

#define SetPoint(Idx,X,Y) Arrow[Idx].x = X; Arrow[Idx].y = Y

    POINT Arrow[3];
    POINT Center;
    HBRUSH oldBrush;
    HPEN   oldPen;

    Center.x = rc.right-10;
    Center.y = rc.bottom-10;

    if (DisplayMode == dmCircling) {

      SetPoint(0, 
               Center.x,
               Center.y-NIBLSCALE(4));
      SetPoint(1, 
               Center.x-NIBLSCALE(8), 
               Center.y+NIBLSCALE(4));
      SetPoint(2, 
               Center.x+NIBLSCALE(8), 
               Center.y+NIBLSCALE(4));

    } else if (DisplayMode == dmFinalGlide) {

      SetPoint(0, 
               Center.x, 
               Center.y+NIBLSCALE(4));
      SetPoint(1, 
               Center.x-NIBLSCALE(8), 
               Center.y-NIBLSCALE(4));
      SetPoint(2, 
               Center.x+NIBLSCALE(8), 
               Center.y-NIBLSCALE(4));
    } else {

      SetPoint(0, 
               Center.x+NIBLSCALE(4), 
               Center.y);
      SetPoint(1, 
               Center.x-NIBLSCALE(4), 
               Center.y+NIBLSCALE(8));
      SetPoint(2, 
               Center.x-NIBLSCALE(4), 
               Center.y-NIBLSCALE(8));

    }

    #ifndef NOTASKABORT
    if (TaskAborted)
      oldBrush = (HBRUSH)SelectObject(hdc, hBrushFlyingModeAbort);
    else
      oldBrush = (HBRUSH)SelectObject(hdc, hbCompass);
    #else
     oldBrush = (HBRUSH)SelectObject(hdc, hbCompass);
    #endif

    oldPen = (HPEN)SelectObject(hdc, hpCompassBorder);
    Polygon(hdc, Arrow, 3);

    SelectObject(hdc, hpCompass);
    Polygon(hdc, Arrow, 3);

    SelectObject(hdc, oldPen);
    SelectObject(hdc, oldBrush);

  }
  #endif // no flighticon 100920


  if (!Appearance.DontShowAutoMacCready && DerivedDrawInfo.AutoMacCready) {
    SelectObject(hDCTemp,hAutoMacCready);

    offset -= 24;

    //changed draw mode & icon for higher opacity 12aug -st

    DrawBitmapX(hdc,
		rc.right+IBLSCALE(offset-3+Appearance.FlightModeOffset.x),
		rc.bottom+IBLSCALE(-20-3+Appearance.FlightModeOffset.y),
		24,20,
		hDCTemp,
		0,0,SRCPAINT);

    DrawBitmapX(hdc,
		rc.right+IBLSCALE(offset-3+Appearance.FlightModeOffset.x),
		rc.bottom+IBLSCALE(-20-3+Appearance.FlightModeOffset.y),
		24,20,
		hDCTemp,
		24,0,SRCAND);

    //  commented @@ 12aug st
    //  BitBlt(hdc,rc.right-48-3,rc.bottom-20-3,24,20,
    //    hDCTemp,0,0,SRCAND);
  };
  
}


typedef struct{
  TCHAR Name[NAME_SIZE+1];
  POINT Pos;
  TextInBoxMode_t Mode;
  int AltArivalAGL;
  bool inTask;
  bool isLandable; // VENTA5
  bool isAirport; // VENTA5
  bool isExcluded;
  int index;
}MapWaypointLabel_t;

bool MapWindow::WaypointInTask(int ind) {
  if (!WayPointList) return false;
  return WayPointList[ind].InTask;
}

//FIX
//static void MapWaypointLabelAdd(TCHAR *Name, int X, int Y, TextInBoxMode_t Mode, int AltArivalAGL, bool inTask=false, bool isLandable=false, bool isAirport=false, bool isExcluded=false);
void MapWaypointLabelAdd(TCHAR *Name, int X, int Y, TextInBoxMode_t Mode, int AltArivalAGL, bool inTask, bool isLandable, bool isAirport, bool isExcluded, int index);
//static int _cdecl MapWaypointLabelListCompare(const void *elem1, const void *elem2 );
int _cdecl MapWaypointLabelListCompare(const void *elem1, const void *elem2 );
//static MapWaypointLabel_t MapWaypointLabelList[50];

MapWaypointLabel_t MapWaypointLabelList[200]; 
//static int MapWaypointLabelListCount=0;
int MapWaypointLabelListCount=0;

bool MapWindow::WaypointInRange(int i) {
  return ((WayPointList[i].Zoom >= MapScale*10) 
          || (WayPointList[i].Zoom == 0)) 
    && (MapScale <= 10);
}

#ifndef LK8000_OPTIMIZE
void MapWindow::DrawWaypoints(HDC hdc, const RECT rc)
{
  unsigned int i;
  TCHAR Buffer[32];
  TCHAR Buffer2[32];
  TCHAR sAltUnit[4];
  TextInBoxMode_t TextDisplayMode;

  // if pan mode, show full names
  int pDisplayTextType = DisplayTextType;
  if (EnablePan) {
    pDisplayTextType = DISPLAYNAME;
  }

  if (!WayPointList) return;

  _tcscpy(sAltUnit, Units::GetAltitudeName());

  MapWaypointLabelListCount = 0;

  for(i=0;i<NumberOfWayPoints;i++)
    {
      if(WayPointList[i].Visible )
	{

#ifdef HAVEEXCEPTIONS
	  __try{
#endif

	    bool irange = false;
	    bool intask = false;
	    bool islandable = false;
	    bool dowrite;

	    intask = WaypointInTask(i);
	    dowrite = intask;

	    TextDisplayMode.AsInt = 0;

	    irange = WaypointInRange(i);

	    if(MapScale > 20) {
	      SelectObject(hDCTemp,hSmall);
	    #ifdef USEISLANDABLE
	    } else if( WayPointCalc[i].IsLandable ) {
	    #else
	    } else if( ((WayPointList[i].Flags & AIRPORT) == AIRPORT) 
		       || ((WayPointList[i].Flags & LANDPOINT) == LANDPOINT) ) {
	    #endif
	      islandable = true; // so we can always draw them
	      if(WayPointList[i].Reachable){

		TextDisplayMode.AsFlag.Reachable = 1;

		if ((DeclutterLabels<MAPLABELS_ALLOFF)||intask) {

		  if (intask || (DeclutterLabels<MAPLABELS_ONLYTOPO)) {
		    TextDisplayMode.AsFlag.Border = 1;
		  }
		  // show all reachable landing fields unless we want a decluttered
		  // screen.
		  dowrite = true;
		}

		#ifdef USEISLANDABLE
		if (WayPointCalc[i].IsAirport)
		#else
		if ((WayPointList[i].Flags & AIRPORT) == AIRPORT)
		#endif
		  SelectObject(hDCTemp,hBmpAirportReachable);
		else
		  SelectObject(hDCTemp,hBmpFieldReachable);
	      } else {
		#ifdef USEISLANDABLE
		if (WayPointCalc[i].IsAirport)
		#else
		if ((WayPointList[i].Flags & AIRPORT) == AIRPORT)
		#endif
		  SelectObject(hDCTemp,hBmpAirportUnReachable);
		else
		  SelectObject(hDCTemp,hBmpFieldUnReachable);
	      }
	    } else {
	      if(MapScale > 4) {
		SelectObject(hDCTemp,hSmall);
	      } else {
		SelectObject(hDCTemp,hTurnPoint);
	      }
	    }

	    if (intask) { // VNT 
	      TextDisplayMode.AsFlag.WhiteBold = 1;
	    }

	    if(irange || intask || islandable || dowrite) {
        
	      DrawBitmapX(hdc,
			  WayPointList[i].Screen.x-NIBLSCALE(10), 
			  WayPointList[i].Screen.y-NIBLSCALE(10),
			  20,20,
			  hDCTemp,0,0,SRCPAINT);
        
	      DrawBitmapX(hdc,
			  WayPointList[i].Screen.x-NIBLSCALE(10), 
			  WayPointList[i].Screen.y-NIBLSCALE(10),
			  20,20,
			  hDCTemp,20,0,SRCAND);
	    }

	    if(intask || irange || dowrite) {
	      bool draw_alt = TextDisplayMode.AsFlag.Reachable 
		&& ((DeclutterLabels<MAPLABELS_ONLYTOPO) || intask);

	      switch(pDisplayTextType) {
	      case DISPLAYNAMEIFINTASK:
		dowrite = intask;
		if (intask) {
		  if (draw_alt)
		    wsprintf(Buffer, TEXT("%s:%d%s"),
			     WayPointList[i].Name, 
			     (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			     sAltUnit);
		  else
		    wsprintf(Buffer, TEXT("%s"),WayPointList[i].Name);
		}
		break;
	      case DISPLAYNAME:
		dowrite = (DeclutterLabels<MAPLABELS_ALLOFF) || intask;
		if (draw_alt)
		  wsprintf(Buffer, TEXT("%s:%d%s"),
			   WayPointList[i].Name, 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		else
		  wsprintf(Buffer, TEXT("%s"),WayPointList[i].Name);
          
		break;
	      case DISPLAYNUMBER:
		dowrite = (DeclutterLabels<MAPLABELS_ALLOFF) || intask;
		if (draw_alt)
		  wsprintf(Buffer, TEXT("%d:%d%s"),
			   WayPointList[i].Number, 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		else
		  wsprintf(Buffer, TEXT("%d"),WayPointList[i].Number);
          
		break;
	      case DISPLAYFIRSTFIVE:
		dowrite = (DeclutterLabels<MAPLABELS_ALLOFF) || intask;
		_tcsncpy(Buffer2, WayPointList[i].Name, 5);
		Buffer2[5] = '\0';
		if (draw_alt)
		  wsprintf(Buffer, TEXT("%s:%d%s"),
			   Buffer2, 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		else
		  wsprintf(Buffer, TEXT("%s"),Buffer2);
          
		break;
	      case DISPLAYFIRSTTHREE:
		dowrite = (DeclutterLabels<MAPLABELS_ALLOFF) || intask;
		_tcsncpy(Buffer2, WayPointList[i].Name, 3);
		Buffer2[3] = '\0';
		if (draw_alt)
		  wsprintf(Buffer, TEXT("%s:%d%s"),
			   Buffer2, 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		else
		  wsprintf(Buffer, TEXT("%s"),Buffer2);
          
		break;
	      case DISPLAYNONE:
		dowrite = (DeclutterLabels<MAPLABELS_ALLOFF) || intask;
		if (draw_alt)
		  wsprintf(Buffer, TEXT("%d%s"), 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		else
		  Buffer[0]= '\0';
	      default:
#if (WINDOWSPC<1)
		ASSERT(0);
#endif
		break;
	      }
        
	      if (dowrite) {
		MapWaypointLabelAdd(
				    Buffer,
				    WayPointList[i].Screen.x+5,
				    WayPointList[i].Screen.y,
				    TextDisplayMode,
				    (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY),
				    intask,false,false,false,i);
	      }
        
	    }
      
#ifdef HAVEEXCEPTIONS
	  }__finally
#endif
	     { ; }
	}
    }
  
  qsort(&MapWaypointLabelList, 
        MapWaypointLabelListCount,
        sizeof(MapWaypointLabel_t), 
        MapWaypointLabelListCompare);

  int j;

  // now draw task/landable waypoints in order of range (closest last)
  // writing unconditionally
  for (j=MapWaypointLabelListCount-1; j>=0; j--){
    MapWaypointLabel_t *E = &MapWaypointLabelList[j];
    // draws if they are in task unconditionally,
    // otherwise, does comparison
    if (E->inTask) {
      TextInBox(hdc, E->Name, E->Pos.x,
                E->Pos.y, 0, E->Mode, 
                false);
    }
  }

  // now draw normal waypoints in order of range (furthest away last)
  // without writing over each other (or the task ones)
  for (j=0; j<MapWaypointLabelListCount; j++) {
    MapWaypointLabel_t *E = &MapWaypointLabelList[j];
    if (!E->inTask) {
      TextInBox(hdc, E->Name, E->Pos.x,
                E->Pos.y, 0, E->Mode, 
                true);
    }
  }

}
#endif

//static int _cdecl MapWaypointLabelListCompare(const void *elem1, const void *elem2 ){
int _cdecl MapWaypointLabelListCompare(const void *elem1, const void *elem2 ){

  // Now sorts elements in task preferentially.
  /*
    if (((MapWaypointLabel_t *)elem1)->inTask && ! ((MapWaypointLabel_t *)elem2)->inTask)
    return (-1);
  */
  if (((MapWaypointLabel_t *)elem1)->AltArivalAGL > ((MapWaypointLabel_t *)elem2)->AltArivalAGL)
    return (-1);
  if (((MapWaypointLabel_t *)elem1)->AltArivalAGL < ((MapWaypointLabel_t *)elem2)->AltArivalAGL)
    return (+1);
  return (0);
}


//static void MapWaypointLabelAdd(TCHAR *Name, int X, int Y,  FIX
void MapWaypointLabelAdd(TCHAR *Name, int X, int Y, 
			 TextInBoxMode_t Mode, 
			 int AltArivalAGL, bool inTask, bool isLandable, bool isAirport, bool isExcluded, int index){
  MapWaypointLabel_t *E;

  if ((X<MapWindow::MapRect.left-WPCIRCLESIZE)
      || (X>MapWindow::MapRect.right+(WPCIRCLESIZE*3))
      || (Y<MapWindow::MapRect.top-WPCIRCLESIZE)
      || (Y>MapWindow::MapRect.bottom+WPCIRCLESIZE)){
    return;
  }

  if (MapWaypointLabelListCount >= (( (signed int)(sizeof(MapWaypointLabelList)/sizeof(MapWaypointLabel_t)))-1)){  // BUGFIX 100207
    return;
  }

  E = &MapWaypointLabelList[MapWaypointLabelListCount];

  _tcscpy(E->Name, Name);
  E->Pos.x = X;
  E->Pos.y = Y;
  E->Mode = Mode;
  E->AltArivalAGL = AltArivalAGL;
  E->inTask = inTask;
  E->isLandable = isLandable;
  E->isAirport  = isAirport;
  E->isExcluded = isExcluded;

  MapWaypointLabelListCount++;

}


void MapWindow::DrawAbortedTask(HDC hdc, const RECT rc, const POINT me)
{
  int i;
  if (!WayPointList) return;
  
  LockTaskData();  // protect from external task changes
#ifdef HAVEEXCEPTIONS
  __try{
#endif
    for(i=0;i<MAXTASKPOINTS-1;i++)
      {
	int index = Task[i].Index;
	if(ValidWayPoint(index))
	  {
	    DrawDashLine(hdc, 1, 
			 WayPointList[index].Screen,
			 me,
			 taskcolor, rc);
	  }
      }
#ifdef HAVEEXCEPTIONS
  }__finally
#endif
     {
       UnlockTaskData();
     }
}


void MapWindow::DrawStartSector(HDC hdc, const RECT rc, 
                                POINT &Start,
                                POINT &End, int Index) {
  double tmp;

  if(StartLine) {
    _DrawLine(hdc, PS_SOLID, NIBLSCALE(5), WayPointList[Index].Screen,
              Start, taskcolor, rc);
    _DrawLine(hdc, PS_SOLID, NIBLSCALE(5), WayPointList[Index].Screen,
              End, taskcolor, rc);
    _DrawLine(hdc, PS_SOLID, NIBLSCALE(1), WayPointList[Index].Screen,
              Start, RGB(255,0,0), rc);
    _DrawLine(hdc, PS_SOLID, NIBLSCALE(1), WayPointList[Index].Screen,
              End, RGB(255,0,0), rc);
  } else {
    tmp = StartRadius*ResMapScaleOverDistanceModify;
    SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
    SelectObject(hdc, hpStartFinishThick);
    Circle(hdc,
           WayPointList[Index].Screen.x,
           WayPointList[Index].Screen.y,(int)tmp, rc, false, false);
    SelectObject(hdc, hpStartFinishThin);
    Circle(hdc,
           WayPointList[Index].Screen.x,
           WayPointList[Index].Screen.y,(int)tmp, rc, false, false);
  }

}


void MapWindow::DrawTask(HDC hdc, RECT rc, const POINT &Orig_Aircraft)
{
  int i;
  double tmp;

  COLORREF whitecolor = RGB_WHITE;
  COLORREF origcolor = SetTextColor(hDCTemp, whitecolor);

  if (!WayPointList) return;

  LockTaskData();  // protect from external task changes
#ifdef HAVEEXCEPTIONS
  __try{
#endif

    if(ValidTaskPoint(0) && ValidTaskPoint(1) && (ActiveWayPoint<2))
      {
	DrawStartSector(hdc,rc, Task[0].Start, Task[0].End, Task[0].Index);
	if (EnableMultipleStartPoints) {
	  for (i=0; i<MAXSTARTPOINTS; i++) {
	    if (StartPoints[i].Active && ValidWayPoint(StartPoints[i].Index)) {
	      DrawStartSector(hdc,rc, 
			      StartPoints[i].Start, 
			      StartPoints[i].End, StartPoints[i].Index);
	    }
	  }
	}
      }
  
    for(i=1;i<MAXTASKPOINTS-1;i++) {

      if(ValidTaskPoint(i) && !ValidTaskPoint(i+1)) { // final waypoint
	if (ActiveWayPoint>1) { 
	  // only draw finish line when past the first
	  // waypoint.
	  if(FinishLine) {
	    _DrawLine(hdc, PS_SOLID, NIBLSCALE(5), 
		      WayPointList[Task[i].Index].Screen,
		      Task[i].Start, taskcolor, rc);
	    _DrawLine(hdc, PS_SOLID, NIBLSCALE(5), 
		      WayPointList[Task[i].Index].Screen,
		      Task[i].End, taskcolor, rc);
	    _DrawLine(hdc, PS_SOLID, NIBLSCALE(1), 
		      WayPointList[Task[i].Index].Screen,
		      Task[i].Start, RGB(255,0,0), rc);
	    _DrawLine(hdc, PS_SOLID, NIBLSCALE(1), 
		      WayPointList[Task[i].Index].Screen,
		      Task[i].End, RGB(255,0,0), rc);
	  } else {
	    tmp = FinishRadius*ResMapScaleOverDistanceModify; 
	    SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
	    SelectObject(hdc, hpStartFinishThick);
	    Circle(hdc,
		   WayPointList[Task[i].Index].Screen.x,
		   WayPointList[Task[i].Index].Screen.y,
		   (int)tmp, rc, false, false); 
	    SelectObject(hdc, hpStartFinishThin);
	    Circle(hdc,
		   WayPointList[Task[i].Index].Screen.x,
		   WayPointList[Task[i].Index].Screen.y,
		   (int)tmp, rc, false, false); 
	  }        
	}
      } // final waypoint
      // DRAW TASK SECTORS
      if(ValidTaskPoint(i) && ValidTaskPoint(i+1)) { // normal sector
	if(AATEnabled != TRUE) {
	  _DrawLine(hdc, PS_DASH,NIBLSCALE(4), WayPointList[Task[i].Index].Screen, Task[i].Start, RGB_MAGENTA, rc); // 091216 127,127,127
	  _DrawLine(hdc, PS_DASH,NIBLSCALE(4), WayPointList[Task[i].Index].Screen, Task[i].End, RGB_MAGENTA, rc); // 091216

	  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH)); 
	  SelectObject(hdc, hpBearing); // 091216
	  if(SectorType== 0) {
	    tmp = SectorRadius*ResMapScaleOverDistanceModify;

	    Circle(hdc,
		   WayPointList[Task[i].Index].Screen.x,
		   WayPointList[Task[i].Index].Screen.y,
		   (int)tmp, rc, false, false); 

	  }
	  // FAI SECTOR
	  if(SectorType==1) {
	    tmp = SectorRadius*ResMapScaleOverDistanceModify;

	    Segment(hdc,
		    WayPointList[Task[i].Index].Screen.x,
		    WayPointList[Task[i].Index].Screen.y,(int)tmp, rc, 
		    Task[i].AATStartRadial-DisplayAngle, 
		    Task[i].AATFinishRadial-DisplayAngle); 

	  }
	  if(SectorType== 2) {
	    // JMW added german rules
	    tmp = 500*ResMapScaleOverDistanceModify;
	    Circle(hdc,
		   WayPointList[Task[i].Index].Screen.x,
		   WayPointList[Task[i].Index].Screen.y,
		   (int)tmp, rc, false, false); 

	    tmp = 10e3*ResMapScaleOverDistanceModify;
          
	    Segment(hdc,
		    WayPointList[Task[i].Index].Screen.x,
		    WayPointList[Task[i].Index].Screen.y,(int)tmp, rc, 
		    Task[i].AATStartRadial-DisplayAngle, 
		    Task[i].AATFinishRadial-DisplayAngle); 

	  }
	} else {
		// ELSE HERE IS   *** AAT ***
	  // JMW added iso lines
	  if ((i==ActiveWayPoint) || (TargetPan && (i==TargetPanIndex))) {
	    // JMW 20080616 flash arc line if very close to target
	    static bool flip = false;
	  
	    if (DerivedDrawInfo.WaypointDistance<AATCloseDistance()*2.0) {
	      flip = !flip;
	    } else {
	      flip = true;
	    }
	    if (flip) {
	      for (int j=0; j<MAXISOLINES-1; j++) {
		if (TaskStats[i].IsoLine_valid[j] 
		    && TaskStats[i].IsoLine_valid[j+1]) {
		  _DrawLine(hdc, PS_SOLID, NIBLSCALE(2), 
			    TaskStats[i].IsoLine_Screen[j], 
			    TaskStats[i].IsoLine_Screen[j+1],
			    RGB(0,0,255), rc);
		}
	      }
	    }
	  }
	}
      }
    }

    for(i=0;i<MAXTASKPOINTS-1;i++) {
      if(ValidTaskPoint(i) && ValidTaskPoint(i+1)) {
	bool is_first = (Task[i].Index < Task[i+1].Index);
	int imin = min(Task[i].Index,Task[i+1].Index);
	int imax = max(Task[i].Index,Task[i+1].Index);
	// JMW AAT!
	double bearing = Task[i].OutBound;
	POINT sct1, sct2;
	if (AATEnabled && !TargetPan) {
	  LatLon2Screen(Task[i].AATTargetLon, 
			Task[i].AATTargetLat, 
			sct1);
	  LatLon2Screen(Task[i+1].AATTargetLon, 
			Task[i+1].AATTargetLat, 
			sct2);
	  DistanceBearing(Task[i].AATTargetLat,
			  Task[i].AATTargetLon,
			  Task[i+1].AATTargetLat,
			  Task[i+1].AATTargetLon,
			  NULL, &bearing);

	  // draw nominal track line
	  DrawDashLine(hdc, NIBLSCALE(1),   // 091217
		       WayPointList[imin].Screen, 
		       WayPointList[imax].Screen, 
		       taskcolor, rc);
	} else {
	  sct1 = WayPointList[Task[i].Index].Screen;
	  sct2 = WayPointList[Task[i+1].Index].Screen;
	}

	if (is_first) {
	  DrawDashLine(hdc, NIBLSCALE(3), 
		       sct1, 
		       sct2, 
		       taskcolor, rc);
	} else {
	  DrawDashLine(hdc, NIBLSCALE(3), 
		       sct2, 
		       sct1, 
		       taskcolor, rc); 
	}

	// draw small arrow along task direction
	POINT p_p;
	POINT Arrow[2] = { {6,6}, {-6,6} };
	ScreenClosestPoint(sct1, sct2, 
			   Orig_Aircraft, &p_p, NIBLSCALE(25));
	PolygonRotateShift(Arrow, 2, p_p.x, p_p.y, 
			   bearing-DisplayAngle);

	_DrawLine(hdc, PS_SOLID, NIBLSCALE(2), Arrow[0], p_p, taskcolor, rc);
	_DrawLine(hdc, PS_SOLID, NIBLSCALE(2), Arrow[1], p_p, taskcolor, rc);
      }
    }
#ifdef HAVEEXCEPTIONS
  }__finally
#endif
     {
       UnlockTaskData();
     }

  // restore original color
  SetTextColor(hDCTemp, origcolor);

}


void MapWindow::DrawTaskAAT(HDC hdc, const RECT rc)
{
  int i;
  double tmp;

  if (!WayPointList) return;
  if (!AATEnabled) return;
  
  LockTaskData();  // protect from external task changes
#ifdef HAVEEXCEPTIONS
  __try{
#endif

    COLORREF whitecolor = RGB_WHITE;
    COLORREF origcolor = SetTextColor(hDCTemp, whitecolor);

    SelectObject(hDCTemp, (HBITMAP)hDrawBitMapTmp);

    SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
    SelectObject(hDCTemp, GetStockObject(WHITE_BRUSH));
    Rectangle(hDCTemp,rc.left,rc.top,rc.right,rc.bottom);
    
    for(i=MAXTASKPOINTS-2;i>0;i--)
      {
	if(ValidTaskPoint(i) && ValidTaskPoint(i+1)) {
	  if(Task[i].AATType == CIRCLE)
	    {
	      tmp = Task[i].AATCircleRadius*ResMapScaleOverDistanceModify;
          
	      // this color is used as the black bit
	      SetTextColor(hDCTemp, 
			   Colours[iAirspaceColour[AATASK]]);
          
	      // this color is the transparent bit
	      SetBkColor(hDCTemp, 
			 whitecolor);

	      if (i<ActiveWayPoint) {
		SelectObject(hDCTemp, GetStockObject(HOLLOW_BRUSH));
	      } else {
		SelectObject(hDCTemp, hAirspaceBrushes[iAirspaceBrush[AATASK]]);
	      }
	      SelectObject(hDCTemp, GetStockObject(BLACK_PEN));
          
	      Circle(hDCTemp,
		     WayPointList[Task[i].Index].Screen.x,
		     WayPointList[Task[i].Index].Screen.y,
		     (int)tmp, rc, true, true); 
	    }
	  else
	    {
          
	      // this color is used as the black bit
	      SetTextColor(hDCTemp, 
			   Colours[iAirspaceColour[AATASK]]);
          
	      // this color is the transparent bit
	      SetBkColor(hDCTemp, 
			 whitecolor);
          
	      if (i<ActiveWayPoint) {
		SelectObject(hDCTemp, GetStockObject(HOLLOW_BRUSH));
	      } else {
		SelectObject(hDCTemp, hAirspaceBrushes[iAirspaceBrush[AATASK]]);
	      }
	      SelectObject(hDCTemp, GetStockObject(BLACK_PEN));
          
	      tmp = Task[i].AATSectorRadius*ResMapScaleOverDistanceModify;
          
	      Segment(hDCTemp,
		      WayPointList[Task[i].Index].Screen.x,
		      WayPointList[Task[i].Index].Screen.y,(int)tmp, rc, 
		      Task[i].AATStartRadial-DisplayAngle, 
		      Task[i].AATFinishRadial-DisplayAngle); 
          
	      DrawSolidLine(hDCTemp,
			    WayPointList[Task[i].Index].Screen, Task[i].AATStart,
			    rc);
	      DrawSolidLine(hDCTemp,
			    WayPointList[Task[i].Index].Screen, Task[i].AATFinish,
			    rc);

	    }

	}
      }

    // restore original color
    SetTextColor(hDCTemp, origcolor);

#if (WINDOWSPC<1)
    TransparentImage(hdc,
		     rc.left,rc.top,
		     rc.right-rc.left,rc.bottom-rc.top,
		     hDCTemp,
		     rc.left,rc.top,
		     rc.right-rc.left,rc.bottom-rc.top,
		     whitecolor
		     );

#else
    TransparentBlt(hdc,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   hDCTemp,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   whitecolor
                   );
#endif
  
#ifdef HAVEEXCEPTIONS
  }__finally
#endif
     {
       UnlockTaskData();
     }
}


void MapWindow::DrawWindAtAircraft2(HDC hdc, const POINT Orig, const RECT rc) {
  int i;
  POINT Start;
  HPEN hpOld;
  HBRUSH hbOld; 
  TCHAR sTmp[12];
  static SIZE tsize = {0,0};
  
  if (DerivedDrawInfo.WindSpeed<1) {
    return; // JMW don't bother drawing it if not significant
  }
  
  if (tsize.cx == 0){

    HFONT oldFont = (HFONT)SelectObject(hdc, MapWindowBoldFont);
    GetTextExtentPoint(hdc, TEXT("99"), 2, &tsize);
    SelectObject(hdc, oldFont);
    tsize.cx = tsize.cx/2;
  }

  hpOld = (HPEN)SelectObject(hdc, hpWind);
  hbOld = (HBRUSH)SelectObject(hdc, hbWind);
  
  int wmag = iround(4.0*DerivedDrawInfo.WindSpeed);
  
  Start.y = Orig.y;
  Start.x = Orig.x;

  int kx = tsize.cx/InfoBoxLayout::scale/2;

  POINT Arrow[7] = { {0,-20}, {-6,-26}, {0,-20}, 
                     {6,-26}, {0,-20}, 
                     {8+kx, -24}, 
                     {-8-kx, -24}};

  for (i=1;i<4;i++)
    Arrow[i].y -= wmag;

  PolygonRotateShift(Arrow, 7, Start.x, Start.y, 
		     DerivedDrawInfo.WindBearing-DisplayAngle);

  if (WindArrowStyle==1) {
    POINT Tail[2] = {{0,-20}, {0,-26-min(20,wmag)*3}};
    double angle = AngleLimit360(DerivedDrawInfo.WindBearing-DisplayAngle);
    for(i=0; i<2; i++) {
      if (InfoBoxLayout::scale>1) {
        Tail[i].x *= InfoBoxLayout::scale;
        Tail[i].y *= InfoBoxLayout::scale;
      }
      protateshift(Tail[i], angle, Start.x, Start.y);
    }

    // optionally draw dashed line
    _DrawLine(hdc, PS_DASH, 1, Tail[0], Tail[1], RGB(0,0,0), rc);
  }

  if ( !(NewMap&&Look8000) || (DisplayMode == dmCircling) ) {

  	_itot(iround(DerivedDrawInfo.WindSpeed * SPEEDMODIFY), sTmp, 10);

  	TextInBoxMode_t TextInBoxMode = { 16 | 32 }; // JMW test {2 | 16};
  	if (Arrow[5].y>=Arrow[6].y) {
  	  TextInBox(hdc, sTmp, Arrow[5].x-kx, Arrow[5].y, 0, TextInBoxMode);
  	} else {
  	  TextInBox(hdc, sTmp, Arrow[6].x-kx, Arrow[6].y, 0, TextInBoxMode);
  	}

  }

  Polygon(hdc,Arrow,5);

  SelectObject(hdc, hbOld);
  SelectObject(hdc, hpOld);
}


void MapWindow::DrawBearing(HDC hdc, const RECT rc)
{

  #if OVERTARGET
  int overindex=GetOvertargetIndex();
  if (overindex<0) return;
/* REMOVE
  int overindex=-1;
  if (OvertargetMode >OVT_TASK) overindex=GetOvertargetIndex();
  if ( (!ValidTaskPoint(ActiveWayPoint)) && (overindex<0)) {
	return; 
  }
*/
  #else
  if (!ValidTaskPoint(ActiveWayPoint)) {
	return; 
  }
  LockTaskData();  // protect from external task changes
  #endif

  double startLat = DrawInfo.Latitude;
  double startLon = DrawInfo.Longitude;
  double targetLat;
  double targetLon;

  #if OVERTARGET
  if (overindex>OVT_TASK) {
  	LockTaskData();
	targetLat = WayPointList[overindex].Latitude;
	targetLon = WayPointList[overindex].Longitude; 
	UnlockTaskData();
	//  DrawGreatCircle(hdc, startLon, startLat, targetLon, targetLat, rc);
	//HPEN hpOld = (HPEN)SelectObject(hdc, hpOvertarget);
	HPEN hpOld = (HPEN)SelectObject(hdc, hpBearing);
	POINT pt[2];
	LatLon2Screen(startLon, startLat, pt[0]);
	LatLon2Screen(targetLon, targetLat, pt[1]);
	ClipPolygon(hdc, pt, 2, rc, false);
	SelectObject(hdc, hpOld);
	return; // remove return to let multiple destination lines drawn
  }
  if (!ValidTaskPoint(ActiveWayPoint)) {
	return; 
  }
  LockTaskData();
  #endif

  if (AATEnabled && (ActiveWayPoint>0) && ValidTaskPoint(ActiveWayPoint+1)) {
    targetLat = Task[ActiveWayPoint].AATTargetLat;
    targetLon = Task[ActiveWayPoint].AATTargetLon; 
  } else {
    targetLat = WayPointList[Task[ActiveWayPoint].Index].Latitude;
    targetLon = WayPointList[Task[ActiveWayPoint].Index].Longitude; 
  }
  UnlockTaskData();

  DrawGreatCircle(hdc, startLon, startLat,
                  targetLon, targetLat, rc);

  if (TargetPan) {
    // Draw all of task if in target pan mode
    startLat = targetLat;
    startLon = targetLon;

    LockTaskData();
    for (int i=ActiveWayPoint+1; i<MAXTASKPOINTS; i++) {
      if (ValidTaskPoint(i)) {

        if (AATEnabled && ValidTaskPoint(i+1)) {
          targetLat = Task[i].AATTargetLat;
          targetLon = Task[i].AATTargetLon; 
        } else {
          targetLat = WayPointList[Task[i].Index].Latitude;
          targetLon = WayPointList[Task[i].Index].Longitude; 
        }
       
        DrawGreatCircle(hdc, startLon, startLat,
                        targetLon, targetLat, rc);

        startLat = targetLat;
        startLon = targetLon;
      }
    }

    // JMW draw symbol at target, makes it easier to see

    if (AATEnabled) {
      for (int i=ActiveWayPoint+1; i<MAXTASKPOINTS; i++) {
        if(ValidTaskPoint(i) && ValidTaskPoint(i+1)) {
          if (i>= ActiveWayPoint) {
            POINT sct;
            LatLon2Screen(Task[i].AATTargetLon, 
                          Task[i].AATTargetLat, 
                          sct);
            DrawBitmapIn(hdc, sct, hBmpTarget);
          }
        }
      }
    }

    UnlockTaskData();

  }

  if (AATEnabled) {
    LockTaskData();
    if (ValidTaskPoint(ActiveWayPoint+1) && (ActiveWayPoint>0)) {
      POINT sct;
      LatLon2Screen(Task[ActiveWayPoint].AATTargetLon, 
                    Task[ActiveWayPoint].AATTargetLat, 
                    sct);
      DrawBitmapIn(hdc, sct, hBmpTarget);
    }
    UnlockTaskData();
  }
}


double MapWindow::GetApproxScreenRange() {
  return (MapScale * max(MapRectBig.right-MapRectBig.left,
                         MapRectBig.bottom-MapRectBig.top))
    *1000.0/GetMapResolutionFactor();
}




extern bool ScreenBlanked;

bool MapWindow::IsDisplayRunning() {
  return (THREADRUNNING && GlobalRunning && !ScreenBlanked && ProgramStarted);
}


void MapWindow::CreateDrawingThread(void)
{
  CLOSETHREAD = FALSE;
  THREADEXIT = FALSE;
  hDrawThread = CreateThread (NULL, 0,  
                              (LPTHREAD_START_ROUTINE )MapWindow::DrawThread, 
                              0, 0, &dwDrawThreadID);
  SetThreadPriority(hDrawThread,THREAD_PRIORITY_NORMAL);
}

void MapWindow::SuspendDrawingThread(void)
{
  LockTerrainDataGraphics();
  THREADRUNNING = FALSE;
  UnlockTerrainDataGraphics();
  //  SuspendThread(hDrawThread);
}

void MapWindow::ResumeDrawingThread(void)
{
  LockTerrainDataGraphics();
  THREADRUNNING = TRUE;
  UnlockTerrainDataGraphics();
  //  ResumeThread(hDrawThread);
}

void MapWindow::CloseDrawingThread(void)
{
  CLOSETHREAD = TRUE;
  SetEvent(drawTriggerEvent); // wake self up
  LockTerrainDataGraphics();
  SuspendDrawingThread();
  UnlockTerrainDataGraphics();
  while(!THREADEXIT) { Sleep(100); };
}





bool MapWindow::PointInRect(const double &lon, const double &lat,
                            const rectObj &bounds) {
  if ((lon> bounds.minx) &&
      (lon< bounds.maxx) &&
      (lat> bounds.miny) &&
      (lat< bounds.maxy)) 
    return true;
  else
    return false;
}


bool MapWindow::PointVisible(const double &lon, const double &lat) {
  if ((lon> screenbounds_latlon.minx) &&
      (lon< screenbounds_latlon.maxx) &&
      (lat> screenbounds_latlon.miny) &&
      (lat< screenbounds_latlon.maxy)) 
    return true;
  else
    return false;
}


bool MapWindow::PointVisible(const POINT &P)
{
  if(( P.x >= MapRect.left ) 
     &&
     ( P.x <= MapRect.right ) 
     &&
     ( P.y >= MapRect.top  ) 
     &&
     ( P.y <= MapRect.bottom  ) 
     )
    return TRUE;
  else
    return FALSE;
}


void MapWindow::DisplayAirspaceWarning(int Type, TCHAR *Name , 
                                       AIRSPACE_ALT Base, AIRSPACE_ALT Top )
{
  TCHAR szMessageBuffer[1024];
  TCHAR szTitleBuffer[1024];
  
  FormatWarningString(Type, Name , Base, Top, szMessageBuffer, szTitleBuffer );

  DoStatusMessage(TEXT("Airspace Query"), szMessageBuffer);
}


// RETURNS Longitude, Latitude!

void MapWindow::OrigScreen2LatLon(const int &x, const int &y, 
                                  double &X, double &Y) 
{
  int sx = x;
  int sy = y;
  irotate(sx, sy, DisplayAngle);
  Y= PanLatitude  - sy*InvDrawScale;
  X= PanLongitude + sx*invfastcosine(Y)*InvDrawScale;
}


void MapWindow::Screen2LatLon(const int &x, const int &y, 
                              double &X, double &Y) 
{
  int sx = x-(int)Orig_Screen.x;
  int sy = y-(int)Orig_Screen.y;
  irotate(sx, sy, DisplayAngle);
  Y= PanLatitude  - sy*InvDrawScale;
  X= PanLongitude + sx*invfastcosine(Y)*InvDrawScale;
}

void MapWindow::LatLon2Screen(const double &lon, const double &lat, 
                              POINT &sc) {
  int Y = Real2Int((PanLatitude-lat)*DrawScale);
  int X = Real2Int((PanLongitude-lon)*fastcosine(lat)*DrawScale);
    
  irotate(X, Y, DisplayAngle);
    
  sc.x = Orig_Screen.x - X;
  sc.y = Orig_Screen.y + Y;
}

// This one is optimised for long polygons
void MapWindow::LatLon2Screen(pointObj *ptin, POINT *ptout, const int n,
			      const int skip) {
  static double lastangle = -1;
  static int cost=1024, sint=0;
  const double mDisplayAngle = DisplayAngle;

  if(mDisplayAngle != lastangle) {
    lastangle = mDisplayAngle;
    int deg = DEG_TO_INT(AngleLimit360(mDisplayAngle));
    cost = ICOSTABLE[deg];
    sint = ISINETABLE[deg];
  }
  const int xxs = Orig_Screen.x*1024-512;
  const int yys = Orig_Screen.y*1024+512;
  const double mDrawScale = DrawScale;
  const double mPanLongitude = PanLongitude;
  const double mPanLatitude = PanLatitude;
  pointObj* p = ptin;
  const pointObj* ptend = ptin+n;

  while (p<ptend) {
    int Y = Real2Int((mPanLatitude-p->y)*mDrawScale);
    int X = Real2Int((mPanLongitude-p->x)*fastcosine(p->y)*mDrawScale);
    ptout->x = (xxs-X*cost + Y*sint)/1024;
    ptout->y = (Y*cost + X*sint + yys)/1024;
    ptout++;
    p+= skip;
  }
}


void MapWindow::_Polyline(HDC hdc, POINT* pt, const int npoints, 
			  const RECT rc) {
#ifdef BUG_IN_CLIPPING
  ClipPolygon(hdc, pt, npoints, rc, false);
  //VENTA2
#elif defined(PNA)
  // if (GlobalModelType == MODELTYPE_PNA_HP31X)
  if (needclipping==true)
    ClipPolygon(hdc, pt, npoints, rc, false);
  else
    Polyline(hdc, pt, npoints);
#else
  Polyline(hdc, pt, npoints);
#endif
}

void MapWindow::DrawSolidLine(const HDC& hdc, const POINT &ptStart, 
                              const POINT &ptEnd, const RECT rc)
{
  POINT pt[2];
  
  pt[0].x= ptStart.x;
  pt[0].y= ptStart.y;
  pt[1].x= ptEnd.x;
  pt[1].y= ptEnd.y;

  _Polyline(hdc, pt, 2, rc);
} 


void MapWindow::_DrawLine(HDC hdc, const int PenStyle, const int width, 
			  const POINT ptStart, const POINT ptEnd, 
			  const COLORREF cr, 
			  const RECT rc) {

  HPEN hpDash,hpOld;
  POINT pt[2];
  //Create a dot pen
  hpDash = (HPEN)CreatePen(PenStyle, width, cr);
  hpOld = (HPEN)SelectObject(hdc, hpDash);

  pt[0].x = ptStart.x;
  pt[0].y = ptStart.y;
  pt[1].x = ptEnd.x;
  pt[1].y = ptEnd.y;

  _Polyline(hdc, pt, 2, rc);

  SelectObject(hdc, hpOld);
  DeleteObject((HPEN)hpDash);
}


void MapWindow::DrawDashLine(HDC hdc, const int width, 
			     const POINT ptStart, const POINT ptEnd, const COLORREF cr,
			     const RECT rc)
{
  int i;
  HPEN hpDash,hpOld;
  POINT pt[2];
  //Create a dot pen
  hpDash = (HPEN)CreatePen(PS_DASH, 1, cr);
  hpOld = (HPEN)SelectObject(hdc, hpDash);

  pt[0].x = ptStart.x;
  pt[0].y = ptStart.y;
  pt[1].x = ptEnd.x;
  pt[1].y = ptEnd.y;
  
  //increment on smallest variance
  if(abs(ptStart.x - ptEnd.x) < abs(ptStart.y - ptEnd.y)){
    for (i = 0; i < width; i++){
      pt[0].x += 1;
      pt[1].x += 1;     
      _Polyline(hdc, pt, 2, rc);
    }   
  } else {
    for (i = 0; i < width; i++){
      pt[0].y += 1;
      pt[1].y += 1;     
      _Polyline(hdc, pt, 2, rc);
    }   
  }
  
  SelectObject(hdc, hpOld);
  DeleteObject((HPEN)hpDash);
  
} 


/* Not used
   void DrawDotLine(HDC hdc, POINT ptStart, POINT ptEnd, COLORREF cr,
   const RECT rc)
   {
   HPEN hpDot, hpOld;
   LOGPEN dashLogPen;
   POINT pt[2];
   //Create a dot pen
   dashLogPen.lopnColor = cr;
   dashLogPen.lopnStyle = PS_DOT;
   dashLogPen.lopnWidth.x = 0;
   dashLogPen.lopnWidth.y = 0;

   hpDot = (HPEN)CreatePenIndirect(&dashLogPen);
   hpOld = (HPEN)SelectObject(hdc, hpDot);

   pt[0].x = ptStart.x;
   pt[0].y = ptStart.y;
   pt[1].x = ptEnd.x;
   pt[1].y = ptEnd.y;
  
   Polyline(hdc, pt, 2);
  
   SelectObject(hdc, hpOld);
   DeleteObject((HPEN)hpDot);
   } 

*/

@


8.27
log
@*** empty log message ***
@
text
@d2 3
a4 1
Copyright_License {
d6 1
a6 32
  XCSoar Glide Computer - http://xcsoar.sourceforge.net/
  Copyright (C) 2000 - 2008  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  $Id: MapWindow.cpp,v 8.26 2010/11/03 11:31:44 root Exp root $
}
d16 1
d38 1
d58 3
a85 2
///:extern bool goCalculating; // 100207

a87 1
///: LKPMODE is portraing mode new, not used now
d96 1
a96 1
#define ISPARAGLIDER (AircraftCategory == (AircraftCategory_t)umParaglider)
a113 1
///////////////////////////////// Initialisation
a300 1
/////////////////////////////////
a324 1
///////////////////
a370 2
///////////////////

a450 9
  ///: static double CruiseMapScale = 10;  // < 090621
  ///: static double CruiseMapScale = MapWindow::RequestMapScale*2; // 090621 
  ///: static double CruiseMapScale = MapWindow::RequestMapScale*2; // BUGFIX 091023
  ///: static double CruiseMapScale=1; 100512 NOW GLOBAL

  ///: static double ClimbMapScale = 0.25; // < 090621
  ///: static double ClimbMapScale = MapWindow::RequestMapScale/20; // 090621
  ///: static double ClimbMapScale = MapWindow::RequestMapScale/20; // BUGFIX 091023
  ///: static double ClimbMapScale=1; 100512 NOW GLOBAL
a456 6
///: 091017 BUGFIX REMOVE
///: if (ISPARAGLIDER) {
///:  CruiseMapScale = MapWindow::RequestMapScale;
///:  ClimbMapScale = MapWindow::RequestMapScale/40;
///: }

a457 1
#if 1
a458 24
#else
	// REMOVE ALL
	if (ISPARAGLIDER) {
		CruiseMapScale = MapWindow::RequestMapScale;
		///: ClimbMapScale = MapWindow::RequestMapScale/40; // 091023 TESTFIX
		///: ClimbMapScale = 0.07; // 091108 changed from 0.05

		switch(PGClimbZoom) {
			case 0:
				ClimbMapScale = 0.05; 
				break;
			case 1:
				ClimbMapScale = 0.07; 
				break;
			case 2:
			default:
				ClimbMapScale = 0.09; 
				break;
		}
	} else {
		CruiseMapScale = MapWindow::RequestMapScale*2;
		ClimbMapScale = MapWindow::RequestMapScale/20;
	}
#endif
a724 1
      ///: COLORREF oldColor = SetBkColor(hDC, RGB(0xff, 0xff, 0xff));
d734 1
a734 2
#if 100621
	///: This is duplicated later on!
a762 16
#else
	case (DeclutterMode_t)dmHigh:
	    brect.left = x-2;
	    brect.right = brect.left+tsize.cx+4;
	    brect.top = y+((tsize.cy+4)>>3)-2;
	    brect.bottom = brect.top+3+tsize.cy-((tsize.cy+4)>>3);
	    break;
	case (DeclutterMode_t)dmLow:
	    brect.left = x;
	    brect.right = brect.left+tsize.cx;
	    brect.top = y+((tsize.cy)>>3);
	    brect.bottom = brect.top+tsize.cy-((tsize.cy)>>3);
	    break;
	default:
	    break;
#endif
d841 1
a841 2
#if 100621
	///: This is duplicated before!
a869 16
#else
	case (DeclutterMode_t)dmHigh:
	    brect.left = x-2;
	    brect.right = brect.left+tsize.cx+4;
	    brect.top = y+((tsize.cy+4)>>3)-2;
	    brect.bottom = brect.top+3+tsize.cy-((tsize.cy+4)>>3);
	    break;
	case (DeclutterMode_t)dmLow:
	    brect.left = x; 
	    brect.right = brect.left+tsize.cx;
	    brect.top = y+((tsize.cy)>>3);
	    brect.bottom = brect.top+tsize.cy-((tsize.cy)>>3);
	    break;
	default:
	    break;
#endif
a969 2
///////////////////////////////////////////////////////////////////////////

a1060 11
/*    
    if (EnableTopology)
      _stprintf(buf, TEXT("\r\n%s / "), gettext(TEXT("ON")));
    else
      _stprintf(buf, TEXT("\r\n%s / "), gettext(TEXT("OFF")));
    
    if (EnableTerrain)
      _stprintf(buf+_tcslen(buf), TEXT("%s"), gettext(TEXT("ON")));
    else
      _stprintf(buf+_tcslen(buf), TEXT("%s"), gettext(TEXT("OFF")));
*/
a1195 1
  ///: 100924
a1201 5
#if (0)
    TCHAR m2buf[100];
    _stprintf(m2buf,_T("oldzoom=%.3f"),RequestMapScale);
    DoStatusMessage(m2buf);
#endif
a1235 6
#if (0)
    TCHAR m3buf[100];
    _stprintf(m3buf,_T("Limit=%.3f"),RequestMapScale);
    DoStatusMessage(m3buf);
#endif

a1239 7
#if (0)
    TCHAR mbuf[100];
    _stprintf(mbuf,_T("zoom=%.3f"),RequestMapScale);
    DoStatusMessage(mbuf);
#endif


a1300 2
///////////////////////////////////////////////////////////////////////////

d1314 2
a1315 2
  SetBkColor(hDC,RGB(0xff,0xff,0xff));
  SetTextColor(hDC,RGB(0x00,0x00,0x00));
d1328 1
a1328 1
      if ((GetPixel(hDC, x, y)) != RGB(0xff,0xff,0xff)){
a1366 2
  ///: in landscape mode, we don't use infoboxes to toggle mapspace? TODO
  ///: if (InfoBoxLayout::landscape
d1375 2
a1376 3
  #if 100228
  ///: Attention... this is duplicated inside Utils2, I am lazy 
  ///: 100923 apparently only #include is duplicated, so no problems
a1378 16
  #else
  #define AIRCRAFTMENUSIZE	NIBLSCALE(28)
  #define COMPASSMENUSIZE	NIBLSCALE(28)
  #endif

#if 0
  static bool doinit=true;

  if (doinit) {
	doinit=false;
 091125 Bug, we need to optimize it later on
	///: keep looking for an initialised BottomSize
	if (BottomSize > 1) doinit=false;
	navboxesY=(MapWindow::MapRect.bottom-MapWindow::MapRect.top)-BottomSize-IBLSCALE(2);
  }
#endif
d1451 13
a1464 3
      ///: hInvBackgroundBrush = CreateSolidBrush(InvBackgroundColor); 091110
      ///: We create here all backgrounds for non terrained map  091110
      ///: BgMapcolor is used to select one of these, and set LKTextBlack accordingly
d1472 1
a1472 1
      ///: BlackScreen requested for white waypoints, no topology working
d1476 1
d1491 1
a1491 2
      //if (Appearance.FlightModeIcon == apFlightModeIconAltA){
      if ( AircraftCategory == (AircraftCategory_t)umParaglider ) {
a1549 1
	///: 091130 new snail trail colors
a1584 2
      ///: hpCompassBorder = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(3), RGB(0xff,0xff,0xff)); fixed 100920
      hpCompassBorder = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB_BLACK); 
d1588 13
d1609 1
d1611 1
d1613 1
a1613 1
      hpWind = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB(0,0,0));
d1615 1
a1615 1
      hpWind = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB(255,0,0));
d1617 7
d1625 1
a1625 2
      hpWindThick = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(4), 
				    RGB(255,220,220));
d1627 7
a1633 4
      hpBearing = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), 
				  RGB(0,0,0));
      hpBestCruiseTrack = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), 
					  RGB(0,0,255));
d1635 1
a1635 7
      hpCompass = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), RGB(0x00,0x00,0x00));
      //hpCompass = (HPEN)CreatePen(PS_SOLID, 1, RGB(0xff,0xff,0xff));
	/*
	#if OVERTARGET
	hpOvertarget = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(2), RGB_RED);
	#endif
	*/
a1637 5
	/*
	#if OVERTARGET
	hpOvertarget = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(4), RGB_MAGENTA);
	#endif
	*/
d1648 16
a1663 20
      hpSpeedSlow=(HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), 
				  RGB(0xFF,0x00,0x00));
      hpSpeedFast=(HPEN)CreatePen(PS_SOLID, NIBLSCALE(1), 
				  RGB(0x00,0xFF,0x00));

      hpStartFinishThick=(HPEN)CreatePen(PS_SOLID, NIBLSCALE(5),
					 taskcolor);

      hpStartFinishThin=(HPEN)CreatePen(PS_SOLID, NIBLSCALE(1),
					RGB(255,0,0));

      hpMapScale = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1),  
				   RGB(0,0,0));
      // VENTA7
      hpMapScale2 = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(1)+1,  
				   RGB(0,0,0));
#if 100423
	///: TerrainLine is for shade, Bg is for perimeter
      ///: hpTerrainLine = (HPEN)CreatePen(PS_SOLID, (2), RGB(0,0,0)); changed 100923
      ///: hpTerrainLineBg = (HPEN)CreatePen(PS_SOLID, (2), RGB_BLACK);
d1666 23
a1688 11
#else
      hpTerrainLine = (HPEN)CreatePen(PS_DASH, (1), 
				      RGB(0x30,0x30,0x30));
      hpTerrainLineBg = (HPEN)CreatePen(PS_SOLID, (1), 
					RGB(0xFF,0xFF,0xFF));
#endif
      // VENTA3
      hpVisualGlideLightBlack = (HPEN)CreatePen(PS_DASH, (1), RGB(0x0,0x0,0x0));
      hpVisualGlideHeavyBlack = (HPEN)CreatePen(PS_DASH, (2), RGB(0x0,0x0,0x0));
      hpVisualGlideLightRed = (HPEN)CreatePen(PS_DASH, (1), RGB(0xff,0x0,0x0));
      hpVisualGlideHeavyRed = (HPEN)CreatePen(PS_DASH, (2), RGB(0xff,0x0,0x0));
d1690 4
a1693 3
#if (MONOCHROME_SCREEN > 0)
      hbCompass=(HBRUSH)CreateSolidBrush(RGB(0xff,0xff,0xff));
#else
d1695 4
a1698 4
#endif
      hbThermalBand=(HBRUSH)CreateSolidBrush(RGB(0x80,0x80,0xFF));
      hbBestCruiseTrack=(HBRUSH)CreateSolidBrush(RGB(0x0,0x0,0xFF));
      hbFinalGlideBelow=(HBRUSH)CreateSolidBrush(RGB(0xFF,0x00,0x00));
d1700 5
a1704 1
      hbFinalGlideAbove=(HBRUSH)CreateSolidBrush(RGB(0x00,0xFF,0x00));
d1706 1
a1707 5
#if (MONOCHROME_SCREEN > 0)
      hbWind=(HBRUSH)CreateSolidBrush(RGB(0x80,0x80,0x80));
#else
      hbWind=(HBRUSH)CreateSolidBrush(RGB(0x80,0x80,0x80));
#endif
d1714 5
a1718 1
      hBrushFlyingModeAbort = (HBRUSH)CreateSolidBrush(RGB(0xff,0x00,0x00));
a1765 3
      DeleteObject((HPEN)hpAircraft);
      DeleteObject((HPEN)hpAircraftBorder);
      DeleteObject((HPEN)hpWind);
d1767 3
d1771 4
a1774 3
      DeleteObject((HPEN)hpBestCruiseTrack);
      DeleteObject((HPEN)hpCompass);

d1776 5
a1789 2
      DeleteObject((HPEN)hpFinalGlideBelowLandable);
      DeleteObject((HPEN)hpMapScale);
a1791 2
      DeleteObject((HPEN)hpSpeedFast);
      DeleteObject((HPEN)hpSpeedSlow);
a1792 1
      DeleteObject((HPEN)hpStartFinishThin);
d1798 1
d1800 1
a1804 1
      DeleteObject((HBRUSH)hbFinalGlideBelowLandable);
d1807 1
d1811 2
d1824 2
a1828 1
      DeleteObject((HBRUSH)hBrushFlyingModeAbort);
a1859 2
      // Added by ARH to show menu button when mapwindow is double clicked.
      //
d1863 1
a1863 1
      ///: Attention please: a DBLCLK is followed by a simple BUTTONUP with NO buttondown.
d1868 3
a1870 3
      ///: Careful! If you ignorenext, any event timed as double click of course will be affected.
      ///: and this means also fast clicking on bottombar!!
      ///: so first lets see if we are in lk8000 text screens.. 
d1872 1
a1872 1
		///: do not ignore next, let buttonup get the signal
d1880 2
a1881 2
		///: ignorenext only when expecting a double click when map is locked! 100318
        	ignorenext=true; // 100318
d1884 1
a1884 1
		        ///: Unlock map only if double clicking on real map, not on navboxes!
d1893 1
a1893 2
		///: OLD FALSE: else we are double clicking on the lk8000 navboxes and we pullup showmenu
		///: REAL Else: old screen mode, dblclk on real map, unlock..
d1928 1
a1928 1
      ///: After calling a menu, on exit as we touch the screen we fall back here
a1965 4
	///: ATTEMPT TO FIX DELAYED RESPONSES WITH TESTFIX 090930
	///: critic: a DBLCLK is followed by a simple BUTTONUP with NO buttondown.
	///: 090930 dwDownTime should be 0 only when no previous dblclk or buttondown.
	///: BUT afdter calling showmenu, after closing menu dbg099 appears. Check it..
a1989 6
/*
	TCHAR buf[80];
	wsprintf(buf,_T("Ys=%d Y=%d Xs=%d X=%d dist=%d Interval %ldms"),YstartScreen, Y, XstartScreen, X, gestDist, dwInterval);
        DoStatusMessage(buf);
*/

d1994 3
a1996 3
		///: GESTURE DETECTION
		///: if gestX >0 gesture from right to left , gestX <0 gesture from left to right
		///: if gestY >0 gesture from down to up ,    gestY <0 gesture from up to down
d2000 1
a2000 1
			///: horizontal includes also perfectly diagonal gestures
d2002 1
a2002 1
				///: we use LKGESTURE definition, but they have nothing to do with those used in other part of source code
d2014 1
a2014 1
		///: end dontdrawthemap and inside mapscreen looking for a gesture
d2017 1
a2017 4
      ///:
      ///: Process Active Icons
      ///:
	#if 100228
a2021 1
	#endif
a2028 1
      ///: VNT10 090909 using AIRCRAFTMENUSIZE 
d2038 2
a2039 5
	//if ( dwInterval < DOUBLECLICKINTERVAL) {
		///:
		///: short click on aircraft icon
		///:
		///: if ( dwInterval < (DOUBLECLICKINTERVAL*2)) {  TESTFIX 091017 shorten period 
a2045 1
			// ignorenext=true; // TESTFIX 090930  BUGFIX 091002 removed!
d2048 2
a2049 3
		///:
		///: Long click on aircraft icon, toggle thermal mode
		///:
d2066 1
a2066 3
			#if 100512
			///: 100512 use CustomKeyHandler for aircrafticon as well
			///: We are here in any case only when dwInterval is <VKLONGCLICK
a2067 1
				///: 3 is aircraft icon key
a2070 10
			#else
			///: 100512 old style click
			if (!ShortcutIbox) goto goto_menu;
			///: toggle old infobox mode on/off 091016
			MapWindow::RequestToggleFullScreen();
			#ifndef DISABLEAUDIO
			if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_BELL"));
			#endif
			break;
			#endif
d2073 1
a2073 1
      ///: end aircraft icon check				
d2075 1
a2075 3
	///: 100920 BUGFIX FOUND! Should work only in fullscreen mode!!
	if (mapmode8000) {  // 100920
	///: 100316 zoomout for everybody in 1.20b
a2076 25
		#if 0 // 100920
		///: This is now inside Utils2 as customkey REMOVABLE HERE! TODO
		if ((dwInterval >= DOUBLECLICKINTERVAL) ) {
			#if 0 // go using UTM recall instead
			///: if we are running a real task, with gates, and we could still start
			if (UseGates() && ValidTaskPoint(1) && ActiveWayPoint<2) { // 100507
				ResetTask();
			} else {
			#endif
				if (PGZoomTrigger==false)
					PGZoomTrigger=true;
				else
					LastZoomTrigger=0;
				 #ifndef DISABLEAUDIO
                        	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
                        	#endif
				break;
			#if 0
			}
			#endif
		} 
		#else
		///: 100920 making customkey TODO TEST
		///: if ((dwInterval >= DOUBLECLICKINTERVAL) ) { // No need, hopefully CHECK
			///: if (dwInterval >=(unsigned)CustomKeyTime) {
d2082 2
a2083 2
			///: we can have problems if fast double clicks?
			///: zoom in
a2088 3
			///: }
		///:}
		#endif
d2092 1
a2092 20
	#if 0 // 100316
	///: 100309 top left click to zoomout 20s
	if ( (X <= (MapRect.left + COMPASSMENUSIZE)) && (Y <= (MapRect.top+COMPASSMENUSIZE)) ) {
		if ((dwInterval >= DOUBLECLICKINTERVAL) ) {
		///: if ((dwInterval >= VKSHORTCLICK) ) { buona idea ma da migliorare
			PGZoomTrigger=true;
			 #ifndef DISABLEAUDIO
                        if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
                        #endif
			///: 100309 test, funziona ma i doubleclick rendono inutilizzabile..
			/*
	    		wParam = 0x26;	// + key = pg Up
			InputEvents::processKey(wParam);
			return TRUE;
			*/
			break;
		} 
	} else 
	#endif
	///: 091129 Use the compass to pullup UTM informations to paragliders
d2099 1
a2099 1
			///: if we are running a real task, with gates, and we could still start
a2105 1
			///: unshifted code
a2115 1
			///: Message::Unlock(); 091218
a2120 1
			///: Message::Lock(); // 091211  091218
d2131 2
a2132 2
	///: else not a paraglider key, process it for gliders, new 100920
	else {  // 100920
d2139 1
a2139 1
				///: we can have problems if fast double clicks?
d2146 1
a2146 1
		///: if not topright, continue
d2148 3
a2150 3
	///: 100920 do all of this only if !dontdrawthemap = we are in fullscreen and not PAN etc.
	///: indentation is wrong here
	} // 100920
d2153 2
a2154 2
	///: "fast virtual keys" are handled locally and not passed to event handler.
	///: they are processed even when virtual keys are disabled, because they concern special lk8000 menus.
d2156 1
a2156 1
	///: First case: for mapspacemodes we manage gestures as well
a2159 2
			///:wsprintf(ventabuf,_T("Vgsize=%d move up %d"),VerticalGestureSize,YstartScreen-Y);
			///:DoStatusMessage(ventabuf);
a2163 2
			///:wsprintf(ventabuf,_T("Vgsize=%d move down %d"),VerticalGestureSize,Y-YstartScreen);
			///:DoStatusMessage(ventabuf);
a2167 2
			///:wsprintf(ventabuf,_T("Hgsize=%d move left %d"),HorizontalGestureSize,XstartScreen-X);
			///:DoStatusMessage(ventabuf);
a2171 2
			///:wsprintf(ventabuf,_T("Hgsize=%d move right %d"),HorizontalGestureSize,X-XstartScreen);
			///:DoStatusMessage(ventabuf);
d2177 2
a2178 2
		///: We are here when lk8000, and NO moving map displayed: virtual enter, virtual up/down, or 
		///: navbox operations including center key.
d2183 2
a2184 2
		///: TODO we could use a single ProcessVirtual for all above, and check that wParam on return
		///: is really correct for gestures as well... since we do not want to go to wirth with gestures!
a2185 1
			//#ifdef DEBUG_VIRTUALKEYS
a2186 1
			//#endif
d2189 1
a2189 2
		//goto Wirth;
		break; // TESTFIX 090930
d2193 3
a2195 4
	///: if clicking on navboxes, process fast virtual keys
	///: maybe check LK8000 active?
	///: This point is selected when in MapSpaceMode==MSM_MAP, i.e. lk8000 with moving map on.
	///: if (  DrawBottom && IsMapFullScreen() && (Y >= (rc.bottom-BottomSize)) ) { BUGFIX 100320
a2201 1
			//#ifdef DEBUG_VIRTUALKEYS
a2202 1
			//#endif
d2205 1
a2205 3
		///: or break??
		//goto Wirth; 
		break; // TESTFIX 090930
d2210 1
a2210 3
      ///: end newmap preliminar checks
      } 

d2214 3
a2216 4
		///: With LOCKED map...
		///: When you single click on the map, here you come.
		///: When you press double click to release lock, you fall here, also.
		///: DoStatusMessage(_T("DBG-035-A")); 
a2218 4
		///: proviamo a velocizzare un po
	      ///: if ((VirtualKeys==(VirtualKeys_t)vkEnabled) ) {  TESTFIX 091019 non va
		///: dblclk does NOT come here.
		///: DoStatusMessage(_T("DBG-035-B")); 
d2221 2
a2222 2
				///: Here we fall when you press for example long center map or do a gesture
				///: DoStatusMessage(_T("ERR-035 Invalid Virtual Key"));
d2225 1
a2225 1
			///: Otherwise its a vk up/down/enter and must be handled, passing vk code down
a2226 1
			///: break; // TESTFIX 090930 BUGFIX 091019
d2229 2
a2230 2
	  ///: while locked, any keypress on the map which is not a virtual key will unfocus infoboxes
	  ///: but first check if it was already unfocused so you will not play a click 
d2238 1
a2238 1
		 ///: DoStatusMessage(_T("Map is locked, defocus ibox")); 
d2240 1
a2240 3
		///:
		///: newmap on, maplock on, NO VK, special case 
		///:
d2242 1
a2242 1
			goto Escamotage; // temporarily dedicated to MaxK
d2244 1
a2244 1
		///: DoStatusMessage(_T("Map is locked, skipping")); 
a2249 1
		///: DoStatusMessage(_T("DBG-096 dwInterval==0"));  // 091020 TODO still to be investigated
d2253 1
a2253 1
	///: we need to calculate it here only if needed TESTFIX 090930
d2266 1
a2266 1
	///: Handling double click passthrough
d2269 1
a2269 1
      ///: On PC a single click is around 80ms, and a doubleclick is around 150ms. 
d2272 2
a2273 2
	///: This is called when long press in center map i.e. for inverting colors, 
	///: and for Virtual keys zoom in/out
a2285 15
#if (0)
	///: TESTFIX 091019 maplock fast response
	///: With maplock active, no need to wait for virtual keys..
      if ((VirtualKeys==(VirtualKeys_t)vkEnabled) && distance<50 && UseMapLock && MapLock ) { 
		wParam=ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
		if (wParam==0) {
			#ifdef DEBUG_VIRTUALKEYS
			DoStatusMessage(_T("DBG-095 invalid Virtual Key!")); 
			#endif
			break;
		}
		//break; // TESTFIX 090930
		goto Wirth; 
      }
#endif
d2287 2
a2288 2
      ///: Process faster clicks here and no precision, but let DBLCLK pass through
      ///: VK are used in the bottom line in this case, forced on for this situation.
d2291 1
a2291 1
		///: DoStatusMessage(_T("Click on hidden map ignored")); 
d2293 3
a2295 3
		///: do not process virtual key if it is timed as a DBLCLK
		///: we want users to get used to double clicking only on infoboxes
		///: and avoid triggering unwanted waypoints details
d2306 1
a2306 2
			//goto Wirth; 
			break; // TESTFIX 090930
d2308 1
a2308 1
		///: do not process click on the underneath window
a2311 1
      ///: a SINGLE click gets here only if timed < DOUBLECLICKINTERVAL/2-30 , i.e.about 145ms ? NONO
d2326 1
a2326 1
	///: disable picking when in pan mode
d2336 6
a2341 4
	if ((fabs(AngleLimit180(newbearing-oldbearing))<30) 
	    || (GPS_INFO.Speed<minspeed)) {
	  GPS_INFO.Speed = min(100.0,max(minspeed,distance/3));
	  // 20080817 JMW change speed only if in direction
a2343 4
	// change bearing without changing speed if direction change > 30
	// 20080815 JMW prevent dragging to stop glider
      
	// JMW trigger recalcs immediately
d2357 2
a2358 4
	if ((fabs(AngleLimit180(newbearing-oldbearing))<30) 
	    || (GPS_INFO.Speed<minspeed)) {
	  GPS_INFO.Speed = min(100.0,max(minspeed,distance/3));
	  // 20080817 JMW change speed only if in direction
a2360 4
	// change bearing without changing speed if direction change > 30
	// 20080815 JMW prevent dragging to stop glider
      
	// JMW trigger recalcs immediately
d2368 4
a2371 4
		///: if map is locked and we are here, then if infobox are under focus accept the click
		///: as an order to defocus. Otherwise since we are under lock condition we simply
		///: ignore the click and break out.
		///:
d2374 1
a2374 1
				///: DoStatusMessage(_T("Map is locked, defocus ibox")); 
d2383 1
a2383 1
				///: DoStatusMessage(_T("PAN map is locked, skipping")); 
d2387 5
a2391 5
		///:
		///: We need to defocus infoboxes on demand here.  
		///: Probably should be a good idea to use it also for standard old map with no VK
		///: We do it also for old standard map with no VK.
		///:
d2393 1
a2393 1
			///: DoStatusMessage(_T("Defocus ibox")); 
d2403 5
a2407 5
		///:
		///: Finally process normally a click on the moving map.
		///: Virtual keys have been processed earlier, so we are now looking for a map selection.
		///: However, timings are different if virtual keys are enabled, for this operation.
		///:
d2409 4
a2412 5
			///:
			///: VNT Shorter the time needed to trigger a WP select, solving also the annoying problem
			///: of unwanted wp selection while double clicking too slow!
			///: And at the same time let this action pass transparently to virtual keys.
			///:
d2427 1
a2427 1
				///: pg UP = zoom in
d2431 1
a2431 1
					///: pg DOWN = zoom out
d2435 1
a2435 1
					///: process center key, do nothing 
d2453 1
a2453 1
				///: 091215 in pan mode and SIM mode, click to center current position
d2457 3
a2459 3
						///: 091219 match only center screen
						if (  (abs(X-((rc.left+rc.right)/2)) <NIBLSCALE(5)) && 
						      (abs(Y-((rc.bottom+rc.top)/2)) <NIBLSCALE(5)) ) {
d2470 1
a2470 1
					///: 091219 match only center screen
d2481 3
a2483 3
				///: If we are here,  (DCI/2)+30 < dwDownTime < DOUBLECLICKINTERVAL
				///: SO this is a tight interval. DCI should not be set too low. See Defines.h
				///: NO: VKSHORTCLICK-DCI  150-350 ?
d2507 1
a2507 1
						///: 091219 match only center screen
d2510 1
a2510 1
							DoStatusMessage(_T("Current position updated"));
d2520 1
a2520 1
					///: 091219 match only center screen
d2637 2
a2638 2
			gettext(TEXT("Shutdown?")),
			gettext(TEXT("Altair system message")),
a2716 1
	///: wpd = CALCULATED_INFO.ZoomDistance; not needed REMOVE 101008
a2757 1
				///: StartupStore(_T("... startautomapscale=mapscale=%f\n"),MapScale);
d2759 1
a2759 1
			else { //@@ 101007 BUGFIX XCSOAR
d2763 1
a2763 2
				if (MapScale != RequestMapScale) { //@@ 101008 do not loose time if same scale
					///: StartupStore(_T("... change mapscale=%f for wpd=%f\n"),RequestMapScale,wpd);
a2769 1
				////?TODO enhancement: for frank          StartingAutoMapScale = MapScale;
a2806 1
			///: StartupStore(_T("... RESET mapscale to %f on the next run!\n"),RequestMapScale); // 101007
a2904 1
  ///if (GliderCenter || EnablePan) {
d2911 1
a2911 1
	///: 100415 automagic northup smart
d2914 17
a2930 4
		int middleY=((rc.bottom-BottomSize)+rc.top)/2;
		///: int middleX=(rc.left+rc.right)/2;
		///: double spanx;
		double spany;
a2932 1
			///: if InfoBoxLayout::fullscreen
a2934 3
			///: This was moving too much the map!
			///: spanx=NIBLSCALE(40);
			///: Orig->x= middleX - (int)(spanx*fastsine(trackbearing));
d2937 3
a2939 3
			///: this is impossible, because northsmart is for landscape only
			Orig->x = (rc.left + rc.right)/2;
			Orig->y = (rc.bottom + rc.top)/2;
d2941 1
d2952 1
a2952 1
		///: 100924 if we are in north up autorient, position the glider in middle screen
d2957 1
a2957 1
			///: else do it normally using configuration
a3005 1
		///: SelectObject(hdc, hSnailPens[8]); 
d3017 1
a3017 1
			if (counter==5 || counter==6|| counter==7) {
d3024 1
a3024 1
			if (++counter>=30) counter=0;
a3060 1
  ///: 091111 ZoomTrigger
a3071 1
  ///: 100304 force calculation if not in map drawing?  || DONTDRAWTHEMAP
a3085 1
  ///: When paragliders call for Zoom, bring it up with a timeout! 091111
d3105 1
a3105 1
		///: previously called, see if time has passed
d3107 1
a3107 1
			///: time has passed, lets go back
d3123 1
a3123 1
  ///: let the calculations run, but dont draw anything but the look8000 when in MapSpaceMode != MSM_MAP
d3134 1
a3134 1
	///: no need to do SelectObject as at the bottom of function
d3138 2
a3139 2
  ///: When no terrain is painted, set a background 091109
  ///: Remember that in this case we have plenty of cpu time to spend for best result
d3144 1
a3144 2
		// SelectObject(hdc, GetStockObject(WHITE_BRUSH)); BUGFIX 091115
		SelectObject(hdc, hInvBackgroundBrush[BgMapColor]); // BUGFIX 091115
d3147 2
a3148 2
		///: Here we are if no terrain is used or available
		if (INVERTCOLORS) { // 091109
a3152 1
			///: SelectObject(hdc, hBackgroundBrush); 091109 CHECK unused
d3157 3
a3159 3
	///: We force LK painting black values on screen depending on the background color in use
	///: TODO make it an array once settled
	///: blackscreen would force everything to be painted white, instead
a3160 1
	///: if (INVERTCOLORS) BlackScreen=true; else BlackScreen=false; 091110 not used
a3176 1
 ///: if (DONTDRAWTHEMAP) goto QuickTrap; // TESTFIX 090930 100319
d3185 1
a3185 1
	///: 101013 sunelevation is never used, it is still a todo in Terrain
d3194 1
a3194 1
	///: 101013 XCSOAR BUGFIX SUNAZIMUTH
a3220 1
 ///: if (DONTDRAWTHEMAP) goto QuickTrap; // TESTFIX 090930 100319
d3228 6
a3233 6
/*
  StartupStore(_T("... Experimental1=%.0f\n"),Experimental1); // REMOVE
  StartupStore(_T("... Experimental2=%.0f\n"),Experimental2); // REMOVE
  Experimental1=0.0; // REMOVE 
  Experimental2=0.0; // REMOVE 
*/
d3235 2
a3236 2
  ///: Topology labels are printed first, using OLD wps positions from previous run!
  ///: Reset for topology labels decluttering engine occurs also in another place here!
a3253 1
 ///: if (DONTDRAWTHEMAP) goto QuickTrap; 100319
a3257 3
  // then airspace..
  //Experimental1=0;
  //Experimental2=0;
a3258 1
  //StartupStore(_T("... Exp1=%.0f  Exp2=%.0f\n"),Experimental1, Experimental2);
a3259 1
 ///: if (DONTDRAWTHEMAP) goto QuickTrap; 100319
a3268 1
    #if 100303
a3275 25
    #else
      /*
      //  Draw trail with white outline --- very slow!
      // clear background bitmap
      SelectObject(hDCTemp, GetStockObject(WHITE_BRUSH));
      Rectangle(hDCTemp, rc.left, rc.top, rc.right, rc.bottom);
      
      SetBkColor(hDCMask, RGB(0xff,0xff,0xff));
      
      // draw trail on background bitmap
      DrawTrail(hDCTemp, Orig_Aircraft, rc);
      DrawTrailFromTask(hDCTemp, rc);
      
      // make mask
      BitBlt(hDCMask, 0, 0, rc.right-rc.left, rc.bottom-rc.top,
      hDCTemp, rc.left, rc.top, SRCCOPY);
      
      BitBlt(hdcDrawWindowBg, rc.left, rc.top, rc.right, rc.bottom,
      hDCMask, 1, 1, SRCAND);
      BitBlt(hdcDrawWindowBg, rc.left, rc.top, rc.right, rc.bottom,
      hDCTemp, rc.left, rc.top, SRCPAINT);
      BitBlt(hdcDrawWindowBg, rc.left, rc.top, rc.right, rc.bottom,
      hDCTemp, rc.left, rc.top, SRCAND);
      */
    #endif
a3277 1
 ///: if (DONTDRAWTHEMAP) goto QuickTrap;
a3301 1
 ///: if (DONTDRAWTHEMAP) goto QuickTrap;
a3313 1
 ///: if (DONTDRAWTHEMAP) goto QuickTrap;
d3347 1
a3347 1
  ///: 091215 VisualGlide drawn BEFORE lk8000 overlays
a3351 3
///:QuickTrap: 
  ///: if ( Look8000 && !EnablePan) DrawLook8000(hdc,rc); // 100303 FIX no Look8000 in Pan mode 100309
  ///: if (DONTDRAWTHEMAP) goto QuickBack; 
a3359 1
#if 100309
a3360 2
#endif
	///: if (LKVarioBar && IsMapFullScreen()) 091214
d3372 1
a3372 1
  ///: Draw cross air for panmode, instead of aircraft icon
d3377 1
a3377 1
  ///: Draw glider or paraglider
a3381 7
/* 091215 REMOVE
  if ( (!TargetPan) && (!EnablePan) && (VisualGlide>0) ) {
    DrawGlideCircle(hdc, Orig, rc); 
  }
*/

  ///: if (!ISPARAGLIDER)	// 091107  using TrackBar 091122
d3389 2
a3390 1
///: QuickBack:
d3423 3
a3425 3
  ///: 100307 REM this is calculating waypoint visible, and must be executed before rendermapwindowbg which calls   
  ///: CalculateWayPointReachable new, setting values for visible wps!
  ///: This is also calculating CalculateScreenBounds 0.0  and placing it inside MapWindow::screenbounds_latlon
a3444 2
///:  DrawMapScale2(hdcDrawWindow,rc, Orig_Aircraft); 091116 TESTFIX OPTIM removed MapScale2
  
d3458 1
a3458 1
  ///: 100303 REMINDER TODO let it be configurable for not circling also, as before
a3462 2
  ///if (!(NewMap && Look8000)||(DisplayMode == dmCircling))
  //if (!(NewMap && Look8000))
d3466 1
a3466 1
  ///: DrawSpeedToFly(hdcDrawWindow, rc);  // 100303 Usable
a3497 1
  ///: DWORD fpsTimeThis = ::GetTickCount(); 100115
a3498 1
  ///: static double lastTime = 0; 100115 useless
a3515 7
  ///: Correct situation when time has changed in the past UNUSED! 100115
/*
  if (lastTime>DrawInfo.Time) {
    lastTime = DrawInfo.Time;
  }
*/

a3518 1
    ///: fpsTimeThis = fpsTimeMapCenter; // XCSOAR BUGFIX 100115 since 1.174.2.12 20070825
a3556 1
  ///: while ((!ProgramStarted) || (!Initialised) || (!goCalculating)) { // 100207
d3563 1
a3563 1
  ///: Reset for topology labels decluttering engine occurs also in another place here!
d3589 1
a3589 1
  ////// This is just here to give fully rendered start screen
d3593 1
a3593 1
  //////
a3661 1
	///: 100113 Check battery status  moved here from Calculation 100128
a3673 1
	///: if ( (InfoBoxLayout::landscape == true) && ( InfoBoxLayout::InfoBoxGeometry == 6) && !InfoBoxLayout::fullscreen) 100308 FIX
a3701 1
  ///: DrawDashLine(hdc, 1, o1, o2, RGB(50,50,50), rc); 091109
a3702 1
	  ///: DrawDashLine(hdc, 1, o1, o2, RGB_INVDRAW, rc); 091219
d3748 1
a3748 1
  if ( AircraftCategory == (AircraftCategory_t)umParaglider ) {
a3762 1
    ///: if (Appearance.InverseAircraft) { 091109
d3764 7
d3776 1
d3802 1
d3805 1
d3838 9
d3854 1
d3879 1
d3882 1
a3998 1
///: COMDIAG requires automatically NEWWARNINGS
a4023 2
    //oldfont=(HFONT)SelectObject(hDC,LK8MapFont);  // 100211
    ///: oldfont=(HFONT)SelectObject(hDC,LK8InfoBigFont);   100222 change
a4128 1
			///: rc.bottom+IBLSCALE(-7+Appearance.FlightModeOffset.y), 091123
a4132 1
			///: rc.bottom+IBLSCALE(-7+Appearance.FlightModeOffset.y), 091123
d4136 1
a4136 1
		///: 091123 not really needed if we remove offset next on
d4184 1
a4184 1
  ///: FlightModeIcon is always 0, unused!
a4311 1
///: 091007 FIXTEST BUGFIX Waypoint not showing (was 50 max) now extended to 200
a4593 3
  ///: if MapW..LabelList==0  Map..Count>= (0-1 = 45281237123 !!) 091109 TODO FIX BUFFER OVERFLOW
  ///: if MapWaypointLabelList is 0 it will really appear as 452834234 ecc. so it wont be detected
  //if (MapWaypointLabelListCount >= (sizeof(MapWaypointLabelList)/sizeof(MapWaypointLabel_t))-1){  // 100207
a4594 11
/* 091119
#if (WINDOWSPC<1)
    StartupStore(_T("++++++ ERR-901 CRITICAL PROBLEM REPORT DEVELOPERS%s"),NEWLINE);
    DoStatusMessage(_T("ERR-901 CRITICAL FAILURE"));
    Sleep(10000);
    ASSERT(0); 091119
#else
    StartupStore(_T("++++++ ERR-901 CRITICAL PROBLEM REPORT DEVELOPERS%s"),NEWLINE);
    DoStatusMessage(_T("ERR-901 CRITICAL FAILURE"));
#endif
*/
d4679 1
a4679 1
  COLORREF whitecolor = RGB(0xff,0xff, 0xff);
d4738 1
a4738 1
      ///: DRAW TASK SECTORS
a4740 4
/*
	  DrawDashLine(hdc, 2, WayPointList[Task[i].Index].Screen, Task[i].Start, RGB_RED, rc); // 091216 127,127,127
	  DrawDashLine(hdc, 2, WayPointList[Task[i].Index].Screen, Task[i].End, RGB_RED, rc);
*/
a4744 1
	  ///: SelectObject(hdc, GetStockObject(BLACK_PEN)); 091216
d4755 1
a4755 1
	  ///: FAI SECTOR
d4784 1
a4784 1
		///: ELSE HERE IS   *** AAT ***
a4832 1
	  ///: DrawDashLine(hdc, 1,   	// 091217
a4842 1
	  ///: DrawDashLine(hdc, 3,  // 091217
a4847 1
	  ///: DrawDashLine(hdc, 3,  // 091217
d4892 1
a4892 1
    COLORREF whitecolor = RGB(0xff,0xff, 0xff);
a4968 2
    //////

a5299 2
////////////////////////////////////////////////////////////////////

a5324 1

a5365 2
////////////////////////////////////////////////////////////////////////

@


8.26
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.25 2010/09/20 15:19:59 root Exp root $
d295 2
d1748 1
d1900 2
d2306 4
a2309 1
			if (UseGates() && ValidTaskPoint(1) && ActiveWayPoint<2) { // 100507
d2582 23
d2627 1
d2716 14
d2742 1
d2766 14
d2792 1
d3248 9
a3256 2
  if (!EnableThermalLocator) 
    return;
d3259 42
a3300 16
    if (DerivedDrawInfo.ThermalEstimate_R>0) {
      LatLon2Screen(DerivedDrawInfo.ThermalEstimate_Longitude, 
                    DerivedDrawInfo.ThermalEstimate_Latitude, 
                    screen);
      DrawBitmapIn(hdc, 
		   screen, 
		   hBmpThermalSource);

	SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
	///: SelectObject(hdc, hSnailPens[8]); 
	SelectObject(hdc, hpAircraft); // white
	if (ISPARAGLIDER)
		Circle(hdc, screen.x, screen.y, (int)(50*ResMapScaleOverDistanceModify), rc); //@@ 101101
	else
		Circle(hdc, screen.x, screen.y, (int)(100*ResMapScaleOverDistanceModify), rc); //@@ 101101
    }
d3302 7
a3308 9
    if (MapScale <= 4) {
      for (int i=0; i<MAX_THERMAL_SOURCES; i++) {
        if (DerivedDrawInfo.ThermalSources[i].Visible) {
          DrawBitmapIn(hdc, 
                       DerivedDrawInfo.ThermalSources[i].Screen, 
                       hBmpThermalSource);
        }
      }
    }
@


8.25
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.24 2010/05/07 17:03:45 root Exp root $
d114 1
d125 3
d295 5
d1314 6
d1517 2
a1518 1
  ///: Attention... this is duplicated inside Utils2, I am lazy
d1734 2
a1735 2
      hpCompassBorder = (HPEN)CreatePen(PS_SOLID, NIBLSCALE(3), 
					RGB(0xff,0xff,0xff));
d1763 5
d1770 5
d1802 5
a1806 2
      hpTerrainLine = (HPEN)CreatePen(PS_SOLID, (2), RGB(0,0,0));
      hpTerrainLineBg = (HPEN)CreatePen(PS_SOLID, (2), RGB_BLACK);
d1897 5
a2150 15
/* TODO REMOVE 
		switch(ScreenSize) {
			case (ScreenSize_t)ss400x240:
			case (ScreenSize_t)ss480x640:
			case (ScreenSize_t)ss240x320:
			case (ScreenSize_t)ss320x240:
				AIRCRAFTMENUSIZE=NIBLSCALE(28)+14;
				COMPASSMENUSIZE=NIBLSCALE(28)+14;
				break;
			default:
				AIRCRAFTMENUSIZE=NIBLSCALE(28)+14;
				COMPASSMENUSIZE=NIBLSCALE(28)+14;
				break;
		}
*/
d2210 1
a2210 1
				if (!CustomKeyHandler(3)) goto goto_menu;
a2212 1

d2227 2
a2228 1

d2231 2
d2252 19
d2332 20
d2907 4
a2910 5
  if(MapScale != RequestMapScale)
    {
      ModifyMapScale();
      useraskedforchange = true;
    }
d2914 1
a2914 1
    wpd = TargetZoomDistance;
d2916 2
a2917 1
    wpd = DerivedDrawInfo.ZoomDistance;
d2920 4
a2923 6
    // set scale exactly so that waypoint distance is the zoom factor
    // across the screen
    RequestMapScale = LimitMapScale(wpd
                                    *DISTANCEMODIFY/ 4.0);
    ModifyMapScale();
    return;
d2927 1
a2927 2
    if(wpd > 0)
      {
d2929 16
a2944 18
	if(
	   (((DisplayOrientation == NORTHTRACK)
	     &&(DisplayMode != dmCircling))
	    ||(DisplayOrientation == NORTHUP) 
	    ||(DisplayOrientation == NORTHSMART)  // 100419
	    || 
	    (((DisplayOrientation == NORTHCIRCLE) 
	      || (DisplayOrientation == TRACKCIRCLE)) 
	     && (DisplayMode == dmCircling) ))
	   && !TargetPan
	   )
	  {
	    AutoZoomFactor = 2.5;
	  }
	else
	  {
	    AutoZoomFactor = 4;
	  }
d2946 16
a2961 7
	if(
	   (wpd < ( AutoZoomFactor * MapScaleOverDistanceModify))
	   || 
	   (StartingAutoMapScale==0.0))
	  {
	    // waypoint is too close, so zoom in
	    // OR just turned waypoint
d2963 12
a2974 2
	    // this is the first time this waypoint has gotten close,
	    // so save original map scale
d2976 3
a2978 24
	    if (StartingAutoMapScale==0.0) {
	      StartingAutoMapScale = MapScale;
	    }

	    // set scale exactly so that waypoint distance is the zoom factor
	    // across the screen
	    RequestMapScale = LimitMapScale(wpd
					    *DISTANCEMODIFY/ AutoZoomFactor);
	    ModifyMapScale();

	  } else {

	  if (useraskedforchange) {

	    // user asked for a zoom change and it was achieved, so
	    // reset starting map scale


	    ////?TODO enhancement: for frank          StartingAutoMapScale = MapScale;
	  }

	}
      }
  } else {
d2980 4
a2983 3
    // reset starting map scale for auto zoom if momentarily switch
    // off autozoom
    //    StartingAutoMapScale = RequestMapScale;
d2987 1
a2987 1
    return;
d2996 3
a2998 3
      if (ValidTaskPoint(ActiveWayPoint)) {
	AutoMapScaleWaypointIndex = Task[ActiveWayPoint].Index;
      }
a3000 1
    // if there is an active waypoint
d3003 10
a3012 3
      // if the current zoom focused waypoint has changed...
      if (AutoMapScaleWaypointIndex != Task[ActiveWayPoint].Index) {
	AutoMapScaleWaypointIndex = Task[ActiveWayPoint].Index;
d3014 2
a3015 3
	// zoom back out to where we were before
	if (StartingAutoMapScale> 0.0) {
	  RequestMapScale = StartingAutoMapScale;
a3017 4
	// reset search for new starting zoom level
	StartingAutoMapScale = 0.0;
      }

d3148 9
a3156 2
		Orig->x = ((rc.right - rc.left )*GliderScreenPositionX/100)+rc.left;
		Orig->y = ((rc.top - rc.bottom )*GliderScreenPositionY/100)+rc.bottom;
d3197 1
a3197 1
      /*
d3199 6
a3204 5
	SelectObject(hdc, GetStockObject(BLACK_PEN));
	Circle(hdc,
	screen.x,
	screen.y, IBLSCALE(5), rc);
      */
d3358 13
a3370 8
    double sunelevation = 40.0;
    double sunazimuth = DisplayAngle-DerivedDrawInfo.WindBearing;
    
    // draw sun from constant angle if very low wind speed
    if (DerivedDrawInfo.WindSpeed<0.5) {
      sunazimuth = DisplayAngle + 45.0;
    }
    
d3640 1
a3640 1
  SetAutoOrientation();
d4408 4
d4480 1
d5327 11
d5339 1
a5339 1
    return; 
a5340 1

d5342 1
d5349 22
@


8.24
log
@pre timegate
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.23 2010/03/18 15:57:10 root Exp root $
d113 5
d120 2
d209 1
a209 1
unsigned char MapWindow::DeclutterLabels = 0;
d475 2
a476 1
  static double CruiseMapScale=1;
d480 1
a480 1
  static double ClimbMapScale=1;
d494 4
d519 1
d735 3
d739 1
d779 3
d783 1
d796 31
d841 1
d844 3
d848 1
d920 31
d965 1
d968 3
d972 1
d1490 6
d1498 1
d2186 11
d2204 1
d2213 17
a2229 8
			if (PGZoomTrigger==false)
				PGZoomTrigger=true;
			else
				LastZoomTrigger=0;
			 #ifndef DISABLEAUDIO
                        if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
                        #endif
			break;
d2260 5
d2286 2
d3163 1
a3330 1

d3334 6
d3341 2
a3343 1
  // reset label over-write preventer
d3345 3
d3366 2
d3369 1
a3558 1
  
d3570 4
a3573 1
  
d3578 1
d3660 1
d3731 1
d3733 3
d3829 1
d4529 1
a4529 1
		if ((DeclutterLabels<2)||intask) {
d4531 1
a4531 1
		  if (intask || (DeclutterLabels<1)) {
d4586 1
a4586 1
		&& ((DeclutterLabels<1) || intask);
d4602 1
a4602 1
		dowrite = (DeclutterLabels<2) || intask;
d4613 1
a4613 1
		dowrite = (DeclutterLabels<2) || intask;
d4624 1
a4624 1
		dowrite = (DeclutterLabels<2) || intask;
d4637 1
a4637 1
		dowrite = (DeclutterLabels<2) || intask;
d4650 1
a4650 1
		dowrite = (DeclutterLabels<2) || intask;
@


8.23
log
@pre addon fast clicks
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.22 2010/03/16 13:46:27 root Exp root $
d85 3
d89 1
d339 3
d344 1
d356 3
d360 1
d1675 4
d1683 1
a1859 1
      ignorenext=true;
d1861 1
d1864 2
d1891 7
d1900 1
d2059 1
d2086 2
a2087 1
		///: toggle old infobox mode on/off 091016
d2220 2
a2221 1
	if (  DrawBottom && IsMapFullScreen() && (Y >= (rc.bottom-BottomSize)) ) {
d2352 1
a2354 1
				#ifdef DEBUG_VIRTUALKEYS
a2355 1
				#endif
d2358 3
d2456 34
d2493 1
d2518 8
d2529 1
d2748 1
d2857 1
d2897 1
d2922 1
a2922 1
    CalculateOrientationTargetPan();
d2924 1
a2924 1
    CalculateOrientationNormal();
d2927 4
a2930 3
  if (GliderCenter || EnablePan) {
    Orig->x = (rc.left + rc.right)/2;
    Orig->y = (rc.bottom + rc.top)/2;
d2933 39
a2971 2
    Orig->x = ((rc.right - rc.left )*GliderScreenPositionX/100)+rc.left;
    Orig->y = ((rc.top - rc.bottom )*GliderScreenPositionY/100)+rc.bottom;
d2973 2
a2974 2
    Orig->x = (rc.left + rc.right)/2;
    Orig->y = ((rc.top - rc.bottom )*GliderScreenPosition/100)+rc.bottom;
d3103 1
d3157 5
a3161 1
 if (DONTDRAWTHEMAP) goto QuickTrap; // TESTFIX 090930
a3178 1
 	if (DONTDRAWTHEMAP) goto QuickTrap; // TESTFIX 090930
d3180 5
d3186 5
d3197 5
a3201 1
 if (DONTDRAWTHEMAP) goto QuickTrap; // TESTFIX 090930
d3216 3
a3218 1
  DrawTaskAAT(hdc, rc);
d3222 5
a3226 1
 if (DONTDRAWTHEMAP) goto QuickTrap;
d3230 5
a3234 1
 if (DONTDRAWTHEMAP) goto QuickTrap;
d3275 5
a3279 1
 if (DONTDRAWTHEMAP) goto QuickTrap;
d3284 3
a3286 1
  DrawTask(hdc, rc, Orig_Aircraft);
d3300 5
a3304 1
 if (DONTDRAWTHEMAP) goto QuickTrap;
d3313 5
a3317 1
 if (DONTDRAWTHEMAP) goto QuickTrap;
d3352 1
a3352 1
QuickTrap: 
d3354 5
a3358 1
  if (DONTDRAWTHEMAP) goto QuickBack; 
d3402 1
a3402 1
QuickBack:
@


8.22
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.21 2010/03/09 23:00:49 root Exp root $
d2069 14
d2084 1
d2102 1
d2920 1
a2920 1
  static double lastTrigger=0;
d2949 1
a2949 1
		lastTrigger=GPS_INFO.Time;
d2954 4
a2957 1
		Event_SetZoom(5.0);
d2966 1
a2966 1
		if ( GPS_INFO.Time > (lastTrigger + 20.0)) {
d2969 1
a2969 1
			lastTrigger=0; // just for safety
@


8.21
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.20 2010/02/16 23:43:48 root Exp root $
d2069 20
a2088 4
      ///: 091129 Use the compass to pullup UTM informations to paragliders
      if (ISPARAGLIDER)
      if ( (X > ((MapRect.right-MapRect.left)- COMPASSMENUSIZE)) &&
	   (Y <= MapRect.top+COMPASSMENUSIZE) ) {
d2117 2
a2118 1
      } // End compass icon check
@


8.20
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.19 2009/12/17 23:50:02 root Exp root $
d67 1
d69 2
d72 2
d75 1
d188 2
d721 1
a721 1
                IBLSCALE(8), IBLSCALE(8));
d934 1
d936 1
a936 1

d1266 1
a1266 1
  static int retglider=IBLSCALE(30);
d1389 8
d1410 1
a1410 1
  navboxesY=(MapWindow::MapRect.bottom-MapWindow::MapRect.top)-BottomSize-IBLSCALE(2); // BUGFIX 091125
d1550 1
a1550 1
      minwidth = max(IBLSCALE(2),IBLSCALE(SnailWidthScale)/16);
d1587 15
a1601 15
	hSnailPens[0] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[0]);
	hSnailPens[1] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[1]);
	hSnailPens[2] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[2]);
	hSnailPens[3] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[3]);
	hSnailPens[4] = (HPEN)CreatePen(PS_SOLID,  iwidth/IBLSCALE(2), hSnailColours[4]);
	hSnailPens[5] = (HPEN)CreatePen(PS_SOLID,  iwidth/IBLSCALE(4), hSnailColours[5]);
	hSnailPens[6] = (HPEN)CreatePen(PS_SOLID,  iwidth/IBLSCALE(4), hSnailColours[6]);
	hSnailPens[7] = (HPEN)CreatePen(PS_SOLID,  iwidth/IBLSCALE(6), hSnailColours[7]);
	hSnailPens[8] = (HPEN)CreatePen(PS_SOLID,  iwidth/IBLSCALE(4), hSnailColours[8]);
	hSnailPens[9] = (HPEN)CreatePen(PS_SOLID,  iwidth/IBLSCALE(4), hSnailColours[9]);
	hSnailPens[10] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[10]);
	hSnailPens[11] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[11]);
	hSnailPens[12] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[12]);
	hSnailPens[13] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[13]);
	hSnailPens[14] = (HPEN)CreatePen(PS_SOLID, iwidth/IBLSCALE(2), hSnailColours[14]);
d1606 1
a1606 1
      hpCompassBorder = (HPEN)CreatePen(PS_SOLID, IBLSCALE(3), 
d1612 2
a1613 2
	hpAircraft = (HPEN)CreatePen(PS_SOLID, IBLSCALE(3), RGB_BLACK);
	hpAircraftBorder = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB_WHITE);
d1615 2
a1616 2
	hpAircraft = (HPEN)CreatePen(PS_SOLID, IBLSCALE(3), RGB_WHITE);
	hpAircraftBorder = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB_BLACK);
d1620 1
a1620 1
      hpWind = (HPEN)CreatePen(PS_SOLID, IBLSCALE(2), RGB(0,0,0));
d1622 1
a1622 1
      hpWind = (HPEN)CreatePen(PS_SOLID, IBLSCALE(2), RGB(255,0,0));
d1625 1
a1625 1
      hpWindThick = (HPEN)CreatePen(PS_SOLID, IBLSCALE(4), 
d1628 1
a1628 1
      hpBearing = (HPEN)CreatePen(PS_SOLID, IBLSCALE(2), 
d1630 1
a1630 1
      hpBestCruiseTrack = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
d1633 1
a1633 1
      hpCompass = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB(0x00,0x00,0x00));
d1636 1
a1636 1
      hpCompass = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB(0xcf,0xcf,0xFF));
d1638 2
a1639 2
      hpThermalBand = (HPEN)CreatePen(PS_SOLID, IBLSCALE(2), RGB(0x40,0x40,0xFF));
      hpThermalBandGlider = (HPEN)CreatePen(PS_SOLID, IBLSCALE(2), RGB(0x00,0x00,0x30));
d1641 2
a1642 2
      hpFinalGlideBelow = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB(0xFF,0xA0,0xA0));
      hpFinalGlideBelowLandable = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB(255,196,0));
d1645 1
a1645 1
      hpFinalGlideAbove = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), RGB(0xA0,0xFF,0xA0));
d1647 1
a1647 1
      hpSpeedSlow=(HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
d1649 1
a1649 1
      hpSpeedFast=(HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
d1652 1
a1652 1
      hpStartFinishThick=(HPEN)CreatePen(PS_SOLID, IBLSCALE(5),
d1655 1
a1655 1
      hpStartFinishThin=(HPEN)CreatePen(PS_SOLID, IBLSCALE(1),
d1658 1
a1658 1
      hpMapScale = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1),  
d1661 1
a1661 1
      hpMapScale2 = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1)+1,  
d1850 1
a1850 1
			if ( Y < (MapWindow::MapRect.bottom-MapWindow::MapRect.top-BottomSize-IBLSCALE(15)) ) {
d1988 21
a2008 2
#define	AIRCRAFTMENUSIZE	IBLSCALE(28)
#define COMPASSMENUSIZE		IBLSCALE(28)
d2012 1
a2012 1
	if (DrawBottom) topicon=MapRect.bottom-MapRect.top-BottomSize;
d2017 2
a2018 2
      if ( (X > ((MapRect.right-MapRect.left)- AIRCRAFTMENUSIZE)) &&
	   (Y > topicon) ) {
d2020 7
a2026 7
		/*
		 * Available for future usage: short click on aircraft icon.
		 * Remember there's already a normal click and a long click on the same icon!
		   090720 short click replacing doubleclick forever!
		 */
		
		//if ( dwInterval < DOUBLECLICKINTERVAL) {
d2322 1
a2322 1
      else if (!TargetPan && (distance>IBLSCALE(36))) {
d2399 2
a2400 2
					if (  (abs(X-((rc.left+rc.right)/2)) <IBLSCALE(5)) && 
					      (abs(Y-((rc.bottom+rc.top)/2)) <IBLSCALE(5)) ) {
d2425 2
a2426 2
					if (  (abs(X-((rc.left+rc.right)/2)) <IBLSCALE(5)) && 
					      (abs(Y-((rc.bottom+rc.top)/2)) <IBLSCALE(5)) ) {
d2819 4
d2825 1
d2895 8
d2904 1
d3040 1
d3044 3
d3058 2
a3059 1
    if (1) {
d3067 1
a3067 1
    } else {
d3091 1
a3091 1
    }
d3097 4
a3100 1
  
d3106 1
d3115 3
d3120 1
d3138 1
d3140 1
d3158 1
a3158 1
  if ( Look8000 ) DrawLook8000(hdc,rc);
d3164 3
d3170 3
d3176 1
d3233 3
a3235 1
  
d3247 1
d3249 1
d3270 1
d3280 1
a3280 1
  //  DrawSpeedToFly(hdcDrawWindow, rc); 
d3422 1
a3422 1
      CreatePen(PS_SOLID, IBLSCALE(2), Colours[iAirspaceColour[i]]);
d3466 1
d3468 1
d3493 4
a3496 3
		//GaugeVario::Show(MapFullScreen); // VENTA FIX QUI REMOVE
#ifdef LK8000_OPTIMIZE
	if ( (InfoBoxLayout::landscape == true) && ( InfoBoxLayout::InfoBoxGeometry == 6) && !InfoBoxLayout::fullscreen)
a3497 1
		GaugeVario::Show(!MapFullScreen);
d3526 1
a3526 1
	  DrawDashLine(hdc, IBLSCALE(1), o1, o2, RGB_INVDRAW, rc);
d3528 1
a3528 1
	  DrawDashLine(hdc, IBLSCALE(1), o1, o2, RGB_DARKGREY, rc);
d3536 1
a3536 1
	  DrawDashLine(hdc, IBLSCALE(1), o1, o2, RGB_INVDRAW, rc); // 091219
d3538 1
a3538 1
	  DrawDashLine(hdc, IBLSCALE(1), o1, o2, RGB_DARKGREY, rc); // 091219
d3773 2
a3774 2
              sc.x-IBLSCALE(5),
              sc.y-IBLSCALE(5),
d3778 2
a3779 2
              sc.x-IBLSCALE(5),
              sc.y-IBLSCALE(5),
d3800 1
a3800 1
  TCHAR gpswarningtext2[] = TEXT(" GPS waiting for fix ");
d3804 3
a3806 3
  TCHAR gpswarningtext3[] = TEXT(" GPS not connected, no ComPort ");
  TCHAR gpswarningtext4[] = TEXT(" GPS not connected, no data rx ");
  TCHAR gpswarningtext5[] = TEXT(" GPS no more connected ");
d3816 1
a3816 1
                rc.left+IBLSCALE(2),
d3822 1
a3822 1
              rc.left+IBLSCALE(24), 
d3828 2
a3829 1
    oldfont=(HFONT)SelectObject(hDC,LK8InfoBigFont);  
d3869 1
a3869 1
                  rc.left+IBLSCALE(2),
d3876 1
a3876 1
                rc.left+IBLSCALE(24), 
d3935 1
a3935 1
                  	rc.bottom - BottomSize+IBLSCALE(1),
d3940 1
a3940 1
                  	rc.bottom-BottomSize+IBLSCALE(1),
d3951 1
d3955 1
d3963 2
d3966 1
d4007 1
a4007 1
               Center.y-IBLSCALE(4));
d4009 2
a4010 2
               Center.x-IBLSCALE(8), 
               Center.y+IBLSCALE(4));
d4012 2
a4013 2
               Center.x+IBLSCALE(8), 
               Center.y+IBLSCALE(4));
d4019 1
a4019 1
               Center.y+IBLSCALE(4));
d4021 2
a4022 2
               Center.x-IBLSCALE(8), 
               Center.y-IBLSCALE(4));
d4024 2
a4025 2
               Center.x+IBLSCALE(8), 
               Center.y-IBLSCALE(4));
d4029 1
a4029 1
               Center.x+IBLSCALE(4), 
d4032 2
a4033 2
               Center.x-IBLSCALE(4), 
               Center.y+IBLSCALE(8));
d4035 2
a4036 2
               Center.x-IBLSCALE(4), 
               Center.y-IBLSCALE(8));
d4040 1
d4045 3
d4125 1
d4169 3
d4174 1
d4190 3
d4194 1
d4199 3
d4203 1
d4223 2
a4224 2
			  WayPointList[i].Screen.x-IBLSCALE(10), 
			  WayPointList[i].Screen.y-IBLSCALE(10),
d4229 2
a4230 2
			  WayPointList[i].Screen.x-IBLSCALE(10), 
			  WayPointList[i].Screen.y-IBLSCALE(10),
d4366 1
a4366 1

d4467 1
a4467 1
    _DrawLine(hdc, PS_SOLID, IBLSCALE(5), WayPointList[Index].Screen,
d4469 1
a4469 1
    _DrawLine(hdc, PS_SOLID, IBLSCALE(5), WayPointList[Index].Screen,
d4471 1
a4471 1
    _DrawLine(hdc, PS_SOLID, IBLSCALE(1), WayPointList[Index].Screen,
d4473 1
a4473 1
    _DrawLine(hdc, PS_SOLID, IBLSCALE(1), WayPointList[Index].Screen,
d4527 1
a4527 1
	    _DrawLine(hdc, PS_SOLID, IBLSCALE(5), 
d4530 1
a4530 1
	    _DrawLine(hdc, PS_SOLID, IBLSCALE(5), 
d4533 1
a4533 1
	    _DrawLine(hdc, PS_SOLID, IBLSCALE(1), 
d4536 1
a4536 1
	    _DrawLine(hdc, PS_SOLID, IBLSCALE(1), 
d4562 2
a4563 2
	  _DrawLine(hdc, PS_DASH,IBLSCALE(4), WayPointList[Task[i].Index].Screen, Task[i].Start, RGB_MAGENTA, rc); // 091216 127,127,127
	  _DrawLine(hdc, PS_DASH,IBLSCALE(4), WayPointList[Task[i].Index].Screen, Task[i].End, RGB_MAGENTA, rc); // 091216
d4621 1
a4621 1
		  _DrawLine(hdc, PS_SOLID, IBLSCALE(2), 
d4656 1
a4656 1
	  DrawDashLine(hdc, IBLSCALE(1),   // 091217
d4667 1
a4667 1
	  DrawDashLine(hdc, IBLSCALE(3), 
d4673 1
a4673 1
	  DrawDashLine(hdc, IBLSCALE(3), 
d4683 1
a4683 1
			   Orig_Aircraft, &p_p, IBLSCALE(25));
d4687 2
a4688 2
	_DrawLine(hdc, PS_SOLID, IBLSCALE(2), Arrow[0], p_p, taskcolor, rc);
	_DrawLine(hdc, PS_SOLID, IBLSCALE(2), Arrow[1], p_p, taskcolor, rc);
@


8.19
log
@1.17f
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.18 2009/12/16 10:55:20 root Exp root $
d100 1
d331 2
a332 1
#ifdef DEBUG_MEM
d1380 2
d1385 2
a1387 1
/* 091125 Bug, we need to optimize it later on
d1390 2
a1391 1
*/
a1392 1
  }
d2052 1
a2052 1
			Message::Unlock();
d2058 1
a2058 1
			Message::Lock(); // 091211
d2362 8
a2369 4
					DoStatusMessage(_T("Current position updated"));
					GPS_INFO.Latitude=PanLatitude;
					GPS_INFO.Longitude=PanLongitude;
					break;
d2375 1
d2388 8
a2395 4
					DoStatusMessage(_T("Current position updated"));
					GPS_INFO.Latitude=PanLatitude;
					GPS_INFO.Longitude=PanLongitude;
					break;
d2398 1
d2706 1
d2717 1
d2719 6
d3235 3
a3237 2
  DWORD fpsTimeThis = ::GetTickCount();
  static double lastTime = 0;
d3253 3
d3259 1
d3261 2
a3262 1
  if (force || (fpsTimeThis - fpsTimeMapCenter > 5000)) {
d3264 2
a3265 1
    fpsTimeThis = fpsTimeMapCenter;
d3273 9
d3290 1
d3303 1
d3402 6
d3446 2
a3447 1
	  DrawDashLine(hdc, 1, o1, o2, RGB_INVDRAW, rc);
d3449 1
a3449 1
	  DrawDashLine(hdc, 1, o1, o2, RGB_DARKGREY, rc);
d3457 1
a3457 1
	  DrawDashLine(hdc, 1, o1, o2, RGB_INVDRAW, rc);
d3459 1
a3459 1
	  DrawDashLine(hdc, 1, o1, o2, RGB_DARKGREY, rc);
d3709 6
d3718 12
a3729 3

  TCHAR gpswarningtext1[] = TEXT("GPS not connected");
  TCHAR gpswarningtext2[] = TEXT("GPS waiting for fix");
d3733 2
a3741 1

d3746 36
d3785 1
d3800 13
d3815 3
d4295 1
a4295 1
  ///: if labellist==0 Map..>= (0-1 = 45281237123 !!) 091109 TODO FIX BUFFER OVERFLOW
d4297 2
a4298 1
  if (MapWaypointLabelListCount >= (sizeof(MapWaypointLabelList)/sizeof(MapWaypointLabel_t))-1){
d4504 1
a4504 1
		///: AAT 
d4553 2
a4554 1
	  DrawDashLine(hdc, 1, 
d4564 2
a4565 1
	  DrawDashLine(hdc, 3, 
d4570 2
a4571 1
	  DrawDashLine(hdc, 3, 
d4574 1
a4574 1
		       taskcolor, rc);
@


8.18
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.17 2009/12/11 23:55:35 root Exp root $
d107 1
a107 1
static const COLORREF taskcolor = RGB(0,120,0); // was 255
d4334 2
a4335 1
      }
d4338 10
a4347 9
	  DrawDashLine(hdc, 2, 
		       WayPointList[Task[i].Index].Screen, 
		       Task[i].Start, RGB(127,127,127), rc);
	  DrawDashLine(hdc, 2, 
		       WayPointList[Task[i].Index].Screen, 
		       Task[i].End, RGB(127,127,127), rc);
        
	  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
	  SelectObject(hdc, GetStockObject(BLACK_PEN));
d4350 1
d4355 1
d4357 1
d4360 1
d4366 1
d4386 1
@


8.17
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.16 2009/11/09 22:24:04 root Exp root $
d59 1
d777 2
a778 1
#if (WINDOWSPC>0)
d810 2
a811 1
#ifdef PNA
d919 1
d1043 1
a1043 1
    
d1053 17
a1069 1
    DoStatusMessage(TEXT("Topology / Terrain"), buf);
d1382 1
d1385 1
d1388 1
d1463 1
a1463 1
      hInvBackgroundBrush[0] = CreateSolidBrush(COLORREF RGB_ICEWHITE);	 // black text required
d1473 1
a1473 1
      hInvBackgroundBrush[9] = CreateSolidBrush(COLORREF RGB_VDARKGREY); // richiede blackscreen
d1523 3
a1526 1
      int iwidth;
d1546 35
d1967 1
d2027 36
d2354 9
d2372 3
a2374 3
			  if (Event_NearestWaypointDetails(Xstart, Ystart, 500*MapScale, false)) {
			    break;
			  }
d2376 11
a2386 3
			  if (Event_InteriorAirspaceDetails(Xstart, Ystart)) {
			    break;
			  }
d2821 7
d2839 35
d2894 2
a2895 1
		SelectObject(hdc, GetStockObject(WHITE_BRUSH));
d2983 3
d2987 1
d3064 5
d3076 2
a3077 1
	if (ISPARAGLIDER && IsMapFullScreen())
d3094 1
d3098 1
d3100 1
a3100 1
  if (!ISPARAGLIDER)	// 091107
d3102 1
a3102 1
    DrawHeading(hdc, Orig, rc); 
d3156 1
a3156 1
  DrawMapScale2(hdcDrawWindow,rc, Orig_Aircraft);
d3172 2
a3173 1
	if (!ISPARAGLIDER) DrawThermalBand(hdcDrawWindow, rc); // 091110
d3177 1
d3714 15
a3728 5
    // has GPS time advanced?
    if(DrawInfo.Time <= LastTime) {
      LastTime = DrawInfo.Time;
    } else {
      flip = !flip;
d3730 5
a3734 6
      // don't bother drawing logger if not active for more than one second
      if ((!LoggerActive)&&(!lastLoggerActive)) {
        drawlogger = false;
      }
      lastLoggerActive = LoggerActive;
    }
d3736 9
a3744 2
    if (drawlogger) {
      offset -= 7;
d3746 3
a3748 20
      if (LoggerActive && flip) {
        SelectObject(hDCTemp,hLogger);
      } else {
        SelectObject(hDCTemp,hLoggerOff);
      }
      //changed draw mode & icon for higher opacity 12aug -st
      DrawBitmapX(hdc,
                  rc.right+IBLSCALE(offset+Appearance.FlightModeOffset.x),
                  rc.bottom+IBLSCALE(-7+Appearance.FlightModeOffset.y),
                  7,7,
                  hDCTemp,
                  0,0,SRCPAINT);

      DrawBitmapX(hdc,
                  rc.right+IBLSCALE(offset+Appearance.FlightModeOffset.x),
                  rc.bottom+IBLSCALE(-7+Appearance.FlightModeOffset.y),
                  7,7,
                  hDCTemp,
                  7,0,SRCAND);
    }
d3751 1
d4179 1
d4181 1
d4183 7
a4189 1
    ASSERT(0);
d4191 1
@


8.16
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.15 2009/10/24 19:21:58 root Exp $
d41 1
d72 1
a72 1
#include "LKUtils.h"
d206 1
d208 1
d238 1
a238 1
HBRUSH  MapWindow::hInvBackgroundBrush;
a289 1
COLORREF MapWindow::InvBackgroundColor = RGB_BLACK;
d742 2
a743 1
      COLORREF oldColor = SetBkColor(hDC, RGB(0xff, 0xff, 0xff));
d772 1
a772 1
	SetTextColor(hDC,RGB(0x00,0x00,0x00));
d774 1
a774 1
	SetTextColor(hDC,RGB(0xff,0xff,0xff)); 
d795 1
a795 1
	SetTextColor(hDC,RGB(0x00,0x00,0x00)); 
d799 1
a799 1
	SetTextColor(hDC,RGB(0x00,0x00,0x00)); // TODO somewhere else text color is not set correctly
d826 1
a826 1
	SetTextColor(hDC,RGB(0x00,0x00,0x00)); 
d830 1
a830 1
	SetTextColor(hDC,RGB(0x00,0x00,0x00)); // TODO somewhere else text color is not set correctly
d862 1
a862 1
		SetTextColor(hDC,RGB(0x00,0x00,0x00)); 
d869 1
a869 1
		SetTextColor(hDC,RGB(0x00,0x00,0x00)); 
d1437 14
a1450 1
      hInvBackgroundBrush = CreateSolidBrush(InvBackgroundColor);
d1455 1
d1457 1
d1530 2
a1531 4
	hpAircraft = (HPEN)CreatePen(PS_SOLID, IBLSCALE(3), 
				     RGB(0x00,0x00,0x00));
	hpAircraftBorder = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
					   RGB(0xff,0xff,0xff));
d1533 2
a1534 4
	hpAircraft = (HPEN)CreatePen(PS_SOLID, IBLSCALE(3), 
				     RGB(0xff,0xff,0xff));
	hpAircraftBorder = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
					   RGB(0x00,0x00,0x00));
d1648 2
d1698 10
a1707 1
      DeleteObject(hInvBackgroundBrush);
d2733 1
a2735 2
    // JMW this isn't needed any more unless we're not drawing terrain
    
d2741 1
a2741 1
		///: consider also inverted screen, and use black for that 091109
d2743 1
a2743 1
			SelectObject(hdc, hInvBackgroundBrush);
d2746 2
a2747 1
			SelectObject(hdc, hBackgroundBrush);
d2752 9
d2907 2
a2908 2
  // Draw traffic
  if (Look8000)
d2910 3
a2912 1
  else
d2914 1
d2917 1
a2917 1
  
d2921 2
a2922 1
  
d3002 2
a3003 2
  if (!(NewMap && Look8000)||(DisplayMode == dmCircling)) // VENTA6
  DrawThermalBand(hdcDrawWindow, rc);
d3226 5
a3230 2
  DrawDashLine(hdc, 1, o1, o2,
               RGB(50,50,50), rc);
d3237 4
a3240 2
  DrawDashLine(hdc, 1, o1, o2,
               RGB(50,50,50), rc);
d3288 4
a3291 3
    if (Appearance.InverseAircraft) {
      hbPAircraftSolid = (HBRUSH) CreateSolidBrush(RGB(0xff,0xff,0xff));
      hbPAircraftSolidBg = (HBRUSH) CreateSolidBrush(RGB(0x00,0x00,0x00));
d3293 2
a3294 2
      hbPAircraftSolid = (HBRUSH) CreateSolidBrush(RGB(0x00,0x00,0x00));
      hbPAircraftSolidBg = (HBRUSH) CreateSolidBrush(RGB(0xff,0xff,0xff));
d3355 2
a3356 2
      hbAircraftSolid = (HBRUSH) CreateSolidBrush(RGB(0xff,0xff,0xff));
      hbAircraftSolidBg = (HBRUSH) CreateSolidBrush(RGB(0x00,0x00,0x00));
d3358 2
a3359 2
      hbAircraftSolid = (HBRUSH) CreateSolidBrush(RGB(0x00,0x00,0x00));
      hbAircraftSolidBg = (HBRUSH) CreateSolidBrush(RGB(0xff,0xff,0xff));
d4007 1
@


8.15
log
@1.15a
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.14 2009/10/23 16:42:47 root Exp root $
d71 1
d84 3
d178 1
a178 1
int MapWindow::GliderScreenPosition = 20; // 20% from bottom
d235 1
d286 2
a287 1
COLORREF MapWindow::BackgroundColor = RGB(0xFF,0xFF,0xFF); //sjt 02NOV05 - was F5F5F5. Changed to increase screen clarity at oblique viewing angles.
d464 14
a477 1
		ClimbMapScale = 0.05;
d1434 1
d1682 1
d1865 1
a1865 1
					gestDir=LKGESTURE_LEFT;
d1867 1
a1867 1
					gestDir=LKGESTURE_RIGHT;
d1870 1
a1870 1
					gestDir=LKGESTURE_UP;
d1872 1
a1872 1
					gestDir=LKGESTURE_DOWN;
d2707 2
a2708 2
  if (!EnableTerrain || !DerivedDrawInfo.TerrainValid 
      || !RasterTerrain::isTerrainLoaded() ) {
d2713 14
a2726 10
    if(InfoWindowActive) {
      SelectObject(hdc, GetStockObject(WHITE_BRUSH));
      SelectObject(hdc, GetStockObject(BLACK_PEN));
    }
    else {
      // JMW added light grey background
      SelectObject(hdc, hBackgroundBrush);
      SelectObject(hdc, GetStockObject(WHITE_PEN));
    }
    Rectangle(hdc,rc.left,rc.top,rc.right,rc.bottom);
d2759 1
a2759 1
    DrawTerrain(hdc, rc, sunazimuth, sunelevation);
d2769 1
a2769 1
    DrawTopology(hdc, rc);
d2892 3
a2894 1
  if ( (!TargetPan) && (!EnablePan) && (Look8000) ) {
d3678 1
d3688 1
a3688 1
void MapWaypointLabelAdd(TCHAR *Name, int X, int Y, TextInBoxMode_t Mode, int AltArivalAGL, bool inTask, bool isLandable, bool isAirport, bool isExcluded);
d3888 1
a3888 1
				    intask,false,false,false);
d3953 1
a3953 1
			 int AltArivalAGL, bool inTask, bool isLandable, bool isAirport, bool isExcluded){
@


8.14
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.13 2009/10/19 15:17:12 root Exp root $
d434 9
a442 4
  //static double CruiseMapScale = 10;
  static double CruiseMapScale = MapWindow::RequestMapScale*2; // VNT 090621 
  //static double ClimbMapScale = 0.25;
  static double ClimbMapScale = MapWindow::RequestMapScale/20;
d445 1
d448 17
a464 5
///: 091017
if (ISPARAGLIDER) {
  CruiseMapScale = MapWindow::RequestMapScale;
  ClimbMapScale = MapWindow::RequestMapScale/40;
}
d1114 16
@


8.13
log
@1.14b
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.12 2009/10/12 13:25:30 root Exp root $
d1964 10
a1973 4

	      ///: Better to keep separated virtual keyboard called from infobox under focus 
	      ///: from unfocused. We could manage things differently.
	      if ((VirtualKeys==(VirtualKeys_t)vkEnabled) && (dwInterval>= DOUBLECLICKINTERVAL)) {  
d1976 2
a1977 3
				//#ifdef DEBUG_VIRTUALKEYS
				DoStatusMessage(_T("ERR-035 Invalid Virtual Key")); 
				//#endif
d1980 3
a1982 2
			//goto Wirth; 
			break; // TESTFIX 090930
d2002 1
a2002 1
		///:  DoStatusMessage(_T("Map is locked, skipping")); 
d2008 1
a2008 1
		DoStatusMessage(_T("DBG-096 dwInterval==0"));
d2045 16
d2815 4
a2818 1
  DrawFLARMTraffic(hdc, rc, Orig_Aircraft);
@


8.12
log
@1.12
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.11 2009/09/30 13:24:26 root Exp root $
d98 1
d442 6
d1071 2
a1072 2
  if ( AircraftCategory == (AircraftCategory_t)umParaglider ) // VENTA4
    minreasonable = 0.01;
d1078 1
a1078 1
      if ( AircraftCategory == (AircraftCategory_t)umParaglider ) minreasonable = 0.02;
d1081 1
a1081 1
      if ( AircraftCategory == (AircraftCategory_t)umParaglider ) minreasonable = 0.01;
d1114 5
d1153 6
d1162 8
d1178 12
a1189 2
int MapWindow::GetMapResolutionFactor(void) {
  return IBLSCALE(30);
d1848 2
a1849 1
		if ( dwInterval < (DOUBLECLICKINTERVAL*2)) {
d1875 7
@


8.11
log
@trying to accelerate
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.10 2009/09/16 10:57:42 root Exp $
d1254 1
a1254 1
  int gestX, gestY, gestDir=LKGESTURE_NONE, gestDist=0;
d1632 1
d1640 1
a1640 1
      if (dontdrawthemap || (mapmode8000 && YstartScreen >=navboxesY)) {  
d1688 1
a1688 2
      ///: TODO FIX missing correct handler of ignorenext elsewhere 090915 maybe fixed
      ///: maybe it should not stay here at all..
d1690 3
a1692 1
		DoStatusMessage(TEXT("BUTTONDOWN with ignorenext"));
d1726 13
a1738 3

      ///: critic: a DBLCLK is followed by a simple BUTTONUP with NO buttondown.
      if (ignorenext||dwDownTime==0) { 
d1741 1
a1741 1
      }
a1746 12
/* FIX REMOVE now in Utils2
      ///: size movement for detecting gestures, vertical only
      ///: THIS SHOULD BE CONFIGURABLE!
      ///: first version values, too short but usable: /6 and /4
      static short VerticalGestureSize=(MapRect.bottom-MapRect.top)/6;
      static short HorizontalGestureSize=(MapRect.right-MapRect.left)/6;
*/
/*
	TCHAR buf[80];
	wsprintf(buf,_T("Ys=%d Y=%d Xs=%d X=%d Interval %ldms"),dwInterval);
        DoStatusMessage(buf);
*/
a1752 1
	gestDist=isqrt4((long)((gestX*gestX) + (gestY*gestY)));
d1761 22
a1782 16
	///: detect gestures here
	///: if gestX >0 gesture from right to left , gestX <0 gesture from left to right
	///: if gestY >0 gesture from down to up ,    gestY <0 gesture from up to down
	//if (gestDist<GestureSize) {
	if (gestDist<GestureSize) { 	// FIX valore da capire, 100?
		gestDir=LKGESTURE_NONE;
	} else
	{
		///: horizontal includes also perfectly diagonal gestures
		if (abs(gestX) >= abs(gestY) ) {
			///: we use LKGESTURE definition, but they have nothing to do with those used in other part of source code
			if (gestX>0) gestDir=LKGESTURE_LEFT;
			else gestDir=LKGESTURE_RIGHT;
		} else { 
			if (gestY>0) gestDir=LKGESTURE_UP;
			else gestDir=LKGESTURE_DOWN;
d1784 2
a1785 2
	}
	} // dontdrawthemap and inside mapscreen looking for a gesture
d1817 1
a1846 34
/*
//TCHAR ventabuf[100];
		if ( (YstartScreen-Y)>VerticalGestureSize) {
			///:wsprintf(ventabuf,_T("Vgsize=%d move up %d"),VerticalGestureSize,YstartScreen-Y);
			///:DoStatusMessage(ventabuf);
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_UP);
			break;
		}
		if ( (Y-YstartScreen)>VerticalGestureSize) {
			///:wsprintf(ventabuf,_T("Vgsize=%d move down %d"),VerticalGestureSize,Y-YstartScreen);
			///:DoStatusMessage(ventabuf);
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_DOWN);
			break;
		}
		if ( (XstartScreen-X)>HorizontalGestureSize) {
			///:wsprintf(ventabuf,_T("Hgsize=%d move left %d"),HorizontalGestureSize,XstartScreen-X);
			///:DoStatusMessage(ventabuf);
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_LEFT);
			break;
		}
		if ( (X-XstartScreen)>HorizontalGestureSize) {
			///:wsprintf(ventabuf,_T("Hgsize=%d move right %d"),HorizontalGestureSize,X-XstartScreen);
			///:DoStatusMessage(ventabuf);
			ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_RIGHT);
			break;
		}
		wParam=ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
		if (wParam!=0) {
			//#ifdef DEBUG_VIRTUALKEYS
			DoStatusMessage(_T("E03 Invalid Virtual Key")); 
			//#endif
			break;
		}
*/
d1873 3
d1877 5
d1884 1
a1884 1
			DoStatusMessage(_T("E03 Invalid Virtual Key")); 
d1888 2
a1889 34
		goto Wirth;

/*
		if (gestDir == LKGESTURE_NONE) {
			wParam=ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_NONE);
			if (wParam!=0) {
				//#ifdef DEBUG_VIRTUALKEYS
				DoStatusMessage(_T("E03 Invalid Virtual Key")); 
				//#endif
				break;
			}
			goto Wirth; // or break?
		} else {
			switch(gestDir) {
				case LKGESTURE_RIGHT:
					ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_RIGHT);
					break;
				case LKGESTURE_LEFT:
					ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_LEFT);
					break;
				case LKGESTURE_DOWN:
					ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_DOWN);
					break;
				case LKGESTURE_UP:
					ProcessVirtualKey(X,Y,dwInterval,LKGESTURE_UP);
					break;
				case LKGESTURE_NONE:
				default:
					DoStatusMessage(_T("Unknown gesture"));
					break;
			}
			break;
		}
*/
d1895 1
d1898 3
d1903 1
a1903 1
			DoStatusMessage(_T("E03 Invalid Virtual Key")); 
d1908 2
a1909 1
		goto Wirth; 
a1919 1
	      // X = LOWORD(lParam); Y = HIWORD(lParam);  // TODO probably REMOVE CHECK
d1926 3
a1928 3
				#ifdef DEBUG_VIRTUALKEYS
				DoStatusMessage(_T("E01 Invalid Virtual Key")); 
				#endif
d1931 2
a1932 1
			goto Wirth; 
d1958 1
a1958 1
		///:DoStatusMessage(_T("dwInterval==0 impossible!")); // TODO FIX HERE
d1962 5
a1966 5

//      distance = isqrt4((long)((XstartScreen-X)*(XstartScreen-X)+
//			       (YstartScreen-Y)*(YstartScreen-Y)))
//	/InfoBoxLayout::scale;
	distance = gestDist /InfoBoxLayout::scale;
d1980 3
d1987 1
a1987 1
			DoStatusMessage(_T("E02 INVALID Virtual Key!")); 
d1991 1
d2012 2
a2013 1
			goto Wirth; 
d2096 3
a2098 1
		///: finally process normally a click on the moving map
d2245 3
d2614 2
d2632 1
d2641 1
a2641 1
 if (DONTDRAWTHEMAP) goto QuickTrap;
a2646 1
 if (DONTDRAWTHEMAP) goto QuickTrap;
d2656 1
d2659 1
d2711 1
d3561 3
a3563 1
MapWaypointLabel_t MapWaypointLabelList[50];
@


8.10
log
@bo ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.9 2009/07/22 10:53:36 root Exp root $
d1639 1
a1639 1
      if (dontdrawthemap || (mapmode8000 && YstartScreen >=navboxesY)) { 
d2610 2
a2611 1
  if (DONTDRAWTHEMAP) {
d2619 1
d2622 1
d2674 3
a2676 1
  
d2681 2
d2689 1
d2693 1
d2729 2
d2744 1
d2748 2
d2775 2
a2776 1
 
d2778 1
d2802 2
@


8.9
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.8 2009/07/20 21:18:57 root Exp root $
d41 2
a61 1
#include "options.h"
d87 6
d96 3
a98 1
#define DONTDRAWTHEMAP IsMapFullScreen()&&NewMap&&Look8000&&!EnablePan&&MapSpaceMode!=1
d101 1
d315 1
d317 1
d320 1
d322 1
d327 1
d329 1
d334 1
d345 1
d871 1
a871 1
    ShowInfoBoxes();
d1254 1
d1262 14
d1632 1
a1632 2
      static bool ignorenext=true;
      ///: VNT This was missing and it was a nasty problem...
d1634 11
d1659 2
a1660 3
		}
/*
			///: else we are double clicking on the lk8000 navboxes and we pullup showmenu
a1668 1
*/
d1673 6
a1678 5
      // VENTA 090721 doubleclick no more used 
      //#ifndef DISABLEAUDIO
      //if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
      //#endif
      //ShowMenu();
d1687 6
a1692 1
      if (ignorenext) break;
d1698 2
d1735 1
d1737 5
a1741 1
      static short GestureSize=(MapRect.bottom-MapRect.top)/4;
d1744 1
a1744 1
	wsprintf(buf,_T("Interval %ldms"),dwInterval);
d1751 31
d1785 1
d1787 9
a1795 3
      ///: TODO VENTA size that iblscale24 to something more precise
      if ( (X > ((MapRect.right-MapRect.left)- IBLSCALE(24))) &&
	   (Y > ((MapRect.bottom-MapRect.top)- IBLSCALE(24))) ) {
d1839 8
a1846 7
	///: First case: mapspacemodes
	if (DONTDRAWTHEMAP) {
TCHAR ventabuf[100];
		if ( (YstartScreen-Y)>GestureSize) {
			wsprintf(ventabuf,_T("gsize=%d move up %d"),GestureSize,YstartScreen-Y);
			DoStatusMessage(ventabuf);
			//ProcessVirtualKey(X,Y,dwInterval,1);
d1849 4
a1852 4
		if ( (Y-YstartScreen)>GestureSize) {
			wsprintf(ventabuf,_T("gsize=%d move down %d"),GestureSize,Y-YstartScreen);
			DoStatusMessage(ventabuf);
			//ProcessVirtualKey(X,Y,dwInterval,2);
d1855 13
a1867 1
		wParam=ProcessVirtualKey(X,Y,dwInterval,0);
d1874 69
a1942 2
		///: or break??
		goto Wirth; 
d1948 1
a1948 1
		wParam=ProcessVirtualKey(X,Y,dwInterval,0);
d1965 1
a1965 1
      if(NewMap&&UseMapLock&&MapLock&&!EnablePan&&!(DONTDRAWTHEMAP)) 
d1972 1
a1972 1
			wParam=ProcessVirtualKey(X,Y,dwInterval,0);
d2005 1
a2005 1
		DoStatusMessage(_T("dwInterval==0 impossible!"));
d2010 4
a2013 3
      distance = isqrt4((long)((XstartScreen-X)*(XstartScreen-X)+
			       (YstartScreen-Y)*(YstartScreen-Y)))
	/InfoBoxLayout::scale;
d2018 1
a2018 1
	wsprintf(buf,_T("XY=%d,%d dist=%S Up=%ld Down=%ld Int=%ld"),X,Y,sbuf,dwUptime,dwDownTime,dwInterval);
d2028 1
a2028 1
		wParam=ProcessVirtualKey(X,Y,dwInterval,0);
d2048 1
a2048 1
			wParam=ProcessVirtualKey(X,Y,dwInterval,0);
d2060 1
a2060 1
      if (DONTDRAWTHEMAP) break;
d2600 3
d2604 1
d2609 1
a2609 1
  ///: let the calculations run, but dont draw anything but the look8000 when in MapSpaceMode != 1  
d2612 6
d2786 6
d2931 6
d2993 4
d3007 1
d3013 1
d3041 6
a3046 1
	GaugeVario::Show(!MapFullScreen);
d3048 7
d4432 1
a4432 1
  hDrawThread = CreateThread (NULL, 0, 
@


8.8
log
@9e
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.7 2009/07/17 15:25:30 root Exp root $
d1616 2
d1627 1
d1632 5
a1636 4
      #ifndef DISABLEAUDIO
      if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK"));
      #endif
      ShowMenu();
d1685 3
d1697 5
a1701 2
      // VNT Experimental Active Icons
      if (NewMap)
d1708 2
d1711 5
a1715 1
		if ( dwInterval < DOUBLECLICKINTERVAL) {
d1722 3
a1724 1
		*/
d1741 50
a1790 2
				
      }
a4495 64
///:
///: colorcode is taken from a 3 bit AsInt union, and thus can only handle up to TEXTMAGENTA (7).
///: technicolor ovverrides previous settings and use full short values
///:
void MapWindow::TextColor(HDC hDC, short colorcode) {

	switch (colorcode) {
	case TEXTBLACK: 
	  SetTextColor(hDC,RGB(0x00,0x00,0x00));  // black 
	  break;
	case TEXTWHITE: 
	  SetTextColor(hDC,RGB(0xff,0xff,0xff));  // white
	  break;
	case TEXTGREEN: 
	  SetTextColor(hDC,RGB(0x00,0xff,0x00));  // green
	  break;
	case TEXTRED:
	  SetTextColor(hDC,RGB(0xff,0x00,0x00));  // red
	  break;
	case TEXTBLUE:
	  SetTextColor(hDC,RGB(0x00,0x00,0xff));  // blue
	  break;
	case TEXTYELLOW:
	  SetTextColor(hDC,RGB(0xff,0xff,0x00));  // yellow
	  break;
	case TEXTCYAN:
	  SetTextColor(hDC,RGB(0x00,0xff,0xff));  // cyan
	  break;
	case TEXTMAGENTA:
	  SetTextColor(hDC,RGB(0xff,0x00,0xff));  // magenta
	  break;
	case TEXTLIGHTGREY: 
	  SetTextColor(hDC,RGB(0xcc,0xcc,0xcc));  // light grey
	  break;
	case TEXTGREY: 
	  SetTextColor(hDC,RGB(0x99,0x99,0x99));  // grey
	  break;
	case TEXTLIGHTGREEN:
	  SetTextColor(hDC,RGB(128,0xff,128));  //  light green
	  break;
	case TEXTLIGHTRED:
	  SetTextColor(hDC,RGB(0xff,0xc2,0xc2));  // light red
	  break;
	case TEXTLIGHTYELLOW:
	  SetTextColor(hDC,RGB(0xff,0xff,160));  // light yellow
	  break;
	case TEXTLIGHTCYAN:
	  SetTextColor(hDC,RGB(99,0xff,0xff));  // light cyan
	  break;
	case TEXTORANGE:
	  SetTextColor(hDC,RGB(255,265,0));  // orange
	  break;
	case TEXTLIGHTORANGE:
	  SetTextColor(hDC,RGB(255,184,51));  // light orange
	  break;
	case TEXTLIGHTBLUE:
	  SetTextColor(hDC,RGB(179,179,255));  // light blue
	  break;
	default:
	  SetTextColor(hDC,RGB(0x00,0xff,0xff));  // magenta so we know it's wrong: nobody use magenta..
	  break;
	}

}
@


8.7
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.6 2009/07/14 19:52:40 root Exp $
d2754 1
a2754 1
      //if ( !( IsMapFullScreen() && !EnablePan && Look8000 && NewMap && MapSpaceMode==1) ) { // QUI FIX
d4430 4
d4437 1
a4437 1
	case 0: 
d4440 1
a4440 1
	case 1: 
d4443 1
a4443 1
	case 2: 
d4446 1
a4446 1
	case 3:
d4449 1
a4449 1
	case 4:
d4452 1
a4452 1
	case 5:
d4455 1
a4455 1
	case 6:
d4458 1
a4458 1
	case 7:
d4461 1
a4461 1
	case 11: 
d4464 1
a4464 1
	case 12: 
d4467 1
a4467 1
	case 21:
a4468 2
	case 31:
	  SetTextColor(hDC,RGB(0xff,0x4d,0x4d));  // light red
d4470 7
a4476 3
	case 51:
	  SetTextColor(hDC,RGB(0xff,0xff,128));  // light yellow
	case 61:
d4478 10
d4489 1
a4489 1
	  SetTextColor(hDC,RGB(0x00,0xff,0xff));  // magenta so we know it's wrong
@


8.6
log
@gestione MapSpaceMode
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.5 2009/07/05 22:54:31 root Exp root $
d4457 15
@


8.5
log
@ok ma da pulire
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.4 2009/07/01 22:27:31 root Exp root $
d89 1
d635 2
a636 1
    notoverlapping = checkLabelBlock(brect);
d675 1
a675 1
    notoverlapping = checkLabelBlock(brect);
d686 16
a701 4
    brect.left = x-2;
    brect.right = brect.left+tsize.cx+4;
    brect.top = y+((tsize.cy+4)>>3)-2;
    brect.bottom = brect.top+3+tsize.cy-((tsize.cy+4)>>3);
d703 1
a703 1
    notoverlapping = checkLabelBlock(brect);
d772 16
a787 4
    brect.left = x-2;
    brect.right = brect.left+tsize.cx+4;
    brect.top = y+((tsize.cy+4)>>3)-2;
    brect.bottom = brect.top+3+tsize.cy-((tsize.cy+4)>>3);
d789 1
a789 1
    notoverlapping = checkLabelBlock(brect);
a1598 5
      // UPDATE: I think there is an event pending and that's why dblclk on infoboxes does not work
      //         as it should.  Never mind, this approach seems to be working just fine. Paolo
#ifdef DEBUG_DBLCLK
      DoStatusMessage(_T("DBLCLK MapWindow")); 
#endif
d1600 2
a1601 1
      dwDownTime = GetTickCount();  // VNT This was missing and it was a nasty problem...
d1607 1
a1607 1
		        // Unlock map only if double clicking on real map, not on navboxes!
d1616 1
a1616 1
			// else we are double clicking on the lk8000 navboxes and we pullup showmenu
d1637 1
a1637 1
      DoStatusMessage(_T("BUTTONDOWN MapWindow")); // VENTA3 
d1672 1
a1672 1
      //: critic: a DBLCLK is followed by a simple BUTTONUP with NO buttondown.
d1678 1
a1678 1
      dwUpTime = GetTickCount(); // moved at the beginning QUI
d1681 1
a1681 1
//
d1683 3
a1685 4
//	wsprintf(buf,_T("Interval %ldms"),dwInterval);
 //       DoStatusMessage(buf);
//

a1694 2
		//long tup=GetTickCount();
		//long tdown=dwUpTime-dwDownTime;
d1697 1
a1697 1
		 * Remember there's also a normal click and a long click on the same icon!
a1703 1
			//dwDownTime= 0L; KO
a1712 1
				// dwDownTime= 0L; KO
a1719 1
				// dwDownTime= 0L; KO
d1727 1
a1727 1
      if(NewMap&&UseMapLock&&MapLock&&!EnablePan) // TEST NewMap
d1729 5
a1733 7
              // dwUpTime = GetTickCount();  TEST FIX MOVED BEGINNING
	      // dwInterval = dwUpTime - dwDownTime;
	      X = LOWORD(lParam); Y = HIWORD(lParam);  // TODO probably REMOVE

	      // Better to keep separated virtual keyboard called from infobox under focus 
	      // from unfocused. We could manage things differently.
	      if ((VirtualKeys==(VirtualKeys_t)vkEnabled) && (dwInterval>= DOUBLECLICKINTERVAL)) {  // TODO FIX TEST for fine tuning
d1736 1
a1736 1
#ifdef DEBUG_VIRTUALKEYS
d1738 1
a1738 2
#endif
				// dwDownTime= 0L; // VENTA TEST FIX KO
d1744 2
a1745 3

	  // while locked, any keypress on the map which is not a virtual key will unfocus infoboxes
	  // but first check if it was already unfocused so you will not play a click 
d1752 2
a1753 4
			  iboxtoclick=true; 
		#ifdef DEBUG_VIRTUALKEYS
		  DoStatusMessage(_T("Map is locked, defocus ibox")); 
		#endif
d1755 3
a1757 3
		//
		// newmap on, maplock on, NO VK, special case 
		//
a1758 2
			//dwUpTime = GetTickCount();  // moved at the beginning VENTA TEST
			// dwDownTime = dwUpTime - dwDownTime;  TEST FIX SHOULD BE A BUG HERE!
d1761 1
a1761 3
		#ifdef DEBUG_VIRTUALKEYS
		  DoStatusMessage(_T("Map is locked, skipping")); 
		#endif
a1762 1
	  // dwDownTime= 0L; KO
a1770 3
      //dwUpTime = GetTickCount(); // moved at the beginning
      //dwInterval = dwUpTime - dwDownTime;
      // X = LOWORD(lParam); Y = HIWORD(lParam);  // VNT10 RIMOSSO INUTILE presente inizio
d1776 1
a1776 1
#ifdef DEBUG_VIRTUALKEYS
d1781 1
a1781 6
#endif

 	/*
		Handling double click passthrough
		Caution, timed clicks from PC with a mouse are different from real touchscreen devices
	 */
d1783 2
a1784 2
      //RECT rc;
      //GetClientRect(hWnd,&rc);
d1786 1
a1786 1
      // On PC a single click is around 80ms, and a doubleclick is around 150ms. 
d1791 1
a1791 1
#ifdef DEBUG_VIRTUALKEYS
d1793 1
a1793 2
#endif
	  		// dwDownTime= 0L; // VENTA TEST FIX KO
d1799 2
a1800 2
      // Process faster clicks here and no precision, but let DBLCLK pass through
      // VK are used in the bottom line in this case, forced on for this situation.
d1803 5
a1807 6
#ifdef DEBUG_VIRTUALKEYS
		DoStatusMessage(_T("Click on hidden map ignored")); 
#endif
		// do not process virtual key if it is timed as a DBLCLK
		// we want users to get used to double clicking only on infoboxes
		// and avoid triggering unwanted waypoints details
a1813 1
	  			// dwDownTime= 0L; // VENTA TEST FIX KO
d1818 2
a1819 2
	  	// dwDownTime= 0L; // VENTA TEST FIX KO
		break; // do not process click on the underneath window
d1821 2
a1822 2

      // a SINGLE click gets here only if timed < DOUBLECLICKINTERVAL/2-30 , i.e.about 145ms ? NONO
a1831 1
	  	// dwDownTime= 0L; // VENTA TEST FIX KO
d1837 2
a1838 2
	  	// dwDownTime= 0L; // VENTA TEST FIX KO
	break; // disable picking when in pan mode
a1857 1
	  	// dwDownTime= 0L; // VENTA TEST FIX KO
d1863 5
a1867 7
		// 
		// 
		// if map is locked and we are here, then if infobox are under focus accept the click
		// as an order to defocus. Otherwise since we are under lock condition we simply
		// ignore the click and break out.
		//
		if (NewMap&&UseMapLock&&MapLock) { // TEST NewMap
d1869 1
a1869 3
				#ifdef DEBUG_VIRTUALKEYS
				DoStatusMessage(_T("Map is locked, defocus ibox")); 
				#endif
a1875 1
				// dwDownTime= 0L; KO
d1877 2
a1878 4
				// dwDownTime= 0L; KO
				#ifdef DEBUG_VIRTUALKEYS
				DoStatusMessage(_T("PAN map is locked, skipping")); 
				#endif
a1879 1
	  	// dwDownTime= 0L; // VENTA TEST FIX KO
d1882 5
a1886 7
		//
		// We need to defocus infoboxes on demand here.  
		// Probably should be a good idea to use it also for standard old map with no VK
		// We do it also for old standard map with no VK.
		//
		//if ( (VirtualKeys==(VirtualKeys_t)vkEnabled) && InfoFocus>=0) { // 
		//if ( (NewMap) && InfoFocus>=0) { // 
d1888 1
a1888 3
			#ifdef DEBUG_VIRTUALKEYS
			DoStatusMessage(_T("Defocus ibox")); 
			#endif
d1894 1
a1894 2
			// dwDownTime= 0L; KO
			iboxtoclick=true; // a stupid hack
d1898 3
a1900 3
		//
		// finally process normally a click on the moving map
		//
d1902 5
a1906 5
			//
			// VNT Shorter the time needed to trigger a WP select, solving also the annoying problem
			// of unwanted wp selection while double clicking too slow!
			// And at the same time let this action pass transparently to virtual keys.
			//
a1908 1
					// dwDownTime= 0L; KO
d1912 3
a1914 3
				// If we are here,  (DCI/2)+30 < dwDownTime < DOUBLECLICKINTERVAL
				// SO this is a tight interval. DCI should not be set too low. See Defines.h
				// NO: VKSHORTCLICK-DCI  150-350 ?
a1915 1
					// dwDownTime= 0L; KO
d1920 1
a1920 1
			if(dwInterval < AIRSPACECLICK) { // original and untouched interval in 
a1921 1
			    // dwDownTime= 0L; KO
a1925 1
			    // dwDownTime= 0L; KO
a1930 1
			    // dwDownTime= 0L; KO
d2365 6
a2370 1
  
d2414 1
d2426 1
a2426 1
  
d2488 4
a2491 1
  
d2496 1
d2531 3
d2565 6
d2586 1
a2586 1
    DrawHorizon(hdcDrawWindow, rc);
d2754 1
a2754 1
      GaugeFLARM::Render(&DrawInfo);
d2756 3
a2758 1
      RenderMapWindow(MapRect);
@


8.4
log
@wip ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.3 2009/06/27 17:17:55 root Exp root $
d1215 1
a1215 1
  static DWORD dwDownTime= 0L, dwUpTime= 0L;
d1578 2
d1590 1
d1598 1
d1607 1
a1607 2
      dwDownTime = GetTickCount();  // VNT This was missing and it was a nasty problem...
#ifndef DISABLEAUDIO
d1609 1
a1609 1
#endif
d1614 1
a1614 1
#ifdef DEBUG_DBLCLK
d1616 1
a1616 1
#endif
d1619 1
d1621 2
d1650 5
d1656 9
d1674 2
a1675 2
		long tup=GetTickCount();
		long tdown=tup-dwDownTime;
d1680 1
a1680 1
		if ( tdown < DOUBLECLICKINTERVAL) {
d1685 1
a1685 1
			dwDownTime= 0L;
d1689 1
a1689 1
		if ( tdown >=1500) { // TODO VKTIMELONG in Defines.h
d1695 1
a1695 1
				dwDownTime= 0L;
d1703 1
a1703 1
				dwDownTime= 0L;
d1713 3
a1715 3
              dwUpTime = GetTickCount(); 
	      dwDownTime = dwUpTime - dwDownTime;
	      X = LOWORD(lParam); Y = HIWORD(lParam); 
d1719 2
a1720 2
	      if ((VirtualKeys==(VirtualKeys_t)vkEnabled) && (dwDownTime>= DOUBLECLICKINTERVAL)) {  // TODO FIX TEST for fine tuning
			wParam=ProcessVirtualKey(X,Y,dwDownTime,0);
d1725 1
d1740 1
d1749 2
a1750 2
			dwUpTime = GetTickCount(); 
			dwDownTime = dwUpTime - dwDownTime;
d1757 1
a1757 1
	  dwDownTime= 0L;
d1761 4
a1764 1
      if (dwDownTime == 0) break; // should be impossible
d1766 2
a1767 2
      dwUpTime = GetTickCount(); 
      dwDownTime = dwUpTime - dwDownTime;
d1777 1
a1777 1
	wsprintf(buf,_T("XY=%d,%d dist=%S ms=%ld"),X,Y,sbuf,dwDownTime);
d1791 2
a1792 2
      if ((VirtualKeys==(VirtualKeys_t)vkEnabled) && distance<50 && (dwDownTime>= DOUBLECLICKINTERVAL)) { 
		wParam=ProcessVirtualKey(X,Y,dwDownTime,0);
d1797 1
d1813 2
a1814 2
		if (dwDownTime >= ( (DOUBLECLICKINTERVAL/2-30) )) { // fast dblclk required here.
			wParam=ProcessVirtualKey(X,Y,dwDownTime,0);
d1819 1
d1824 1
d1828 1
a1828 1
      // So far, a single click gets here if timed < DOUBLECLICKINTERVAL/2-30 , i.e.about 145ms
d1838 1
d1840 1
a1840 1
      } else if (!TargetPan && EnablePan && (distance>36)) {
d1844 1
d1865 1
d1887 2
a1888 1
				dwDownTime= 0L;
d1890 1
a1890 1
				dwDownTime= 0L;
d1895 1
d1914 2
a1915 1
			dwDownTime= 0L;
d1928 1
a1928 1
			if(dwDownTime < 100) { //100ms is way enough for a short click
d1930 1
a1930 1
					dwDownTime= 0L;
d1934 3
a1936 1
				// If we are here, dwDownTime <DOUBLECLICKINTERVAL but >DCI/3
d1938 1
a1938 1
					dwDownTime= 0L;
d1943 1
a1943 1
			if(dwDownTime < 1000) {
d1945 1
a1945 1
			    dwDownTime= 0L;
d1950 1
a1950 1
			    dwDownTime= 0L;
d1956 1
@


8.3
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.2 2009/06/24 10:03:24 root Exp root $
d1656 4
d1667 19
d1687 1
d2566 2
a2567 2
  //if (!(NewMap && Look8000)||(DisplayMode == dmCircling))
  if (!(NewMap && Look8000))
@


8.2
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 8.1 2009/06/19 20:28:25 venta Exp root $
a1015 2
// VENTA4 TODO someone please fix more zoom for para (how?)
// JMW you've done it!
d1298 6
a1303 6
      if (Appearance.FlightModeIcon == apFlightModeIconAltA){
	//hCruise=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_CRUISE_B));
	//hClimb=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_CLIMB_B));
	//hFinalGlide=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FINALGLIDE_B));
	//hAbort=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FINALGLIDE_ABORT_B));
	//hBmpClimbeAbort=LoadBitmap(hInst, MAKEINTRESOURCE(IDB_CLIMB_ABORT_B));
d1578 1
a1578 1
      if (UseMapLock) {
d1643 25
a1667 1
      if(MapLock&&!EnablePan)
a1685 1
	  dwDownTime= 0L;
d1696 1
a1696 1
		  DoStatusMessage(_T("Map is locked, unfocus ibox")); 
d1699 8
d1711 1
d1719 1
a1719 1
      X = LOWORD(lParam); Y = HIWORD(lParam);                     
d1737 2
a1738 2
      RECT rc;
      GetClientRect(hWnd,&rc);
d1756 1
d1766 3
a1768 3
#ifdef DEBUG_VIRTUALKEYS
				DoStatusMessage(_T("Virtual Key 0")); 
#endif
d1776 2
d1816 7
a1822 1
		if (MapLock) {
d1825 1
a1825 1
				DoStatusMessage(_T("PAN map is locked, unfocus ibox")); 
d1829 3
d1841 18
a1858 16
	
	if (VirtualKeys==(VirtualKeys_t)vkEnabled) {
		// VNT Shorter the time needed to trigger a WP select, solving also the annoying problem
		// of unwanted wp selection while double clicking too slow!
		// And at the same time let this action pass transparently to virtual keys.
		if(dwDownTime < 100) { //100ms is way enough for a short click
		  if (Event_NearestWaypointDetails(Xstart, Ystart, 500*MapScale, false)) {
		    dwDownTime= 0L;
		    break;
		  }
		} else {
		  // If we are here, dwDownTime <DOUBLECLICKINTERVAL but >DCI/3
		  if (Event_InteriorAirspaceDetails(Xstart, Ystart)) {
		    dwDownTime= 0L;
		    break;
		  }
d1860 22
a1881 6
	} else {
		if(dwDownTime < 1000) {
		  if (Event_NearestWaypointDetails(Xstart, Ystart, 500*MapScale, false)) {
		    dwDownTime= 0L;
		    break;
		  }
d1883 12
a1894 6
		  if (Event_InteriorAirspaceDetails(Xstart, Ystart)) {
		    dwDownTime= 0L;
		    break;
		  }
		}
	} // NewMap
a2483 2
    // VENTA TODO check other cases to exclude VG
    // JMW added one of those cases..
d2542 2
a2543 1
  if (!(NewMap && Look8000)||(DisplayMode == dmCircling))
d2546 1
a2546 1
  //  DrawSpeedToFly(hdcDrawWindow, rc);
d2552 2
a2553 1
   * In fact we just need once in a second somewhere to check for the following.
d2555 1
a2555 1
  if ( InfoWindowActive && UseMapLock ) {
d2779 52
@


8.1
log
@beta8
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.8 2009/06/14 11:28:52 root Exp $
d79 1
d176 3
a178 3
double MapWindow::RequestMapScale = 5;
double MapWindow::MapScale = 5;
double MapWindow::MapScaleOverDistanceModify = 5/DISTANCEMODIFY;
d414 4
a417 2
  static double CruiseMapScale = 10;
  static double ClimbMapScale = 0.25;
d1029 2
a1030 1
      minreasonable = 0.88;
d1032 1
a1032 1
      if ( AircraftCategory == (AircraftCategory_t)umParaglider ) minreasonable = 0.14;
d1570 7
a1576 7
      // Added by ARH to show menu button when mapwindow is
      // double clicked.
      // VENTA3 TODO: do not handle this event and remove CS_DBLCLKS in register class.
      // Only handle timed clicks in BUTTONDOWN with no proximity and allow triple clicks
      // and less CPU hogging.
      // UPDATE> I think there is an event pending and that's why dblclk on infoboxes does not work
      //         as it should.  
d1578 1
a1578 1
      DoStatusMessage(_T("DBLCLK MapWindow")); // VENTA3 
d1580 2
a1581 2
      if ((AircraftCategory == (AircraftCategory_t)umParaglider) && InfoWindowActive )
	// VENTA4 TODO make use of map doubleclick for anything else than ShowMenu in the near future
d1583 22
a1604 6
	  DoStatusMessage(_T("MAP UNLOCKED")); 
	  dwDownTime= 0L;
	  DefocusInfoBox();
	  SetFocus(hWnd);
	  break;
	}
d1606 3
d1643 1
a1643 1
    
d1645 2
a1646 6
      //if ( (AircraftCategory == (AircraftCategory_t)umParaglider) && !InfoBoxLayout::fullscreen )
      //TCHAR ventabuffer[80];
      //wsprintf(ventabuffer,TEXT("WMKEY uMsg=%d wParam=%ld lParam=%ld"), uMsg, wParam,(unsigned long)lParam);
      //DoStatusMessage(ventabuffer); FIX REMOVE 
      if(InfoWindowActive&&!EnablePan)
	{
d1653 1
a1653 1
	      if (NewMap && (dwDownTime>= DOUBLECLICKINTERVAL)) {  // TODO FIX TEST for fine tuning
d1657 1
a1657 1
				DoStatusMessage(_T("Invalid Virtual Key")); 
a1662 3
	  if ( AircraftCategory == (AircraftCategory_t)umParaglider ) {
	      break; // VNT do not defocus for paraglider until a dblclk
          }
d1665 17
a1681 2
	  DefocusInfoBox();
	  SetFocus(hWnd);
d1683 1
a1683 1
	}
a1687 5

//			TCHAR sbu[40];
//			wsprintf(sbu,_T("up=%ld down=%ld%"),dwUpTime,dwDownTime);
//	  		DoStatusMessage(sbu); 

d1694 5
a1698 6
/*
	TCHAR buf[80];
	char sbuf[80];
	sprintf(sbuf,"%f",distance);
	wsprintf(buf,_T("X=%d Xst=%d Y=%d Yst=%d distance=%S"),
	X,XstartScreen,Y,YstartScreen,sbuf);
d1700 2
a1701 1
*/
d1704 1
a1704 2
		Caution, timed clicks from PC with a mouse are different from real CE device
		We set 50 as an experimental non-configurable value, which showed to be reasonable
d1710 3
a1712 1
      if (distance<50 && NewMap && (dwDownTime>= DOUBLECLICKINTERVAL)) {  // TODO TEST for fine tuning
d1716 1
a1716 1
			DoStatusMessage(_T("INVALID Virtual Key!")); 
d1724 1
d1783 33
a1815 5
	if(dwDownTime < 1000) {
	  if (Event_NearestWaypointDetails(Xstart, Ystart, 500*MapScale, false)) {
	    dwDownTime= 0L;
	    break;
	  }
d1817 14
a1830 6
	  if (Event_InteriorAirspaceDetails(Xstart, Ystart)) {
	    dwDownTime= 0L;
	    break;
	  }
	}
      }
d2485 9
d4281 1
a4281 1
	  SetTextColor(hDC,RGB(0x00,0xff,0xff));  // magenta
@


1.8
log
@provvisorio ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.7 2009/06/11 19:50:04 root Exp root $
@



1.7
log
@alfa
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.6 2009/06/09 16:44:11 root Exp root $
d1626 1
a1626 1
      if(InfoWindowActive)
d1665 21
a1685 2
      // Handling double click passthrough
      if (NewMap && (dwDownTime>= DOUBLECLICKINTERVAL)) {  // TODO TEST for fine tuning
d1696 20
a1715 4

      distance = isqrt4((long)((XstartScreen-X)*(XstartScreen-X)+
			       (YstartScreen-Y)*(YstartScreen-Y)))
	/InfoBoxLayout::scale;
@


1.6
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.5 2009/06/07 11:38:07 root Exp $
d69 1
d1213 1
a1213 1
  static DWORD dwDownTime= 0, dwUpTime= 0;
d1580 1
a1580 1
	  dwDownTime= 0;
d1585 1
d1623 3
d1628 19
a1646 2
	  if ( AircraftCategory == (AircraftCategory_t)umParaglider ) break; 
	  // VENTA4 use doubleclick to defocus
d1648 1
a1648 1
	  dwDownTime= 0;
a1652 2
      if (dwDownTime== 0) 
	break;
d1654 9
a1662 2
      dwUpTime = GetTickCount(); dwDownTime = dwUpTime - dwDownTime;
    
d1664 14
d1722 1
a1722 1
	    dwDownTime= 0;
d1727 1
a1727 1
	    dwDownTime= 0;
d1751 2
a1752 1
      // VENTA-TODO careful here, keyup no more trapped for PNA!
d1756 1
a1756 1
      wsprintf(ventabuffer,TEXT("MAPWND uMsg %d wParam %d"), uMsg, wParam);
d1845 2
a1846 2

      dwDownTime= 0;
d1853 1
a1853 1
	dwDownTime= 0;
d1859 1
a1859 1
	dwDownTime= 0;
d2514 1
a2514 1
      if (BigZoom) {
d2516 2
a2517 1
	DrawMapScale(hdcScreen, MapRect, true);
@


1.5
log
@ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.4 2009/06/04 16:02:57 root Exp root $
d254 1
d296 2
a297 1
extern HFONT  InfoWindowFont;
d1260 9
d1410 4
a1413 1
      hpMapScale = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
@


1.4
log
@nuova versione ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.3 2009/06/01 22:14:03 root Exp root $
d708 1
a708 18

	switch (Mode.AsFlag.Color) {
	case 0: 
	  SetTextColor(hDC,RGB(0xff,0xff,0xff)); 
	  break;
	case 1: 
	  SetTextColor(hDC,RGB(0x00,0xff,0x00));  // green
	  break;
	case 2:
	  SetTextColor(hDC,RGB(0xff,0x00,0x00));  // red
	  break;
	case 3:
	  SetTextColor(hDC,RGB(0x00,0x00,0xff));  // blue
	  break;
	default:
	  SetTextColor(hDC,RGB(0xff,0xff,0xff)); 
	  break;
	}
d739 1
a739 18

	switch (Mode.AsFlag.Color) {
	case 0: 
	  SetTextColor(hDC,RGB(0xff,0xff,0xff)); 
	  break;
	case 1: 
	  SetTextColor(hDC,RGB(0x00,0xff,0x00));  // green
	  break;
	case 2:
	  SetTextColor(hDC,RGB(0xff,0x00,0x00));  // red
	  break;
	case 3:
	  SetTextColor(hDC,RGB(0x00,0x00,0xff));  // blue
	  break;
	default:
	  SetTextColor(hDC,RGB(0xff,0xff,0xff)); 
	  break;
	}
d745 1
a745 1
	SetTextColor(hDC,RGB(0x00,0x00,0x00)); 
d762 6
a767 1
      ExtTextOut(hDC, x, y, 0, NULL, Value, size, NULL);
d769 6
a774 1
      ExtTextOut(hDC, x, y, ETO_OPAQUE, NULL, Value, size, NULL);
d4091 33
@


1.3
log
@funziona
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.2 2009/05/27 09:56:06 root Exp root $
d686 1
a686 1
      if (NewMap||OutlinedTp)
d699 9
a707 7
      if (NewMap||OutlinedTp) {
	ExtTextOut(hDC, x, y+2, 0, NULL, Value, size, NULL); 
	ExtTextOut(hDC, x, y-2, 0, NULL, Value, size, NULL); 
	ExtTextOut(hDC, x-3, y, 0, NULL, Value, size, NULL); 
	ExtTextOut(hDC, x+3, y, 0, NULL, Value, size, NULL); 
	ExtTextOut(hDC, x, y+3, 0, NULL, Value, size, NULL); 
	ExtTextOut(hDC, x, y-3, 0, NULL, Value, size, NULL); 
d730 1
a730 1
      if (NewMap||OutlinedTp)
a733 1
      ExtTextOut(hDC, x+3, y, ETO_OPAQUE, NULL, Value, size, NULL);
a737 1
      ExtTextOut(hDC, x-3, y, ETO_OPAQUE, NULL, Value, size, NULL);
d740 16
a755 5
      ExtTextOut(hDC, x, y+2, ETO_OPAQUE, NULL, Value, size, NULL);
      ExtTextOut(hDC, x, y-2, ETO_OPAQUE, NULL, Value, size, NULL);
      ExtTextOut(hDC, x, y+3, ETO_OPAQUE, NULL, Value, size, NULL);
      ExtTextOut(hDC, x, y-3, ETO_OPAQUE, NULL, Value, size, NULL);
      if (NewMap||OutlinedTp) {
d778 1
a778 1
      if (NewMap||OutlinedTp)
d2344 1
d2347 1
a2347 1
  // VENTA5 FIX make it redundant
d3069 1
a3069 1
	    if (intask||OutlinedTp) { // VNT 
d3713 10
a3722 1
  _itot(iround(DerivedDrawInfo.WindSpeed * SPEEDMODIFY), sTmp, 10);
a3723 5
  TextInBoxMode_t TextInBoxMode = { 16 | 32 }; // JMW test {2 | 16};
  if (Arrow[5].y>=Arrow[6].y) {
    TextInBox(hdc, sTmp, Arrow[5].x-kx, Arrow[5].y, 0, TextInBoxMode);
  } else {
    TextInBox(hdc, sTmp, Arrow[6].x-kx, Arrow[6].y, 0, TextInBoxMode);
@


1.2
log
@work in progress ma ok
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.1 2009/05/25 09:47:57 root Exp root $
d2966 6
a2971 3
static int _cdecl MapWaypointLabelListCompare(const void *elem1, const void *elem2 );
static MapWaypointLabel_t MapWaypointLabelList[50];
static int MapWaypointLabelListCount=0;
a3206 323
//
// VENTA5 modified to declutter boxed outlandings and turnpoints symbols with no names and
// to make airport names visible in middle zoom levels. Also supposed to be smarter in deciding
// if an airport or outlanding need to be fully visible with arrival height or not.
//
void MapWindow::DrawWaypointsNew(HDC hdc, const RECT rc)
{
  unsigned int i; 
  int bestwp=-1;
  TCHAR Buffer[32];
  TCHAR Buffer2[32];
  TCHAR sAltUnit[4];
  TextInBoxMode_t TextDisplayMode;

  // if pan mode, show full names
  int pDisplayTextType = DisplayTextType;
  if (EnablePan) {
    pDisplayTextType = DISPLAYNAME;
  }

  if (!WayPointList) return;

  _tcscpy(sAltUnit, Units::GetAltitudeName());

  MapWaypointLabelListCount = 0;

  // VENTA5 Preliminar check to exclude boxed outlandings
  // hopefully the time we spend here is compensated by the time saved painting unnecessary outlandings

  int arrivalcutoff=0, foundairport=0;
  bool isairport;
  bool islandpoint;

  if (MapScale <=20) for(i=0;i<NumberOfWayPoints;i++) 
    {
      if (WayPointList[i].Visible == false )	continue;
      if ( (WayPointList[i].Flags & LANDPOINT) != LANDPOINT) continue;

      if ((WayPointList[i].Flags & AIRPORT) == AIRPORT) {
	if (WayPointList[i].Reachable == false)	{
	  SelectObject(hDCTemp,hBmpAirportUnReachable);
	} else
	  {
	    SelectObject(hDCTemp,hBmpAirportReachable);
	    if ( arrivalcutoff < (int)(WayPointList[i].AltArivalAGL)) {
	      arrivalcutoff = (int)(WayPointList[i].AltArivalAGL);
	      bestwp=i; foundairport++;
	    }
	  }
      } else { // outlanding
	if (WayPointList[i].Reachable == false)	 
	  SelectObject(hDCTemp,hBmpFieldUnReachable);
	else { 
	  SelectObject(hDCTemp,hBmpFieldReachable);
	  if (foundairport == 0) { // get the outlanding as bestwp only if no other choice
	    // do not set arrivalcutoff: any next reachable airport is better than an outlanding
	    if ( arrivalcutoff < (int)(WayPointList[i].AltArivalAGL)) bestwp=i;  
	  }
	}
      }

      DrawBitmapX(hdc,
		  WayPointList[i].Screen.x-IBLSCALE(10), 
		  WayPointList[i].Screen.y-IBLSCALE(10),
		  20,20,
		  hDCTemp,0,0,SRCPAINT);

      DrawBitmapX(hdc,
		  WayPointList[i].Screen.x-IBLSCALE(10), 
		  WayPointList[i].Screen.y-IBLSCALE(10),
		  20,20,
		  hDCTemp,20,0,SRCAND);

    }
  if (foundairport==0 && bestwp>=0)  arrivalcutoff = (int)WayPointList[bestwp].AltArivalAGL;



  for(i=0;i<NumberOfWayPoints;i++)
    {
      if(WayPointList[i].Visible )
	{

#ifdef HAVEEXCEPTIONS
	  __try{
#endif

	    bool irange = false;
	    bool intask = false;
	    bool islandable;	// isairport+islandpoint
	    bool excluded=false;
	    bool dowrite;

	    intask = WaypointInTask(i);
	    dowrite = intask; // initially set only for intask
	    TextDisplayMode.AsInt = 0;

	    // airports are also landpoints. should be better handled
	    isairport=((WayPointList[i].Flags & AIRPORT) == AIRPORT);
	    islandpoint=((WayPointList[i].Flags & LANDPOINT) == LANDPOINT);

	    if (isairport || islandpoint) islandable=true; else islandable=false;

	    irange = WaypointInRange(i); // always in range if MapScale <=10  since no zoom in waypoints is documented
	    // and .Zoom is always 0. 

	    if(MapScale > 20) { 
	      SelectObject(hDCTemp,hSmall);
	      irange=false;
	      goto NiklausWirth; // with compliments
	    } 

	    if( islandable ) { 

	      if(WayPointList[i].Reachable){

		TextDisplayMode.AsFlag.Reachable = 1;

		if ( isairport )
		  SelectObject(hDCTemp,hBmpAirportReachable);
		else
		  SelectObject(hDCTemp,hBmpFieldReachable);

		if ((DeclutterLabels<2)||intask) { 

		  dowrite = true;

		  // exclude outlandings worst than visible airports, only when there are visible reachable airports!
		  if ( isairport==false && islandpoint==true ) {
		    if ( (int)WayPointList[i].AltArivalAGL >=2000 ) { // more filter
		      excluded=true;
		    } else {
		      if ( i==bestwp && foundairport==0 ) { // this outlanding is the best option
			isairport=true;
			islandpoint=false; // make it an airport TODO paint it as best
		      } else
			{
			  if ( foundairport >0 ) {
			    if ( (int)WayPointList[i].AltArivalAGL <= arrivalcutoff ) {
			      excluded=true;
			    } 
			    /*
			      if (MapScale >3 && MapScale <10 ) {
			      if ( (i!=bestwp)  && (arrivalcutoff>600) ) {
			      if ( (arrivalcutoff / ((int)WayPointList[i].AltArivalAGL+1))<4) {
			      excluded=true;
			      }
			      if (foundairport>2) excluded=true;
			      }
			      } else {
			      if ( (int)WayPointList[i].AltArivalAGL <= arrivalcutoff ) {
			      excluded=true;
			      } 
			      }
			    */
			  }
			}
		    }

		  }  else
		    // do not display airport arrival if close to the best so far.
		    // ex: best arrival is 1200m, include onlye below 1200/4  (prevent division by zero)
		    // This way we only display far points, and skip closer points 
		    // WE NEED MORE INFO ABOUT LANDING POINTS: THE .CUP FORMAT WILL LET US KNOW WHAT IS
		    // BEST TO SHOW AND WHAT IS NOT. Winpilot format is useless here.
		    {
		      dowrite=true;// TEST FIX not necessary probably
		      // it's an airport
		      if ( (i != bestwp) && (arrivalcutoff>600) ) {
			if ( (arrivalcutoff / ((int)WayPointList[i].AltArivalAGL+1))<4 ) {
			  excluded=true;
			}
		      }
		    } 
		}


	      } else  // landable waypoint is unreachable
		{
		  dowrite=true; 
		  if ( isairport ) {
		    SelectObject(hDCTemp,hBmpAirportUnReachable);
		  } else {
		    SelectObject(hDCTemp,hBmpFieldUnReachable);
		  }
		}
	    } else { // waypoint is an ordinary turnpoint
	      if(MapScale > 4) {
		SelectObject(hDCTemp,hSmall);
	      } else {
		SelectObject(hDCTemp,hTurnPoint);
	      }

	    } // end landable-not landable

	  NiklausWirth:

	    if (intask||OutlinedTp) { 
	      TextDisplayMode.AsFlag.WhiteBold = 1;
	    }

	    // here come both turnpoints and landables..
	    if( intask || irange || dowrite) {  // irange almost always set when MapScale <=10 

	      bool draw_alt = TextDisplayMode.AsFlag.Reachable && ((DeclutterLabels<1) || intask); // reachable landing point!

	      if (excluded==true) draw_alt=false; // exclude close outlandings

	      switch(pDisplayTextType) {

	      case DISPLAYNAMEIFINTASK:
		dowrite = intask;
		if (intask) {
		  if (draw_alt) {
		    wsprintf(Buffer, TEXT("%s:%d%s"),
			     WayPointList[i].Name, 
			     (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			     sAltUnit);
		  }
		  else {
		    wsprintf(Buffer, TEXT("%s"),WayPointList[i].Name);
		  }
		}
		break;
// FIX VENTA6 completare
	      case DISPLAYNAME:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		if ( (islandable && !isairport) && MapScale >=10 ) dowrite=0; // FIX then no need to go further

		if (draw_alt) {
		  if ( ArrivalValue == (ArrivalValue_t) avAltitude )
		  	wsprintf(Buffer, TEXT("%s:%d%s"), WayPointList[i].Name, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), sAltUnit);
		  else 
		  	wsprintf(Buffer, TEXT("%s:%d"), WayPointList[i].Name, (int)WayPointCalc[i].GR);

		  //wsprintf(Buffer, TEXT("%s:%d:%d"), WayPointList[i].Name, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), (int)MapScale);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
		} else {
		  wsprintf(Buffer, TEXT("%s"),WayPointList[i].Name);
		  //wsprintf(Buffer, TEXT("%s%d"),WayPointList[i].Name,(int)MapScale);
		  if (islandable && isairport) {
		    TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
		  }
		}
				  
		break;
	      case DISPLAYNUMBER:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		if ( (islandable && !isairport) && MapScale >=10 ) dowrite=0; // FIX then no need to go further

		if (draw_alt) {
		  wsprintf(Buffer, TEXT("%d:%d%s"), WayPointList[i].Number, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), sAltUnit);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
		} else {
		  wsprintf(Buffer, TEXT("%d"),WayPointList[i].Number);
		  if (islandable && isairport) {
		    TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
		  }
		}
		break;
	      case DISPLAYFIRSTFIVE:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		_tcsncpy(Buffer2, WayPointList[i].Name, 5);
		Buffer2[5] = '\0';
		if (draw_alt) {
		  wsprintf(Buffer, TEXT("%s:%d%s"),
			   Buffer2, 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
		}
		else {
		  wsprintf(Buffer, TEXT("%s"),Buffer2);
		  if (islandable && isairport) {
		    TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
		  }

		}
				  
		break;
	      case DISPLAYFIRSTTHREE:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		_tcsncpy(Buffer2, WayPointList[i].Name, 3);
		Buffer2[3] = '\0';
		if (draw_alt) {
		  wsprintf(Buffer, TEXT("%s:%d%s"),
			   Buffer2, 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
		}
		else {
		  wsprintf(Buffer, TEXT("%s"),Buffer2);
		  if (islandable && isairport) {
		    TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
		  }

		}
				  
				  
		break;
	      case DISPLAYNONE:
		dowrite = (DeclutterLabels<2) || intask || islandable; 
		if (draw_alt) {
		  wsprintf(Buffer, TEXT("%d%s"), 
			   (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), 
			   sAltUnit);
		  TextDisplayMode.AsFlag.Border = 1;
		  TextDisplayMode.AsFlag.WhiteBold = 0;
		}
		else {
		  Buffer[0]= '\0';
		  dowrite=false;
		}
	      default:
#if (WINDOWSPC<1)
		ASSERT(0);
#endif
		break;
a3207 1
	      } // end intask/irange/dowrite
d3209 2
a3210 92
	      if (MapScale>=3 && MapScale<10 && islandable && dowrite) { // can't find a better solution for this 
		if (isairport)
		  TextInBox(hdc, Buffer, WayPointList[i].Screen.x+5, WayPointList[i].Screen.y, 0, TextDisplayMode, false);  
		else
		  TextInBox(hdc, Buffer, WayPointList[i].Screen.x+5, WayPointList[i].Screen.y, 0, TextDisplayMode, true);  
		dowrite=false; // do not pass it along
	      }
	      if (MapScale<3 && islandable && dowrite) { // damned irange problems
		TextInBox(hdc, Buffer, WayPointList[i].Screen.x+5,
			  WayPointList[i].Screen.y, 0, TextDisplayMode, false);  
		dowrite=false; // do not pass it along
	      }
	      if (MapScale>=10 && MapScale<20 && islandable && dowrite) { // damned irange problems
		TextInBox(hdc, Buffer, WayPointList[i].Screen.x+5,
			  WayPointList[i].Screen.y, 0, TextDisplayMode, true); 
		dowrite=false; // do not pass it along
	      }

	      if (dowrite) { 
		MapWaypointLabelAdd(
				    Buffer,
				    WayPointList[i].Screen.x+5,
				    WayPointList[i].Screen.y,
				    TextDisplayMode,
				    (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY),
				    intask,islandable,isairport,excluded);
	      }
	    } // end if intask
      
#ifdef HAVEEXCEPTIONS
	  }__finally
#endif
	     { ; }
	} // if visible
    } // for all waypoints
 
  qsort(&MapWaypointLabelList, MapWaypointLabelListCount, sizeof(MapWaypointLabel_t), MapWaypointLabelListCompare);

  int j;

  // now draw task/landable waypoints in order of range (closest last)
  // writing unconditionally

  for (j=MapWaypointLabelListCount-1; j>=0; j--){

    MapWaypointLabel_t *E = &MapWaypointLabelList[j];

    // draws if they are in task unconditionally,
    // otherwise, does comparison
    if ( E->inTask || (E->isLandable && !E->isExcluded) ) { 
      TextInBox(hdc, E->Name, E->Pos.x,
		E->Pos.y, 0, E->Mode, 
		false); 
    }
  }

  // now draw normal waypoints in order of range (furthest away last)
  // without writing over each other (or the task ones)
  for (j=0; j<MapWaypointLabelListCount; j++) {

    MapWaypointLabel_t *E = &MapWaypointLabelList[j];

    if (!E->inTask && !E->isLandable ) {

      if ( TextInBox(hdc, E->Name, E->Pos.x, E->Pos.y, 0, E->Mode, true) == true) {
	if(MapScale > 4) {
	  SelectObject(hDCTemp,hSmall);
	} else {
	  SelectObject(hDCTemp,hTurnPoint);
	}

	DrawBitmapX(hdc,
		    E->Pos.x-IBLSCALE(10), 
		    E->Pos.y-IBLSCALE(10),
		    20,20,
		    hDCTemp,0,0,SRCPAINT);
        
	DrawBitmapX(hdc,
		    E->Pos.x-IBLSCALE(10), 
		    E->Pos.y-IBLSCALE(10),
		    20,20,
		    hDCTemp,20,0,SRCAND);
      }


    }
  }

} // end DrawWaypoint


static int _cdecl MapWaypointLabelListCompare(const void *elem1, const void *elem2 ){
a4098 317

/*
 * The VisualGlide by Paolo Ventafridda
 * Sort of a Stockmar dynamic chart!
 *
 * VisualGlide=1 : Steady sector/circle
 *             2 : Moving sector/circle   optional configurable, not much useful.
 */
void MapWindow::DrawGlideCircle(HDC hdc, POINT Orig, RECT rc )
{
  double tmp=0;
  TCHAR gtext[100];
  char text[20]; // TODO size it 

  double cruise= CALCULATED_INFO.CruiseLD;
  // VENTA3 TODO: use maxcruise with tail wind with a better checking. Otherwise use only bestLD for safety
  // VENTA3 TODO: make maxcruise dynamic 
  // static double maxcruise=(GlidePolar::bestld*1.2); // max bestLD + 20% (max tail wind benefit) 
  static double maxcruise=(GlidePolar::bestld); 
  static double mincruise=(GlidePolar::bestld/4);
  int i;
  double gunit;
  COLORREF oldcolor=0;
  HFONT oldfont;
  static int spread=0;
  //static short rcx=rc.left+rc.right/2-30; 
  //static short rcy=rc.top+rc.bottom-35;
  short rcx=rc.left+rc.right/2-IBLSCALE(20); 
  short rcy=rc.bottom-IBLSCALE(15); // 35

  if ( cruise < 0 ) cruise = GlidePolar::bestld;
  if ( cruise < mincruise ) return;
  if ( cruise >maxcruise ) cruise=maxcruise;

  // Spread from 
  static short turn=1;
  static short count=0;
  spread += (10 * turn); 
  if ( spread <-25 || spread >25 ) turn*=-1;
  if ( ++count >6) count=-1;

  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
  // SetBkMode(hdc,TRANSPARENT);

  oldfont = (HFONT)SelectObject(hdc, MapWindowBoldFont);

  // 100m or 300ft scale
  if ( Units::GetUserAltitudeUnit() == unMeter ) gunit=100; else gunit = 91.44;

  for (i=1; i<9; i++) {

      SelectObject(hdc, hpVisualGlideHeavyBlack);
/* uncomment to make it toggling colors
    if (turn>0 ) {
      if ( (i==2 || i==4 || i==6 || i == 8) ) SelectObject(hdc, hpVisualGlideHeavyRed);
      else SelectObject(hdc, hpVisualGlideLightRed);
    } else {
      if ( (i==2 || i==4 || i==6 || i == 8) ) SelectObject(hdc, hpVisualGlideHeavyBlack);
      else SelectObject(hdc, hpVisualGlideLightBlack);
    }
*/

    /*
     * TRACKUP, NORTHUP, NORTHCIRCLE, TRACKCIRCLE, NORTHTRACK
     */
    if ( ( DisplayOrientation == TRACKUP) || (DisplayOrientation == NORTHCIRCLE) 
	 || (DisplayOrientation == TRACKCIRCLE)
	 && (DisplayMode != dmCircling) )
      {
	if ( VisualGlide == 1 ) {
	  tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
	  DrawArc(hdc, Orig.x, Orig.y,(int)tmp, rc, 315, 45);
	} else
	  {
	    tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
	    DrawArc(hdc, Orig.x, Orig.y,(int)tmp, rc, 330+spread, 30+spread);
	  }
      } else
      {
	tmp = i*gunit*cruise*ResMapScaleOverDistanceModify;
	Circle(hdc, Orig.x,Orig.y,(int)tmp, rc, true, false);
      }

    //		if (count > 0) {

    if (turn>0||true) oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); 
    else oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x00)); // red
    /*
      switch (count) {
      case 1:
      case 3:
      case 5:
      case 7:
      oldcolor=SetTextColor(hdc, RGB(0xff,0xff,0xff)); // white
      break;
      case 2:
      case 4:
      case 6:
      case 8:
      oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x20));
      break;
      default:
      oldcolor=SetTextColor(hdc, RGB(0x00,0x00,0xff)); // blue
      break;
      }
    */
    if ( i==2 || i==4 || i==6 || i==8 ) { 
      if ( Units::GetUserAltitudeUnit() == unMeter ) wsprintf(gtext,_T("-%dm"),i*100); else
	wsprintf(gtext,_T("-%dft"),i*300);
      if (count<5)
	ExtTextOut( hdc, Orig.x+35, Orig.y-5 - (int) tmp, 0, NULL, gtext , _tcslen(gtext), NULL );
    }
    SetTextColor(hdc,oldcolor);
    //		}
    //		if (count >0) {
    if (turn>0||true) oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); // dark grey
    else oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x00)); // red
    /*
      switch (count) {
      case 1:
      case 3:
      case 5:
      oldcolor=SetTextColor(hdc, RGB(0x00,0x00,0xff)); // blue
      break;
      case 2:
      case 4:
      case 6:
      oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x20));
      break;
      default:
      oldcolor=SetTextColor(hdc, RGB(0x00,0x00,0xff)); // blue
      break;
      }
    */
    if ( i==2 || i==4 || i==6 || i==8 ) {
      if ( Units::GetUserDistanceUnit() == unKiloMeter ) 
	{
	  //sprintf(text,"%3.1f Km",i*100*cruise /1000);
	  sprintf(text,"%3.0fkm",i*100*cruise /1000);
	} else  if ( Units::GetUserDistanceUnit() == unNauticalMiles ) 
	{
	  //sprintf(text,"%3.1f nmi", i*100*cruise / 1852);
	  sprintf(text,"%3.0fnm", i*100*cruise / 1852);
	} else  if ( Units::GetUserDistanceUnit() == unStatuteMiles )
	{
	  //sprintf(text,"%3.1f mi", i*100*cruise / 1609);
	  sprintf(text,"%3.0fm", i*100*cruise / 1609);
	}

      wsprintf(gtext,_T("%S"),text);; 
      if (count<5)
	ExtTextOut( hdc, Orig.x-100, Orig.y-5 - (int) tmp, 0, NULL, gtext , _tcslen(gtext), NULL );
    }
    SetTextColor(hdc,oldcolor);
    //		}

  }

  SelectObject(hdc, oldfont);
  if (NewMap||OutlinedTp)
    oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); // dark grey 0x50
  else {
    if (turn>0||true) 
      oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); // dark grey 0x50
    else 
      oldcolor=SetTextColor(hdc, RGB(0xff,0x00,0x00)); // red
  }

  wsprintf(gtext,_T("L/D:%d"),(int)cruise);

  //ExtTextOut( hdc, Orig.x+30, Orig.y +20 , 0, NULL, gtext , _tcslen(gtext), NULL );
  //ExtTextOut( hdc, Orig.x-30, Orig_Aircraft.y +50 , 0, NULL, gtext , _tcslen(gtext), NULL );
  //ExtTextOut( hdc, (rc.left+rc.right)/2, rc.top+rc.bottom-20 , 0, NULL, gtext , _tcslen(gtext), NULL );

  if (NewMap||OutlinedTp) {
    ExtTextOut( hdc, rcx+3, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx+2, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx+1, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx-1, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx-2, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx-3, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy+1 , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy+2 , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy+3 , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy-1 , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy-2 , 0, NULL, gtext , _tcslen(gtext), NULL );
    ExtTextOut( hdc, rcx, rcy-3 , 0, NULL, gtext , _tcslen(gtext), NULL );
    SetTextColor(hdc,RGB(0xff,0xff,0xff));
  }
  ExtTextOut( hdc, rcx, rcy , 0, NULL, gtext , _tcslen(gtext), NULL );


  SetTextColor(hdc,oldcolor);

}

/*
 * Had no time to even try to complete this part. Maybe in the next few days...
 */
void MapWindow::DrawLook8000(HDC hdc,  RECT rc )
{
//  TCHAR gtext[100];
  char text[30];
  TCHAR Buffer[100];
  int wpgoto=-1;
  COLORREF	oldcolor=0;
  HFONT		oldfont=0;
  TextInBoxMode_t TextDisplayMode;


  //if (!InfoBoxLayout::landscape) return;
  //if (!IsMapFullScreen()) return;

  TextDisplayMode.AsInt = 0;

  //static short rcx=rc.left+IBLSCALE(50);
  //static short rcy=rc.top+rc.bottom-IBLSCALE(10);
  short rcx=rc.left+IBLSCALE(1);
  short rcy=rc.top+IBLSCALE(1);

  if (DisplayMode == dmCircling) return; // TODO pan mode too? need those other cases

  wpgoto=ActiveWayPoint;

    if (ValidTaskPoint(wpgoto)) {
      int index = Task[wpgoto].Index;
      if ( index >=0 ) {
	if (WayPointList[index].Reachable) {
	  TextDisplayMode.AsFlag.Color = 1; // 1 green 2 red 0 none
	} else {
	  TextDisplayMode.AsFlag.Color = 2;
	}

	wsprintf(Buffer, TEXT("XX: %s"),  WayPointList[index].Name);
	// JMW undefined...	ConvToUpper(Buffer);
	// VNT it's really inside Utils.cpp ...but only for PNA or fivv... I'll fix it when it becomes usable
	TextDisplayMode.AsFlag.WhiteBold = 1; 
	TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  
      }
    }


  if (ValidTaskPoint(ActiveWayPoint) && CALCULATED_INFO.WaypointDistance > 10.0) {

  TextDisplayMode.AsFlag.Color = 0;
  rcx=rc.right-IBLSCALE(15);
  rcy=rc.top+ IBLSCALE(80);

  //if (EnableVarioGauge && MapRectBig.right == rc.right)  rcx -= InfoBoxLayout::ControlWidth;


  SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
  // SetBkMode(hdc,TRANSPARENT);


  TextDisplayMode.AsFlag.WhiteBold = 1; // outlined 
  TextDisplayMode.AsFlag.NoSetFont = 1; 
  TextDisplayMode.AsFlag.AlligneRight = 1;
  //oldfont = (HFONT)SelectObject(hdc, StatisticsFont);
  oldfont = (HFONT)SelectObject(hdc, InfoWindowFont);

  //sprintf(text,"%2d",(int)CALCULATED_INFO.GRFinish); // TODO FIX GRFinish to make it GRNext or create new IB
  int value=(int)WayPointCalc[Task[ActiveWayPoint].Index].GR;
  if (value <1 || value >INVALID_GR )
	strcpy(text,"---");
  else 
  	sprintf(text,"%3d",value);

  wsprintf(Buffer, TEXT("%S"),text);
	
  TextInBox(hdc, Buffer, rcx,rcy, 0, TextDisplayMode, false);  

  value=(int)CALCULATED_INFO.CruiseLD;
  if (value <0 || value>999)
	strcpy(text,"+++");
  else
  	sprintf(text,"%3d",(int)CALCULATED_INFO.CruiseLD);
  wsprintf(Buffer, TEXT("%S"),text);

  TextInBox(hdc, Buffer, rcx,rcy+IBLSCALE(25), 0, TextDisplayMode, false); 


  //rcx=(rc.right-rc.left)/2 - IBLSCALE(10);
  //rcy=rc.top+ IBLSCALE(15);
  TextDisplayMode.AsFlag.AlligneRight = 0;
  TextDisplayMode.AsFlag.AlligneCenter = 1;


    double Value = CALCULATED_INFO.WaypointBearing -  GPS_INFO.TrackBearing;

    if (Value < -180.0)
      Value += 360.0;
    else
    if (Value > 180.0)
      Value -= 360.0;

#ifndef __MINGW32__
    if (Value > 1)
      _stprintf(Buffer, TEXT("%2.0f"), Value);
    else if (Value < -1)
      _stprintf(Buffer, TEXT("%2.0f"), -Value);
    else
      _tcscpy(Buffer, TEXT(""));
#else
    if (Value > 1)
      _stprintf(Buffer, TEXT("%2.0f"), Value);
    else if (Value < -1)
      _stprintf(Buffer, TEXT("%2.0f"), -Value);
    else
      _tcscpy(Buffer, TEXT(""));
#endif

  TextInBox(hdc, Buffer, (rc.right-rc.left)/2 - IBLSCALE(10),rc.top+IBLSCALE(15), 0, TextDisplayMode, false);
} 

  SelectObject(hdc, oldfont); 
}
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
  $Id: MapWindow.cpp,v 1.228 2009/05/24 10:56:52 jwharington Exp $
d40 1
d700 1
a700 1
	ExtTextOut(hDC, x, y+2, 0, NULL, Value, size, NULL); // make it bolder to look like an LX8000
d702 3
a704 3
	ExtTextOut(hDC, x-3, y, 0, NULL, Value, size, NULL); // fix add bolder
	ExtTextOut(hDC, x+3, y, 0, NULL, Value, size, NULL); // fix add
	ExtTextOut(hDC, x, y+3, 0, NULL, Value, size, NULL); // make it bolder to look like an LX8000
a2274 1
  // VENTA3 VisualGlide
a3203 1

d3428 1
d3434 5
a3438 1
		  wsprintf(Buffer, TEXT("%s:%d%s"), WayPointList[i].Name, (int)(WayPointList[i].AltArivalAGL*ALTITUDEMODIFY), sAltUnit);
a3620 1

d4510 1
a4510 1
// VENTA3 
d4516 1
a4516 1
 *             2 : Moving sector/circle   TODO: either comment this or improve it, seems useless.. 
d4561 2
d4570 1
d4595 1
a4595 1
    if (turn>0) oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); 
d4625 1
a4625 1
    if (turn>0) oldcolor=SetTextColor(hdc, RGB(0x0,0x0,0x0)); // dark grey
d4672 1
a4672 1
    if (turn>0) 
d4711 2
a4712 1
  TCHAR gtext[100];
d4716 1
a4716 1
  HFONT		oldfont;
d4730 4
a4733 2
  if (DisplayMode != dmCircling)  {
    wpgoto=ActiveWayPoint;
d4743 1
a4743 1
	wsprintf(Buffer, TEXT("TO: %s"),  WayPointList[index].Name);
a4749 1
  }
d4752 1
d4754 3
a4756 6


  /*

  short rcx=rc.right-IBLSCALE(30);
  short rcy=rc.top+ IBLSCALE(80);
a4768 1
  //oldfont = (HFONT)SelectObject(hdc, StatisticsFont);
d4771 8
a4778 1
  wsprintf(Buffer, TEXT("0.0"));
d4782 6
a4787 1
  wsprintf(Buffer, TEXT("+803"));
d4796 26
a4821 1
  wsprintf(Buffer, TEXT("<<145%S"),_T(DEG));
d4823 1
a4825 1
  */
@
