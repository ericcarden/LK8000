head	8.15;
access;
symbols
	beta8:8.1;
locks
	root:8.15; strict;
comment	@// @;


8.15
date	2010.12.12.14.27.14;	author root;	state Exp;
branches;
next	8.14;

8.14
date	2010.11.25.00.21.10;	author root;	state Exp;
branches;
next	8.13;

8.13
date	2009.12.17.20.40.10;	author root;	state Exp;
branches;
next	8.12;

8.12
date	2009.11.30.01.50.54;	author root;	state Exp;
branches;
next	8.11;

8.11
date	2009.11.18.17.26.56;	author root;	state Exp;
branches;
next	8.10;

8.10
date	2009.11.17.21.57.42;	author root;	state Exp;
branches;
next	8.9;

8.9
date	2009.11.14.01.07.44;	author root;	state Exp;
branches;
next	8.8;

8.8
date	2009.10.20.22.41.25;	author root;	state Exp;
branches;
next	8.7;

8.7
date	2009.10.04.22.20.34;	author root;	state Exp;
branches;
next	8.6;

8.6
date	2009.09.22.12.56.28;	author root;	state Exp;
branches;
next	8.5;

8.5
date	2009.09.02.20.51.17;	author root;	state Exp;
branches;
next	8.4;

8.4
date	2009.06.28.21.31.31;	author root;	state Exp;
branches;
next	8.3;

8.3
date	2009.06.27.17.19.04;	author root;	state Exp;
branches;
next	8.2;

8.2
date	2009.06.24.10.04.10;	author root;	state Exp;
branches;
next	8.1;

8.1
date	2009.06.19.20.28.25;	author venta;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.15.09.32.21;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.11.19.50.14;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.08.11.33.16;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.07.11.38.33;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.06.12.21.58;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.27.11.27.25;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.25.13.31.28;	author root;	state Exp;
branches;
next	;


desc
@@

8.15
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: MapWindow2.cpp,v 8.14 2010/11/25 00:21:10 root Exp $
*/

#include "StdAfx.h"
#include "compatibility.h"
#include "options.h"
#include "Defines.h"

#include "MapWindow.h"
#include "OnLineContest.h"
#include "Utils.h"
#include "XCSoar.h"
#include "LKUtils.h"
#include "Utils2.h"
#include "Units.h"
#include "Logger.h"
#include "McReady.h"
#include "Airspace.h"
#include "Waypointparser.h"
#include "Dialogs.h"
#include "externs.h"
#include "VarioSound.h"
#include "InputEvents.h"
#include <windows.h>
#include <math.h>

#include <tchar.h>

#include "Task.h"

#include "Terrain.h"
#include "RasterTerrain.h"

#include "GaugeVarioAltA.h"
#include "GaugeCDI.h"
#include "GaugeFLARM.h"
#include "InfoBoxLayout.h"
#include "LKMapWindow.h"

#if (WINDOWSPC>0)
#include <wingdi.h>
#endif

#ifdef DEBUG
#if (WINDOWSPC<1)
#define DRAWLOAD
extern HFONT  MapWindowFont;
extern int timestats_av;
extern int misc_tick_count;
#endif
#endif

extern HWND hWndCDIWindow;
extern HFONT MapLabelFont;
extern HFONT  MapWindowBoldFont;

#define TASKINDEX    Task[ActiveWayPoint].Index

#ifndef NOCDIGAUGE
void MapWindow::DrawCDI() {
  bool dodrawcdi = false;

  if (DerivedDrawInfo.Circling) {
    if (EnableCDICircling) {
      dodrawcdi = true;
    }
  } else {
    if (EnableCDICruise) {
      dodrawcdi = true;
    }    
  }

  if (dodrawcdi) {
    ShowWindow(hWndCDIWindow, SW_SHOW);
    
    // JMW changed layout here to fit reorganised display
    // insert waypoint bearing ".<|>." into CDIScale string"
    
    TCHAR CDIScale[] = TEXT("330..340..350..000..010..020..030..040..050..060..070..080..090..100..110..120..130..140..150..160..170..180..190..200..210..220..230..240..250..260..270..280..290..300..310..320..330..340..350..000..010..020..030..040.");
    TCHAR CDIDisplay[25] = TEXT("");
    int j;
    int CDI_WP_Bearing = (int)DerivedDrawInfo.WaypointBearing/2;
    CDIScale[CDI_WP_Bearing + 9] = 46;
    CDIScale[CDI_WP_Bearing + 10] = 60;
    CDIScale[CDI_WP_Bearing + 11] = 124; // "|" character
    CDIScale[CDI_WP_Bearing + 12] = 62; 
    CDIScale[CDI_WP_Bearing + 13] = 46;
    for (j=0;j<24;j++) CDIDisplay[j] = CDIScale[(j + (int)(DrawInfo.TrackBearing)/2)];
    CDIDisplay[24] = _T('\0');
    // JMW fix bug! This indicator doesn't always display correctly!
    
    // JMW added arrows at end of CDI to point to track if way off..
    int deltacdi = iround(DerivedDrawInfo.WaypointBearing-DrawInfo.TrackBearing);
    
    while (deltacdi>180) {
      deltacdi-= 360;
    }
    while (deltacdi<-180) {
      deltacdi+= 360;
    }
    if (deltacdi>20) {
      CDIDisplay[21]='>';
      CDIDisplay[22]='>';
      CDIDisplay[23]='>';
    }
    if (deltacdi<-20) {
      CDIDisplay[0]='<';
      CDIDisplay[1]='<';
      CDIDisplay[2]='<';
    }
    
    SetWindowText(hWndCDIWindow,CDIDisplay);
    // end of new code to display CDI scale
  } else {
    ShowWindow(hWndCDIWindow, SW_HIDE);
  }
}
#endif


double MapWindow::findMapScaleBarSize(const RECT rc) {

  int range = rc.bottom-rc.top;
//  int nbars = 0;
//  int nscale = 1;
  double pixelsize = MapScale/GetMapResolutionFactor(); // km/pixel
  
  // find largest bar size that will fit in display

  double displaysize = range*pixelsize/2; // km

  if (displaysize>100.0) {
    return 100.0/pixelsize;
  }
  if (displaysize>10.0) {
    return 10.0/pixelsize;
  }
  if (displaysize>1.0) {
    return 1.0/pixelsize;
  }
  if (displaysize>0.1) {
    return 0.1/pixelsize;
  }
  // this is as far as is reasonable
  return 0.1/pixelsize;
}

#ifndef LK8000_OPTIMIZE
void MapWindow::DrawMapScale2(HDC hDC, const RECT rc, 
			      const POINT Orig_Aircraft)
{
  if (Appearance.MapScale2 == apMs2None) return;

  HPEN hpOld   = (HPEN)SelectObject(hDC, hpMapScale);
  HPEN hpWhite = (HPEN)GetStockObject(WHITE_PEN);
  HPEN hpBlack = (HPEN)GetStockObject(BLACK_PEN);

  bool color = false;
  POINT Start, End={0,0};
  bool first=true;

  int barsize = iround(findMapScaleBarSize(rc));

  Start.x = rc.right-1;
  for (Start.y=Orig_Aircraft.y; Start.y<rc.bottom+barsize; Start.y+= barsize) {
    if (color) {
      SelectObject(hDC, hpWhite);
    } else {
      SelectObject(hDC, hpBlack);
    }
    if (!first) {
      DrawSolidLine(hDC,Start,End, rc);
    } else {
      first=false;
    }
    End = Start;
    color = !color;
  }

  color = true;
  first = true;
  for (Start.y=Orig_Aircraft.y; Start.y>rc.top-barsize; Start.y-= barsize) {
    if (color) {
      SelectObject(hDC, hpWhite);
    } else {
      SelectObject(hDC, hpBlack);
    }
    if (!first) {
      DrawSolidLine(hDC,Start,End, rc);
    } else {
      first=false;
    }
    End = Start;
    color = !color;
  }

  // draw text as before
  
  SelectObject(hDC, hpOld);

}
#endif


#if 0
// new version, using estimated IAS
void MapWindow::DrawSpeedToFly(HDC hDC, RECT rc) {
  POINT chevron[3];
  double ias;

  HPEN hpOld;
  HBRUSH hbOld;

  int i;

#ifndef _SIM_
  #if 0
  if (!(DrawInfo.AirspeedAvailable && DrawInfo.VarioAvailable)) {
    return;
  }
  #endif
  // we use estimated airspeed now
  if (!(DrawInfo.AirspeedAvailable && DrawInfo.VarioAvailable)) 
	ias=DerivedDrawInfo.IndicatedAirspeedEstimated;
  else
	ias=DrawInfo.IndicatedAirspeed;
#else
  ias=DerivedDrawInfo.IndicatedAirspeedEstimated;
#endif

  hbOld = (HBRUSH)SelectObject(hDC, GetStockObject(WHITE_BRUSH));
  hpOld = (HPEN)SelectObject(hDC, hpBearing);

  double vdiff;
  int vsize = (rc.bottom-rc.top)/2;

  vdiff = (DerivedDrawInfo.VOpt - ias)/40.0;
  // 25.0 m/s is maximum scale
  vdiff = max(-0.5,min(0.5,vdiff)); // limit it
  
  int yoffset=0;
  int hyoffset=0;
  vsize = iround(fabs(vdiff*vsize));
  int xoffset = rc.right-NIBLSCALE(25);
  int ycenter = (rc.bottom+rc.top)/2;

  int k=0;

  for (k=0; k<2; k++) {

    for (i=0; i< vsize; i+= 5) {
      if (vdiff>0) {
        yoffset = i+ycenter+k;
        hyoffset = NIBLSCALE(4);
      } else {
        yoffset = -i+ycenter-k;
        hyoffset = -NIBLSCALE(4);
      }
      chevron[0].x = xoffset;
      chevron[0].y = yoffset;
      chevron[1].x = xoffset+NIBLSCALE(10);
      chevron[1].y = yoffset+hyoffset;
      chevron[2].x = xoffset+NIBLSCALE(20);
      chevron[2].y = yoffset;
      
      _Polyline(hDC, chevron, 3, rc);
    }
    if (vdiff>0) {
      hpOld = (HPEN)SelectObject(hDC, hpSpeedSlow);
    } else {
      hpOld = (HPEN)SelectObject(hDC, hpSpeedFast);
    }
  }

  SelectObject(hDC, hpBearing);
  chevron[0].x = xoffset-NIBLSCALE(3);
  chevron[0].y = ycenter;
  chevron[1].x = xoffset+NIBLSCALE(3+20);
  chevron[1].y = ycenter;
  _Polyline(hDC, chevron, 2, rc);
    
  SelectObject(hDC, hbOld);
  SelectObject(hDC, hpOld);

}
#endif

#define fSnailColour(cv) max(0,min((short)(NUMSNAILCOLORS-1), (short)((cv+1.0)/2.0*NUMSNAILCOLORS)))

#if TOPOFASTLABEL
int MapWindow::nLabelBlocks;
int MapWindow::nVLabelBlocks[SCREENVSLOTS+1];
RECT MapWindow::LabelBlockCoords[SCREENVSLOTS+1][MAXVLABELBLOCKS+1];
// this slots char array is simply loading the slot number. A nibble should be enough, but no problems to use 8 bits.
char * MapWindow::slot;

// Returns true if label can be printed, not overlapping other labels
bool MapWindow::checkLabelBlock(RECT *rc) {
  static bool doinit=true;

  // This item is out of screen, probably because zoom was made and we still have old wps
  // or we panned, or we have a far away takeoff still in the list
  if (rc->top <0 || rc->top>ScreenSizeY) return false;
  // we must limit the out of screen of bottom label size to clipped screen
  if (rc->bottom>ScreenSizeY) rc->bottom=ScreenSizeY;

  if (rc->left>ScreenSizeX) return false;
  if (rc->right<0) return false;

  if (doinit) {
	// vertical coordinate Y for bottom size of each slot
	unsigned int slotbottom[SCREENVSLOTS+1];
	unsigned int slotsize=ScreenSizeY/SCREENVSLOTS;
	unsigned int i, j;
	for (j=0; j<(SCREENVSLOTS-1); j++) {
		i=(j*slotsize)+slotsize;
		slotbottom[j]=i;
	}
	slotbottom[SCREENVSLOTS-1]=ScreenSizeY;

	slot=(char *)malloc((ScreenSizeY+1)*sizeof(char));
	// j initially is slot 0; we keep <= for safety
	for (i=0, j=0; i<=(unsigned int)ScreenSizeY; i++) {
		if ( i>slotbottom[j] ) j++;
		// just for safety
		if (j>(SCREENVSLOTS-1)) j=SCREENVSLOTS-1;
		slot[i]=(char)j;
	}

	doinit=false;
  }

  if (DeclutterMode==(DeclutterMode_t)dmDisabled) return true;

  // Max number of labels on screen
  if (nLabelBlocks>LKMaxLabels) return false;

  // rc.top is searched in its slot, but the label could also spread to the next slot...

  unsigned int vslot=(char)slot[rc->top];

  #define nvlabelslot nVLabelBlocks[vslot]

  // Check rc.top in its slot
  for (int i=0; i< nvlabelslot; i++) {
	// CheckRect is used only here
	if (CheckRectOverlap(&LabelBlockCoords[vslot][i],rc)) {
		// When overlapping, DO NOT insert this label in the list! It has not been printed!
		// StartupStore(_T("... item %d overlapping in slot %d with nvlabels=%d\n"),i,vslot,nvlabelslot);
		return false;
	}
  }
  // top is ok, now check if using also next slot
  bool doslot2=false;
  unsigned int v2slot=(char)slot[rc->bottom];
  #define nv2labelslot nVLabelBlocks[v2slot]
  if (v2slot != vslot) {
	for (int i=0; i< nv2labelslot; i++) {
		//if (CheckRectOverlap(&LabelBlockCoords[v2slot][i],&rc)) {
		if (CheckRectOverlap(&LabelBlockCoords[v2slot][i],rc)) {
			// StartupStore(_T("... item %d overlapping in secondary slot %d with nvlabels=%d\n"),i,v2slot,nv2labelslot);
			return false;
		}
	}
	doslot2=true;
  }

  // now insert the label in the list, for next checks
  if (nvlabelslot <(MAXVLABELBLOCKS-1)) {
	LabelBlockCoords[vslot][nvlabelslot]= *rc;
	nLabelBlocks++;
	nVLabelBlocks[vslot]++;
	// StartupStore(_T("... added label in slot %d nvlabelslot now=%d tot=%d\n"), vslot,nVLabelBlocks[vslot], nLabelBlocks);
	if (!doslot2) return true;
  } else {
	// if the label cannot be checked because the list is full, don't print the label!
	// StartupStore(_T("... label list is full vslot=%d, item not added%s"),vslot,NEWLINE);
	return false;
  }

  // Now check secondary list, if needed
  if (nv2labelslot <(MAXVLABELBLOCKS-1)) {
	LabelBlockCoords[v2slot][nv2labelslot]= *rc;
	nLabelBlocks++;
	nVLabelBlocks[v2slot]++;
	// StartupStore(_T("... added label in slot %d nvlabelslot now=%d tot=%d\n"), vslot,nVLabelBlocks[vslot], nLabelBlocks);
	return true;
  } else {
	// if the label cannot be checked because the list is full, don't print the label!
	// StartupStore(_T("... second label list is full v2slot=%d, item not added%s"),v2slot,NEWLINE);
	return false;
  }

  return true;
}

#else
	// old label check with no topofast 
#endif

rectObj MapWindow::CalculateScreenBounds(double scale) {
  // compute lat lon extents of visible screen
  rectObj sb;

  if (scale>= 1.0) {
    POINT screen_center;
    LatLon2Screen(PanLongitude, 
                  PanLatitude,
                  screen_center);
    
    sb.minx = sb.maxx = PanLongitude;
    sb.miny = sb.maxy = PanLatitude;
    
    int dx, dy;
    unsigned int maxsc=0;
    dx = screen_center.x-MapRect.right;
    dy = screen_center.y-MapRect.top;
    maxsc = max(maxsc, isqrt4(dx*dx+dy*dy));
    dx = screen_center.x-MapRect.left;
    dy = screen_center.y-MapRect.top;
    maxsc = max(maxsc, isqrt4(dx*dx+dy*dy));
    dx = screen_center.x-MapRect.left;
    dy = screen_center.y-MapRect.bottom;
    maxsc = max(maxsc, isqrt4(dx*dx+dy*dy));
    dx = screen_center.x-MapRect.right;
    dy = screen_center.y-MapRect.bottom;
    maxsc = max(maxsc, isqrt4(dx*dx+dy*dy));
    
    for (int i=0; i<10; i++) {
      double ang = i*360.0/10;
      POINT p;
      double X, Y;
      p.x = screen_center.x + iround(fastcosine(ang)*maxsc*scale);
      p.y = screen_center.y + iround(fastsine(ang)*maxsc*scale);
      Screen2LatLon(p.x, p.y, X, Y);
      sb.minx = min(X, sb.minx);
      sb.miny = min(Y, sb.miny);
      sb.maxx = max(X, sb.maxx);
      sb.maxy = max(Y, sb.maxy);
    }

  } else {

    double xmin, xmax, ymin, ymax;
    int x, y;
    double X, Y;
    
    x = MapRect.left; 
    y = MapRect.top; 
    Screen2LatLon(x, y, X, Y);
    xmin = X; xmax = X;
    ymin = Y; ymax = Y;

    x = MapRect.right; 
    y = MapRect.top; 
    Screen2LatLon(x, y, X, Y);
    xmin = min(xmin, X); xmax = max(xmax, X);
    ymin = min(ymin, Y); ymax = max(ymax, Y);
  
    x = MapRect.right; 
    y = MapRect.bottom; 
    Screen2LatLon(x, y, X, Y);
    xmin = min(xmin, X); xmax = max(xmax, X);
    ymin = min(ymin, Y); ymax = max(ymax, Y);
  
    x = MapRect.left; 
    y = MapRect.bottom; 
    Screen2LatLon(x, y, X, Y);
    xmin = min(xmin, X); xmax = max(xmax, X);
    ymin = min(ymin, Y); ymax = max(ymax, Y);
  

    sb.minx = xmin;
    sb.maxx = xmax;
    sb.miny = ymin;
    sb.maxy = ymax;

  }

  return sb;
}



void MapWindow::ScanVisibility(rectObj *bounds_active) {
  // received when the SetTopoBounds determines the visibility
  // boundary has changed.
  // This happens rarely, so it is good pre-filtering of what is visible.
  // (saves from having to do it every screen redraw)
  const rectObj bounds = *bounds_active;

  // far visibility for snail trail

  SNAIL_POINT *sv= SnailTrail;
  const SNAIL_POINT *se = sv+TRAILSIZE;
  while (sv<se) {
    sv->FarVisible = ((sv->Longitude> bounds.minx) &&
		      (sv->Longitude< bounds.maxx) &&
		      (sv->Latitude> bounds.miny) &&
		      (sv->Latitude< bounds.maxy));
    sv++;
  }

  // far visibility for waypoints

  if (WayPointList) {
    WAYPOINT *wv = WayPointList;
    const WAYPOINT *we = WayPointList+NumberOfWayPoints;
    while (wv<we) {
      // TODO code: optimise waypoint visibility
      wv->FarVisible = ((wv->Longitude> bounds.minx) &&
			(wv->Longitude< bounds.maxx) &&
			(wv->Latitude> bounds.miny) &&
			(wv->Latitude< bounds.maxy));
      wv++;
    }
  }

  // far visibility for airspace

  if (AirspaceCircle) {
    for (AIRSPACE_CIRCLE* circ = AirspaceCircle;
         circ < AirspaceCircle+NumberOfAirspaceCircles; circ++) {
      circ->FarVisible = 
        (msRectOverlap(&circ->bounds, bounds_active) == MS_TRUE) ||
        (msRectContained(bounds_active, &circ->bounds) == MS_TRUE) ||
        (msRectContained(&circ->bounds, bounds_active) == MS_TRUE);
    }
  }

  if (AirspaceArea) {
    for(AIRSPACE_AREA *area = AirspaceArea;
        area < AirspaceArea+NumberOfAirspaceAreas; area++) {
      area->FarVisible = 
        (msRectOverlap(&area->bounds, bounds_active) == MS_TRUE) ||
        (msRectContained(bounds_active, &area->bounds) == MS_TRUE) ||
        (msRectContained(&area->bounds, bounds_active) == MS_TRUE);
    }
  }

}


void MapWindow::CalculateScreenPositionsThermalSources() {
  for (int i=0; i<MAX_THERMAL_SOURCES; i++) {
    if (DerivedDrawInfo.ThermalSources[i].LiftRate>0) {
      double dh = DerivedDrawInfo.NavAltitude
        -DerivedDrawInfo.ThermalSources[i].GroundHeight;
      if (dh<0) {
        DerivedDrawInfo.ThermalSources[i].Visible = false;
        continue;
      }

      double t = dh/DerivedDrawInfo.ThermalSources[i].LiftRate;
      double lat, lon;
      FindLatitudeLongitude(DerivedDrawInfo.ThermalSources[i].Latitude, 
                            DerivedDrawInfo.ThermalSources[i].Longitude,
                            DerivedDrawInfo.WindBearing, 
                            -DerivedDrawInfo.WindSpeed*t,
                            &lat, &lon);
      if (PointVisible(lon,lat)) {
        LatLon2Screen(lon, 
                      lat, 
                      DerivedDrawInfo.ThermalSources[i].Screen);
        DerivedDrawInfo.ThermalSources[i].Visible = 
          PointVisible(DerivedDrawInfo.ThermalSources[i].Screen);
      } else {
        DerivedDrawInfo.ThermalSources[i].Visible = false;
      }
    } else {
      DerivedDrawInfo.ThermalSources[i].Visible = false;
    }
  }
}


void MapWindow::CalculateScreenPositionsAirspaceCircle(AIRSPACE_CIRCLE &circ) {
  circ.Visible = false;
  if (!circ.FarVisible) return;
  if (iAirspaceMode[circ.Type]%2 == 1) {
    double basealt;
    double topalt;
    if (circ.Base.Base != abAGL) {
      basealt = circ.Base.Altitude;
    } else {
      basealt = circ.Base.AGL + CALCULATED_INFO.TerrainAlt;
    }
    if (circ.Top.Base != abAGL) {
      topalt = circ.Top.Altitude;
    } else {
      topalt = circ.Top.AGL + CALCULATED_INFO.TerrainAlt;
    }
    if(CheckAirspaceAltitude(basealt, topalt)) {
      if (msRectOverlap(&circ.bounds, &screenbounds_latlon) 
          || msRectContained(&screenbounds_latlon, &circ.bounds)) {

	if (!circ._NewWarnAckNoBrush &&
	    !(iAirspaceBrush[circ.Type] == NUMAIRSPACEBRUSHES-1)) {
	  circ.Visible = 2;
	} else {
	  circ.Visible = 1;
	}

        LatLon2Screen(circ.Longitude, 
                      circ.Latitude, 
                      circ.Screen);
        circ.ScreenR = iround(circ.Radius*ResMapScaleOverDistanceModify);
      }
    }
  }
}

void MapWindow::CalculateScreenPositionsAirspaceArea(AIRSPACE_AREA &area) {
  area.Visible = false;
  if (!area.FarVisible) return;
  if (iAirspaceMode[area.Type]%2 == 1) {
    double basealt;
    double topalt;
    if (area.Base.Base != abAGL) {
      basealt = area.Base.Altitude;
    } else {
      basealt = area.Base.AGL + CALCULATED_INFO.TerrainAlt;
    }
    if (area.Top.Base != abAGL) {
      topalt = area.Top.Altitude;
    } else {
      topalt = area.Top.AGL + CALCULATED_INFO.TerrainAlt;
    }
    if(CheckAirspaceAltitude(basealt, topalt)) {
      if (msRectOverlap(&area.bounds, &screenbounds_latlon) 
          || msRectContained(&screenbounds_latlon, &area.bounds)) {
        AIRSPACE_POINT *ap= AirspacePoint+area.FirstPoint;
        const AIRSPACE_POINT *ep= ap+area.NumPoints;
        POINT* sp= AirspaceScreenPoint+area.FirstPoint;
        while (ap < ep) {
	  // JMW optimise!
            LatLon2Screen(ap->Longitude, 
                          ap->Latitude, 
                          *sp);
            ap++;
            sp++;
        }               

	if (!area._NewWarnAckNoBrush &&
	    !(iAirspaceBrush[area.Type] == NUMAIRSPACEBRUSHES-1)) {
	  area.Visible = 2;
	} else {
	  area.Visible = 1;
	}
      }
    }
  }
}

void MapWindow::CalculateScreenPositionsAirspace() {
  
  
  if (AirspaceCircle) {
    for (AIRSPACE_CIRCLE* circ = AirspaceCircle;
         circ < AirspaceCircle+NumberOfAirspaceCircles; circ++) {
      CalculateScreenPositionsAirspaceCircle(*circ);
    }
  }
  if (AirspaceArea) {
    for(AIRSPACE_AREA *area = AirspaceArea;
        area < AirspaceArea+NumberOfAirspaceAreas; area++) {
      CalculateScreenPositionsAirspaceArea(*area);
    }
  }
}


void MapWindow::CalculateScreenPositions(POINT Orig, RECT rc, 
                                         POINT *Orig_Aircraft)
{
  unsigned int i;

  Orig_Screen = Orig;

  if (!EnablePan) {
  
    if (GliderCenter 
        && DerivedDrawInfo.Circling 
        && (EnableThermalLocator==2)) {
      
      if (DerivedDrawInfo.ThermalEstimate_R>0) {
        PanLongitude = DerivedDrawInfo.ThermalEstimate_Longitude; 
        PanLatitude = DerivedDrawInfo.ThermalEstimate_Latitude;
        // TODO enhancement: only pan if distance of center to
        // aircraft is smaller than one third screen width

        POINT screen;
        LatLon2Screen(PanLongitude, 
                      PanLatitude, 
                      screen);

        LatLon2Screen(DrawInfo.Longitude, 
                      DrawInfo.Latitude, 
                      *Orig_Aircraft);
	#if FIX_MAPSIZE
	// Should use ReducedMapSize() test TODO FIX
        if ((fabs((double)Orig_Aircraft->x-screen.x)<(rc.right-rc.left)/3)
            && (fabs((double)Orig_Aircraft->y-(screen.y-BottomSize))<(rc.bottom-rc.top-BottomSize)/3)) {
	#else
        if ((fabs((double)Orig_Aircraft->x-screen.x)<(rc.right-rc.left)/3)
            && (fabs((double)Orig_Aircraft->y-screen.y)<(rc.bottom-rc.top)/3)) {
	#endif
          
        } else {
          // out of bounds, center on aircraft
          PanLongitude = DrawInfo.Longitude;
          PanLatitude = DrawInfo.Latitude;
        }
      } else {
        PanLongitude = DrawInfo.Longitude;
        PanLatitude = DrawInfo.Latitude;
      }
    } else {
      // Pan is off
      PanLongitude = DrawInfo.Longitude;
      PanLatitude = DrawInfo.Latitude;
    }
  }

  LatLon2Screen(DrawInfo.Longitude, 
                DrawInfo.Latitude, 
                *Orig_Aircraft);

  // very important
  screenbounds_latlon = CalculateScreenBounds(0.0);

  #if TOPOFASTLABEL
  // preserve this calculation for 0.0 until next round!
  // This is already done since screenbounds_latlon is global. Beware that DrawTrail will change it later on
  // to expand boundaries by 1 minute
  #endif

  // get screen coordinates for all task waypoints

  LockTaskData();

  if (WayPointList) {
    int index;
    for (i=0; i<MAXTASKPOINTS; i++) {
      index = Task[i].Index;
      if (index>=0) {
        
        LatLon2Screen(WayPointList[index].Longitude, 
                      WayPointList[index].Latitude, 
                      WayPointList[index].Screen);
        WayPointList[index].Visible = 
          PointVisible(WayPointList[index].Screen);
      }      
    }
    if (EnableMultipleStartPoints) {
      for(i=0;i<MAXSTARTPOINTS-1;i++) {
        index = StartPoints[i].Index;
        if (StartPoints[i].Active && (index>=0)) {

          LatLon2Screen(WayPointList[index].Longitude, 
                        WayPointList[index].Latitude, 
                        WayPointList[index].Screen);
          WayPointList[index].Visible = 
            PointVisible(WayPointList[index].Screen);
        }
      }
    }

    // only calculate screen coordinates for waypoints that are visible

    for(i=0;i<NumberOfWayPoints;i++)
      {
        WayPointList[i].Visible = false;
        if (!WayPointList[i].FarVisible) continue;
        if(PointVisible(WayPointList[i].Longitude, WayPointList[i].Latitude) )
          {
            LatLon2Screen(WayPointList[i].Longitude, WayPointList[i].Latitude,
                          WayPointList[i].Screen);
            WayPointList[i].Visible = PointVisible(WayPointList[i].Screen);
          }
      }
  }

  if(TrailActive)
  {
    iSnailNext = SnailNext; 
    // set this so that new data doesn't arrive between calculating
    // this and the screen updates
  }

  if (EnableMultipleStartPoints) {
    for(i=0;i<MAXSTARTPOINTS-1;i++) {
      if (StartPoints[i].Active && ValidWayPoint(StartPoints[i].Index)) {
        LatLon2Screen(StartPoints[i].SectorEndLon, 
                      StartPoints[i].SectorEndLat, StartPoints[i].End);
        LatLon2Screen(StartPoints[i].SectorStartLon, 
                      StartPoints[i].SectorStartLat, StartPoints[i].Start);
      }
    }
  }
  
  for(i=0;i<MAXTASKPOINTS-1;i++)
  {
    bool this_valid = ValidTaskPoint(i);
    bool next_valid = ValidTaskPoint(i+1);
    if (AATEnabled && this_valid) {
      LatLon2Screen(Task[i].AATTargetLon, Task[i].AATTargetLat, 
                    Task[i].Target);
    }

    if(this_valid && !next_valid)
    {
      // finish
      LatLon2Screen(Task[i].SectorEndLon, Task[i].SectorEndLat, Task[i].End);
      LatLon2Screen(Task[i].SectorStartLon, Task[i].SectorStartLat, Task[i].Start);      
    }
    if(this_valid && next_valid)
    {
      LatLon2Screen(Task[i].SectorEndLon, Task[i].SectorEndLat, Task[i].End);
      LatLon2Screen(Task[i].SectorStartLon, Task[i].SectorStartLat, Task[i].Start);

      if((AATEnabled) && (Task[i].AATType == SECTOR))
      {
        LatLon2Screen(Task[i].AATStartLon, Task[i].AATStartLat, Task[i].AATStart);
        LatLon2Screen(Task[i].AATFinishLon, Task[i].AATFinishLat, Task[i].AATFinish);
      }
      if (AATEnabled && (((int)i==ActiveWayPoint) || 
			 (TargetPan && ((int)i==TargetPanIndex)))) {

	for (int j=0; j<MAXISOLINES; j++) {
	  if (TaskStats[i].IsoLine_valid[j]) {
	    LatLon2Screen(TaskStats[i].IsoLine_Longitude[j], 
			  TaskStats[i].IsoLine_Latitude[j], 
			  TaskStats[i].IsoLine_Screen[j]);
	  }
	}
      }
    }
  }

  UnlockTaskData();

}


// JMW to be used for target preview
bool MapWindow::SetTargetPan(bool do_pan, int target_point) {
  static double old_latitude;
  static double old_longitude;
  static bool old_pan=false;
  static bool old_fullscreen=false;

  if (!TargetPan || (TargetPanIndex != target_point)) {
    TargetDrag_State = 0;
  }

  TargetPanIndex = target_point;

  if (do_pan && !TargetPan) {
    old_latitude = PanLatitude;
    old_longitude = PanLongitude;
    old_pan = EnablePan;
    EnablePan = true;
    TargetPan = do_pan;
    old_fullscreen = RequestFullScreen;
    if (RequestFullScreen) {
      RequestFullScreen = false;
    }
    SwitchZoomClimb();
  }
  if (do_pan) {
    LockTaskData();
    if (ValidTaskPoint(target_point)) {
      PanLongitude = WayPointList[Task[target_point].Index].Longitude;
      PanLatitude = WayPointList[Task[target_point].Index].Latitude;
      if (target_point==0) {
        TargetZoomDistance = max(2e3, StartRadius*2);
      } else if (!ValidTaskPoint(target_point+1)) {
        TargetZoomDistance = max(2e3, FinishRadius*2);
      } else if (AATEnabled) {
        if (Task[target_point].AATType == SECTOR) {
          TargetZoomDistance = max(2e3, Task[target_point].AATSectorRadius*2);
        } else {
          TargetZoomDistance = max(2e3, Task[target_point].AATCircleRadius*2);
        }
      } else {
        TargetZoomDistance = max(2e3, SectorRadius*2);
      }
    }
    UnlockTaskData();
  } else if (TargetPan) {
    PanLongitude = old_longitude;
    PanLatitude = old_latitude;
    EnablePan = old_pan;
    TargetPan = do_pan;
    if (old_fullscreen) {
      RequestFullScreen = true;
    }
    SwitchZoomClimb();
  }
  TargetPan = do_pan;
  return old_pan;
};

// Draw bearing line to target
void MapWindow::DrawGreatCircle(HDC hdc,
                                double startLon, double startLat,
                                double targetLon, double targetLat,
				const RECT rc) {


  // Simple and this should work for PNA with display bug

  HPEN hpOld = (HPEN)SelectObject(hdc, hpBearing);
  POINT pt[2];
  LatLon2Screen(startLon, 
                startLat,
                pt[0]);
  LatLon2Screen(targetLon, 
                targetLat,
                pt[1]);
  ClipPolygon(hdc, pt, 2, rc, false);

  SelectObject(hdc, hpOld);
}



int MapWindow::iSnailNext=0;

extern OLCOptimizer olc;

void MapWindow::DrawTrailFromTask(HDC hdc, const RECT rc, 
				  const double TrailFirstTime) {
  static POINT ptin[MAXCLIPPOLYGON];

  if((TrailActive!=3) || (DisplayMode == dmCircling) || (TrailFirstTime<0))
    return;

  const double mTrailFirstTime = TrailFirstTime - DerivedDrawInfo.TakeOffTime;
  // since olc keeps track of time wrt takeoff

  olc.SetLine();
  int n = min(MAXCLIPPOLYGON,olc.getN());
  int i, j=0;
  for (i=0; i<n; i++) {
    if (olc.getTime(i)>= mTrailFirstTime) 
      break;
    LatLon2Screen(olc.getLongitude(i), 
                  olc.getLatitude(i), 
                  ptin[j]);
    j++;
  }
  if (j>=2) {
    SelectObject(hdc,hSnailPens[NUMSNAILCOLORS/2]);
    ClipPolygon(hdc, ptin, j, rc, false);
  }
}

extern HFONT  TitleWindowFont;

void MapWindow::CalculateScreenPositionsGroundline(void) {
  if (FinalGlideTerrain) {
    LatLon2Screen(DerivedDrawInfo.GlideFootPrint,
		  Groundline, NUMTERRAINSWEEPS+1, 1);
  }
}


void MapWindow::DrawTerrainAbove(HDC hDC, const RECT rc) {

  if (!DerivedDrawInfo.Flying) return;

  COLORREF whitecolor = RGB(0xff,0xff,0xff);
  COLORREF graycolor = RGB(0xf0,0xf0,0xf0);
  COLORREF origcolor = SetTextColor(hDCTemp, whitecolor);

  SetBkMode(hDCTemp, TRANSPARENT);

  SelectObject(hDCTemp, (HBITMAP)hDrawBitMapTmp);
  SetBkColor(hDCTemp, whitecolor);

  SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  SetTextColor(hDCTemp, graycolor);
  SelectObject(hDCTemp, hAboveTerrainBrush); // hAirspaceBrushes[3] or 6
  Rectangle(hDCTemp,rc.left,rc.top,rc.right,rc.bottom);

  SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  SelectObject(hDCTemp, GetStockObject(WHITE_BRUSH));
  Polygon(hDCTemp,Groundline,NUMTERRAINSWEEPS+1);

  // need to do this to prevent drawing of colored outline
  SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
#if (WINDOWSPC<1)
    TransparentImage(hDC,
                     rc.left, rc.top,
                     rc.right-rc.left,rc.bottom-rc.top,
                     hDCTemp,
                     rc.left, rc.top,
                     rc.right-rc.left,rc.bottom-rc.top,
                     whitecolor
                     );
    
#else
    TransparentBlt(hDC,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   hDCTemp,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   whitecolor
                   );
  #endif

  // restore original color
  SetTextColor(hDCTemp, origcolor);
  SetBkMode(hDCTemp,OPAQUE);

}


void MapWindow::DrawProjectedTrack(HDC hdc, const RECT rc, const POINT Orig) {
  if ((ActiveWayPoint<=0) || !ValidTaskPoint(ActiveWayPoint) || !AATEnabled) { 
    return;
  }
  #ifndef NOTASKABORT
  if (DerivedDrawInfo.Circling || TaskIsTemporary()) {
  #else
  if (DerivedDrawInfo.Circling) {
  #endif
    // don't display in various modes
    return;
  }

  // TODO feature: maybe have this work even if no task?
  // TODO feature: draw this also when in target pan mode

  LockTaskData();  // protect from external task changes

  double startLat = DrawInfo.Latitude;
  double startLon = DrawInfo.Longitude;
  double previousLat;
  double previousLon;
  if (AATEnabled) {
    previousLat = Task[max(0,ActiveWayPoint-1)].AATTargetLat;
    previousLon = Task[max(0,ActiveWayPoint-1)].AATTargetLon; 
  } else {
    previousLat = WayPointList[Task[max(0,ActiveWayPoint-1)].Index].Latitude;
    previousLon = WayPointList[Task[max(0,ActiveWayPoint-1)].Index].Longitude; 
  }
  UnlockTaskData();

  double distance_from_previous, bearing;
  DistanceBearing(previousLat, previousLon,
		  startLat, startLon,
		  &distance_from_previous,
		  &bearing);

  if (distance_from_previous < 100.0) {
    bearing = DrawInfo.TrackBearing;
    // too short to have valid data
  }
  POINT pt[2] = {{0,-75},{0,-400}};
  if (TargetPan) {
    double screen_range = GetApproxScreenRange();
    double flow = 0.4;
    double fhigh = 1.5;
    screen_range = max(screen_range, DerivedDrawInfo.WaypointDistance);

    double p1Lat;
    double p1Lon;
    double p2Lat;
    double p2Lon;
    FindLatitudeLongitude(startLat, startLon, 
			  bearing, flow*screen_range,
			  &p1Lat, &p1Lon);
    FindLatitudeLongitude(startLat, startLon, 
			  bearing, fhigh*screen_range,
			  &p2Lat, &p2Lon);
    LatLon2Screen(p1Lon, p1Lat, pt[0]);
    LatLon2Screen(p2Lon, p2Lat, pt[1]);
  } else if (fabs(bearing-DerivedDrawInfo.WaypointBearing)<10) {
    // too small an error to bother
    return;
  } else {
    pt[1].y = (long)(-max(MapRectBig.right-MapRectBig.left,
			  MapRectBig.bottom-MapRectBig.top)*1.2);
    PolygonRotateShift(pt, 2, Orig.x, Orig.y, 
		       bearing-DisplayAngle);
  }
  DrawDashLine(hdc, 2, pt[0], pt[1], RGB(0,0,0), rc);
}


bool MapWindow::TargetDragged(double *longitude, double *latitude) {
  bool retval = false;
  LockTaskData();
  if (TargetDrag_State==2) {
    *longitude = TargetDrag_Longitude;
    *latitude = TargetDrag_Latitude;
    TargetDrag_State = 0;
    retval = true;
  }
  UnlockTaskData();
  return retval;
}





void MapWindow::DrawTeammate(HDC hdc, RECT rc)
{
  POINT point;

  if (TeammateCodeValid)
    {
      if(PointVisible(TeammateLongitude, TeammateLatitude) )
	{
	  LatLon2Screen(TeammateLongitude, TeammateLatitude, point);

	  SelectObject(hDCTemp,hBmpTeammatePosition);
	  DrawBitmapX(hdc,
		      point.x-NIBLSCALE(10), 
		      point.y-NIBLSCALE(10),
		      20,20,
		      hDCTemp,0,0,SRCPAINT);
	
	  DrawBitmapX(hdc,
		      point.x-NIBLSCALE(10), 
		      point.y-NIBLSCALE(10),
		      20,20,
		      hDCTemp,20,0,SRCAND);
	}
    }
}



void MapWindow::DrawThermalBand(HDC hDC, const RECT rc)
{
  POINT GliderBand[5] = { {0,0},{23,0},{22,0},{24,0},{0,0} };
  
  if ((DerivedDrawInfo.TaskAltitudeDifference>50)
      &&(DisplayMode == dmFinalGlide)) {
    return;
  }

  // JMW TODO accuracy: gather proper statistics
  // note these should/may also be relative to ground
  int i;
  double mth = DerivedDrawInfo.MaxThermalHeight;
  double maxh, minh;
  double h;
  double Wt[NUMTHERMALBUCKETS];
  double ht[NUMTHERMALBUCKETS];
  double Wmax=0.0;
  int TBSCALEY = ( (rc.bottom - rc.top )/2)-NIBLSCALE(30);
#define TBSCALEX 20
  
  // calculate height above safety altitude
  double hoffset = SAFETYALTITUDEBREAKOFF+DerivedDrawInfo.TerrainBase;
  h = DerivedDrawInfo.NavAltitude-hoffset;

  bool draw_start_height = ((ActiveWayPoint==0) && (ValidTaskPoint(0)) 
			    && (StartMaxHeight!=0)
			    && (DerivedDrawInfo.TerrainValid));
  double hstart=0;
  if (draw_start_height) {
    if (StartHeightRef == 0) {
      hstart = (StartMaxHeight/1000)+DerivedDrawInfo.TerrainAlt; //@@ 100315
    } else {
      hstart = StartMaxHeight/1000; // 100315
    }
    hstart -= hoffset;
  }

  short lkvariooffset;
  // vario is displayed only in fullscreen mode, if enabled
  if (IsMapFullScreen())
	lkvariooffset=rc.left + LKVarioBar?(LKVarioSize+1):0; //@@ 091118
  else
	lkvariooffset=rc.left;

  // calculate top/bottom height
  maxh = max(h, mth);
  minh = min(h, 0);

  if (draw_start_height) {
    maxh = max(maxh, hstart);
    minh = min(minh, hstart);
  }
  
  // no thermalling has been done above safety altitude
  if (mth<=1) {
    return;
  }
  if (maxh-minh<=0) {
    return;
  }

  // normalised heights
  double hglider = (h-minh)/(maxh-minh);
  hstart = (hstart-minh)/(maxh-minh);

  // calculate averages
  int numtherm = 0;

  double mc = MACCREADY;
  Wmax = max(0.5,mc);

  for (i=0; i<NUMTHERMALBUCKETS; i++) {
    double wthis = 0;
    // height of this thermal point [0,mth]
    double hi = i*mth/NUMTHERMALBUCKETS;
    double hp = ((hi-minh)/(maxh-minh));

    if (DerivedDrawInfo.ThermalProfileN[i]>5) {
      // now requires 10 items in bucket before displaying,
      // to eliminate kinks
      wthis = DerivedDrawInfo.ThermalProfileW[i]
                 /DerivedDrawInfo.ThermalProfileN[i];
    }
    if (wthis>0.0) {
      ht[numtherm]= hp;
      Wt[numtherm]= wthis;
      Wmax = max(Wmax,wthis/1.5);
      numtherm++;
    }
  }

  if ((!draw_start_height) && (numtherm<=1)) {
    return; // don't display if insufficient statistics
    // but do draw if start height needs to be drawn
  }
  
  // drawing info
  HPEN hpOld;
  

  // position of thermal band
  if (numtherm>1) {
    hpOld = (HPEN)SelectObject(hDC, hpThermalBand);
    HBRUSH hbOld = (HBRUSH)SelectObject(hDC, hbThermalBand);
 

    POINT ThermalProfile[NUMTHERMALBUCKETS+2];
    for (i=0; i<numtherm; i++) {    
      ThermalProfile[1+i].x = 
	(iround((Wt[i]/Wmax)*IBLSCALE(TBSCALEX)))+lkvariooffset; //@@ 091118
      
      ThermalProfile[1+i].y = 
	NIBLSCALE(4)+iround(TBSCALEY*(1.0-ht[i]))+rc.top;
    }
    ThermalProfile[0].x = lkvariooffset;
    ThermalProfile[0].y = ThermalProfile[1].y;
    ThermalProfile[numtherm+1].x = lkvariooffset; //@@ 091118
    ThermalProfile[numtherm+1].y = ThermalProfile[numtherm].y;

    Polygon(hDC,ThermalProfile,numtherm+2);
    SelectObject(hDC, hbOld);
  }
    
  // position of thermal band

  GliderBand[0].x += lkvariooffset; // 091123 added
  GliderBand[0].y = NIBLSCALE(4)+iround(TBSCALEY*(1.0-hglider))+rc.top;
  GliderBand[1].y = GliderBand[0].y;
  GliderBand[1].x = max(iround((mc/Wmax)*IBLSCALE(TBSCALEX)),NIBLSCALE(4)) +lkvariooffset; //@@ 091118 rc.left

  GliderBand[2].x = GliderBand[1].x-NIBLSCALE(4);
  GliderBand[2].y = GliderBand[0].y-NIBLSCALE(4);
  GliderBand[3].x = GliderBand[1].x;
  GliderBand[3].y = GliderBand[1].y;
  GliderBand[4].x = GliderBand[1].x-NIBLSCALE(4);
  GliderBand[4].y = GliderBand[0].y+NIBLSCALE(4);

  hpOld = (HPEN)SelectObject(hDC, hpThermalBandGlider);
  
  Polyline(hDC,GliderBand, 2);
  Polyline(hDC,GliderBand+2, 3); // arrow head

  if (draw_start_height) {
    SelectObject(hDC, hpFinalGlideBelow);
    GliderBand[0].y = NIBLSCALE(4)+iround(TBSCALEY*(1.0-hstart))+rc.top;
    GliderBand[1].y = GliderBand[0].y;
    Polyline(hDC, GliderBand, 2);
  }

  SelectObject(hDC, hpOld);
  
}

// revised for variometer gauge
void MapWindow::DrawFinalGlide(HDC hDC, const RECT rc)
{

  SIZE           TextSize;

  if (NewMap&&(GlideBarMode == (GlideBarMode_t)gbDisabled)) {
	GlideBarOffset=0;
	return;
  }

  POINT GlideBar[6] = { {0,0},{9,-9},{18,0},{18,0},{9,0},{0,0} };
  POINT GlideBar0[6] = { {0,0},{9,-9},{18,0},{18,0},{9,0},{0,0} };
  
  HPEN hpOld;
  HBRUSH hbOld;
  
  TCHAR Value[10];
  
  int Offset;
  int Offset0;
  int i;
  int lkVarioOffset=0, minBar, maxBar;

  if (Look8000&&IsMapFullScreen()&&LKVarioBar) //@@ 091115
	lkVarioOffset=LKVarioSize+NIBLSCALE(2); //@@ 091114

  // 091114
  switch(ScreenSize) {
	case (ScreenSize_t)ss480x234:
	case (ScreenSize_t)ss480x272:
	case (ScreenSize_t)ss720x408:
		minBar=-40;
		maxBar=40;
		break;
	case (ScreenSize_t)ss800x480:
	case (ScreenSize_t)ss400x240:
		minBar=-45;
		maxBar=45;
	default:
		minBar=-50; // was 60
		maxBar=50;
		break;
  }
  
  LockTaskData();  // protect from external task changes
  #ifdef HAVEEXCEPTIONS
  __try{
  #endif

  #if 101004
  int barindex;
  barindex=GetOvertargetIndex();
  if (barindex>=0) {
  #else
  if (ValidTaskPoint(ActiveWayPoint)){
  #endif

	const int y0 = ( (rc.bottom - rc.top )/2)+rc.top;
	if (OvertargetMode != OVT_TASK) { //@@ 101004
		Offset=(int)WayPointCalc[barindex].AltArriv[AltArrivMode];
		Offset0=Offset;
	} else {
		// 60 units is size, div by 8 means 60*8 = 480 meters.
		if ( (GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
			Offset = ((int)DerivedDrawInfo.TaskAltitudeDifference)/8; 
			Offset0 = ((int)DerivedDrawInfo.TaskAltitudeDifference0)/8; 
		} else {
			Offset = ((int)DerivedDrawInfo.NextAltitudeDifference)/8; 
			Offset0 = ((int)DerivedDrawInfo.NextAltitudeDifference0)/8; 
		}
	}
	// TODO feature: should be an angle if in final glide mode

	if(Offset > maxBar) Offset = maxBar;
	if(Offset < minBar) Offset = minBar;
	Offset = IBLSCALE(Offset);
	if(Offset<0) {
		GlideBar[1].y = NIBLSCALE(9);
	}
      
	if(Offset0 > maxBar) Offset0 = maxBar;
	if(Offset0 < minBar) Offset0 = minBar;
	Offset0 = IBLSCALE(Offset0);
	if(Offset0<0) {
		GlideBar0[1].y = NIBLSCALE(9);
	}
 
	for(i=0;i<6;i++) {
		GlideBar[i].y += y0;
		// if vario activated
		GlideBar[i].x = IBLSCALE(GlideBar[i].x)+rc.left+lkVarioOffset; //@@ 091114
	}
	GlideBar[0].y -= Offset;
	GlideBar[1].y -= Offset;
	GlideBar[2].y -= Offset;

	for(i=0;i<6;i++) {
		GlideBar0[i].y += y0;
		GlideBar0[i].x = IBLSCALE(GlideBar0[i].x)+rc.left+lkVarioOffset; //@@ 091114
	}
	GlideBar0[0].y -= Offset0;
	GlideBar0[1].y -= Offset0;
	GlideBar0[2].y -= Offset0;

	if ((Offset<0)&&(Offset0<0)) {
		// both below
		if (Offset0!= Offset) {
			int dy = (GlideBar0[0].y-GlideBar[0].y) +(GlideBar0[0].y-GlideBar0[3].y); dy = max(NIBLSCALE(3), dy);
			GlideBar[3].y = GlideBar0[0].y-dy;
			GlideBar[4].y = GlideBar0[1].y-dy;
			GlideBar[5].y = GlideBar0[2].y-dy;
          
			GlideBar0[0].y = GlideBar[3].y;
			GlideBar0[1].y = GlideBar[4].y;
			GlideBar0[2].y = GlideBar[5].y;
		} else {
			Offset0 = 0;
		}

	} else if ((Offset>0)&&(Offset0>0)) {
		// both above
		GlideBar0[3].y = GlideBar[0].y;
		GlideBar0[4].y = GlideBar[1].y;
		GlideBar0[5].y = GlideBar[2].y;

		if (abs(Offset0-Offset)<NIBLSCALE(4)) {
			Offset= Offset0;
		} 
	}

	// draw actual glide bar

	if (Offset<=0) {
		if (LandableReachable && (OvertargetMode==OVT_TASK)) { //@@ 101004
			hpOld = (HPEN)SelectObject(hDC, hpFinalGlideBelowLandable);
			hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideBelowLandable);
		} else {
			hpOld = (HPEN)SelectObject(hDC, hpFinalGlideBelow);
			hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideBelow);
		}
	} else {
		hpOld = (HPEN)SelectObject(hDC, hpFinalGlideAbove);
		hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideAbove);
	}
	Polygon(hDC,GlideBar,6);

	// draw glide bar at mc 0 and X  only for OVT_TASK 101004
	// we dont have mc0 calc ready for other overtargets, not granted at least
	if (OvertargetMode == OVT_TASK) {
		if (Offset0<=0) {
			if (LandableReachable) {
				SelectObject(hDC, hpFinalGlideBelowLandable);
				SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
			} else {
				SelectObject(hDC, hpFinalGlideBelow);
				SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
			}
		} else {
			SelectObject(hDC, hpFinalGlideAbove);
			SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
		}
		if (Offset!=Offset0) {
			Polygon(hDC,GlideBar0,6);
		}

		// JMW draw x on final glide bar if unreachable at current Mc
		// hpAircraftBorder

		if ( (GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
			if ((DerivedDrawInfo.TaskTimeToGo>0.9*ERROR_TIME) || 
			((MACCREADY<0.01) && (DerivedDrawInfo.TaskAltitudeDifference<0))) {
				SelectObject(hDC, hpAircraftBorder);
				POINT Cross[4] = { {-5, -5}, { 5,  5}, {-5,  5}, { 5, -5} };
				for (i=0; i<4; i++) {
					Cross[i].x = IBLSCALE(Cross[i].x+9)+lkVarioOffset; //@@ 091114
					Cross[i].y = IBLSCALE(Cross[i].y+9)+y0;
				}
				Polygon(hDC,Cross,2);
				Polygon(hDC,&Cross[2],2);
			}
		} else {
			if ((MACCREADY<0.01) && (DerivedDrawInfo.NextAltitudeDifference<0)) {
				SelectObject(hDC, hpAircraftBorder);
				POINT Cross[4] = { {-5, -5}, { 5,  5}, {-5,  5}, { 5, -5} };
				for (i=0; i<4; i++) {
					Cross[i].x = IBLSCALE(Cross[i].x+9)+lkVarioOffset;
					Cross[i].y = IBLSCALE(Cross[i].y+9)+y0;
				}
				Polygon(hDC,Cross,2);
				Polygon(hDC,&Cross[2],2);
			}
		}
	}

	// this is the only used choice: draw boxed value in the center
	if (Appearance.IndFinalGlide == fgFinalGlideDefault){

		if (OvertargetMode == OVT_TASK ) { //@@ 101004
			if ((GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
				if ( (ALTITUDEMODIFY*DerivedDrawInfo.TaskAltitudeDifference) <ALTDIFFLIMIT) //@@ 091114
					_stprintf(Value,TEXT(" --- "));
				else
					_stprintf(Value,TEXT("%1.0f "), ALTITUDEMODIFY*DerivedDrawInfo.TaskAltitudeDifference);
			} else {
				if ( (ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference) < ALTDIFFLIMIT) //@@ 091114
					_stprintf(Value,TEXT(" --- "));
				else
					_stprintf(Value,TEXT("%1.0f "), ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
			}
		} else {
			if ( (ALTITUDEMODIFY*WayPointCalc[barindex].AltArriv[AltArrivMode]) < ALTDIFFLIMIT)
				_stprintf(Value,TEXT(" --- "));
			else
				_stprintf(Value,TEXT("%1.0f "), ALTITUDEMODIFY*WayPointCalc[barindex].AltArriv[AltArrivMode]);
		}

		if (Offset>=0) {
			Offset = GlideBar[2].y+Offset+NIBLSCALE(5);
		} else {
			if (Offset0>0) {
				Offset = GlideBar0[1].y-NIBLSCALE(15);
			} else {
				Offset = GlideBar[2].y+Offset-NIBLSCALE(15);
			}
		}
		// VENTA10
		GetTextExtentPoint(hDC, Value, _tcslen(Value), &TextSize); 
		GlideBarOffset=max(NIBLSCALE(11),TextSize.cx) - NIBLSCALE(2);
 
		TextInBoxMode_t TextInBoxMode = {1|8};
		// boxed numbers are a bit too much on the left, so increase the offset
		TextInBox(hDC, Value, lkVarioOffset+NIBLSCALE(1), (int)Offset, 0, TextInBoxMode); //@@ 091114

	} else {
		// This part is unused
#if 0
		if (Appearance.IndFinalGlide == fgFinalGlideAltA){

			HFONT oldFont;
			int y = GlideBar[3].y;
			// was ((rc.bottom - rc.top )/2)-rc.top-
			//            Appearance.MapWindowBoldFont.CapitalHeight/2-1;
			int x = GlideBar[2].x+NIBLSCALE(1);
			HBITMAP Bmp;
			POINT  BmpPos;
			POINT  BmpSize;

			if ((GlideBarMode == (GlideBarMode_t)gbFinish)||!NewMap) {
				_stprintf(Value, TEXT("%1.0f"), Units::ToUserAltitude(DerivedDrawInfo.TaskAltitudeDifference));
			} else {
				_stprintf(Value, TEXT("%1.0f"), Units::ToUserAltitude(DerivedDrawInfo.NextAltitudeDifference));
			}
          
			oldFont = (HFONT)SelectObject(hDC, MapWindowBoldFont);
			GetTextExtentPoint(hDC, Value, _tcslen(Value), &TextSize);
          
			SelectObject(hDC, GetStockObject(WHITE_BRUSH));
			SelectObject(hDC, GetStockObject(WHITE_PEN));
			Rectangle(hDC, x, y, x+NIBLSCALE(1)+TextSize.cx, y+Appearance.MapWindowBoldFont.CapitalHeight+NIBLSCALE(2));
          
			ExtTextOut(hDC, x+NIBLSCALE(1), y+Appearance.MapWindowBoldFont.CapitalHeight
				 -Appearance.MapWindowBoldFont.AscentHeight+NIBLSCALE(1), 0, NULL, Value, _tcslen(Value), NULL);
          
			if (Units::GetUnitBitmap(Units::GetUserAltitudeUnit(), &Bmp, &BmpPos, &BmpSize, 0)){
				HBITMAP oldBitMap = (HBITMAP)SelectObject(hDCTemp, Bmp);
				DrawBitmapX(hDC, x+TextSize.cx+NIBLSCALE(1), y, BmpSize.x, BmpSize.y, hDCTemp, BmpPos.x, BmpPos.y, SRCCOPY);
				SelectObject(hDCTemp, oldBitMap);
			}
          
			SelectObject(hDC, oldFont);
		}
#endif
          
	}
	SelectObject(hDC, hbOld);
	SelectObject(hDC, hpOld);
    } else GlideBarOffset=0; 	// 091125 BUGFIX glidebaroffset is zero when no task point
#ifdef HAVEEXCEPTIONS
  }__finally
#endif
     {
       UnlockTaskData();
     }
  
}


void MapWindow::DrawCompass(HDC hDC, const RECT rc)
{
  POINT Start;
  HPEN hpOld;
  HBRUSH hbOld; 

  if (Appearance.CompassAppearance == apCompassDefault){

	    Start.y = NIBLSCALE(19)+rc.top;
	    Start.x = rc.right - NIBLSCALE(19);

    if (EnableVarioGauge && MapRectBig.right == rc.right)
        Start.x -= InfoBoxLayout::ControlWidth;

    POINT Arrow[5] = { {0,-18}, {-6,10}, {0,0}, {6,10}, {0,-18}};

    hpOld = (HPEN)SelectObject(hDC, hpCompass);
    hbOld = (HBRUSH)SelectObject(hDC, hbCompass);

    // North arrow
    PolygonRotateShift(Arrow, 5, Start.x, Start.y, -DisplayAngle);
    Polygon(hDC,Arrow,5);

    SelectObject(hDC, hbOld);
    SelectObject(hDC, hpOld);

  } else
  if (Appearance.CompassAppearance == apCompassAltA){

    static double lastDisplayAngle = 9999.9;
    static int lastRcRight = 0, lastRcTop = 0;
    static POINT Arrow[5] = { {0,-11}, {-5,9}, {0,3}, {5,9}, {0,-11}};
    extern bool EnableVarioGauge;


    if (lastDisplayAngle != DisplayAngle || lastRcRight != rc.right || lastRcTop != rc.top){

      Arrow[0].x  = 0;
      Arrow[0].y  = -11;
      Arrow[1].x  = -5;
      Arrow[1].y  = 9;
      Arrow[2].x  = 0;
      Arrow[2].y  = 3;
      Arrow[3].x  = 5;
      Arrow[3].y  = 9;
      Arrow[4].x  = 0;
      Arrow[4].y  = -11;

	#if NEWPNAV
	// no more clock, no need to have different compass position
	Start.y = rc.top + NIBLSCALE(11); 
	Start.x = rc.right - NIBLSCALE(11);
	#else
	if (InfoBoxLayout::landscape) {
	      Start.y = rc.top + NIBLSCALE(11); 
	      Start.x = rc.right - NIBLSCALE(11);
	} else {
		if (MapWindow::IsMapFullScreen() && (Look8000==(Look8000_t)lxcAdvanced) ) {
		      Start.y = rc.top + NIBLSCALE(35); 
		      Start.x = rc.right - NIBLSCALE(11);
		} else {
		      Start.y = rc.top + NIBLSCALE(11);
		      Start.x = rc.right - NIBLSCALE(11);
		}
	}
	#endif

      if (EnableVarioGauge && MapRectBig.right == rc.right) {
        Start.x -= InfoBoxLayout::ControlWidth;
      }

      // North arrow
      PolygonRotateShift(Arrow, 5, Start.x, Start.y, 
                         -DisplayAngle);

      lastDisplayAngle = DisplayAngle;
      lastRcRight = rc.right;
      lastRcTop = rc.top;
    }

    hpOld = (HPEN)SelectObject(hDC, hpCompassBorder);
    hbOld = (HBRUSH)SelectObject(hDC, hbCompass);
    Polygon(hDC,Arrow,5);

    SelectObject(hDC, hpCompass);
    Polygon(hDC,Arrow,5);

    SelectObject(hDC, hbOld);
    SelectObject(hDC, hpOld);

  }

}

void MapWindow::ClearAirSpace(bool fill) {
  COLORREF whitecolor = RGB(0xff,0xff,0xff);

  SetTextColor(hDCTemp, whitecolor);
  SetBkMode(hDCTemp, TRANSPARENT);	  
  SelectObject(hDCTemp, (HBITMAP)hDrawBitMapTmp);
  SetBkColor(hDCTemp, whitecolor);	  
  SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  SelectObject(hDCTemp, GetStockObject(WHITE_BRUSH));
  Rectangle(hDCTemp,MapRect.left,MapRect.top,MapRect.right,MapRect.bottom);
  if (fill) {
    SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  }
}

// TODO code: optimise airspace drawing
void MapWindow::DrawAirSpace(HDC hdc, const RECT rc)
{
  COLORREF whitecolor = RGB(0xff,0xff,0xff);
  unsigned int i;
  
  bool found = false;

  if (AirspaceCircle) {
    // draw without border
    for(i=0;i<NumberOfAirspaceCircles;i++) {
      if (AirspaceCircle[i].Visible==2) {
	if (!found) {
	  ClearAirSpace(true);
	  found = true;
	}
        // this color is used as the black bit
        SetTextColor(hDCTemp,
                     Colours[iAirspaceColour[AirspaceCircle[i].Type]]);
        // get brush, can be solid or a 1bpp bitmap
        SelectObject(hDCTemp,
                     hAirspaceBrushes[iAirspaceBrush[AirspaceCircle[i].Type]]);
        Circle(hDCTemp,
               AirspaceCircle[i].Screen.x ,
               AirspaceCircle[i].Screen.y ,
               AirspaceCircle[i].ScreenR ,rc, true, true);
      }
    }
  }

  if (AirspaceArea) {
    for(i=0;i<NumberOfAirspaceAreas;i++) {
      if(AirspaceArea[i].Visible ==2) {
	if (!found) {
	  ClearAirSpace(true);
	  found = true;
	}
        // this color is used as the black bit
        SetTextColor(hDCTemp, 
                     Colours[iAirspaceColour[AirspaceArea[i].Type]]);
        SelectObject(hDCTemp,
                     hAirspaceBrushes[iAirspaceBrush[AirspaceArea[i].Type]]);         
        ClipPolygon(hDCTemp,
                    AirspaceScreenPoint+AirspaceArea[i].FirstPoint,
                    AirspaceArea[i].NumPoints, rc, true);
      }      
    }
  }
  
  // draw it again, just the outlines

  if (found) {
    SelectObject(hDCTemp, GetStockObject(HOLLOW_BRUSH));
    SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  }

  if (AirspaceCircle) {
    for(i=0;i<NumberOfAirspaceCircles;i++) {
      if (AirspaceCircle[i].Visible) {
	if (!found) {
	  ClearAirSpace(false);
	  found = true;
	}
        if (bAirspaceBlackOutline) {
          SelectObject(hDCTemp, GetStockObject(BLACK_PEN));
        } else {
          SelectObject(hDCTemp, hAirspacePens[AirspaceCircle[i].Type]);
        }
        Circle(hDCTemp,
               AirspaceCircle[i].Screen.x ,
               AirspaceCircle[i].Screen.y ,
               AirspaceCircle[i].ScreenR ,rc, true, false);
      }
    }
  }

  if (AirspaceArea) {
    for(i=0;i<NumberOfAirspaceAreas;i++) {
      if(AirspaceArea[i].Visible) {
	if (!found) {
	  ClearAirSpace(false);
	  found = true;
	}
        if (bAirspaceBlackOutline) {
          SelectObject(hDCTemp, GetStockObject(BLACK_PEN));
        } else {
          SelectObject(hDCTemp, hAirspacePens[AirspaceArea[i].Type]);
        }

	POINT *pstart = AirspaceScreenPoint+AirspaceArea[i].FirstPoint;
        ClipPolygon(hDCTemp, pstart,
                    AirspaceArea[i].NumPoints, rc, false);

	if (AirspaceArea[i].NumPoints>2) {
	  // JMW close if open
	  if ((pstart[0].x != pstart[AirspaceArea[i].NumPoints-1].x) ||
	      (pstart[0].y != pstart[AirspaceArea[i].NumPoints-1].y)) {
	    POINT ps[2];
	    ps[0] = pstart[0];
	    ps[1] = pstart[AirspaceArea[i].NumPoints-1];
	    _Polyline(hDCTemp, ps, 2, rc);
	  }
	}

      }      
    }
  }


  if (found) {
    // need to do this to prevent drawing of colored outline
    SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
#if (WINDOWSPC<1)
    TransparentImage(hdc,
                     rc.left, rc.top,
                     rc.right-rc.left,rc.bottom-rc.top,
                     hDCTemp,
                     rc.left, rc.top,
                     rc.right-rc.left,rc.bottom-rc.top,
                     whitecolor
                     );
    
#else
    TransparentBlt(hdc,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   hDCTemp,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   whitecolor
                   );
  #endif
    // restore original color
    //    SetTextColor(hDCTemp, origcolor);
    SetBkMode(hDCTemp,OPAQUE);
  }
}


void MapWindow::DrawMapScale(HDC hDC, const RECT rc /* the Map Rect*/, 
                             const bool ScaleChangeFeedback)
{


  if ((Appearance.MapScale == apMsDefault) || NewMap){

    TCHAR Scale[80];
    TCHAR Scale2[80];
    TCHAR TEMP[20];
    POINT Start, End;
    COLORREF origcolor = SetTextColor(hDC, OverColorRef);

    HPEN hpOld;
    TextInBoxMode_t TextDisplayMode; 
    hpOld = (HPEN)SelectObject(hDC, hpMapScale2);


    // TODO use Appearance font Hight to calculate correct offset

    Start.x = rc.right-NIBLSCALE(6); End.x = rc.right-NIBLSCALE(6);

    Start.y = rc.bottom-BottomSize-NIBLSCALE(4); // 100922
    End.y = Start.y - NIBLSCALE(42);
    DrawSolidLine(hDC,Start,End, rc);

    Start.x = rc.right-NIBLSCALE(11); End.x = rc.right-NIBLSCALE(6);
    End.y = Start.y;
    DrawSolidLine(hDC,Start,End, rc);

     Start.y = Start.y - NIBLSCALE(42); End.y = Start.y;
    //Start.y = Start.y - NIBLSCALE(30); End.y = Start.y; // 091116 BUGFIX MapScale NO we keep same scale, and change value 091117
    DrawSolidLine(hDC,Start,End, rc);

    SelectObject(hDC, hpOld);

    _tcscpy(Scale2,TEXT(""));

    if (!CALCULATED_INFO.TerrainValid)
	_tcscat(Scale2,TEXT(" TERRAIN!"));

    if (AutoZoom) {
      _tcscat(Scale2,TEXT(" AZM"));
    }
    if (EnablePan) {
      _tcscat(Scale2,TEXT(" PAN"));
    }
    if (EnableAuxiliaryInfo) {
      _tcscat(Scale2,TEXT(" iAUX"));
    }

    if (DrawBottom) {
	switch(BottomMode) {
		case BM_TRM:
      			_tcscat(Scale2,TEXT(" TRM0"));
			break;
		case BM_CRU:
      			_tcscat(Scale2,TEXT(" NAV1"));
			break;
		case BM_HGH:
      			_tcscat(Scale2,TEXT(" ALT2"));
			break;
		case BM_AUX:
      			_tcscat(Scale2,TEXT(" STA3"));
			break;
		case BM_TSK:
      			_tcscat(Scale2,TEXT(" TSK4"));
			break;
		case BM_ALT:
      			_tcscat(Scale2,TEXT(" ATN5"));
			break;
		case BM_SYS:
      			_tcscat(Scale2,TEXT(" SYS6"));
			break;
		case BM_CUS2:
      			_tcscat(Scale2,TEXT(" CRU7"));
			break;
		case BM_CUS3:
      			_tcscat(Scale2,TEXT(" FIN8"));
			break;
		case BM_CUS:
      			_tcscat(Scale2,TEXT(" AUX9"));
			break;
		default:
			break;
	}
    }

    if (ReplayLogger::IsEnabled()) {
      _tcscat(Scale2,TEXT(" REPLAY"));
    }
    if (BallastTimerActive) {
      _stprintf(TEMP,TEXT(" BALLAST %3.0fL"), WEIGHTS[2]*BALLAST);
      _tcscat(Scale2, TEMP);
    }

    TCHAR Buffer[20];
    RASP.ItemLabel(RasterTerrain::render_weather, Buffer);
    if (_tcslen(Buffer)) {
      _tcscat(Scale,TEXT(" ")); 
      _tcscat(Scale, Buffer);
    }

    _tcscpy(Scale,TEXT(""));
    double mapScale=MapScale*1.4; // FIX 091117
    if (ISPARAGLIDER) {
	if ((mapScale) <1.0) {
		_stprintf(Scale,TEXT("%1.0f"),mapScale*1000);
		_tcscat(Scale, Units::GetAltitudeName()); 
	}
	else if((MapScale*3) <3) {
		_stprintf(Scale,TEXT("%1.1f"),mapScale);
		_tcscat(Scale, Units::GetDistanceName()); 
	}
	else {
		_stprintf(Scale,TEXT("%1.0f"),mapScale);
		_tcscat(Scale, Units::GetDistanceName()); 
	}
    } else {
	if (mapScale <0.1)
	{
		_stprintf(Scale,TEXT("%1.2f"),mapScale);
	}
	else if(mapScale <3)
	{
		_stprintf(Scale,TEXT("%1.1f"),mapScale);
	}
	else
	{
		_stprintf(Scale,TEXT("%1.0f"),mapScale);
	}
	_tcscat(Scale, Units::GetDistanceName()); 
    }


    SIZE tsize;

    TextDisplayMode.AsInt = 0;
    TextDisplayMode.AsFlag.Color = TEXTWHITE;
    TextDisplayMode.AsFlag.WhiteBold = 1;
    TextDisplayMode.AsFlag.NoSetFont = 0;
    TextDisplayMode.AsFlag.AlligneRight = 0;
    TextDisplayMode.AsFlag.AlligneCenter = 0;

    GetTextExtentPoint(hDC, Scale, _tcslen(Scale), &tsize);
    LKWriteText(hDC, Scale, rc.right-NIBLSCALE(11)-tsize.cx, End.y+NIBLSCALE(3), 0, WTMODE_OUTLINED, WTALIGN_LEFT, OverColorRef, true); 

    GetTextExtentPoint(hDC, Scale2, _tcslen(Scale2), &tsize);
    if (!CALCULATED_INFO.TerrainValid) 
      LKWriteText(hDC, Scale2, rc.right-NIBLSCALE(11)-tsize.cx, End.y+NIBLSCALE(3)+tsize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_RED, true); 
    else
      LKWriteText(hDC, Scale2, rc.right-NIBLSCALE(11)-tsize.cx, End.y+NIBLSCALE(3)+tsize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, OverColorRef, true); 


    #ifdef DRAWLOAD
    SelectObject(hDC, MapWindowFont);
    wsprintf(Scale,TEXT("            %d %d ms"), timestats_av,
             misc_tick_count);
    ExtTextOut(hDC, rc.left, rc.top, 0, NULL, Scale, _tcslen(Scale), NULL);
    #endif

    // restore original color
    SetTextColor(hDC, origcolor);

    SelectObject(hDC, hpOld);

  }

}

// Glide Amoeba area
// NOTE: Shaded line is displayed only when in flight, otherwise only a dashed line is used
void MapWindow::DrawGlideThroughTerrain(HDC hDC, const RECT rc) {
  HPEN hpOld;

  //double h,dh;
  TCHAR hbuf[10];
  static bool doinit=true;
  static TextInBoxMode_t tmode;
  bool wrotevalue=false;

  if (doinit) {
	tmode.AsInt=0;
	tmode.AsFlag.Border=1;
	doinit=false;
  }

  hpOld = (HPEN)SelectObject(hDC, hpTerrainLineBg); 

  // draw a dashed perimetral line first
  _Polyline(hDC,Groundline,NUMTERRAINSWEEPS+1, rc);

  // draw shade if selected and during a flight
  if ((FinalGlideTerrain==1) || ((!EnableTerrain || !DerivedDrawInfo.Flying) && (FinalGlideTerrain==2))) { 
	SelectObject(hDC,hpTerrainLine);
	_Polyline(hDC,Groundline,NUMTERRAINSWEEPS+1, rc);
  }

  // draw red cross obstacles only if destination looks reachable!
  // only if using OVT_TASK of course!

#ifdef _SIM_ 
  if ( (OvertargetMode == OVT_TASK) && ValidTaskPoint(ActiveWayPoint) )  // 100930
#else
  if ( (OvertargetMode==OVT_TASK) && DerivedDrawInfo.Flying && ValidTaskPoint(ActiveWayPoint)) // 100930
#endif
  if (WayPointCalc[TASKINDEX].AltArriv[AltArrivMode] >0) { 

	POINT sc;
	// If calculations detected an obstacle...
	if ((DerivedDrawInfo.TerrainWarningLatitude != 0.0) &&(DerivedDrawInfo.TerrainWarningLongitude != 0.0)) {

		// only if valid position, and visible
		if (DerivedDrawInfo.FarObstacle_Lon >0) 
		if (PointVisible(DerivedDrawInfo.FarObstacle_Lon, DerivedDrawInfo.FarObstacle_Lat)) {
			LatLon2Screen(DerivedDrawInfo.FarObstacle_Lon, DerivedDrawInfo.FarObstacle_Lat, sc);
			DrawBitmapIn(hDC, sc, hTerrainWarning);

			if (DerivedDrawInfo.FarObstacle_AltArriv <=-50 ||  DerivedDrawInfo.FarObstacle_Dist<5000 ) {
				_stprintf(hbuf,_T(" %.0f"),ALTITUDEMODIFY*DerivedDrawInfo.FarObstacle_AltArriv);
				TextInBox(hDC,hbuf,sc.x+NIBLSCALE(15), sc.y, 0, tmode,false); 
				wrotevalue=true;
			}
		} // visible far obstacle

		if (PointVisible(DerivedDrawInfo.TerrainWarningLongitude, DerivedDrawInfo.TerrainWarningLatitude)) {
			LatLon2Screen(DerivedDrawInfo.TerrainWarningLongitude, DerivedDrawInfo.TerrainWarningLatitude, sc);
			DrawBitmapIn(hDC, sc, hTerrainWarning);
#if 0
			// 091203 add obstacle altitude on moving map
			h =  max(0,RasterTerrain::GetTerrainHeight(DerivedDrawInfo.TerrainWarningLatitude, 
				DerivedDrawInfo.TerrainWarningLongitude)); 
			if (h==TERRAIN_INVALID) h=0; //@@ 101027 FIX but unused
			dh = CALCULATED_INFO.NavAltitude - h - SAFETYALTITUDETERRAIN;
			_stprintf(hbuf,_T(" %.0f"),ALTITUDEMODIFY*dh);
			TextInBox(hDC,hbuf,sc.x+NIBLSCALE(10), sc.y, 0, tmode,false); 
#else
			// if far obstacle was painted with value...
			if (wrotevalue) {
				// if it is not too near the nearest..
				if ( (fabs(DerivedDrawInfo.FarObstacle_Lon - DerivedDrawInfo.TerrainWarningLongitude) >0.02) &&
					(fabs(DerivedDrawInfo.FarObstacle_Lat - DerivedDrawInfo.TerrainWarningLatitude) >0.02)) {
					// and it the arrival altitude is actually negative (rounding terrain errors?)
					if ( DerivedDrawInfo.ObstacleAltArriv <=-50)
					// and there is a significant difference in the numbers, then paint value also for nearest
					if (  fabs(DerivedDrawInfo.ObstacleAltArriv - DerivedDrawInfo.FarObstacle_AltArriv) >100 ) {
						_stprintf(hbuf,_T(" %.0f"),ALTITUDEMODIFY*DerivedDrawInfo.ObstacleAltArriv);
						TextInBox(hDC,hbuf,sc.x+NIBLSCALE(15), sc.y, 0, tmode,false); 
					}
				}
			} else {
				// else paint value only if meaningful or very close to us
				// -1 to 10m become -1 for rounding errors
				if ( (DerivedDrawInfo.ObstacleAltArriv >-1) && (DerivedDrawInfo.ObstacleAltArriv <10))
					DerivedDrawInfo.ObstacleAltArriv=-1;
				if (DerivedDrawInfo.ObstacleAltArriv <=-50 ||  
				 ((DerivedDrawInfo.ObstacleAltArriv<0) && (DerivedDrawInfo.ObstacleDistance<5000)) ) {

					_stprintf(hbuf,_T(" %.0f"),ALTITUDEMODIFY*DerivedDrawInfo.ObstacleAltArriv);
					TextInBox(hDC,hbuf,sc.x+NIBLSCALE(15), sc.y, 0, tmode,false); 
				}
			}
#endif
		} // visible nearest obstacle
	} // obstacles detected
  } // within glide range

  SelectObject(hDC, hpOld);
}


void MapWindow::DrawBestCruiseTrack(HDC hdc, const POINT Orig)
{
  HPEN hpOld;
  HBRUSH hbOld;

  if (ActiveWayPoint<0) {
    return; // nothing to draw..
  }
  if (!ValidTaskPoint(ActiveWayPoint)) {
    return;
  }

  if (DerivedDrawInfo.WaypointDistance < 0.010)
    return;

  // dont draw bestcruise indicator if not needed
  if (fabs(DerivedDrawInfo.BestCruiseTrack-DerivedDrawInfo.WaypointBearing)<2) { // 091202 10 to 2
	return;
  } 


  hpOld = (HPEN)SelectObject(hdc, hpBestCruiseTrack);
  hbOld = (HBRUSH)SelectObject(hdc, hbBestCruiseTrack);

  if (Appearance.BestCruiseTrack == ctBestCruiseTrackDefault){

    int dy = (long)(70); 
    POINT Arrow[7] = { {-1,-40}, {1,-40}, {1,0}, {6,8}, {-6,8}, {-1,0}, {-1,-40}};

    Arrow[2].y -= dy;
    Arrow[3].y -= dy;
    Arrow[4].y -= dy;
    Arrow[5].y -= dy;

    PolygonRotateShift(Arrow, 7, Orig.x, Orig.y, 
                       DerivedDrawInfo.BestCruiseTrack-DisplayAngle);

    Polygon(hdc,Arrow,7);

  } else
  if (Appearance.BestCruiseTrack == ctBestCruiseTrackAltA){

    POINT Arrow[] = { {-1,-40}, {-1,-62}, {-6,-62}, {0,-70}, {6,-62}, {1,-62}, {1,-40}, {-1,-40}};

    PolygonRotateShift(Arrow, sizeof(Arrow)/sizeof(Arrow[0]),
                       Orig.x, Orig.y, 
                       DerivedDrawInfo.BestCruiseTrack-DisplayAngle);
    Polygon(hdc, Arrow, (sizeof(Arrow)/sizeof(Arrow[0])));
  }

  SelectObject(hdc, hpOld);
  SelectObject(hdc, hbOld);
}

@


8.14
log
@*** empty log message ***
@
text
@d2 3
a4 1
Copyright_License {
d6 1
a6 33
  XCSoar Glide Computer - http://xcsoar.sourceforge.net/
  Copyright (C) 2000 - 2008  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>
	Mirek Jezek <mjezek@@ipplc.cz>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  $Id: MapWindow2.cpp,v 8.13 2009/12/17 20:40:10 root Exp root $
}
a28 1
// #include <assert.h>
a61 1
#define ISPARAGLIDER (AircraftCategory == (AircraftCategory_t)umParaglider)
d211 1
a211 1
///: 100303 new version, using estimated IAS
a218 1
  //  TCHAR Value[10];
a219 2
  ///: if (Appearance.DontShowSpeedToFly || !DerivedDrawInfo.Flying)
   ///: return;
d227 1
a227 1
  ///: we use estimated airspeed now
a232 2
  // cheat
  ///: DrawInfo.IndicatedAirspeed = DrawInfo.Speed;
a241 1
  ///:vdiff = (DerivedDrawInfo.VOpt - DrawInfo.IndicatedAirspeed)/40.0;
a294 210
#ifndef LK8000_OPTIMIZE
void MapWindow::DrawFLARMTraffic(HDC hDC, RECT rc, POINT Orig_Aircraft) {

  if (!EnableFLARMMap) return;

  if (!DrawInfo.FLARM_Available) return;

  HPEN hpOld;
  HPEN thinBlackPen = CreatePen(PS_SOLID, NIBLSCALE(1), RGB(0,0,0));
  POINT Arrow[5];

  hpOld = (HPEN)SelectObject(hDC, thinBlackPen);

  int i;
//  double dX, dY;
  TextInBoxMode_t displaymode;
  displaymode.AsInt = 0;

  double screenrange = GetApproxScreenRange();
  double scalefact = screenrange/6000.0;

  HBRUSH redBrush = CreateSolidBrush(RGB_RED);
  HBRUSH yellowBrush = CreateSolidBrush(RGB_YELLOW);
  HBRUSH greenBrush = CreateSolidBrush(RGB_GREEN);

  for (i=0; i<FLARM_MAX_TRAFFIC; i++) {
    if (DrawInfo.FLARM_Traffic[i].ID!=0) {

      double target_lon;
      double target_lat;

      target_lon = DrawInfo.FLARM_Traffic[i].Longitude;
      target_lat = DrawInfo.FLARM_Traffic[i].Latitude;

      if ((EnableFLARMMap==2)&&(scalefact>1.0)) {
        double distance;
        double bearing;

        DistanceBearing(DrawInfo.Latitude,
                        DrawInfo.Longitude,
                        target_lat,
                        target_lon,
                        &distance,
                        &bearing);

        FindLatitudeLongitude(DrawInfo.Latitude, 
                              DrawInfo.Longitude, 
                              bearing,
                              distance*scalefact, 
                              &target_lat, 
                              &target_lon);

      }
      
      // TODO feature: draw direction, rel height?
      POINT sc, sc_name, sc_av;
      LatLon2Screen(target_lon, 
                    target_lat, 
                    sc);

      sc_name = sc;

      sc_name.y -= NIBLSCALE(16);
      sc_av = sc_name;

#ifndef FLARM_AVERAGE
      if (DrawInfo.FLARM_Traffic[i].Name) {
       // displaymode.AsFlag.Border=1;
       TextInBox(hDC, DrawInfo.FLARM_Traffic[i].Name, sc.x+NIBLSCALE(3), sc.y, 0, displaymode, true);
      }
#else
      TCHAR label_name[100];
      TCHAR label_avg[100];

      sc_av.x += NIBLSCALE(3);

      if (DrawInfo.FLARM_Traffic[i].Name) {
	sc_name.y -= NIBLSCALE(8);
	_stprintf(label_name, TEXT("%s"), DrawInfo.FLARM_Traffic[i].Name);
      } else {
	label_name[0]= _T('\0');
      }

      if (DrawInfo.FLARM_Traffic[i].Average30s>=0.1) {
	_stprintf(label_avg, TEXT("%.1f"), 
		  LIFTMODIFY*DrawInfo.FLARM_Traffic[i].Average30s);
      } else {
	label_avg[0]= _T('\0');
      }

#ifdef DEBUG
      // for testing only!
      _stprintf(label_avg, TEXT("2.3"));
      _stprintf(label_name, TEXT("WUE"));
#endif

      float vmax = (float)(1.5*min(5.0, max(MACCREADY,0.5)));
      float vmin = (float)(-1.5*min(5.0, max(MACCREADY,2.0)));
      
      float cv = DrawInfo.FLARM_Traffic[i].Average30s;
      if (cv<0) {
        cv /= (-vmin); // JMW fixed bug here
      } else {
        cv /= vmax;
      }
      
      int colourIndex = fSnailColour(cv);

      // JMW TODO enhancement: decluttering of FLARM altitudes (sort by max lift)

      int dx = (sc_av.x-Orig_Aircraft.x);
      int dy = (sc_av.y-Orig_Aircraft.y);

      if (dx*dx+dy*dy > NIBLSCALE(30)*NIBLSCALE(30)) {
	// only draw labels if not close to aircraft

	HGDIOBJ oldFont = SelectObject(hDC, MapLabelFont);	
	COLORREF oldTextColor = SetTextColor(hDC, RGB(0,0,0));

	if (_tcslen(label_name)>0) {
	  ExtTextOut(hDC, sc_name.x, sc_name.y, ETO_OPAQUE, NULL, label_name, _tcslen(label_name), NULL); 
	}

	if (_tcslen(label_avg)>0) {
	  int size = _tcslen(label_avg);
	  SIZE tsize;
	  RECT brect;

	  GetTextExtentPoint(hDC, label_avg, size, &tsize);
	  brect.left = sc_av.x-2;
	  brect.right = brect.left+tsize.cx+6;
	  brect.top = sc_av.y+((tsize.cy+4)>>3)-2;
	  brect.bottom = brect.top+3+tsize.cy-((tsize.cy+4)>>3);

	  ///: HPEN hpOld = (HPEN)SelectObject(hDC, hSnailPens[colourIndex]); 091007 BUGFIX shadowing DrawFLARM
	  HPEN hpOld2 = (HPEN)SelectObject(hDC, hSnailPens[colourIndex]); 
	  HBRUSH hVarioBrush = CreateSolidBrush(hSnailColours[colourIndex]);
	  HBRUSH hbOld = (HBRUSH)SelectObject(hDC, hVarioBrush);

	  RoundRect(hDC, brect.left, brect.top, brect.right, brect.bottom, 
		    NIBLSCALE(8), NIBLSCALE(8));
#if (WINDOWSPC>0)
      SetBkMode(hDC,TRANSPARENT);
      ExtTextOut(hDC, sc_av.x, sc_av.y, 0, NULL, label_avg, size, NULL);
#else
      ExtTextOut(hDC, sc_av.x, sc_av.y, ETO_OPAQUE, NULL, label_avg, size, NULL);
#endif

	  ///: SelectObject(hDC, hpOld);  091007 BUGFIX
	  SelectObject(hDC, hpOld2);
	  SelectObject(hDC, hbOld);
	  DeleteObject(hVarioBrush);

	}

	SelectObject(hDC, oldFont);
	SetTextColor(hDC, oldTextColor);

      }

#endif
      if ((DrawInfo.FLARM_Traffic[i].AlarmLevel>0) 
	  && (DrawInfo.FLARM_Traffic[i].AlarmLevel<4)) {
	DrawBitmapIn(hDC, sc, hFLARMTraffic);
      }

      Arrow[0].x = -4;
      Arrow[0].y = 5;
      Arrow[1].x = 0;
      Arrow[1].y = -6;
      Arrow[2].x = 4;
      Arrow[2].y = 5;
      Arrow[3].x = 0;
      Arrow[3].y = 2;
      Arrow[4].x = -4;
      Arrow[4].y = 5;

      //      double vmag = max(1.0,min(15.0,DrawInfo.FLARM_Traffic[i].Speed/5.0))*2;

      switch (DrawInfo.FLARM_Traffic[i].AlarmLevel) {
      case 1:
	  SelectObject(hDC, yellowBrush);
	  break;
      case 2:
      case 3:
	  SelectObject(hDC, redBrush);
	  break;
      case 0:
      case 4:
	  SelectObject(hDC, greenBrush);
	  break;
      }

      PolygonRotateShift(Arrow, 5, sc.x, sc.y, 
                         DrawInfo.FLARM_Traffic[i].TrackBearing - DisplayAngle);
      Polygon(hDC,Arrow,5);

    }
  }

  SelectObject(hDC, hpOld);

  DeleteObject((HPEN)thinBlackPen);
  DeleteObject(greenBrush);
  DeleteObject(yellowBrush);
  DeleteObject(redBrush);

}
#endif

d299 1
a299 1
///: this slots char array is simply loading the slot number. A nibble should be enough, but no problems to use 8 bits.
d302 1
a302 1
///: Returns true if label can be printed, not overlapping other labels
d306 2
a307 2
  ///: This item is out of screen, probably because zoom was made and we still have old wps
  ///: or we panned, or we have a far away takeoff still in the list
d309 1
a309 1
  ///: we must limit the out of screen of bottom label size to clipped screen
d316 1
a316 1
	///: vertical coordinate Y for bottom size of each slot
a324 5
/*
	for (j=0; j<SCREENVSLOTS; j++) {
		StartupStore(_T("... slot[%d]= %d\n"),j, slotbottom[j]);
	}
*/
d327 1
a327 1
	///: j initially is slot 0; we keep <= for safety
d330 1
a330 1
		///: just for safety
a333 5
/*
	for (i=0; i<=(unsigned int)ScreenSizeY; i++) {
		StartupStore(_T("... slot[%d]=  %d\n"),i, (char)slot[i]);
	}
*/
d340 1
a340 1
  ///: Max number of labels on screen
d343 1
a343 1
  ///: rc.top is searched in its slot, but the label could also spread to the next slot...
a345 10
  #if 0
  ///: REMOVE after check version
  if (vslot>=SCREENVSLOTS) {
	DebugStore("vslot %d INVALID!",vslot);
	StartupStore(_T("...... vslot %d INVALID!%s"),vslot,NEWLINE);
	return false;
  }
  #endif

  ///: StartupStore(_T("... rc.top=%d rc.bottom=%d vslot top=%d=%d \n"),rc.top, rc.bottom, (char)slot[rc.top],vslot);
d349 1
a349 10
  #if 0
  if (nvlabelslot <0 || nvlabelslot>=MAXVLABELBLOCKS) {
	///: REMOVE after check version
	DebugStore("nvlabelslot %d INVALID!",nvlabelslot);
	StartupStore(_T("... nvlabelslot INVALID!%s"),NEWLINE);
	return false;
  }
  #endif

  ///: Check rc.top in its slot
d351 1
a351 2
	///: CheckRect is used only here
	//if (CheckRectOverlap(&LabelBlockCoords[vslot][i],&rc)) {
d353 2
a354 2
		///: When overlapping, DO NOT insert this label in the list! It has not been printed!
		///: StartupStore(_T("... item %d overlapping in slot %d with nvlabels=%d\n"),i,vslot,nvlabelslot);
d358 1
a358 1
  ///: top is ok, now check if using also next slot
a360 1
  ///: int nv2labelslot=0;
a362 1
	///: nv2labelslot=nVLabelBlocks[v2slot];
d366 1
a366 1
			///: StartupStore(_T("... item %d overlapping in secondary slot %d with nvlabels=%d\n"),i,v2slot,nv2labelslot);
d373 1
a373 1
  ///: now insert the label in the list, for next checks
a374 1
	//LabelBlockCoords[vslot][nvlabelslot]= rc;
d378 1
a378 1
	///: StartupStore(_T("... added label in slot %d nvlabelslot now=%d tot=%d\n"), vslot,nVLabelBlocks[vslot], nLabelBlocks);
d381 2
a382 3
	///: 100617 if the label cannot be checked because the list is full, don't print the label!
	///:StartupStore(_T("... label list is full vslot=%d, item not added%s"),vslot,NEWLINE);
	///:DebugStore("label list is full, vslot=%d, item not added", vslot);
d386 1
a386 1
  ///: Now check secondary list, if needed
a387 1
	//LabelBlockCoords[v2slot][nv2labelslot]= rc;
d391 1
a391 1
	///: StartupStore(_T("... added label in slot %d nvlabelslot now=%d tot=%d\n"), vslot,nVLabelBlocks[vslot], nLabelBlocks);
d394 2
a395 3
	///: 100617 if the label cannot be checked because the list is full, don't print the label!
	///:StartupStore(_T("... second label list is full v2slot=%d, item not added%s"),v2slot,NEWLINE);
	///:DebugStore("second label list is full, v2slot=%d, item not added", v2slot);
d403 1
a403 42
int MapWindow::nLabelBlocks;
RECT MapWindow::LabelBlockCoords[MAXLABELBLOCKS];

///: Returns true if label can be printed, not overlapping other labels
bool MapWindow::checkLabelBlock(RECT rc) {
  if (DeclutterMode==(DeclutterMode_t)dmDisabled) return true;
  #ifndef LKTOPO
  bool ok = true;
  #endif

  #if TOPOFAST
  ///: Max number of labels on screen
  if (nLabelBlocks>LKMaxLabels) return false;
  #endif

  for (int i=0; i<nLabelBlocks; i++) {
	///: CheckRect used only here
	if (CheckRectOverlap(LabelBlockCoords[i],rc)) {
		#if LKTOPO
		///: When overlapping, DO NOT insert this label in the list! It has not been printed!
		return false;
		#else
		ok = false;
		continue;
		#endif
	}
  }
  ///: now insert the label in the list, for next checks
  if (nLabelBlocks<MAXLABELBLOCKS-1) {
	LabelBlockCoords[nLabelBlocks]= rc;
	nLabelBlocks++;
  }
  #if LKTOPO
  ///: 100617 if the label cannot be checked because the list is full, don't print the label!
  else {
	return false;
  }
  return true;
  #else
  return ok;
  #endif
}
d706 1
a706 1
	///: Should use ReducedMapSize() test 101109 TODO FIX
d734 1
a734 1
  ///: very important
d738 3
a740 3
  ///: 100709 preserve this calculation for 0.0 until next round!
  ///: This is already done since screenbounds_latlon is global. Beware that DrawTrail will change it later on
  ///: to expand boundaries by 1 minute
a748 1
    ///: REM 100307 check taskpoints
a849 95
#ifndef LK8000_OPTIMIZE
// THIS IS NOT USED - using now the new version
static bool CheckLandableReachableTerrain(NMEA_INFO *Basic,
                                          DERIVED_INFO *Calculated,
                                          double LegToGo,
                                          double LegBearing) {
  double lat, lon;
  bool out_of_range;
  double distance_soarable = 
    FinalGlideThroughTerrain(LegBearing, 
                             Basic, Calculated, 
                             &lat,
                             &lon,
                             LegToGo, &out_of_range, NULL);
    
  if ((out_of_range)||(distance_soarable> LegToGo)) {
    return true;
  } else {
    return false;
  }
}
#endif

// VNT : john should this be moved to the calculation task, and activated when map is displayed only?
// 091004 this can be OPTIMIZED!
// 091134 this is very buggy! disabled and unused
#ifndef LK8000_OPTIMIZE
void MapWindow::CalculateWaypointReachable(void)
{
  unsigned int i;
  double WaypointDistance, WaypointBearing,AltitudeRequired,AltitudeDifference;
  double dtmp;

  LandableReachable = false;

  if (!WayPointList) return;

  LockTaskData();

  for(i=0;i<NumberOfWayPoints;i++)
  {
    if ((WayPointList[i].Visible && 
	  #ifndef USEISLANDABLE
	 (
	  ((WayPointList[i].Flags & AIRPORT) == AIRPORT) ||
	  ((WayPointList[i].Flags & LANDPOINT) == LANDPOINT)
	  ))
	  #else
	  (WayPointCalc[i].IsLandable))
	  #endif
	|| WaypointInTask(i) ) {

      DistanceBearing(DrawInfo.Latitude, 
		      DrawInfo.Longitude, 
		      WayPointList[i].Latitude, 
		      WayPointList[i].Longitude,
		      &WaypointDistance,
		      &WaypointBearing);

      // We ought to start saving calculated values for later reusage, and save cpu.
      // This is a good place to start from, since this function is called everytime
      // the map is redrawn.
      // VENTA6: TODO need to optimize bestalternate and many other functions, later... 090525
      WayPointCalc[i].Distance=WaypointDistance; 
      WayPointCalc[i].Bearing=WaypointBearing;

	if (SafetyAltitudeMode==0 && !WayPointCalc[i].IsLandable)
		dtmp=DerivedDrawInfo.NavAltitude - WayPointList[i].Altitude;
	else
		dtmp=DerivedDrawInfo.NavAltitude - SAFETYALTITUDEARRIVAL - WayPointList[i].Altitude;

	if (dtmp>0) {
		WayPointCalc[i].GR = WaypointDistance / dtmp;
		if (WayPointCalc[i].GR > INVALID_GR) WayPointCalc[i].GR=INVALID_GR; else
		if (WayPointCalc[i].GR <1) WayPointCalc[i].GR=1;
	} else
		WayPointCalc[i].GR = INVALID_GR;

	// VENTA6 TODO set also AltArriv here	
      
      AltitudeRequired = 
	GlidePolar::MacCreadyAltitude
	(GlidePolar::SafetyMacCready, 
	 WaypointDistance,
	 WaypointBearing, 
	 DerivedDrawInfo.WindSpeed, 
	 DerivedDrawInfo.WindBearing,
	 0,0,true,0);

	if (SafetyAltitudeMode==0 && !WayPointCalc[i].IsLandable)
      		AltitudeRequired = AltitudeRequired + WayPointList[i].Altitude ;
	else
      		AltitudeRequired = AltitudeRequired + SAFETYALTITUDEARRIVAL + WayPointList[i].Altitude ;

      WayPointCalc[i].AltReqd[AltArrivMode] = AltitudeRequired; // VENTA6
a850 203
      AltitudeDifference = DerivedDrawInfo.NavAltitude - AltitudeRequired;                                      
      WayPointList[i].AltArivalAGL = AltitudeDifference;
      
      if(AltitudeDifference >=0){
	WayPointList[i].Reachable = TRUE;
	if (!LandableReachable || ((int)i==ActiveWayPoint)) {
	  if (CheckLandableReachableTerrain(&DrawInfo, 
					    &DerivedDrawInfo,
					    WaypointDistance, 
					    WaypointBearing)) {
	    LandableReachable = true;
	///: BUGS! 100116  but unused function..
	  } else if ((int)i==ActiveWayPoint) {  
	    WayPointList[i].Reachable = FALSE;
	  }
	}
      } else {
	WayPointList[i].Reachable = FALSE;
      }
    }
  }

  if (!LandableReachable) {
    // widen search to far visible waypoints 
    // (only do this if can't see one at present)

    for(i=0;i<NumberOfWayPoints;i++)
      {
        if(!WayPointList[i].Visible && WayPointList[i].FarVisible) 
          // visible but only at a distance (limit this to 100km radius)
          {
	    #ifndef USEISLANDABLE
            if(  ((WayPointList[i].Flags & AIRPORT) == AIRPORT) 
                 || ((WayPointList[i].Flags & LANDPOINT) == LANDPOINT) )
	    #else
            if( WayPointCalc[i].IsLandable )
	    #endif
              {
                DistanceBearing(DrawInfo.Latitude, 
                                DrawInfo.Longitude, 
                                WayPointList[i].Latitude, 
                                WayPointList[i].Longitude,
                                &WaypointDistance,
                                &WaypointBearing);
               
      WayPointCalc[i].Distance=WaypointDistance;  // VENTA6
      WayPointCalc[i].Bearing=WaypointBearing;

                if (WaypointDistance<100000.0) {
                  AltitudeRequired = 
                    GlidePolar::MacCreadyAltitude
                    (GlidePolar::SafetyMacCready, 
                     WaypointDistance,
                     WaypointBearing, 
                     DerivedDrawInfo.WindSpeed, 
                     DerivedDrawInfo.WindBearing,
                     0,0,true,0);
                  
		if (SafetyAltitudeMode==0 && !WayPointCalc[i].IsLandable)
	                  AltitudeRequired = AltitudeRequired + WayPointList[i].Altitude ;
		else
	                  AltitudeRequired = AltitudeRequired + SAFETYALTITUDEARRIVAL + WayPointList[i].Altitude ;


                  AltitudeDifference = DerivedDrawInfo.NavAltitude - AltitudeRequired;                                      
                  WayPointList[i].AltArivalAGL = AltitudeDifference;

      WayPointCalc[i].AltReqd[AltArrivMode] = AltitudeRequired; // VENTA6

                  if(AltitudeDifference >=0){
                    WayPointList[i].Reachable = TRUE;
                    if (!LandableReachable) {
                      if (CheckLandableReachableTerrain(&DrawInfo, 
                                                        &DerivedDrawInfo,
                                                        WaypointDistance, 
                                                        WaypointBearing)) {
                        LandableReachable = true;
                      }
                    }
                  } else {
                    WayPointList[i].Reachable = FALSE;
                  }
                }
              }     
          }
      }
  }

  UnlockTaskData(); 
}
#endif


/*
void MapWindow::DrawHorizon(HDC hDC, const RECT rc)
{
  POINT Start;

  Start.y = IBLSCALE(55)+rc.top;
  Start.x = rc.right - IBLSCALE(19);
  if (EnableVarioGauge && MapRectBig.right == rc.right)
    Start.x -= InfoBoxLayout::ControlWidth;

  HPEN   hpHorizonSky;
  HBRUSH hbHorizonSky;
  HPEN   hpHorizonGround;
  HBRUSH hbHorizonGround;
  HPEN   hpOld;
  HBRUSH hbOld;

  hpHorizonSky = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
                                 RGB(0x40,0x40,0xff));
  hbHorizonSky = (HBRUSH)CreateSolidBrush(RGB(0xA0,0xA0,0xff));

  hpHorizonGround = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
                                    RGB(106,55,12));
  hbHorizonGround = (HBRUSH)CreateSolidBrush(
                                             RGB(157,101,60));

  int radius = IBLSCALE(17);
  double phi = max(-89,min(89,DerivedDrawInfo.BankAngle));
  double alpha = RAD_TO_DEG
    *acos(max(-1.0,min(1.0,DerivedDrawInfo.PitchAngle/50.0)));
  double alpha1 = 180-alpha-phi;
  double alpha2 = 180+alpha-phi;

  hpOld = (HPEN)SelectObject(hDC, hpHorizonSky);
  hbOld = (HBRUSH)SelectObject(hDC, hbHorizonSky);

  Segment(hDC, Start.x, Start.y, radius, rc, 
          alpha2, alpha1, true);

  SelectObject(hDC, hpHorizonGround);
  SelectObject(hDC, hbHorizonGround);

  Segment(hDC, Start.x, Start.y, radius, rc, 
          alpha1, alpha2, true);

  POINT a1, a2;

 // 
 // a1.x = Start.x + fastsine(alpha1)*radius;
 // a1.y = Start.y - fastcosine(alpha1)*radius;
 // a2.x = Start.x + fastsine(alpha2)*radius;
 // a2.y = Start.y - fastcosine(alpha2)*radius;
 //
 // _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
 //           a1, a2, RGB(0,0,0));
 // 

  a1.x = Start.x+radius/2;
  a1.y = Start.y;
  a2.x = Start.x-radius/2;
  a2.y = Start.y;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, a2, RGB(0,0,0), rc);

  a1.x = Start.x;
  a1.y = Start.y-radius/4;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, Start, RGB(0,0,0), rc);

  //

#define ROOT2 0.70711

  int rr2p = lround(radius*ROOT2+IBLSCALE(1));
  int rr2n = lround(radius*ROOT2);

  a1.x = Start.x+rr2p;
  a1.y = Start.y-rr2p;
  a2.x = Start.x+rr2n;
  a2.y = Start.y-rr2n;

  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
            a1, a2, RGB(0,0,0), rc);

  a1.x = Start.x-rr2p;
  a1.y = Start.y-rr2p;
  a2.x = Start.x-rr2n;
  a2.y = Start.y-rr2n;

  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
            a1, a2, RGB(0,0,0), rc);

  // JMW experimental, display stall sensor
  double s = max(0.0,min(1.0,DrawInfo.StallRatio));
  long m = (long)((rc.bottom-rc.top)*s*s);
  a1.x = rc.right-1;
  a1.y = rc.bottom-m;
  a2.x = a1.x-10;
  a2.y = a1.y;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, a2, RGB(0xff,0,0), rc);

  SelectObject(hDC, hbOld);
  SelectObject(hDC, hpOld);
  DeleteObject((HPEN)hpHorizonSky);
  DeleteObject((HBRUSH)hbHorizonSky);
  DeleteObject((HPEN)hpHorizonGround);
  DeleteObject((HBRUSH)hbHorizonGround);
}
*/
d910 1
a916 70
#if OLD_GREAT_CIRCLE
  // TODO accuracy: this is actually wrong, it should recalculate the
  // bearing each step
  double distance=0;
  double distanceTotal=0;
  double Bearing;

  DistanceBearing(startLat,
                  startLon,
                  targetLat,
                  targetLon,
                  &distanceTotal,
                  &Bearing);

  distance = distanceTotal;
  
  if (distanceTotal==0.0) {
    return;
  }

  double d_distance = max(5000.0,distanceTotal/10);

  HPEN hpOld = (HPEN)SelectObject(hdc, hpBearing);

  POINT StartP;
  POINT EndP;
  LatLon2Screen(startLon, 
                startLat,
                StartP);
  LatLon2Screen(targetLon, 
                targetLat,
                EndP);

  if (d_distance>distanceTotal) {
    DrawSolidLine(hdc, StartP, EndP, rc);
  } else {

    for (int i=0; i<= 10; i++) {

      double tlat1, tlon1;

      FindLatitudeLongitude(startLat, 
                            startLon, 
                            Bearing,
                            min(distance,d_distance), 
                            &tlat1, 
                            &tlon1);
      
      DistanceBearing(tlat1,
                      tlon1,
                      targetLat,
                      targetLon,
                      &distance,
                      &Bearing);
      
      LatLon2Screen(tlon1, 
                    tlat1,
                    EndP);
      
      DrawSolidLine(hdc, StartP, EndP, rc);
      
      StartP.x = EndP.x;
      StartP.y = EndP.y;

      startLat = tlat1;
      startLon = tlon1;
      
    }
  }
#else
a928 1
#endif
a935 275
#ifndef NEWTRAIL
// This function is slow...
double MapWindow::DrawTrail( HDC hdc, const POINT Orig, const RECT rc)
{
  int i, snail_index;
  SNAIL_POINT P1;
  static BOOL last_circling = FALSE;
  static float vario_max= 5.0;
  static float vario_min= -5.0;
  static bool need_colour = true;

  double TrailFirstTime = -1;

  if(!TrailActive)
    return -1;

  if ((DisplayMode == dmCircling) != last_circling) {
    need_colour = true;
  }
  last_circling = (DisplayMode == dmCircling);

  //////////// Trail drift calculations

  double traildrift_lat = 0.0;
  double traildrift_lon = 0.0;
  
  if (EnableTrailDrift && (DisplayMode == dmCircling)) {
    double tlat1, tlon1;
    
    FindLatitudeLongitude(DrawInfo.Latitude, 
                          DrawInfo.Longitude, 
                          DerivedDrawInfo.WindBearing, 
                          DerivedDrawInfo.WindSpeed,
                          &tlat1, &tlon1);
    traildrift_lat = (DrawInfo.Latitude-tlat1);
    traildrift_lon = (DrawInfo.Longitude-tlon1);
  } else {
    traildrift_lat = 0.0;
    traildrift_lon = 0.0;
  }
  
  // JMW don't draw first bit from home airport

  /////////////  Trail size

  int num_trail_max;
  if (TrailActive!=2) {
    num_trail_max = TRAILSIZE;
  } else {
    num_trail_max = TRAILSIZE/TRAILSHRINK;
  }
  if ((DisplayMode == dmCircling)) {
    num_trail_max /= TRAILSHRINK;
  }

  ///////////// Vario colour scaling

  float this_vario_max = (float)(1.5*min(5.0, max(MACCREADY,0.5)));
  float this_vario_min = (float)(-1.5*min(5.0, max(MACCREADY,2.0)));
  vario_max = this_vario_max;
  vario_min = this_vario_min;

  ///////////// Snail skipping 

  const int skip_divisor = num_trail_max/5;
  int skip_border = skip_divisor;
  int skip_level= 3; // TODO code: try lower level?

  int snail_offset = TRAILSIZE+iSnailNext-num_trail_max;
  while (snail_offset>= TRAILSIZE) {
    snail_offset -= TRAILSIZE;
  }
  while (snail_offset< 0) {
    snail_offset += TRAILSIZE;
  }
  const int zero_offset = (TRAILSIZE-snail_offset);
  skip_border += zero_offset % skip_level;

  int index_skip = ((int)DrawInfo.Time)%skip_level;

  // TODO code: Divide by time step cruise/circling for zero_offset

  ///////////// Keep track of what's drawn

  bool this_visible = true;
  bool last_visible = false;
  POINT point_lastdrawn;
  point_lastdrawn.x = 0;
  point_lastdrawn.y = 0;

  ///////////// Average colour display for skipped points
  float vario_av = 0;
  int vario_av_num = 0;

  ///////////// Constants for speedups

  const bool display_circling = DisplayMode == dmCircling;
  const double display_time = DrawInfo.Time;

  // expand bounds so in strong winds the appropriate snail points are
  // still visible (since they are being tested before drift is applied)
  // this expands them by one minute

  ///: 100709 mmmh. this is not a good idea. other functions will think to be within screen boundaries!

  rectObj bounds_thermal = screenbounds_latlon;
  screenbounds_latlon.minx -= fabs(60.0*traildrift_lon);
  screenbounds_latlon.maxx += fabs(60.0*traildrift_lon);
  screenbounds_latlon.miny -= fabs(60.0*traildrift_lat);
  screenbounds_latlon.maxy += fabs(60.0*traildrift_lat);

  const rectObj bounds = bounds_thermal;

  const int deg = DEG_TO_INT(AngleLimit360(DisplayAngle));
  const int cost = ICOSTABLE[deg];
  const int sint = ISINETABLE[deg];
  const int xxs = Orig_Screen.x*1024-512;
  const int yys = Orig_Screen.y*1024+512;
  const double mDrawScale = DrawScale;
  const double mPanLongitude = PanLongitude;
  const double mPanLatitude = PanLatitude;

  ////////////// Main loop

  for(i=1;i< num_trail_max; ++i) 
  {
    ///// Handle skipping

    if (i>=skip_border) {
      skip_level= max(1,skip_level-1);
      skip_border= i+2*(zero_offset % skip_level)+skip_divisor;
      index_skip = skip_level;
    }

    index_skip++;
    if ((i<num_trail_max-10) && (index_skip < skip_level)) {
      continue;
    } else {
      index_skip=0;
    }

    ////// Find the snail point

    snail_index = snail_offset+i;
    while (snail_index>=TRAILSIZE) {
      snail_index-= TRAILSIZE;
    }

    P1 = SnailTrail[snail_index];

    /////// Mark first time of display point

    if (((TrailFirstTime<0) || (P1.Time<TrailFirstTime)) && (P1.Time>=0)) {
      TrailFirstTime = P1.Time;
    }

    //////// Ignoring display elements for modes

    if (display_circling) {
      if ((!P1.Circling)&&( i<num_trail_max-60 )) {
        // ignore cruise mode lines unless very recent
	last_visible = false;
        continue;
      }
    } else {
      //  if ((P1.Circling)&&( snail_index % 5 != 0 )) {
        // JMW TODO code: This won't work properly!
        // draw only every 5 points from circling when in cruise mode
	//        continue;
      //      }
    }

    ///////// Filter if far visible

    if (!P1.FarVisible) {
      last_visible = false;
      continue;
    }

    ///////// Determine if this is visible

    this_visible =   ((P1.Longitude> bounds.minx) &&
		     (P1.Longitude< bounds.maxx) &&
		     (P1.Latitude> bounds.miny) &&
		     (P1.Latitude< bounds.maxy)) ;

    if (!this_visible && !last_visible) {
      last_visible = false;
      continue;
    }

    ////////// Find coordinates on screen after applying trail drift

    // now we know either point is visible, better get screen coords
    // if we don't already.

    double dt = max(0,(display_time-P1.Time)*P1.DriftFactor);
    double this_lon = P1.Longitude+traildrift_lon*dt;
    double this_lat = P1.Latitude+traildrift_lat*dt;

#if 1
    // this is faster since many parameters are const
    int Y = Real2Int((mPanLatitude-this_lat)*mDrawScale);
    int X = Real2Int((mPanLongitude-this_lon)*fastcosine(this_lat)*mDrawScale);
    P1.Screen.x = (xxs-X*cost + Y*sint)/1024;
    P1.Screen.y = (Y*cost + X*sint + yys)/1024;
#else
    LatLon2Screen(this_lon, 
		  this_lat, 
		  P1.Screen);
#endif

    ////////// Determine if we should skip if close to previous point

    if (last_visible && this_visible) {
      // only average what's visible

      if (abs(P1.Screen.y-point_lastdrawn.y)
	  +abs(P1.Screen.x-point_lastdrawn.x)<NIBLSCALE(4)) {
	vario_av += P1.Vario;
	vario_av_num ++;
	continue;
	// don't draw if very short line
      }
    }

    ////////// Lookup the colour if it's not already set

    if ((P1.Colour<0)||(P1.Colour>=NUMSNAILCOLORS)) {
      float colour_vario = P1.Vario;
      if (vario_av_num) {
	// set color to average if skipped
	colour_vario = (colour_vario+vario_av)/(vario_av_num+1);
	vario_av_num= 0;
	vario_av= 0;
      }
      if (colour_vario<0) {
	colour_vario /= (-vario_min); // JMW fixed bug here
      } else {
	colour_vario /= vario_max;
      }
      P1.Colour = fSnailColour(colour_vario);
    }
    SelectObject(hdc, hSnailPens[P1.Colour]);

    if (!last_visible) { // draw set cursor at P1
#ifndef NOLINETO
      MoveToEx(hdc, P1.Screen.x, P1.Screen.y, NULL);
#endif
    } else {
#ifndef NOLINETO
      LineTo(hdc, P1.Screen.x, P1.Screen.y);
#else
      DrawSolidLine(hdc, P1.Screen, point_lastdrawn, rc);
#endif
    }
    point_lastdrawn = P1.Screen;
    last_visible = this_visible;
  }

  // draw final point to glider
  if (last_visible) {
#ifndef NOLINETO 
    LineTo(hdc, Orig.x, Orig.y);
#else
    DrawSolidLine(hdc, Orig, point_lastdrawn, rc);
#endif
  }

  return TrailFirstTime;
}


#endif

a964 2

///////
a966 119
#ifndef LK8000_OPTIMIZE
void MapWindow::DrawOffTrackIndicator(HDC hdc, const RECT rc) {
  if ((ActiveWayPoint<=0) || !ValidTaskPoint(ActiveWayPoint)) {
    return;
  }

  if (fabs(DrawInfo.TrackBearing-DerivedDrawInfo.WaypointBearing)<10) {
    // insignificant error
    return;
  }
  #ifndef NOTASKABORT
  if (DerivedDrawInfo.Circling || TaskIsTemporary() || TargetPan) {
  #else
  if (DerivedDrawInfo.Circling || TargetPan) {
  #endif
    // don't display in various modes
    return;
  }

  double distance_max = min(DerivedDrawInfo.WaypointDistance,
			    GetApproxScreenRange()*0.7);
  if (distance_max < 5000.0) {
    // too short to bother
    return;
  }

  LockTaskData();  // protect from external task changes

  double startLat = DrawInfo.Latitude;
  double startLon = DrawInfo.Longitude;
  double targetLat;
  double targetLon;
  double dLat, dLon;

  if (AATEnabled && ValidTaskPoint(ActiveWayPoint+1)) {
    targetLat = Task[ActiveWayPoint].AATTargetLat;
    targetLon = Task[ActiveWayPoint].AATTargetLon; 
  } else {
    targetLat = WayPointList[TASKINDEX].Latitude;
    targetLon = WayPointList[TASKINDEX].Longitude; 
  }
  UnlockTaskData();

  HFONT oldFont = (HFONT)SelectObject(hdc, TitleWindowFont);
  SetTextColor(hdc, RGB(0x0,0x0,0x0));
      
  int ilast = 0;
  for (double d=0.25; d<=1.0; d+= 0.25) {
    double distance0, distance1;

    FindLatitudeLongitude(startLat, startLon, 
			  DrawInfo.TrackBearing, 
			  distance_max*d,
			  &dLat, &dLon);

    DistanceBearing(startLat, startLon,
		    dLat, dLon,
		    &distance0,
		    NULL);
    DistanceBearing(dLat, dLon,
		    targetLat, targetLon,
		    &distance1,
		    NULL);

    double distance = (distance0+distance1)/DerivedDrawInfo.WaypointDistance;
    int idist = iround((distance-1.0)*100);

    if ((idist != ilast) && (idist>0) && (idist<1000)) {

      TCHAR Buffer[5];
      _stprintf(Buffer, TEXT("%d"), idist);
      short size = _tcslen(Buffer);
      SIZE tsize;
      POINT sc;
      RECT brect;
      LatLon2Screen(dLon, dLat, sc);
      GetTextExtentPoint(hdc, Buffer, size, &tsize);

	// VENTA10
      switch (DeclutterMode) {
	case (DeclutterMode_t)dmHigh :
	      brect.left = sc.x-4;
	      brect.right = brect.left+tsize.cx+4;
	      brect.top = sc.y-4;
	      brect.bottom = brect.top+tsize.cy+4;
	      if (checkLabelBlock(brect)) {
		ExtTextOut(hdc, sc.x-tsize.cx/2, sc.y-tsize.cy/2, 
			   0, NULL, Buffer, size, NULL);
		ilast = idist;
	      }
	      break;
	case (DeclutterMode_t)dmLow :
	      brect.left = sc.x;
	      brect.right = brect.left+tsize.cx;
	      brect.top = sc.y;
	      brect.bottom = brect.top+tsize.cy;
	      if (checkLabelBlock(brect)) {
		ExtTextOut(hdc, sc.x-tsize.cx/2, sc.y-tsize.cy/2, 
			   0, NULL, Buffer, size, NULL);
		ilast = idist;
	      }
	      break;
	case (DeclutterMode_t)dmDisabled :
		ExtTextOut(hdc, sc.x-tsize.cx/2, sc.y-tsize.cy/2, 
			   0, NULL, Buffer, size, NULL);
		ilast = idist;
	      break;
	default:
	      break;
	
      }
    }

  }

  SelectObject(hdc, oldFont);
}
#endif // OPTIMIZE

d1184 1
a1184 1
  ///: vario is displayed only in fullscreen mode, if enabled
d1299 1
a1299 1
///: revised 091114 for variometer gauge
a1372 1
	///: if(Offset > 60) Offset = 60;  091114 all 60 changed to 50
d1494 1
a1494 1
	///: this is the only used choice: draw boxed value in the center
d1530 1
a1530 1
		///: boxed numbers are a bit too much on the left, so increase the offset
d1534 2
a1535 1
		///: This part is unused
a1537 1
			///: SIZE  TextSize; // 091007 BUGFIX
d1570 2
a1572 1
		}
d1636 1
a1636 1
	///: no more clock, no need to have different compass position
d1745 1
a1745 1
  ////////// draw it again, just the outlines
a1845 3
    ///: COLORREF whitecolor = RGB(0xd0,0xd0, 0xd0); 100923 no more used
    //COLORREF blackcolor = RGB(0x20,0x20, 0x20); REMOVE
    ///: COLORREF origcolor = SetTextColor(hDC, whitecolor); 100923
d1857 1
a1857 3
     ///: 100922 FIX correct position for resolution 
     ///: Start.y = rc.bottom-NIBLSCALE(42); 
     Start.y = rc.bottom-BottomSize-NIBLSCALE(4); // 100922
a1858 1
    //Start.y = rc.bottom-NIBLSCALE(42); End.y = Start.y - NIBLSCALE(30); // 091116 BUGFIX MapScale ok
a1972 1
    ///: 101013
a2001 127
  #if 0 // 101013
  if ((Appearance.MapScale == apMsAltA) && !NewMap){

    static int LastMapWidth = 0;
    double MapWidth;
    TCHAR ScaleInfo[80];
    TCHAR TEMP[20];

    HFONT          oldFont;
    int            Height;
    SIZE           TextSize;
    HBRUSH         oldBrush;
    HPEN           oldPen;
    COLORREF       oldTextColor;
    HBITMAP        oldBitMap;
    Units_t        Unit;


    if (ScaleChangeFeedback)
      MapWidth = (RequestMapScale * rc.right)/DISTANCEMODIFY/GetMapResolutionFactor();
    else
      MapWidth = (MapScale * rc.right)/DISTANCEMODIFY/GetMapResolutionFactor();

    oldFont = (HFONT)SelectObject(hDC, MapWindowBoldFont);

    Units::FormatUserMapScale(&Unit, MapWidth, ScaleInfo, sizeof(ScaleInfo)/sizeof(TCHAR));
    GetTextExtentPoint(hDC, ScaleInfo, _tcslen(ScaleInfo), &TextSize);
    LastMapWidth = (int)MapWidth;

    Height = Appearance.MapWindowBoldFont.CapitalHeight+IBLSCALE(2);  

    // 2: add 1pix border

    oldBrush = (HBRUSH)SelectObject(hDC, GetStockObject(WHITE_BRUSH));
    oldPen = (HPEN)SelectObject(hDC, GetStockObject(WHITE_PEN));
    Rectangle(hDC, 0, rc.bottom-Height, 
              TextSize.cx + NIBLSCALE(21), rc.bottom);

    if (ScaleChangeFeedback){
      SetBkMode(hDC, TRANSPARENT);
      oldTextColor = SetTextColor(hDC, RGB(0xff,0,0));
    }else 
       oldTextColor = SetTextColor(hDC, RGB(0,0,0));

    ExtTextOut(hDC, NIBLSCALE(7), 
           rc.bottom-Appearance.MapWindowBoldFont.AscentHeight-NIBLSCALE(1), 
           0, NULL, ScaleInfo, _tcslen(ScaleInfo), NULL);

    oldBitMap = (HBITMAP)SelectObject(hDCTemp, hBmpMapScale);

    DrawBitmapX(hDC, 0, rc.bottom-Height, 6, 11, hDCTemp, 0, 0, SRCCOPY);
    DrawBitmapX(hDC, 
           NIBLSCALE(14)+TextSize.cx, 
           rc.bottom-Height, 8, 11, hDCTemp, 6, 0, SRCCOPY);

    if (!ScaleChangeFeedback){
      HBITMAP Bmp;
      POINT   BmpPos, BmpSize;

      if (Units::GetUnitBitmap(Unit, &Bmp, &BmpPos, &BmpSize, 0)){
        HBITMAP oldBitMapa = (HBITMAP)SelectObject(hDCTemp, Bmp);

        DrawBitmapX(hDC, 
                    NIBLSCALE(8)+TextSize.cx, rc.bottom-Height, 
                    BmpSize.x, BmpSize.y, 
                    hDCTemp, BmpPos.x, BmpPos.y, SRCCOPY);
        SelectObject(hDCTemp, oldBitMapa);
      }
    }

    int y = rc.bottom-Height-
      (Appearance.TitleWindowFont.AscentHeight+NIBLSCALE(2));
    if (!ScaleChangeFeedback){
      // bool FontSelected = false;
      // TODO code: gettext these
      ScaleInfo[0] = 0;
      if (AutoZoom) {
        _tcscat(ScaleInfo, TEXT("AUTO "));
      }
      if (TargetPan) {
        _tcscat(ScaleInfo, TEXT("TARGET "));
      } else if (EnablePan) {
        _tcscat(ScaleInfo, TEXT("PAN "));
      }
      if (EnableAuxiliaryInfo) {
        _tcscat(ScaleInfo, TEXT("AUX "));
      }
      if (ReplayLogger::IsEnabled()) {
        _tcscat(ScaleInfo, TEXT("REPLAY "));
      }
      if (BallastTimerActive) {
        _stprintf(TEMP,TEXT("BALLAST %3.0f LITERS"), WEIGHTS[2]*BALLAST);
        _tcscat(ScaleInfo, TEMP);
      }
      TCHAR Buffer[20];
      RASP.ItemLabel(RasterTerrain::render_weather, Buffer);
      if (_tcslen(Buffer)) {
        _tcscat(ScaleInfo, Buffer);
      }

      if (ScaleInfo[0]) {
        SelectObject(hDC, TitleWindowFont);
        // FontSelected = true;
        ExtTextOut(hDC, NIBLSCALE(1), y, 0, NULL, ScaleInfo, 
                   _tcslen(ScaleInfo), NULL);
        y -= (Appearance.TitleWindowFont.CapitalHeight+NIBLSCALE(1));
      }
    }

    #ifdef DRAWLOAD
    SelectObject(hDC, MapWindowFont);
    wsprintf(ScaleInfo,TEXT("    %d %d ms"), 
             timestats_av,
             misc_tick_count);

    ExtTextOut(hDC, rc.left, rc.top, 0, NULL, ScaleInfo, 
               _tcslen(ScaleInfo), NULL);
    #endif

    SetTextColor(hDC, oldTextColor);
    SelectObject(hDC, oldPen);
    SelectObject(hDC, oldFont);
    SelectObject(hDC, oldBrush);
    SelectObject(hDCTemp, oldBitMap);

  }
  #endif // 101013
d2005 2
a2006 3
///: Glide Amoeba area
///: 091123 Draw FinalGlideTerrain glide area
///: NOTE: Shaded line is displayed only when in flight, otherwise only a dashed line is used
d2024 1
a2024 2
  ///: draw a dashed perimetral line first
  ///: SelectObject(hDC,hpTerrainLineBg); FIXED useless 100923
d2027 1
a2027 1
  ///: draw shade if selected and during a flight
d2033 2
a2034 2
  ///: draw red cross obstacles only if destination looks reachable!
  ///: 100930 only if using OVT_TASK of course!
a2036 1
  ///: if ( ValidTaskPoint(ActiveWayPoint) )  // 091215
a2038 1
  ///: if (DerivedDrawInfo.Flying && ValidTaskPoint(ActiveWayPoint)) // 091215
a2042 3
	///: 091123 only draw if apparently destination is reachable DISABLED REMOVE
	///: if ( WayPointList[Task[ActiveWayPoint].Index].Reachable )

d2044 1
a2044 1
	///: If calculations detected an obstacle...
d2047 1
a2047 5
		///: 091215 first we draw far obstacle
		//if ( (fabs(DerivedDrawInfo.FarObstacle_Lon - DerivedDrawInfo.TerrainWarningLongitude) >0.01) &&
		//	(fabs(DerivedDrawInfo.FarObstacle_Lat - DerivedDrawInfo.TerrainWarningLatitude) >0.01)) {

		///: only if valid position, and visible
a2052 8
				/*
				if ( (DerivedDrawInfo.FarObstacle_AltArriv >= ( DerivedDrawInfo.ObstacleAltArriv + 20)) ||
					(DerivedDrawInfo.ObstacleAltArriv<=20)) {
					_stprintf(hbuf,_T(" %.0f"),ALTITUDEMODIFY*DerivedDrawInfo.FarObstacle_AltArriv);
					TextInBox(hDC,hbuf,sc.x+NIBLSCALE(15), sc.y, 0, tmode,false); 
				}
				*/

d2064 1
a2064 1
			///: 091203 add obstacle altitude on moving map
a2070 1
			///:
d2072 1
a2072 9
			/*
			///: 091209
			if (DerivedDrawInfo.ObstacleAltArriv <=-50 ||  DerivedDrawInfo.ObstacleDistance<5000 ) {
				_stprintf(hbuf,_T(" %.0f"),ALTITUDEMODIFY*DerivedDrawInfo.ObstacleAltArriv);
				TextInBox(hDC,hbuf,sc.x+NIBLSCALE(15), sc.y, 0, tmode,false); 
			}
			*/

			///: 091215 if far obstacle was painted with value...
d2074 1
a2074 1
				///: if it is not too near the nearest..
d2077 1
a2077 1
					///: and it the arrival altitude is actually negative (rounding terrain errors?)
d2079 1
a2079 1
					///: and there is a significant difference in the numbers, then paint value also for nearest
d2086 2
a2087 2
				///: else paint value only if meaningful or very close to us
				///: 091220 -1 to 10m become -1 for rounding errors
d2121 1
a2121 1
  ///: 091130 FIX dont draw bestcruise indicator if not needed
d2124 1
a2124 1
  } // 091202
@


8.13
log
@1.17f
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.12 2009/11/30 01:50:54 root Exp root $
d96 1
d155 1
a155 1

d185 1
a185 1

d239 1
d242 2
a243 1
/*
d246 1
d253 2
a254 2
  if (Appearance.DontShowSpeedToFly || !DerivedDrawInfo.Flying)
    return;
d257 1
d261 6
d269 2
a270 1
  DrawInfo.IndicatedAirspeed = DrawInfo.Speed;
d279 2
a280 1
  vdiff = (DerivedDrawInfo.VOpt - DrawInfo.IndicatedAirspeed)/40.0;
d287 1
a287 1
  int xoffset = rc.right-IBLSCALE(25);
d297 1
a297 1
        hyoffset = IBLSCALE(4);
d300 1
a300 1
        hyoffset = -IBLSCALE(4);
d304 1
a304 1
      chevron[1].x = xoffset+IBLSCALE(10);
d306 1
a306 1
      chevron[2].x = xoffset+IBLSCALE(20);
d319 1
a319 1
  chevron[0].x = xoffset-IBLSCALE(3);
d321 1
a321 1
  chevron[1].x = xoffset+IBLSCALE(3+20);
d329 1
a329 1
*/
d333 1
d341 1
a341 1
  HPEN thinBlackPen = CreatePen(PS_SOLID, IBLSCALE(1), RGB(0,0,0));
d354 3
a356 3
  HBRUSH redBrush = CreateSolidBrush(RGB(0xFF,0x00,0x00));
  HBRUSH yellowBrush = CreateSolidBrush(RGB(0xFF,0xFF,0x00));
  HBRUSH greenBrush = CreateSolidBrush(RGB(0x00,0xFF,0x00));
d395 1
a395 1
      sc_name.y -= IBLSCALE(16);
d401 1
a401 1
       TextInBox(hDC, DrawInfo.FLARM_Traffic[i].Name, sc.x+IBLSCALE(3), sc.y, 0, displaymode, true);
d407 1
a407 1
      sc_av.x += IBLSCALE(3);
d410 1
a410 1
	sc_name.y -= IBLSCALE(8);
d446 1
a446 1
      if (dx*dx+dy*dy > IBLSCALE(30)*IBLSCALE(30)) {
d473 1
a473 1
		    IBLSCALE(8), IBLSCALE(8));
d541 21
d563 29
d593 94
a686 2
//////////////////////
// JMW added simple code to prevent text writing over map city names
d690 1
d693 1
d695 6
d703 10
a712 4
    if (CheckRectOverlap(LabelBlockCoords[i],rc)) {
      ok = false;
      continue;
    }
d714 1
d716 7
a722 2
    LabelBlockCoords[nLabelBlocks]= rc;
    nLabelBlocks++;
d724 2
d727 1
d729 1
a729 1

d1030 5
a1034 1

d1037 1
d1059 1
d1062 6
d1074 1
d1176 1
a1176 1
#if (0)
d1202 1
a1202 1
#if (0)
d1218 1
d1223 3
d1283 2
a1284 1
	  } else if ((int)i==ActiveWayPoint) {
d1303 1
d1306 3
d1363 2
d1733 2
d1848 1
a1848 1
	  +abs(P1.Screen.x-point_lastdrawn.x)<IBLSCALE(4)) {
d1938 1
d1948 1
d1950 3
d2055 1
a2055 1

d2121 1
d2123 3
d2219 2
a2220 2
		      point.x-IBLSCALE(10), 
		      point.y-IBLSCALE(10),
d2225 2
a2226 2
		      point.x-IBLSCALE(10), 
		      point.y-IBLSCALE(10),
d2253 1
a2253 1
  int TBSCALEY = ( (rc.bottom - rc.top )/2)-IBLSCALE(30);
d2266 1
a2266 1
      hstart = StartMaxHeight+DerivedDrawInfo.TerrainAlt;
d2268 1
a2268 1
      hstart = StartMaxHeight;
d2276 1
a2276 1
	lkvariooffset=rc.left + LKVarioBar?(LKVarioSize+1):0; // 091118
d2345 1
a2345 2
	/// (iround((Wt[i]/Wmax)*IBLSCALE(TBSCALEX)))+rc.left; REMOVE
	(iround((Wt[i]/Wmax)*IBLSCALE(TBSCALEX)))+lkvariooffset; // 091118
d2348 1
a2348 1
	IBLSCALE(4)+iround(TBSCALEY*(1.0-ht[i]))+rc.top;
a2349 1
    /// ThermalProfile[0].x = rc.left; REMOVE
d2352 1
a2352 2
    // ThermalProfile[numtherm+1].x = rc.left; REMOVE
    ThermalProfile[numtherm+1].x = lkvariooffset; // 091118
d2362 1
a2362 1
  GliderBand[0].y = IBLSCALE(4)+iround(TBSCALEY*(1.0-hglider))+rc.top;
d2364 1
a2364 1
  GliderBand[1].x = max(iround((mc/Wmax)*IBLSCALE(TBSCALEX)),IBLSCALE(4)) +lkvariooffset; // 091118 rc.left
d2366 2
a2367 2
  GliderBand[2].x = GliderBand[1].x-IBLSCALE(4);
  GliderBand[2].y = GliderBand[0].y-IBLSCALE(4);
d2370 2
a2371 2
  GliderBand[4].x = GliderBand[1].x-IBLSCALE(4);
  GliderBand[4].y = GliderBand[0].y+IBLSCALE(4);
d2380 1
a2380 1
    GliderBand[0].y = IBLSCALE(4)+iround(TBSCALEY*(1.0-hstart))+rc.top;
d2393 1
a2393 8
  /*
   * VENTA NEWMAP draw finalglide bar mode:
   * - When in Final glide
   * - Only to Next Turnpoint
   * - Never
   */

    SIZE           TextSize;
d2395 1
a2395 1
   if (NewMap&&(GlideBarMode == (GlideBarMode_t)gbDisabled)) {
d2398 1
a2398 12
   }
  // if (DerivedDrawInfo.FinalGlide == 0 ) return; 

  /*
  POINT Scale[18] = {
    {5,-50 }, {14,-60 }, {23, -50},
    {5,-40 }, {14,-50 }, {23, -40},
    {5,-30 }, {14,-40 }, {23, -30},
    {5,-20 }, {14,-30 }, {23, -20},
    {5,-10 }, {14,-20 }, {23, -10},
    {5, 0  }, {14,-10 }, {23,   0},
  };*/
d2413 2
a2414 2
  if (Look8000&&IsMapFullScreen()&&LKVarioBar) // 091115
	lkVarioOffset=LKVarioSize+IBLSCALE(2); // 091114
d2420 1
d2439 7
a2445 2
    if (ValidTaskPoint(ActiveWayPoint)){
    // if (ActiveWayPoint >= 0) {
d2447 15
a2461 1
      const int y0 = ( (rc.bottom - rc.top )/2)+rc.top;
d2463 7
a2469 17
      // 60 units is size, div by 8 means 60*8 = 480 meters.
  	 if ( (GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
	      Offset = ((int)DerivedDrawInfo.TaskAltitudeDifference)/8; 
	      Offset0 = ((int)DerivedDrawInfo.TaskAltitudeDifference0)/8; 
         } else {
	      Offset = ((int)DerivedDrawInfo.NextAltitudeDifference)/8; 
	      Offset0 = ((int)DerivedDrawInfo.NextAltitudeDifference0)/8; 
         }
      // TODO feature: should be an angle if in final glide mode

      // if(Offset > 60) Offset = 60;  091114 all 60 changed to 50
      if(Offset > maxBar) Offset = maxBar;
      if(Offset < minBar) Offset = minBar;
      Offset = IBLSCALE(Offset);
      if(Offset<0) {
        GlideBar[1].y = IBLSCALE(9);
      }
d2471 31
a2501 35
      if(Offset0 > maxBar) Offset0 = maxBar;
      if(Offset0 < minBar) Offset0 = minBar;
      Offset0 = IBLSCALE(Offset0);
      if(Offset0<0) {
        GlideBar0[1].y = IBLSCALE(9);
      }
      
      for(i=0;i<6;i++)
        {
          GlideBar[i].y += y0;
	  // if vario activated
          GlideBar[i].x = IBLSCALE(GlideBar[i].x)+rc.left+lkVarioOffset; // 091114
        }
      GlideBar[0].y -= Offset;
      GlideBar[1].y -= Offset;
      GlideBar[2].y -= Offset;

      for(i=0;i<6;i++)
        {
          GlideBar0[i].y += y0;
          GlideBar0[i].x = IBLSCALE(GlideBar0[i].x)+rc.left+lkVarioOffset; // 091114
        }
      GlideBar0[0].y -= Offset0;
      GlideBar0[1].y -= Offset0;
      GlideBar0[2].y -= Offset0;

      if ((Offset<0)&&(Offset0<0)) {
        // both below
        if (Offset0!= Offset) {
          int dy = (GlideBar0[0].y-GlideBar[0].y)
            +(GlideBar0[0].y-GlideBar0[3].y);
          dy = max(IBLSCALE(3), dy);
          GlideBar[3].y = GlideBar0[0].y-dy;
          GlideBar[4].y = GlideBar0[1].y-dy;
          GlideBar[5].y = GlideBar0[2].y-dy;
d2503 6
a2508 6
          GlideBar0[0].y = GlideBar[3].y;
          GlideBar0[1].y = GlideBar[4].y;
          GlideBar0[2].y = GlideBar[5].y;
        } else {
          Offset0 = 0;
        }
d2510 24
a2533 72
      } else if ((Offset>0)&&(Offset0>0)) {
        // both above
        GlideBar0[3].y = GlideBar[0].y;
        GlideBar0[4].y = GlideBar[1].y;
        GlideBar0[5].y = GlideBar[2].y;

        if (abs(Offset0-Offset)<IBLSCALE(4)) {
          Offset= Offset0;
        } 
      }

      // draw actual glide bar
      if (Offset<=0) {
        if (LandableReachable) {
          hpOld = (HPEN)SelectObject(hDC, hpFinalGlideBelowLandable);
          hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideBelowLandable);
        } else {
          hpOld = (HPEN)SelectObject(hDC, hpFinalGlideBelow);
          hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideBelow);
        }
      } else {
        hpOld = (HPEN)SelectObject(hDC, hpFinalGlideAbove);
        hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideAbove);
      }
      Polygon(hDC,GlideBar,6);

      // draw glide bar at mc 0
      if (Offset0<=0) {
        if (LandableReachable) {
          SelectObject(hDC, hpFinalGlideBelowLandable);
          SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
        } else {
          SelectObject(hDC, hpFinalGlideBelow);
          SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
        }
      } else {
        SelectObject(hDC, hpFinalGlideAbove);
        SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
      }
      if (Offset!=Offset0) {
        Polygon(hDC,GlideBar0,6);
      }

      // JMW draw x on final glide bar if unreachable at current Mc
      // hpAircraftBorder
      // VNT: this is not clear. should tell user in another way

   if ( (GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
      if ((DerivedDrawInfo.TaskTimeToGo>0.9*ERROR_TIME)
	  || ((MACCREADY<0.01) && (DerivedDrawInfo.TaskAltitudeDifference<0))) {
	SelectObject(hDC, hpAircraftBorder);
	POINT Cross[4] = { {-5, -5},
			   { 5,  5},
			   {-5,  5},
			   { 5, -5} };
	for (i=0; i<4; i++) {
	  Cross[i].x = IBLSCALE(Cross[i].x+9)+lkVarioOffset; // 091114
	  Cross[i].y = IBLSCALE(Cross[i].y+9)+y0;
	}
        Polygon(hDC,Cross,2);
        Polygon(hDC,&Cross[2],2);
      }
     } else {
      if ((MACCREADY<0.01) && (DerivedDrawInfo.NextAltitudeDifference<0)) {
	SelectObject(hDC, hpAircraftBorder);
	POINT Cross[4] = { {-5, -5},
			   { 5,  5},
			   {-5,  5},
			   { 5, -5} };
	for (i=0; i<4; i++) {
	  Cross[i].x = IBLSCALE(Cross[i].x+9)+lkVarioOffset;
	  Cross[i].y = IBLSCALE(Cross[i].y+9)+y0;
d2535 1
a2535 3
        Polygon(hDC,Cross,2);
        Polygon(hDC,&Cross[2],2);
      }
d2537 18
d2556 2
d2559 25
a2583 1
     }
d2588 12
a2599 5
		if ((GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
			if ( (ALTITUDEMODIFY*DerivedDrawInfo.TaskAltitudeDifference) <ALTDIFFLIMIT) // 091114
				_stprintf(Value,TEXT(" --- "));
			else
				_stprintf(Value,TEXT("%1.0f "), ALTITUDEMODIFY*DerivedDrawInfo.TaskAltitudeDifference);
d2601 1
a2601 1
			if ( (ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference) < ALTDIFFLIMIT) // 091114
d2604 1
a2604 1
				_stprintf(Value,TEXT("%1.0f "), ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
d2608 1
a2608 1
			Offset = GlideBar[2].y+Offset+IBLSCALE(5);
d2611 1
a2611 1
				Offset = GlideBar0[1].y-IBLSCALE(15);
d2613 1
a2613 1
				Offset = GlideBar[2].y+Offset-IBLSCALE(15);
d2618 1
a2618 1
		GlideBarOffset=max(IBLSCALE(11),TextSize.cx) - IBLSCALE(2);
d2622 1
a2622 1
		TextInBox(hDC, Value, lkVarioOffset+IBLSCALE(1), (int)Offset, 0, TextInBoxMode); // 091114
d2633 1
a2633 1
			int x = GlideBar[2].x+IBLSCALE(1);
d2649 1
a2649 1
			Rectangle(hDC, x, y, x+IBLSCALE(1)+TextSize.cx, y+Appearance.MapWindowBoldFont.CapitalHeight+IBLSCALE(2));
d2651 2
a2652 2
			ExtTextOut(hDC, x+IBLSCALE(1), y+Appearance.MapWindowBoldFont.CapitalHeight
				 -Appearance.MapWindowBoldFont.AscentHeight+IBLSCALE(1), 0, NULL, Value, _tcslen(Value), NULL);
d2656 1
a2656 1
				DrawBitmapX(hDC, x+TextSize.cx+IBLSCALE(1), y, BmpSize.x, BmpSize.y, hDCTemp, BmpPos.x, BmpPos.y, SRCCOPY);
d2685 2
a2686 2
	    Start.y = IBLSCALE(19)+rc.top;
	    Start.x = rc.right - IBLSCALE(19);
d2725 5
d2731 2
a2732 2
	      Start.y = rc.top + IBLSCALE(11); 
	      Start.x = rc.right - IBLSCALE(11);
d2734 3
a2736 3
		if (MapWindow::IsMapFullScreen() && (Look8000==(Look8000_t)lxcAdvanced) ) {  // VENTA10 bugfix QUI 
		      Start.y = rc.top + IBLSCALE(35); 
		      Start.x = rc.right - IBLSCALE(11);
d2738 2
a2739 2
		      Start.y = rc.top + IBLSCALE(11);
		      Start.x = rc.right - IBLSCALE(11);
d2742 1
d2894 1
d2936 1
a2936 1
    COLORREF whitecolor = RGB(0xd0,0xd0, 0xd0);
d2938 2
a2939 1
    COLORREF origcolor = SetTextColor(hDC, whitecolor);
d2948 7
a2954 3
    Start.x = rc.right-IBLSCALE(6); End.x = rc.right-IBLSCALE(6);
     Start.y = rc.bottom-IBLSCALE(42); End.y = Start.y - IBLSCALE(42);
    //Start.y = rc.bottom-IBLSCALE(42); End.y = Start.y - IBLSCALE(30); // 091116 BUGFIX MapScale ok
d2957 1
a2957 1
    Start.x = rc.right-IBLSCALE(11); End.x = rc.right-IBLSCALE(6);
d2961 2
a2962 2
     Start.y = Start.y - IBLSCALE(42); End.y = Start.y;
    //Start.y = Start.y - IBLSCALE(30); End.y = Start.y; // 091116 BUGFIX MapScale NO we keep same scale, and change value 091117
d2969 3
d2979 1
a2979 1
      _tcscat(Scale2,TEXT(" AUX"));
d2985 1
a2985 1
      			_tcscat(Scale2,TEXT(" TRM"));
d2988 4
a2991 1
      			_tcscat(Scale2,TEXT(" CRU"));
d2994 1
a2994 1
      			_tcscat(Scale2,TEXT(" AUX"));
d2997 4
a3000 1
      			_tcscat(Scale2,TEXT(" TSK"));
d3003 4
a3006 1
      			_tcscat(Scale2,TEXT(" SYS"));
d3008 2
a3009 2
		case BM_ALT:
      			_tcscat(Scale2,TEXT(" ALT"));
d3012 1
a3012 1
      			_tcscat(Scale2,TEXT(" CUS"));
d3023 1
a3023 1
      _stprintf(TEMP,TEXT(" BALLAST %3.0f LITERS"), WEIGHTS[2]*BALLAST);
d3026 1
d3069 1
d3077 1
a3077 3
    ///: TextInBox(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7), 0, TextDisplayMode,false); OLD REMOVE
    LKWriteText(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 
    ///: LKWriteText(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(4), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); wrong with system font! 091117
d3080 4
a3083 3
    ///: TextInBox(hDC,   Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7)+tsize.cy, 0, TextDisplayMode,false); OLD REMOVE
    LKWriteText(hDC, Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7)+tsize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 
    ///:LKWriteText(hDC, Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(4)+tsize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); wrong with system font! 091117
d3099 1
d3135 1
a3135 1
              TextSize.cx + IBLSCALE(21), rc.bottom);
d3143 2
a3144 2
    ExtTextOut(hDC, IBLSCALE(7), 
           rc.bottom-Appearance.MapWindowBoldFont.AscentHeight-IBLSCALE(1), 
d3151 1
a3151 1
           IBLSCALE(14)+TextSize.cx, 
d3162 1
a3162 1
                    IBLSCALE(8)+TextSize.cx, rc.bottom-Height, 
d3170 1
a3170 1
      (Appearance.TitleWindowFont.AscentHeight+IBLSCALE(2));
d3202 1
a3202 1
        ExtTextOut(hDC, IBLSCALE(1), y, 0, NULL, ScaleInfo, 
d3204 1
a3204 1
        y -= (Appearance.TitleWindowFont.CapitalHeight+IBLSCALE(1));
d3225 1
d3229 1
a3229 1

d3239 1
a3239 1
  bool wrotevalue=false; // 091215
d3250 1
a3250 1
  SelectObject(hDC,hpTerrainLineBg);
d3254 1
a3254 1
  if ((FinalGlideTerrain==1) || ((!EnableTerrain || !DerivedDrawInfo.Flying) && (FinalGlideTerrain==2))) {
d3260 1
d3263 2
a3264 1
  if ( ValidTaskPoint(ActiveWayPoint) )  // 091215
d3266 2
a3267 1
  if (DerivedDrawInfo.Flying && ValidTaskPoint(ActiveWayPoint)) // 091215
d3292 1
a3292 1
					TextInBox(hDC,hbuf,sc.x+IBLSCALE(15), sc.y, 0, tmode,false); 
d3298 1
a3298 1
				TextInBox(hDC,hbuf,sc.x+IBLSCALE(15), sc.y, 0, tmode,false); 
d3309 2
a3310 1
				DerivedDrawInfo.TerrainWarningLongitude));
d3313 1
a3313 1
			TextInBox(hDC,hbuf,sc.x+IBLSCALE(10), sc.y, 0, tmode,false); 
d3320 1
a3320 1
				TextInBox(hDC,hbuf,sc.x+IBLSCALE(15), sc.y, 0, tmode,false); 
d3327 2
a3328 2
				if ( (fabs(DerivedDrawInfo.FarObstacle_Lon - DerivedDrawInfo.TerrainWarningLongitude) >0.01) &&
					(fabs(DerivedDrawInfo.FarObstacle_Lat - DerivedDrawInfo.TerrainWarningLatitude) >0.01)) {
d3334 1
a3334 1
						TextInBox(hDC,hbuf,sc.x+IBLSCALE(15), sc.y, 0, tmode,false); 
d3339 3
d3346 1
a3346 1
					TextInBox(hDC,hbuf,sc.x+IBLSCALE(15), sc.y, 0, tmode,false); 
@


8.12
log
@*** empty log message ***
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.11 2009/11/18 17:26:56 root Exp root $
d94 1
a94 1

d984 2
d1005 1
d1427 1
d1698 2
d1737 1
d1766 2
a1767 2
    targetLat = WayPointList[Task[ActiveWayPoint].Index].Latitude;
    targetLon = WayPointList[Task[ActiveWayPoint].Index].Longitude; 
d2231 1
d3004 1
a3004 1
///: Shaded line is displayed only when in flight, otherwise only a dashed line is used
d3008 12
d3032 10
a3041 3
  ///: draw a red cross if destination in unreacchable
  if (DerivedDrawInfo.Flying && ValidTaskPoint(ActiveWayPoint)) {
	///: 091123 only draw if apparently destination is reachable DISABLED
d3043 3
d3047 26
a3072 1
		POINT sc;
d3076 43
a3118 3
		}
	}
  }
d3139 6
@


8.11
log
@*** empty log message ***
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.10 2009/11/17 21:57:42 root Exp root $
a983 1

d1006 2
d1158 1
d2052 7
d2114 1
d2119 2
a2120 1
  
d2124 2
a2125 1
	(iround((Wt[i]/Wmax)*IBLSCALE(TBSCALEX)))+rc.left;
d2130 2
a2131 1
    ThermalProfile[0].x = rc.left;
d2133 2
a2134 1
    ThermalProfile[numtherm+1].x = rc.left;
d2143 1
d2146 1
a2146 2
  GliderBand[1].x = max(iround((mc/Wmax)*IBLSCALE(TBSCALEX)),IBLSCALE(4))
    +rc.left;
d2458 1
a2458 1
    }
d2995 2
d3000 1
a3000 2
  hpOld = (HPEN)SelectObject(hDC, 
                             hpTerrainLineBg);  //sjt 02feb06 added bg line
d3002 1
d3005 5
a3009 4
  if ((FinalGlideTerrain==1) || 
      ((!EnableTerrain || !DerivedDrawInfo.Flying) && (FinalGlideTerrain==2))) {
    SelectObject(hDC,hpTerrainLine);
    _Polyline(hDC,Groundline,NUMTERRAINSWEEPS+1, rc);
d3012 1
d3014 9
a3022 11
    if ((DerivedDrawInfo.TerrainWarningLatitude != 0.0)
        &&(DerivedDrawInfo.TerrainWarningLongitude != 0.0)) {
      
      POINT sc;
      if (PointVisible(DerivedDrawInfo.TerrainWarningLongitude,
                       DerivedDrawInfo.TerrainWarningLatitude)) {
        LatLon2Screen(DerivedDrawInfo.TerrainWarningLongitude,
                      DerivedDrawInfo.TerrainWarningLatitude, sc);
        DrawBitmapIn(hDC, sc, hTerrainWarning);
      }
    }
d3026 1
a3027 1
}
@


8.10
log
@*** empty log message ***
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.9 2009/11/14 01:07:44 root Exp root $
a2714 13
    // Apparently not used, so I am changing IBLSCALE(30) to 42 for NewMap
    // I'll make this mode more readable for PNA later

/* 
    ///: 091116  unused. removable TODO REMOVE
    double hMapScale;
    if (ScaleChangeFeedback)
	hMapScale = (RequestMapScale * rc.right)/DISTANCEMODIFY/GetMapResolutionFactor();
    else
	hMapScale = (MapScale * rc.right)/DISTANCEMODIFY/GetMapResolutionFactor();
    ///Units::FormatUserMapScale(&Unit, MapWidth, ScaleInfo, sizeof(ScaleInfo)/sizeof(TCHAR));
*/

d2719 2
a2720 2
    // Start.y = rc.bottom-IBLSCALE(42); End.y = Start.y - IBLSCALE(42);
    Start.y = rc.bottom-IBLSCALE(42); End.y = Start.y - IBLSCALE(30); // 091116 BUGFIX MapScale
d2727 2
a2728 2
    // Start.y = Start.y - IBLSCALE(42); End.y = Start.y;
    Start.y = Start.y - IBLSCALE(30); End.y = Start.y; // 091116 BUGFIX MapScale
d2788 1
d2790 2
a2791 2
	if ((MapScale) <1.0) {
		_stprintf(Scale,TEXT("%1.0f"),MapScale*1000);
d2795 1
a2795 1
		_stprintf(Scale,TEXT("%1.1f"),MapScale);
d2799 1
a2799 1
		_stprintf(Scale,TEXT("%1.0f"),MapScale);
d2803 1
a2803 1
	if (MapScale <0.1)
d2805 1
a2805 1
		_stprintf(Scale,TEXT("%1.2f"),MapScale);
d2807 1
a2807 1
	else if(MapScale <3)
d2809 1
a2809 1
		_stprintf(Scale,TEXT("%1.1f"),MapScale);
d2813 1
a2813 1
		_stprintf(Scale,TEXT("%1.0f"),MapScale);
d2830 2
a2831 2
    ///: LKWriteText(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 091116
    LKWriteText(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(4), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d2835 2
a2836 2
    ///: LKWriteText(hDC, Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7)+tsize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 091116
    LKWriteText(hDC, Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(4)+tsize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
@


8.9
log
@*** empty log message ***
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.8 2009/10/20 22:41:25 root Exp root $
d2157 1
a2157 1

d2186 2
a2187 4
  POINT GlideBar[6] =
    { {0,0},{9,-9},{18,0},{18,0},{9,0},{0,0} };
  POINT GlideBar0[6] =
    { {0,0},{9,-9},{18,0},{18,0},{9,0},{0,0} };
d2197 20
d2238 3
a2240 2
      if(Offset > 60) Offset = 60;
      if(Offset < -60) Offset = -60;
d2246 2
a2247 2
      if(Offset0 > 60) Offset0 = 60;
      if(Offset0 < -60) Offset0 = -60;
d2256 2
a2257 1
          GlideBar[i].x = IBLSCALE(GlideBar[i].x)+rc.left;
d2266 1
a2266 1
          GlideBar0[i].x = IBLSCALE(GlideBar0[i].x)+rc.left;
d2345 1
a2345 1
	  Cross[i].x = IBLSCALE(Cross[i].x+9);
d2359 1
a2359 1
	  Cross[i].x = IBLSCALE(Cross[i].x+9);
d2370 2
a2371 1
      if (Appearance.IndFinalGlide == fgFinalGlideDefault){
d2373 11
a2383 7
   if ((GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
        _stprintf(Value,TEXT("%1.0f "), 
                  ALTITUDEMODIFY*DerivedDrawInfo.TaskAltitudeDifference);
      } else {
        _stprintf(Value,TEXT("%1.0f "), 
                  ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
      }
d2385 12
a2396 12
        if (Offset>=0) {
          Offset = GlideBar[2].y+Offset+IBLSCALE(5);
        } else {
          if (Offset0>0) {
            Offset = GlideBar0[1].y-IBLSCALE(15);
          } else {
            Offset = GlideBar[2].y+Offset-IBLSCALE(15);
          }
        }
	// VENTA10
	GetTextExtentPoint(hDC, Value, _tcslen(Value), &TextSize); 
	GlideBarOffset=max(IBLSCALE(11),TextSize.cx) - IBLSCALE(2);
d2398 3
a2400 2
        TextInBoxMode_t TextInBoxMode = {1|8};
        TextInBox(hDC, Value, 0, (int)Offset, 0, TextInBoxMode);
a2401 17
      } else
	// VENTA10: TODO no need to keep this option configurable. too many configs already!
        if (Appearance.IndFinalGlide == fgFinalGlideAltA){

          ///: SIZE  TextSize; // 091007 BUGFIX
          HFONT oldFont;
          int y = GlideBar[3].y;
          // was ((rc.bottom - rc.top )/2)-rc.top-
          //            Appearance.MapWindowBoldFont.CapitalHeight/2-1;
          int x = GlideBar[2].x+IBLSCALE(1);
          HBITMAP Bmp;
          POINT  BmpPos;
          POINT  BmpSize;

   if ((GlideBarMode == (GlideBarMode_t)gbFinish)||!NewMap) {
          _stprintf(Value, TEXT("%1.0f"), 
                    Units::ToUserAltitude(DerivedDrawInfo.TaskAltitudeDifference));
d2403 18
a2420 3
          _stprintf(Value, TEXT("%1.0f"), 
                    Units::ToUserAltitude(DerivedDrawInfo.NextAltitudeDifference));
	}
d2422 2
a2423 2
          oldFont = (HFONT)SelectObject(hDC, MapWindowBoldFont);
          GetTextExtentPoint(hDC, Value, _tcslen(Value), &TextSize);
d2425 3
a2427 5
          SelectObject(hDC, GetStockObject(WHITE_BRUSH));
          SelectObject(hDC, GetStockObject(WHITE_PEN));
          Rectangle(hDC, x, y, 
                    x+IBLSCALE(1)+TextSize.cx, 
                    y+Appearance.MapWindowBoldFont.CapitalHeight+IBLSCALE(2));
d2429 2
a2430 4
          ExtTextOut(hDC, x+IBLSCALE(1), 
                     y+Appearance.MapWindowBoldFont.CapitalHeight
                     -Appearance.MapWindowBoldFont.AscentHeight+IBLSCALE(1), 
                     0, NULL, Value, _tcslen(Value), NULL);
d2432 5
a2436 6
          if (Units::GetUnitBitmap(Units::GetUserAltitudeUnit(), &Bmp, &BmpPos, &BmpSize, 0)){
            HBITMAP oldBitMap = (HBITMAP)SelectObject(hDCTemp, Bmp);
            DrawBitmapX(hDC, x+TextSize.cx+IBLSCALE(1), y, BmpSize.x, BmpSize.y, 
                        hDCTemp, BmpPos.x, BmpPos.y, SRCCOPY);
            SelectObject(hDCTemp, oldBitMap);
          }
d2438 1
a2438 1
          SelectObject(hDC, oldFont);
d2440 4
a2443 4
        }

      SelectObject(hDC, hbOld);
      SelectObject(hDC, hpOld);
d2718 11
d2732 2
a2733 1
    Start.y = rc.bottom-IBLSCALE(42); End.y = Start.y - IBLSCALE(42);
d2740 2
a2741 1
    Start.y = Start.y - IBLSCALE(42); End.y = Start.y;
d2841 3
a2843 2
    //TextInBox(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7), 0, TextDisplayMode,false);
    LKWriteText(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d2846 3
a2848 2
    //TextInBox(hDC,   Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7)+tsize.cy, 0, TextDisplayMode,false);
    LKWriteText(hDC, Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7)+tsize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d2888 1
a2888 2
    Units::FormatUserMapScale(&Unit, MapWidth, ScaleInfo, 
                              sizeof(ScaleInfo)/sizeof(TCHAR));
@


8.8
log
@1.14b
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.7 2009/10/04 22:20:34 root Exp root $
d386 2
a387 3
        TextInBox(hDC, DrawInfo.FLARM_Traffic[i].Name, sc.x+IBLSCALE(3),
                  sc.y, 0, displaymode, 
                  true);
a459 1

d2810 1
a2810 1
    LKWriteText(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE);
d2814 1
a2814 1
    LKWriteText(hDC, Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7)+tsize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE);
@


8.7
log
@pre safetyaltitude
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.6 2009/09/22 12:56:28 root Exp root $
d93 2
d454 2
a455 1
	  HPEN hpOld = (HPEN)SelectObject(hDC, hSnailPens[colourIndex]);
d468 3
a470 1
	  SelectObject(hDC, hpOld);
d1044 5
a1048 1
	dtmp=DerivedDrawInfo.NavAltitude - SAFETYALTITUDEARRIVAL - WayPointList[i].Altitude;
a1065 2
      AltitudeRequired = AltitudeRequired + SAFETYALTITUDEARRIVAL 
	+ WayPointList[i].Altitude ;
d1067 6
a1072 1
      WayPointCalc[i].AltReqd = AltitudeRequired; // VENTA6
d1127 6
a1132 2
                  AltitudeRequired = AltitudeRequired + SAFETYALTITUDEARRIVAL 
                    + WayPointList[i].Altitude ;
d1136 1
a1136 1
      WayPointCalc[i].AltReqd = AltitudeRequired; // VENTA6
d2382 1
a2382 1
          SIZE  TextSize;
d2691 1
a2691 1
    COLORREF blackcolor = RGB(0x20,0x20, 0x20);
d2771 27
a2797 11
    if(MapScale <0.1)
    {
      _stprintf(Scale,TEXT("%1.2f"),MapScale);
    }
    else if(MapScale <3)
    {
      _stprintf(Scale,TEXT("%1.1f"),MapScale);
    }
    else
    {
      _stprintf(Scale,TEXT("%1.0f"),MapScale);
a2798 1
    _tcscat(Scale, Units::GetDistanceName()); 
@


8.6
log
@pre clean
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.5 2009/09/02 20:51:17 root Exp root $
d48 1
d1003 1
d2780 2
a2781 1
    TextInBox(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7), 0, TextDisplayMode,false);
d2784 2
a2785 1
    TextInBox(hDC, Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7)+tsize.cy, 0, TextDisplayMode,false);
@


8.5
log
@progress
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.4 2009/06/28 21:31:31 root Exp $
d47 2
d73 1
d2712 1
a2712 1
		case 0:
d2715 1
a2715 1
		case 1:
d2718 1
a2718 1
		case 2:
d2721 1
a2721 1
		case 3:
d2724 1
a2724 1
		case 4:
d2727 1
a2727 1
		case 5:
d2730 3
d3006 1
@


8.4
log
@ok
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.3 2009/06/27 17:19:04 root Exp root $
d528 1
d1138 1
a1138 2


d1185 9
a1193 9
  /*
  a1.x = Start.x + fastsine(alpha1)*radius;
  a1.y = Start.y - fastcosine(alpha1)*radius;
  a2.x = Start.x + fastsine(alpha2)*radius;
  a2.y = Start.y - fastcosine(alpha2)*radius;

  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
            a1, a2, RGB(0,0,0));
  */
d1247 1
a1247 2


a1306 1

d1778 32
a1809 9
      brect.left = sc.x-4;
      brect.right = brect.left+tsize.cx+4;
      brect.top = sc.y-4;
      brect.bottom = brect.top+tsize.cy+4;

      if (checkLabelBlock(brect)) {
	ExtTextOut(hdc, sc.x-tsize.cx/2, sc.y-tsize.cy/2, 
		   0, NULL, Buffer, size, NULL);
	ilast = idist;
d1880 1
a1880 1
  if ((ActiveWayPoint<=0) || !ValidTaskPoint(ActiveWayPoint) || !AATEnabled) {
d2424 1
a2424 6
/*
    if (NewMap&&Look8000) {
	    Start.y = rc.bottom-IBLSCALE(19);
	    Start.x = rc.right - IBLSCALE(59);
    } else {
*/
a2426 1
//  }
d2447 1
a2447 1
    static int lastRcRight = 0;
d2451 2
a2452 1
    if (lastDisplayAngle != DisplayAngle || lastRcRight != rc.right){
d2464 4
a2467 4
/*
	if (NewMap&&Look8000) {
	      Start.y = rc.bottom - IBLSCALE(10);
	      Start.x = rc.right - IBLSCALE(51);
d2469 8
a2476 4
*/
	      Start.y = rc.top + IBLSCALE(10);
	      Start.x = rc.right - IBLSCALE(11);
//	}
d2488 1
d2674 1
a2674 1
    TextInBoxMode_t TextDisplayMode; // VENTA7
@


8.3
log
@ok
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 8.2 2009/06/24 10:04:10 root Exp root $
d2128 6
a2133 1
   if (NewMap&&(GlideBarMode == (GlideBarMode_t)gbDisabled)) return;
d2274 1
d2329 4
a2332 1
        
d2337 1
@


8.2
log
@*** empty log message ***
@
text
@d35 1
a35 1
  $Id: MapWindow2.cpp,v 1.48 2009/06/08 13:54:43 jwharington Exp $
a242 1

d2667 1
a2667 1
      _tcscat(Scale2,TEXT(" AZOOM"));
d2679 1
a2679 1
      			_tcscat(Scale2,TEXT(" THERMAL"));
@


8.1
log
@beta8
@
text
@d1 2969
a2969 2935
/*
Copyright_License {

  XCSoar Glide Computer - http://xcsoar.sourceforge.net/
  Copyright (C) 2000 - 2008  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

}
*/

#include "StdAfx.h"
#include "compatibility.h"
#include "options.h"
#include "Defines.h"

#include "MapWindow.h"
#include "OnLineContest.h"
#include "Utils.h"
#include "Units.h"
#include "Logger.h"
#include "McReady.h"
#include "Airspace.h"
#include "Waypointparser.h"
#include "Dialogs.h"
#include "externs.h"
#include "VarioSound.h"
#include "InputEvents.h"
// #include <assert.h>
#include <windows.h>
#include <math.h>

#include <tchar.h>

#include "Task.h"

#include "Terrain.h"
#include "RasterTerrain.h"

#include "GaugeVarioAltA.h"
#include "GaugeCDI.h"
#include "GaugeFLARM.h"
#include "InfoBoxLayout.h"

#if (WINDOWSPC>0)
#include <wingdi.h>
#endif

#ifdef DEBUG
#if (WINDOWSPC<1)
#define DRAWLOAD
extern HFONT  MapWindowFont;
extern int timestats_av;
extern int misc_tick_count;
#endif
#endif

extern HWND hWndCDIWindow;
extern HFONT MapLabelFont;
extern HFONT  MapWindowBoldFont;


void MapWindow::DrawCDI() {
  bool dodrawcdi = false;

  if (DerivedDrawInfo.Circling) {
    if (EnableCDICircling) {
      dodrawcdi = true;
    }
  } else {
    if (EnableCDICruise) {
      dodrawcdi = true;
    }    
  }

  if (dodrawcdi) {
    ShowWindow(hWndCDIWindow, SW_SHOW);
    
    // JMW changed layout here to fit reorganised display
    // insert waypoint bearing ".<|>." into CDIScale string"
    
    TCHAR CDIScale[] = TEXT("330..340..350..000..010..020..030..040..050..060..070..080..090..100..110..120..130..140..150..160..170..180..190..200..210..220..230..240..250..260..270..280..290..300..310..320..330..340..350..000..010..020..030..040.");
    TCHAR CDIDisplay[25] = TEXT("");
    int j;
    int CDI_WP_Bearing = (int)DerivedDrawInfo.WaypointBearing/2;
    CDIScale[CDI_WP_Bearing + 9] = 46;
    CDIScale[CDI_WP_Bearing + 10] = 60;
    CDIScale[CDI_WP_Bearing + 11] = 124; // "|" character
    CDIScale[CDI_WP_Bearing + 12] = 62; 
    CDIScale[CDI_WP_Bearing + 13] = 46;
    for (j=0;j<24;j++) CDIDisplay[j] = CDIScale[(j + (int)(DrawInfo.TrackBearing)/2)];
    CDIDisplay[24] = _T('\0');
    // JMW fix bug! This indicator doesn't always display correctly!
    
    // JMW added arrows at end of CDI to point to track if way off..
    int deltacdi = iround(DerivedDrawInfo.WaypointBearing-DrawInfo.TrackBearing);
    
    while (deltacdi>180) {
      deltacdi-= 360;
    }
    while (deltacdi<-180) {
      deltacdi+= 360;
    }
    if (deltacdi>20) {
      CDIDisplay[21]='>';
      CDIDisplay[22]='>';
      CDIDisplay[23]='>';
    }
    if (deltacdi<-20) {
      CDIDisplay[0]='<';
      CDIDisplay[1]='<';
      CDIDisplay[2]='<';
    }
    
    SetWindowText(hWndCDIWindow,CDIDisplay);
    // end of new code to display CDI scale
  } else {
    ShowWindow(hWndCDIWindow, SW_HIDE);
  }
}



double MapWindow::findMapScaleBarSize(const RECT rc) {

  int range = rc.bottom-rc.top;
//  int nbars = 0;
//  int nscale = 1;
  double pixelsize = MapScale/GetMapResolutionFactor(); // km/pixel
  
  // find largest bar size that will fit in display

  double displaysize = range*pixelsize/2; // km

  if (displaysize>100.0) {
    return 100.0/pixelsize;
  }
  if (displaysize>10.0) {
    return 10.0/pixelsize;
  }
  if (displaysize>1.0) {
    return 1.0/pixelsize;
  }
  if (displaysize>0.1) {
    return 0.1/pixelsize;
  }
  // this is as far as is reasonable
  return 0.1/pixelsize;
}


void MapWindow::DrawMapScale2(HDC hDC, const RECT rc, 
			      const POINT Orig_Aircraft)
{
  if (Appearance.MapScale2 == apMs2None) return;

  HPEN hpOld   = (HPEN)SelectObject(hDC, hpMapScale);
  HPEN hpWhite = (HPEN)GetStockObject(WHITE_PEN);
  HPEN hpBlack = (HPEN)GetStockObject(BLACK_PEN);

  bool color = false;
  POINT Start, End={0,0};
  bool first=true;

  int barsize = iround(findMapScaleBarSize(rc));

  Start.x = rc.right-1;
  for (Start.y=Orig_Aircraft.y; Start.y<rc.bottom+barsize; Start.y+= barsize) {
    if (color) {
      SelectObject(hDC, hpWhite);
    } else {
      SelectObject(hDC, hpBlack);
    }
    if (!first) {
      DrawSolidLine(hDC,Start,End, rc);
    } else {
      first=false;
    }
    End = Start;
    color = !color;
  }

  color = true;
  first = true;
  for (Start.y=Orig_Aircraft.y; Start.y>rc.top-barsize; Start.y-= barsize) {
    if (color) {
      SelectObject(hDC, hpWhite);
    } else {
      SelectObject(hDC, hpBlack);
    }
    if (!first) {
      DrawSolidLine(hDC,Start,End, rc);
    } else {
      first=false;
    }
    End = Start;
    color = !color;
  }

  // draw text as before
  
  SelectObject(hDC, hpOld);

}


/*
void MapWindow::DrawSpeedToFly(HDC hDC, RECT rc) {
  POINT chevron[3];

  HPEN hpOld;
  HBRUSH hbOld;

  //  TCHAR Value[10];
  int i;

  if (Appearance.DontShowSpeedToFly || !DerivedDrawInfo.Flying)
    return;

#ifndef _SIM_
  if (!(DrawInfo.AirspeedAvailable && DrawInfo.VarioAvailable)) {
    return;
  }
#else
  // cheat
  DrawInfo.IndicatedAirspeed = DrawInfo.Speed;
#endif

  hbOld = (HBRUSH)SelectObject(hDC, GetStockObject(WHITE_BRUSH));
  hpOld = (HPEN)SelectObject(hDC, hpBearing);

  double vdiff;
  int vsize = (rc.bottom-rc.top)/2;

  vdiff = (DerivedDrawInfo.VOpt - DrawInfo.IndicatedAirspeed)/40.0;
  // 25.0 m/s is maximum scale
  vdiff = max(-0.5,min(0.5,vdiff)); // limit it
  
  int yoffset=0;
  int hyoffset=0;
  vsize = iround(fabs(vdiff*vsize));
  int xoffset = rc.right-IBLSCALE(25);
  int ycenter = (rc.bottom+rc.top)/2;

  int k=0;

  for (k=0; k<2; k++) {

    for (i=0; i< vsize; i+= 5) {
      if (vdiff>0) {
        yoffset = i+ycenter+k;
        hyoffset = IBLSCALE(4);
      } else {
        yoffset = -i+ycenter-k;
        hyoffset = -IBLSCALE(4);
      }
      chevron[0].x = xoffset;
      chevron[0].y = yoffset;
      chevron[1].x = xoffset+IBLSCALE(10);
      chevron[1].y = yoffset+hyoffset;
      chevron[2].x = xoffset+IBLSCALE(20);
      chevron[2].y = yoffset;
      
      _Polyline(hDC, chevron, 3, rc);
    }
    if (vdiff>0) {
      hpOld = (HPEN)SelectObject(hDC, hpSpeedSlow);
    } else {
      hpOld = (HPEN)SelectObject(hDC, hpSpeedFast);
    }
  }

  SelectObject(hDC, hpBearing);
  chevron[0].x = xoffset-IBLSCALE(3);
  chevron[0].y = ycenter;
  chevron[1].x = xoffset+IBLSCALE(3+20);
  chevron[1].y = ycenter;
  _Polyline(hDC, chevron, 2, rc);
    
  SelectObject(hDC, hbOld);
  SelectObject(hDC, hpOld);

}
*/

#define fSnailColour(cv) max(0,min((short)(NUMSNAILCOLORS-1), (short)((cv+1.0)/2.0*NUMSNAILCOLORS)))

void MapWindow::DrawFLARMTraffic(HDC hDC, RECT rc, POINT Orig_Aircraft) {

  if (!EnableFLARMMap) return;

  if (!DrawInfo.FLARM_Available) return;

  HPEN hpOld;
  HPEN thinBlackPen = CreatePen(PS_SOLID, IBLSCALE(1), RGB(0,0,0));
  POINT Arrow[5];

  hpOld = (HPEN)SelectObject(hDC, thinBlackPen);

  int i;
//  double dX, dY;
  TextInBoxMode_t displaymode;
  displaymode.AsInt = 0;

  double screenrange = GetApproxScreenRange();
  double scalefact = screenrange/6000.0;

  HBRUSH redBrush = CreateSolidBrush(RGB(0xFF,0x00,0x00));
  HBRUSH yellowBrush = CreateSolidBrush(RGB(0xFF,0xFF,0x00));
  HBRUSH greenBrush = CreateSolidBrush(RGB(0x00,0xFF,0x00));

  for (i=0; i<FLARM_MAX_TRAFFIC; i++) {
    if (DrawInfo.FLARM_Traffic[i].ID!=0) {

      double target_lon;
      double target_lat;

      target_lon = DrawInfo.FLARM_Traffic[i].Longitude;
      target_lat = DrawInfo.FLARM_Traffic[i].Latitude;

      if ((EnableFLARMMap==2)&&(scalefact>1.0)) {
        double distance;
        double bearing;

        DistanceBearing(DrawInfo.Latitude,
                        DrawInfo.Longitude,
                        target_lat,
                        target_lon,
                        &distance,
                        &bearing);

        FindLatitudeLongitude(DrawInfo.Latitude, 
                              DrawInfo.Longitude, 
                              bearing,
                              distance*scalefact, 
                              &target_lat, 
                              &target_lon);

      }
      
      // TODO feature: draw direction, rel height?
      POINT sc, sc_name, sc_av;
      LatLon2Screen(target_lon, 
                    target_lat, 
                    sc);

      sc_name = sc;

      sc_name.y -= IBLSCALE(16);
      sc_av = sc_name;

#ifndef FLARM_AVERAGE
      if (DrawInfo.FLARM_Traffic[i].Name) {
        TextInBox(hDC, DrawInfo.FLARM_Traffic[i].Name, sc.x+IBLSCALE(3),
                  sc.y, 0, displaymode, 
                  true);
      }
#else
      TCHAR label_name[100];
      TCHAR label_avg[100];

      sc_av.x += IBLSCALE(3);

      if (DrawInfo.FLARM_Traffic[i].Name) {
	sc_name.y -= IBLSCALE(8);
	_stprintf(label_name, TEXT("%s"), DrawInfo.FLARM_Traffic[i].Name);
      } else {
	label_name[0]= _T('\0');
      }

      if (DrawInfo.FLARM_Traffic[i].Average30s>=0.1) {
	_stprintf(label_avg, TEXT("%.1f"), 
		  LIFTMODIFY*DrawInfo.FLARM_Traffic[i].Average30s);
      } else {
	label_avg[0]= _T('\0');
      }

#ifdef DEBUG
      // for testing only!
      _stprintf(label_avg, TEXT("2.3"));
      _stprintf(label_name, TEXT("WUE"));
#endif

      float vmax = (float)(1.5*min(5.0, max(MACCREADY,0.5)));
      float vmin = (float)(-1.5*min(5.0, max(MACCREADY,2.0)));
      
      float cv = DrawInfo.FLARM_Traffic[i].Average30s;
      if (cv<0) {
        cv /= (-vmin); // JMW fixed bug here
      } else {
        cv /= vmax;
      }
      
      int colourIndex = fSnailColour(cv);

      // JMW TODO enhancement: decluttering of FLARM altitudes (sort by max lift)

      int dx = (sc_av.x-Orig_Aircraft.x);
      int dy = (sc_av.y-Orig_Aircraft.y);

      if (dx*dx+dy*dy > IBLSCALE(30)*IBLSCALE(30)) {
	// only draw labels if not close to aircraft

	HGDIOBJ oldFont = SelectObject(hDC, MapLabelFont);	
	COLORREF oldTextColor = SetTextColor(hDC, RGB(0,0,0));

	if (_tcslen(label_name)>0) {
	  ExtTextOut(hDC, sc_name.x, sc_name.y, ETO_OPAQUE, NULL, label_name, _tcslen(label_name), NULL); 
	}

	if (_tcslen(label_avg)>0) {
	  int size = _tcslen(label_avg);
	  SIZE tsize;
	  RECT brect;

	  GetTextExtentPoint(hDC, label_avg, size, &tsize);
	  brect.left = sc_av.x-2;
	  brect.right = brect.left+tsize.cx+6;
	  brect.top = sc_av.y+((tsize.cy+4)>>3)-2;
	  brect.bottom = brect.top+3+tsize.cy-((tsize.cy+4)>>3);

	  HPEN hpOld = (HPEN)SelectObject(hDC, hSnailPens[colourIndex]);
	  HBRUSH hVarioBrush = CreateSolidBrush(hSnailColours[colourIndex]);
	  HBRUSH hbOld = (HBRUSH)SelectObject(hDC, hVarioBrush);

	  RoundRect(hDC, brect.left, brect.top, brect.right, brect.bottom, 
		    IBLSCALE(8), IBLSCALE(8));

#if (WINDOWSPC>0)
      SetBkMode(hDC,TRANSPARENT);
      ExtTextOut(hDC, sc_av.x, sc_av.y, 0, NULL, label_avg, size, NULL);
#else
      ExtTextOut(hDC, sc_av.x, sc_av.y, ETO_OPAQUE, NULL, label_avg, size, NULL);
#endif
	  SelectObject(hDC, hpOld);
	  SelectObject(hDC, hbOld);
	  DeleteObject(hVarioBrush);

	}

	SelectObject(hDC, oldFont);
	SetTextColor(hDC, oldTextColor);

      }

#endif
      if ((DrawInfo.FLARM_Traffic[i].AlarmLevel>0) 
	  && (DrawInfo.FLARM_Traffic[i].AlarmLevel<4)) {
	DrawBitmapIn(hDC, sc, hFLARMTraffic);
      }

      Arrow[0].x = -4;
      Arrow[0].y = 5;
      Arrow[1].x = 0;
      Arrow[1].y = -6;
      Arrow[2].x = 4;
      Arrow[2].y = 5;
      Arrow[3].x = 0;
      Arrow[3].y = 2;
      Arrow[4].x = -4;
      Arrow[4].y = 5;

      //      double vmag = max(1.0,min(15.0,DrawInfo.FLARM_Traffic[i].Speed/5.0))*2;

      switch (DrawInfo.FLARM_Traffic[i].AlarmLevel) {
      case 1:
	  SelectObject(hDC, yellowBrush);
	  break;
      case 2:
      case 3:
	  SelectObject(hDC, redBrush);
	  break;
      case 0:
      case 4:
	  SelectObject(hDC, greenBrush);
	  break;
      }

      PolygonRotateShift(Arrow, 5, sc.x, sc.y, 
                         DrawInfo.FLARM_Traffic[i].TrackBearing - DisplayAngle);
      Polygon(hDC,Arrow,5);

    }
  }

  SelectObject(hDC, hpOld);

  DeleteObject((HPEN)thinBlackPen);
  DeleteObject(greenBrush);
  DeleteObject(yellowBrush);
  DeleteObject(redBrush);

}


//////////////////////
// JMW added simple code to prevent text writing over map city names
int MapWindow::nLabelBlocks;
RECT MapWindow::LabelBlockCoords[MAXLABELBLOCKS];

bool MapWindow::checkLabelBlock(RECT rc) {
  bool ok = true;

  for (int i=0; i<nLabelBlocks; i++) {
    if (CheckRectOverlap(LabelBlockCoords[i],rc)) {
      ok = false;
      continue;
    }
  }
  if (nLabelBlocks<MAXLABELBLOCKS-1) {
    LabelBlockCoords[nLabelBlocks]= rc;
    nLabelBlocks++;
  }
  return ok;
}


rectObj MapWindow::CalculateScreenBounds(double scale) {
  // compute lat lon extents of visible screen
  rectObj sb;

  if (scale>= 1.0) {
    POINT screen_center;
    LatLon2Screen(PanLongitude, 
                  PanLatitude,
                  screen_center);
    
    sb.minx = sb.maxx = PanLongitude;
    sb.miny = sb.maxy = PanLatitude;
    
    int dx, dy;
    unsigned int maxsc=0;
    dx = screen_center.x-MapRect.right;
    dy = screen_center.y-MapRect.top;
    maxsc = max(maxsc, isqrt4(dx*dx+dy*dy));
    dx = screen_center.x-MapRect.left;
    dy = screen_center.y-MapRect.top;
    maxsc = max(maxsc, isqrt4(dx*dx+dy*dy));
    dx = screen_center.x-MapRect.left;
    dy = screen_center.y-MapRect.bottom;
    maxsc = max(maxsc, isqrt4(dx*dx+dy*dy));
    dx = screen_center.x-MapRect.right;
    dy = screen_center.y-MapRect.bottom;
    maxsc = max(maxsc, isqrt4(dx*dx+dy*dy));
    
    for (int i=0; i<10; i++) {
      double ang = i*360.0/10;
      POINT p;
      double X, Y;
      p.x = screen_center.x + iround(fastcosine(ang)*maxsc*scale);
      p.y = screen_center.y + iround(fastsine(ang)*maxsc*scale);
      Screen2LatLon(p.x, p.y, X, Y);
      sb.minx = min(X, sb.minx);
      sb.miny = min(Y, sb.miny);
      sb.maxx = max(X, sb.maxx);
      sb.maxy = max(Y, sb.maxy);
    }

  } else {

    double xmin, xmax, ymin, ymax;
    int x, y;
    double X, Y;
    
    x = MapRect.left; 
    y = MapRect.top; 
    Screen2LatLon(x, y, X, Y);
    xmin = X; xmax = X;
    ymin = Y; ymax = Y;

    x = MapRect.right; 
    y = MapRect.top; 
    Screen2LatLon(x, y, X, Y);
    xmin = min(xmin, X); xmax = max(xmax, X);
    ymin = min(ymin, Y); ymax = max(ymax, Y);
  
    x = MapRect.right; 
    y = MapRect.bottom; 
    Screen2LatLon(x, y, X, Y);
    xmin = min(xmin, X); xmax = max(xmax, X);
    ymin = min(ymin, Y); ymax = max(ymax, Y);
  
    x = MapRect.left; 
    y = MapRect.bottom; 
    Screen2LatLon(x, y, X, Y);
    xmin = min(xmin, X); xmax = max(xmax, X);
    ymin = min(ymin, Y); ymax = max(ymax, Y);
  

    sb.minx = xmin;
    sb.maxx = xmax;
    sb.miny = ymin;
    sb.maxy = ymax;

  }

  return sb;
}



void MapWindow::ScanVisibility(rectObj *bounds_active) {
  // received when the SetTopoBounds determines the visibility
  // boundary has changed.
  // This happens rarely, so it is good pre-filtering of what is visible.
  // (saves from having to do it every screen redraw)
  const rectObj bounds = *bounds_active;

  // far visibility for snail trail

  SNAIL_POINT *sv= SnailTrail;
  const SNAIL_POINT *se = sv+TRAILSIZE;
  while (sv<se) {
    sv->FarVisible = ((sv->Longitude> bounds.minx) &&
		      (sv->Longitude< bounds.maxx) &&
		      (sv->Latitude> bounds.miny) &&
		      (sv->Latitude< bounds.maxy));
    sv++;
  }

  // far visibility for waypoints

  if (WayPointList) {
    WAYPOINT *wv = WayPointList;
    const WAYPOINT *we = WayPointList+NumberOfWayPoints;
    while (wv<we) {
      // TODO code: optimise waypoint visibility
      wv->FarVisible = ((wv->Longitude> bounds.minx) &&
			(wv->Longitude< bounds.maxx) &&
			(wv->Latitude> bounds.miny) &&
			(wv->Latitude< bounds.maxy));
      wv++;
    }
  }

  // far visibility for airspace

  if (AirspaceCircle) {
    for (AIRSPACE_CIRCLE* circ = AirspaceCircle;
         circ < AirspaceCircle+NumberOfAirspaceCircles; circ++) {
      circ->FarVisible = 
        (msRectOverlap(&circ->bounds, bounds_active) == MS_TRUE) ||
        (msRectContained(bounds_active, &circ->bounds) == MS_TRUE) ||
        (msRectContained(&circ->bounds, bounds_active) == MS_TRUE);
    }
  }

  if (AirspaceArea) {
    for(AIRSPACE_AREA *area = AirspaceArea;
        area < AirspaceArea+NumberOfAirspaceAreas; area++) {
      area->FarVisible = 
        (msRectOverlap(&area->bounds, bounds_active) == MS_TRUE) ||
        (msRectContained(bounds_active, &area->bounds) == MS_TRUE) ||
        (msRectContained(&area->bounds, bounds_active) == MS_TRUE);
    }
  }

}


void MapWindow::CalculateScreenPositionsThermalSources() {
  for (int i=0; i<MAX_THERMAL_SOURCES; i++) {
    if (DerivedDrawInfo.ThermalSources[i].LiftRate>0) {
      double dh = DerivedDrawInfo.NavAltitude
        -DerivedDrawInfo.ThermalSources[i].GroundHeight;
      if (dh<0) {
        DerivedDrawInfo.ThermalSources[i].Visible = false;
        continue;
      }

      double t = dh/DerivedDrawInfo.ThermalSources[i].LiftRate;
      double lat, lon;
      FindLatitudeLongitude(DerivedDrawInfo.ThermalSources[i].Latitude, 
                            DerivedDrawInfo.ThermalSources[i].Longitude,
                            DerivedDrawInfo.WindBearing, 
                            -DerivedDrawInfo.WindSpeed*t,
                            &lat, &lon);
      if (PointVisible(lon,lat)) {
        LatLon2Screen(lon, 
                      lat, 
                      DerivedDrawInfo.ThermalSources[i].Screen);
        DerivedDrawInfo.ThermalSources[i].Visible = 
          PointVisible(DerivedDrawInfo.ThermalSources[i].Screen);
      } else {
        DerivedDrawInfo.ThermalSources[i].Visible = false;
      }
    } else {
      DerivedDrawInfo.ThermalSources[i].Visible = false;
    }
  }
}


void MapWindow::CalculateScreenPositionsAirspaceCircle(AIRSPACE_CIRCLE &circ) {
  circ.Visible = false;
  if (!circ.FarVisible) return;
  if (iAirspaceMode[circ.Type]%2 == 1) 
    if(CheckAirspaceAltitude(circ.Base.Altitude, 
                             circ.Top.Altitude)) {
      if (msRectOverlap(&circ.bounds, &screenbounds_latlon) 
          || msRectContained(&screenbounds_latlon, &circ.bounds)) {

	if (!circ._NewWarnAckNoBrush &&
	    !(iAirspaceBrush[circ.Type] == NUMAIRSPACEBRUSHES-1)) {
	  circ.Visible = 2;
	} else {
	  circ.Visible = 1;
	}

        LatLon2Screen(circ.Longitude, 
                      circ.Latitude, 
                      circ.Screen);
        circ.ScreenR = iround(circ.Radius*ResMapScaleOverDistanceModify);
      }
    }
}

void MapWindow::CalculateScreenPositionsAirspaceArea(AIRSPACE_AREA &area) {
  area.Visible = false;
  if (!area.FarVisible) return;
  if (iAirspaceMode[area.Type]%2 == 1) 
    if(CheckAirspaceAltitude(area.Base.Altitude, 
                             area.Top.Altitude)) {
      if (msRectOverlap(&area.bounds, &screenbounds_latlon) 
          || msRectContained(&screenbounds_latlon, &area.bounds)) {
        AIRSPACE_POINT *ap= AirspacePoint+area.FirstPoint;
        const AIRSPACE_POINT *ep= ap+area.NumPoints;
        POINT* sp= AirspaceScreenPoint+area.FirstPoint;
        while (ap < ep) {
	  // JMW optimise!
            LatLon2Screen(ap->Longitude, 
                          ap->Latitude, 
                          *sp);
            ap++;
            sp++;
        }               

	if (!area._NewWarnAckNoBrush &&
	    !(iAirspaceBrush[area.Type] == NUMAIRSPACEBRUSHES-1)) {
	  area.Visible = 2;
	} else {
	  area.Visible = 1;
	}
      }
    }
}

void MapWindow::CalculateScreenPositionsAirspace() {
  
  
  if (AirspaceCircle) {
    for (AIRSPACE_CIRCLE* circ = AirspaceCircle;
         circ < AirspaceCircle+NumberOfAirspaceCircles; circ++) {
      CalculateScreenPositionsAirspaceCircle(*circ);
    }
  }
  if (AirspaceArea) {
    for(AIRSPACE_AREA *area = AirspaceArea;
        area < AirspaceArea+NumberOfAirspaceAreas; area++) {
      CalculateScreenPositionsAirspaceArea(*area);
    }
  }
}


void MapWindow::CalculateScreenPositions(POINT Orig, RECT rc, 
                                         POINT *Orig_Aircraft)
{
  unsigned int i;

  Orig_Screen = Orig;

  if (!EnablePan) {
  
    if (GliderCenter 
        && DerivedDrawInfo.Circling 
        && (EnableThermalLocator==2)) {
      
      if (DerivedDrawInfo.ThermalEstimate_R>0) {
        PanLongitude = DerivedDrawInfo.ThermalEstimate_Longitude; 
        PanLatitude = DerivedDrawInfo.ThermalEstimate_Latitude;
        // TODO enhancement: only pan if distance of center to
        // aircraft is smaller than one third screen width

        POINT screen;
        LatLon2Screen(PanLongitude, 
                      PanLatitude, 
                      screen);

        LatLon2Screen(DrawInfo.Longitude, 
                      DrawInfo.Latitude, 
                      *Orig_Aircraft);

        if ((fabs((double)Orig_Aircraft->x-screen.x)<(rc.right-rc.left)/3)
            && (fabs((double)Orig_Aircraft->y-screen.y)<(rc.bottom-rc.top)/3)) {
          
        } else {
          // out of bounds, center on aircraft
          PanLongitude = DrawInfo.Longitude;
          PanLatitude = DrawInfo.Latitude;
        }
      } else {
        PanLongitude = DrawInfo.Longitude;
        PanLatitude = DrawInfo.Latitude;
      }
    } else {
      // Pan is off
      PanLongitude = DrawInfo.Longitude;
      PanLatitude = DrawInfo.Latitude;
    }
  }

  LatLon2Screen(DrawInfo.Longitude, 
                DrawInfo.Latitude, 
                *Orig_Aircraft);

  screenbounds_latlon = CalculateScreenBounds(0.0);

  // get screen coordinates for all task waypoints

  LockTaskData();

  if (WayPointList) {
    int index;
    for (i=0; i<MAXTASKPOINTS; i++) {
      index = Task[i].Index;
      if (index>=0) {
        
        LatLon2Screen(WayPointList[index].Longitude, 
                      WayPointList[index].Latitude, 
                      WayPointList[index].Screen);
        WayPointList[index].Visible = 
          PointVisible(WayPointList[index].Screen);
      }      
    }
    if (EnableMultipleStartPoints) {
      for(i=0;i<MAXSTARTPOINTS-1;i++) {
        index = StartPoints[i].Index;
        if (StartPoints[i].Active && (index>=0)) {

          LatLon2Screen(WayPointList[index].Longitude, 
                        WayPointList[index].Latitude, 
                        WayPointList[index].Screen);
          WayPointList[index].Visible = 
            PointVisible(WayPointList[index].Screen);
        }
      }
    }

    // only calculate screen coordinates for waypoints that are visible

    for(i=0;i<NumberOfWayPoints;i++)
      {
        WayPointList[i].Visible = false;
        if (!WayPointList[i].FarVisible) continue;
        if(PointVisible(WayPointList[i].Longitude, WayPointList[i].Latitude) )
          {
            LatLon2Screen(WayPointList[i].Longitude, WayPointList[i].Latitude,
                          WayPointList[i].Screen);
            WayPointList[i].Visible = PointVisible(WayPointList[i].Screen);
          }
      }
  }

  if(TrailActive)
  {
    iSnailNext = SnailNext; 
    // set this so that new data doesn't arrive between calculating
    // this and the screen updates
  }

  if (EnableMultipleStartPoints) {
    for(i=0;i<MAXSTARTPOINTS-1;i++) {
      if (StartPoints[i].Active && ValidWayPoint(StartPoints[i].Index)) {
        LatLon2Screen(StartPoints[i].SectorEndLon, 
                      StartPoints[i].SectorEndLat, StartPoints[i].End);
        LatLon2Screen(StartPoints[i].SectorStartLon, 
                      StartPoints[i].SectorStartLat, StartPoints[i].Start);
      }
    }
  }
  
  for(i=0;i<MAXTASKPOINTS-1;i++)
  {
    bool this_valid = ValidTaskPoint(i);
    bool next_valid = ValidTaskPoint(i+1);
    if (AATEnabled && this_valid) {
      LatLon2Screen(Task[i].AATTargetLon, Task[i].AATTargetLat, 
                    Task[i].Target);
    }

    if(this_valid && !next_valid)
    {
      // finish
      LatLon2Screen(Task[i].SectorEndLon, Task[i].SectorEndLat, Task[i].End);
      LatLon2Screen(Task[i].SectorStartLon, Task[i].SectorStartLat, Task[i].Start);      
    }
    if(this_valid && next_valid)
    {
      LatLon2Screen(Task[i].SectorEndLon, Task[i].SectorEndLat, Task[i].End);
      LatLon2Screen(Task[i].SectorStartLon, Task[i].SectorStartLat, Task[i].Start);

      if((AATEnabled) && (Task[i].AATType == SECTOR))
      {
        LatLon2Screen(Task[i].AATStartLon, Task[i].AATStartLat, Task[i].AATStart);
        LatLon2Screen(Task[i].AATFinishLon, Task[i].AATFinishLat, Task[i].AATFinish);
      }
      if (AATEnabled && (((int)i==ActiveWayPoint) || 
			 (TargetPan && ((int)i==TargetPanIndex)))) {

	for (int j=0; j<MAXISOLINES; j++) {
	  if (TaskStats[i].IsoLine_valid[j]) {
	    LatLon2Screen(TaskStats[i].IsoLine_Longitude[j], 
			  TaskStats[i].IsoLine_Latitude[j], 
			  TaskStats[i].IsoLine_Screen[j]);
	  }
	}
      }
    }
  }

  UnlockTaskData();

}


static bool CheckLandableReachableTerrain(NMEA_INFO *Basic,
                                          DERIVED_INFO *Calculated,
                                          double LegToGo,
                                          double LegBearing) {
  double lat, lon;
  bool out_of_range;
  double distance_soarable = 
    FinalGlideThroughTerrain(LegBearing, 
                             Basic, Calculated, 
                             &lat,
                             &lon,
                             LegToGo, &out_of_range, NULL);
    
  if ((out_of_range)||(distance_soarable> LegToGo)) {
    return true;
  } else {
    return false;
  }
}

// VNT : john should this be moved to the calculation task, and activated when map is displayed only?
void MapWindow::CalculateWaypointReachable(void)
{
  unsigned int i;
  double WaypointDistance, WaypointBearing,AltitudeRequired,AltitudeDifference;
  double dtmp;

  LandableReachable = false;

  if (!WayPointList) return;

  LockTaskData();

  for(i=0;i<NumberOfWayPoints;i++)
  {
    if ((WayPointList[i].Visible && 
	 (
	  ((WayPointList[i].Flags & AIRPORT) == AIRPORT) ||
	  ((WayPointList[i].Flags & LANDPOINT) == LANDPOINT)
	  ))
	|| WaypointInTask(i) ) {

      DistanceBearing(DrawInfo.Latitude, 
		      DrawInfo.Longitude, 
		      WayPointList[i].Latitude, 
		      WayPointList[i].Longitude,
		      &WaypointDistance,
		      &WaypointBearing);

      // We ought to start saving calculated values for later reusage, and save cpu.
      // This is a good place to start from, since this function is called everytime
      // the map is redrawn.
      // VENTA6: TODO need to optimize bestalternate and many other functions, later... 090525
      WayPointCalc[i].Distance=WaypointDistance; 
      WayPointCalc[i].Bearing=WaypointBearing;

	dtmp=DerivedDrawInfo.NavAltitude - SAFETYALTITUDEARRIVAL - WayPointList[i].Altitude;
	if (dtmp>0) {
		WayPointCalc[i].GR = WaypointDistance / dtmp;
		if (WayPointCalc[i].GR > INVALID_GR) WayPointCalc[i].GR=INVALID_GR; else
		if (WayPointCalc[i].GR <1) WayPointCalc[i].GR=1;
	} else
		WayPointCalc[i].GR = INVALID_GR;

	// VENTA6 TODO set also AltArriv here	
      
      AltitudeRequired = 
	GlidePolar::MacCreadyAltitude
	(GlidePolar::SafetyMacCready, 
	 WaypointDistance,
	 WaypointBearing, 
	 DerivedDrawInfo.WindSpeed, 
	 DerivedDrawInfo.WindBearing,
	 0,0,true,0);
      AltitudeRequired = AltitudeRequired + SAFETYALTITUDEARRIVAL 
	+ WayPointList[i].Altitude ;

      WayPointCalc[i].AltReqd = AltitudeRequired; // VENTA6

      AltitudeDifference = DerivedDrawInfo.NavAltitude - AltitudeRequired;                                      
      WayPointList[i].AltArivalAGL = AltitudeDifference;
      
      if(AltitudeDifference >=0){
	WayPointList[i].Reachable = TRUE;
	if (!LandableReachable || ((int)i==ActiveWayPoint)) {
	  if (CheckLandableReachableTerrain(&DrawInfo, 
					    &DerivedDrawInfo,
					    WaypointDistance, 
					    WaypointBearing)) {
	    LandableReachable = true;
	  } else if ((int)i==ActiveWayPoint) {
	    WayPointList[i].Reachable = FALSE;
	  }
	}
      } else {
	WayPointList[i].Reachable = FALSE;
      }
    }
  }

  if (!LandableReachable) {
    // widen search to far visible waypoints 
    // (only do this if can't see one at present)

    for(i=0;i<NumberOfWayPoints;i++)
      {
        if(!WayPointList[i].Visible && WayPointList[i].FarVisible) 
          // visible but only at a distance (limit this to 100km radius)
          {
            if(  ((WayPointList[i].Flags & AIRPORT) == AIRPORT) 
                 || ((WayPointList[i].Flags & LANDPOINT) == LANDPOINT) )
              {
                DistanceBearing(DrawInfo.Latitude, 
                                DrawInfo.Longitude, 
                                WayPointList[i].Latitude, 
                                WayPointList[i].Longitude,
                                &WaypointDistance,
                                &WaypointBearing);
               
      WayPointCalc[i].Distance=WaypointDistance;  // VENTA6
      WayPointCalc[i].Bearing=WaypointBearing;

                if (WaypointDistance<100000.0) {
                  AltitudeRequired = 
                    GlidePolar::MacCreadyAltitude
                    (GlidePolar::SafetyMacCready, 
                     WaypointDistance,
                     WaypointBearing, 
                     DerivedDrawInfo.WindSpeed, 
                     DerivedDrawInfo.WindBearing,
                     0,0,true,0);
                  
                  AltitudeRequired = AltitudeRequired + SAFETYALTITUDEARRIVAL 
                    + WayPointList[i].Altitude ;
                  AltitudeDifference = DerivedDrawInfo.NavAltitude - AltitudeRequired;                                      
                  WayPointList[i].AltArivalAGL = AltitudeDifference;

      WayPointCalc[i].AltReqd = AltitudeRequired; // VENTA6

                  if(AltitudeDifference >=0){
                    WayPointList[i].Reachable = TRUE;
                    if (!LandableReachable) {
                      if (CheckLandableReachableTerrain(&DrawInfo, 
                                                        &DerivedDrawInfo,
                                                        WaypointDistance, 
                                                        WaypointBearing)) {
                        LandableReachable = true;
                      }
                    }
                  } else {
                    WayPointList[i].Reachable = FALSE;
                  }
                }
              }     
          }
      }
  }

  UnlockTaskData(); 
}


void MapWindow::DrawHorizon(HDC hDC, const RECT rc)
{
  POINT Start;

  Start.y = IBLSCALE(55)+rc.top;
  Start.x = rc.right - IBLSCALE(19);
  if (EnableVarioGauge && MapRectBig.right == rc.right)
    Start.x -= InfoBoxLayout::ControlWidth;

  HPEN   hpHorizonSky;
  HBRUSH hbHorizonSky;
  HPEN   hpHorizonGround;
  HBRUSH hbHorizonGround;
  HPEN   hpOld;
  HBRUSH hbOld;

  hpHorizonSky = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
                                 RGB(0x40,0x40,0xff));
  hbHorizonSky = (HBRUSH)CreateSolidBrush(RGB(0xA0,0xA0,0xff));

  hpHorizonGround = (HPEN)CreatePen(PS_SOLID, IBLSCALE(1), 
                                    RGB(106,55,12));
  hbHorizonGround = (HBRUSH)CreateSolidBrush(
                                             RGB(157,101,60));

  int radius = IBLSCALE(17);
  double phi = max(-89,min(89,DerivedDrawInfo.BankAngle));
  double alpha = RAD_TO_DEG
    *acos(max(-1.0,min(1.0,DerivedDrawInfo.PitchAngle/50.0)));
  double alpha1 = 180-alpha-phi;
  double alpha2 = 180+alpha-phi;

  hpOld = (HPEN)SelectObject(hDC, hpHorizonSky);
  hbOld = (HBRUSH)SelectObject(hDC, hbHorizonSky);

  Segment(hDC, Start.x, Start.y, radius, rc, 
          alpha2, alpha1, true);

  SelectObject(hDC, hpHorizonGround);
  SelectObject(hDC, hbHorizonGround);

  Segment(hDC, Start.x, Start.y, radius, rc, 
          alpha1, alpha2, true);

  POINT a1, a2;

  /*
  a1.x = Start.x + fastsine(alpha1)*radius;
  a1.y = Start.y - fastcosine(alpha1)*radius;
  a2.x = Start.x + fastsine(alpha2)*radius;
  a2.y = Start.y - fastcosine(alpha2)*radius;

  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
            a1, a2, RGB(0,0,0));
  */

  a1.x = Start.x+radius/2;
  a1.y = Start.y;
  a2.x = Start.x-radius/2;
  a2.y = Start.y;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, a2, RGB(0,0,0), rc);

  a1.x = Start.x;
  a1.y = Start.y-radius/4;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, Start, RGB(0,0,0), rc);

  //

#define ROOT2 0.70711

  int rr2p = lround(radius*ROOT2+IBLSCALE(1));
  int rr2n = lround(radius*ROOT2);

  a1.x = Start.x+rr2p;
  a1.y = Start.y-rr2p;
  a2.x = Start.x+rr2n;
  a2.y = Start.y-rr2n;

  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
            a1, a2, RGB(0,0,0), rc);

  a1.x = Start.x-rr2p;
  a1.y = Start.y-rr2p;
  a2.x = Start.x-rr2n;
  a2.y = Start.y-rr2n;

  _DrawLine(hDC, PS_SOLID, IBLSCALE(1), 
            a1, a2, RGB(0,0,0), rc);

  // JMW experimental, display stall sensor
  double s = max(0.0,min(1.0,DrawInfo.StallRatio));
  long m = (long)((rc.bottom-rc.top)*s*s);
  a1.x = rc.right-1;
  a1.y = rc.bottom-m;
  a2.x = a1.x-10;
  a2.y = a1.y;
  _DrawLine(hDC, PS_SOLID, IBLSCALE(2), 
            a1, a2, RGB(0xff,0,0), rc);

  SelectObject(hDC, hbOld);
  SelectObject(hDC, hpOld);
  DeleteObject((HPEN)hpHorizonSky);
  DeleteObject((HBRUSH)hbHorizonSky);
  DeleteObject((HPEN)hpHorizonGround);
  DeleteObject((HBRUSH)hbHorizonGround);
}


// JMW to be used for target preview
bool MapWindow::SetTargetPan(bool do_pan, int target_point) {
  static double old_latitude;
  static double old_longitude;
  static bool old_pan=false;
  static bool old_fullscreen=false;

  if (!TargetPan || (TargetPanIndex != target_point)) {
    TargetDrag_State = 0;
  }

  TargetPanIndex = target_point;

  if (do_pan && !TargetPan) {
    old_latitude = PanLatitude;
    old_longitude = PanLongitude;
    old_pan = EnablePan;
    EnablePan = true;
    TargetPan = do_pan;
    old_fullscreen = RequestFullScreen;
    if (RequestFullScreen) {
      RequestFullScreen = false;
    }
    SwitchZoomClimb();
  }
  if (do_pan) {
    LockTaskData();
    if (ValidTaskPoint(target_point)) {
      PanLongitude = WayPointList[Task[target_point].Index].Longitude;
      PanLatitude = WayPointList[Task[target_point].Index].Latitude;
      if (target_point==0) {
        TargetZoomDistance = max(2e3, StartRadius*2);
      } else if (!ValidTaskPoint(target_point+1)) {
        TargetZoomDistance = max(2e3, FinishRadius*2);
      } else if (AATEnabled) {
        if (Task[target_point].AATType == SECTOR) {
          TargetZoomDistance = max(2e3, Task[target_point].AATSectorRadius*2);
        } else {
          TargetZoomDistance = max(2e3, Task[target_point].AATCircleRadius*2);
        }
      } else {
        TargetZoomDistance = max(2e3, SectorRadius*2);
      }
    }
    UnlockTaskData();
  } else if (TargetPan) {
    PanLongitude = old_longitude;
    PanLatitude = old_latitude;
    EnablePan = old_pan;
    TargetPan = do_pan;
    if (old_fullscreen) {
      RequestFullScreen = true;
    }
    SwitchZoomClimb();
  }
  TargetPan = do_pan;
  return old_pan;
};


void MapWindow::DrawGreatCircle(HDC hdc,
                                double startLon, double startLat,
                                double targetLon, double targetLat,
				const RECT rc) {


#if OLD_GREAT_CIRCLE
  // TODO accuracy: this is actually wrong, it should recalculate the
  // bearing each step
  double distance=0;
  double distanceTotal=0;
  double Bearing;

  DistanceBearing(startLat,
                  startLon,
                  targetLat,
                  targetLon,
                  &distanceTotal,
                  &Bearing);

  distance = distanceTotal;
  
  if (distanceTotal==0.0) {
    return;
  }

  double d_distance = max(5000.0,distanceTotal/10);

  HPEN hpOld = (HPEN)SelectObject(hdc, hpBearing);

  POINT StartP;
  POINT EndP;
  LatLon2Screen(startLon, 
                startLat,
                StartP);
  LatLon2Screen(targetLon, 
                targetLat,
                EndP);

  if (d_distance>distanceTotal) {
    DrawSolidLine(hdc, StartP, EndP, rc);
  } else {

    for (int i=0; i<= 10; i++) {

      double tlat1, tlon1;

      FindLatitudeLongitude(startLat, 
                            startLon, 
                            Bearing,
                            min(distance,d_distance), 
                            &tlat1, 
                            &tlon1);
      
      DistanceBearing(tlat1,
                      tlon1,
                      targetLat,
                      targetLon,
                      &distance,
                      &Bearing);
      
      LatLon2Screen(tlon1, 
                    tlat1,
                    EndP);
      
      DrawSolidLine(hdc, StartP, EndP, rc);
      
      StartP.x = EndP.x;
      StartP.y = EndP.y;

      startLat = tlat1;
      startLon = tlon1;
      
    }
  }
#else
  // Simple and this should work for PNA with display bug

  HPEN hpOld = (HPEN)SelectObject(hdc, hpBearing);
  POINT pt[2];
  LatLon2Screen(startLon, 
                startLat,
                pt[0]);
  LatLon2Screen(targetLon, 
                targetLat,
                pt[1]);
  ClipPolygon(hdc, pt, 2, rc, false);

#endif
  SelectObject(hdc, hpOld);
}



int MapWindow::iSnailNext=0;

// This function is slow...
double MapWindow::DrawTrail( HDC hdc, const POINT Orig, const RECT rc)
{
  int i, snail_index;
  SNAIL_POINT P1;
  static BOOL last_circling = FALSE;
  static float vario_max= 5.0;
  static float vario_min= -5.0;
  static bool need_colour = true;

  double TrailFirstTime = -1;

  if(!TrailActive)
    return -1;

  if ((DisplayMode == dmCircling) != last_circling) {
    need_colour = true;
  }
  last_circling = (DisplayMode == dmCircling);

  //////////// Trail drift calculations

  double traildrift_lat = 0.0;
  double traildrift_lon = 0.0;
  
  if (EnableTrailDrift && (DisplayMode == dmCircling)) {
    double tlat1, tlon1;
    
    FindLatitudeLongitude(DrawInfo.Latitude, 
                          DrawInfo.Longitude, 
                          DerivedDrawInfo.WindBearing, 
                          DerivedDrawInfo.WindSpeed,
                          &tlat1, &tlon1);
    traildrift_lat = (DrawInfo.Latitude-tlat1);
    traildrift_lon = (DrawInfo.Longitude-tlon1);
  } else {
    traildrift_lat = 0.0;
    traildrift_lon = 0.0;
  }
  
  // JMW don't draw first bit from home airport

  /////////////  Trail size

  int num_trail_max;
  if (TrailActive!=2) {
    num_trail_max = TRAILSIZE;
  } else {
    num_trail_max = TRAILSIZE/TRAILSHRINK;
  }
  if ((DisplayMode == dmCircling)) {
    num_trail_max /= TRAILSHRINK;
  }

  ///////////// Vario colour scaling

  float this_vario_max = (float)(1.5*min(5.0, max(MACCREADY,0.5)));
  float this_vario_min = (float)(-1.5*min(5.0, max(MACCREADY,2.0)));
  vario_max = this_vario_max;
  vario_min = this_vario_min;

  ///////////// Snail skipping 

  const int skip_divisor = num_trail_max/5;
  int skip_border = skip_divisor;
  int skip_level= 3; // TODO code: try lower level?

  int snail_offset = TRAILSIZE+iSnailNext-num_trail_max;
  while (snail_offset>= TRAILSIZE) {
    snail_offset -= TRAILSIZE;
  }
  while (snail_offset< 0) {
    snail_offset += TRAILSIZE;
  }
  const int zero_offset = (TRAILSIZE-snail_offset);
  skip_border += zero_offset % skip_level;

  int index_skip = ((int)DrawInfo.Time)%skip_level;

  // TODO code: Divide by time step cruise/circling for zero_offset

  ///////////// Keep track of what's drawn

  bool this_visible = true;
  bool last_visible = false;
  POINT point_lastdrawn;
  point_lastdrawn.x = 0;
  point_lastdrawn.y = 0;

  ///////////// Average colour display for skipped points
  float vario_av = 0;
  int vario_av_num = 0;

  ///////////// Constants for speedups

  const bool display_circling = DisplayMode == dmCircling;
  const double display_time = DrawInfo.Time;

  // expand bounds so in strong winds the appropriate snail points are
  // still visible (since they are being tested before drift is applied)
  // this expands them by one minute

  rectObj bounds_thermal = screenbounds_latlon;
  screenbounds_latlon.minx -= fabs(60.0*traildrift_lon);
  screenbounds_latlon.maxx += fabs(60.0*traildrift_lon);
  screenbounds_latlon.miny -= fabs(60.0*traildrift_lat);
  screenbounds_latlon.maxy += fabs(60.0*traildrift_lat);

  const rectObj bounds = bounds_thermal;

  const int deg = DEG_TO_INT(AngleLimit360(DisplayAngle));
  const int cost = ICOSTABLE[deg];
  const int sint = ISINETABLE[deg];
  const int xxs = Orig_Screen.x*1024-512;
  const int yys = Orig_Screen.y*1024+512;
  const double mDrawScale = DrawScale;
  const double mPanLongitude = PanLongitude;
  const double mPanLatitude = PanLatitude;

  ////////////// Main loop

  for(i=1;i< num_trail_max; ++i) 
  {
    ///// Handle skipping

    if (i>=skip_border) {
      skip_level= max(1,skip_level-1);
      skip_border= i+2*(zero_offset % skip_level)+skip_divisor;
      index_skip = skip_level;
    }

    index_skip++;
    if ((i<num_trail_max-10) && (index_skip < skip_level)) {
      continue;
    } else {
      index_skip=0;
    }

    ////// Find the snail point

    snail_index = snail_offset+i;
    while (snail_index>=TRAILSIZE) {
      snail_index-= TRAILSIZE;
    }

    P1 = SnailTrail[snail_index];

    /////// Mark first time of display point

    if (((TrailFirstTime<0) || (P1.Time<TrailFirstTime)) && (P1.Time>=0)) {
      TrailFirstTime = P1.Time;
    }

    //////// Ignoring display elements for modes

    if (display_circling) {
      if ((!P1.Circling)&&( i<num_trail_max-60 )) {
        // ignore cruise mode lines unless very recent
	last_visible = false;
        continue;
      }
    } else {
      //  if ((P1.Circling)&&( snail_index % 5 != 0 )) {
        // JMW TODO code: This won't work properly!
        // draw only every 5 points from circling when in cruise mode
	//        continue;
      //      }
    }

    ///////// Filter if far visible

    if (!P1.FarVisible) {
      last_visible = false;
      continue;
    }

    ///////// Determine if this is visible

    this_visible =   ((P1.Longitude> bounds.minx) &&
		     (P1.Longitude< bounds.maxx) &&
		     (P1.Latitude> bounds.miny) &&
		     (P1.Latitude< bounds.maxy)) ;

    if (!this_visible && !last_visible) {
      last_visible = false;
      continue;
    }

    ////////// Find coordinates on screen after applying trail drift

    // now we know either point is visible, better get screen coords
    // if we don't already.

    double dt = max(0,(display_time-P1.Time)*P1.DriftFactor);
    double this_lon = P1.Longitude+traildrift_lon*dt;
    double this_lat = P1.Latitude+traildrift_lat*dt;

#if 1
    // this is faster since many parameters are const
    int Y = Real2Int((mPanLatitude-this_lat)*mDrawScale);
    int X = Real2Int((mPanLongitude-this_lon)*fastcosine(this_lat)*mDrawScale);
    P1.Screen.x = (xxs-X*cost + Y*sint)/1024;
    P1.Screen.y = (Y*cost + X*sint + yys)/1024;
#else
    LatLon2Screen(this_lon, 
		  this_lat, 
		  P1.Screen);
#endif

    ////////// Determine if we should skip if close to previous point

    if (last_visible && this_visible) {
      // only average what's visible

      if (abs(P1.Screen.y-point_lastdrawn.y)
	  +abs(P1.Screen.x-point_lastdrawn.x)<IBLSCALE(4)) {
	vario_av += P1.Vario;
	vario_av_num ++;
	continue;
	// don't draw if very short line
      }
    }

    ////////// Lookup the colour if it's not already set

    if ((P1.Colour<0)||(P1.Colour>=NUMSNAILCOLORS)) {
      float colour_vario = P1.Vario;
      if (vario_av_num) {
	// set color to average if skipped
	colour_vario = (colour_vario+vario_av)/(vario_av_num+1);
	vario_av_num= 0;
	vario_av= 0;
      }
      if (colour_vario<0) {
	colour_vario /= (-vario_min); // JMW fixed bug here
      } else {
	colour_vario /= vario_max;
      }
      P1.Colour = fSnailColour(colour_vario);
    }
    SelectObject(hdc, hSnailPens[P1.Colour]);

    if (!last_visible) { // draw set cursor at P1
#ifndef NOLINETO
      MoveToEx(hdc, P1.Screen.x, P1.Screen.y, NULL);
#endif
    } else {
#ifndef NOLINETO
      LineTo(hdc, P1.Screen.x, P1.Screen.y);
#else
      DrawSolidLine(hdc, P1.Screen, point_lastdrawn, rc);
#endif
    }
    point_lastdrawn = P1.Screen;
    last_visible = this_visible;
  }

  // draw final point to glider
  if (last_visible) {
#ifndef NOLINETO 
    LineTo(hdc, Orig.x, Orig.y);
#else
    DrawSolidLine(hdc, Orig, point_lastdrawn, rc);
#endif
  }

  return TrailFirstTime;
}


extern OLCOptimizer olc;

void MapWindow::DrawTrailFromTask(HDC hdc, const RECT rc, 
				  const double TrailFirstTime) {
  static POINT ptin[MAXCLIPPOLYGON];

  if((TrailActive!=3) || (DisplayMode == dmCircling) || (TrailFirstTime<0))
    return;

  const double mTrailFirstTime = TrailFirstTime - DerivedDrawInfo.TakeOffTime;
  // since olc keeps track of time wrt takeoff

  olc.SetLine();
  int n = min(MAXCLIPPOLYGON,olc.getN());
  int i, j=0;
  for (i=0; i<n; i++) {
    if (olc.getTime(i)>= mTrailFirstTime) 
      break;
    LatLon2Screen(olc.getLongitude(i), 
                  olc.getLatitude(i), 
                  ptin[j]);
    j++;
  }
  if (j>=2) {
    SelectObject(hdc,hSnailPens[NUMSNAILCOLORS/2]);
    ClipPolygon(hdc, ptin, j, rc, false);
  }
}


///////
extern HFONT  TitleWindowFont;

void MapWindow::DrawOffTrackIndicator(HDC hdc, const RECT rc) {
  if ((ActiveWayPoint<=0) || !ValidTaskPoint(ActiveWayPoint)) {
    return;
  }
  if (fabs(DrawInfo.TrackBearing-DerivedDrawInfo.WaypointBearing)<10) {
    // insignificant error
    return;
  }
  if (DerivedDrawInfo.Circling || TaskIsTemporary() || TargetPan) {
    // don't display in various modes
    return;
  }

  double distance_max = min(DerivedDrawInfo.WaypointDistance,
			    GetApproxScreenRange()*0.7);
  if (distance_max < 5000.0) {
    // too short to bother
    return;
  }

  LockTaskData();  // protect from external task changes

  double startLat = DrawInfo.Latitude;
  double startLon = DrawInfo.Longitude;
  double targetLat;
  double targetLon;
  double dLat, dLon;

  if (AATEnabled && ValidTaskPoint(ActiveWayPoint+1)) {
    targetLat = Task[ActiveWayPoint].AATTargetLat;
    targetLon = Task[ActiveWayPoint].AATTargetLon; 
  } else {
    targetLat = WayPointList[Task[ActiveWayPoint].Index].Latitude;
    targetLon = WayPointList[Task[ActiveWayPoint].Index].Longitude; 
  }
  UnlockTaskData();

  HFONT oldFont = (HFONT)SelectObject(hdc, TitleWindowFont);
  SetTextColor(hdc, RGB(0x0,0x0,0x0));
      
  int ilast = 0;
  for (double d=0.25; d<=1.0; d+= 0.25) {
    double distance0, distance1;

    FindLatitudeLongitude(startLat, startLon, 
			  DrawInfo.TrackBearing, 
			  distance_max*d,
			  &dLat, &dLon);

    DistanceBearing(startLat, startLon,
		    dLat, dLon,
		    &distance0,
		    NULL);
    DistanceBearing(dLat, dLon,
		    targetLat, targetLon,
		    &distance1,
		    NULL);

    double distance = (distance0+distance1)/DerivedDrawInfo.WaypointDistance;
    int idist = iround((distance-1.0)*100);

    if ((idist != ilast) && (idist>0) && (idist<1000)) {

      TCHAR Buffer[5];
      _stprintf(Buffer, TEXT("%d"), idist);
      short size = _tcslen(Buffer);
      SIZE tsize;
      POINT sc;
      RECT brect;
      LatLon2Screen(dLon, dLat, sc);
      GetTextExtentPoint(hdc, Buffer, size, &tsize);

      brect.left = sc.x-4;
      brect.right = brect.left+tsize.cx+4;
      brect.top = sc.y-4;
      brect.bottom = brect.top+tsize.cy+4;

      if (checkLabelBlock(brect)) {
	ExtTextOut(hdc, sc.x-tsize.cx/2, sc.y-tsize.cy/2, 
		   0, NULL, Buffer, size, NULL);
	ilast = idist;
      }
    }

  }

  SelectObject(hdc, oldFont);
}


void MapWindow::CalculateScreenPositionsGroundline(void) {
  if (FinalGlideTerrain) {
    LatLon2Screen(DerivedDrawInfo.GlideFootPrint,
		  Groundline, NUMTERRAINSWEEPS+1, 1);
  }
}


void MapWindow::DrawTerrainAbove(HDC hDC, const RECT rc) {

  if (!DerivedDrawInfo.Flying) return;

  COLORREF whitecolor = RGB(0xff,0xff,0xff);
  COLORREF graycolor = RGB(0xf0,0xf0,0xf0);
  COLORREF origcolor = SetTextColor(hDCTemp, whitecolor);

  SetBkMode(hDCTemp, TRANSPARENT);

  SelectObject(hDCTemp, (HBITMAP)hDrawBitMapTmp);
  SetBkColor(hDCTemp, whitecolor);

  SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  SetTextColor(hDCTemp, graycolor);
  SelectObject(hDCTemp, hAboveTerrainBrush); // hAirspaceBrushes[3] or 6
  Rectangle(hDCTemp,rc.left,rc.top,rc.right,rc.bottom);

  SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  SelectObject(hDCTemp, GetStockObject(WHITE_BRUSH));
  Polygon(hDCTemp,Groundline,NUMTERRAINSWEEPS+1);

  // need to do this to prevent drawing of colored outline
  SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
#if (WINDOWSPC<1)
    TransparentImage(hDC,
                     rc.left, rc.top,
                     rc.right-rc.left,rc.bottom-rc.top,
                     hDCTemp,
                     rc.left, rc.top,
                     rc.right-rc.left,rc.bottom-rc.top,
                     whitecolor
                     );
    
#else
    TransparentBlt(hDC,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   hDCTemp,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   whitecolor
                   );
  #endif

  // restore original color
  SetTextColor(hDCTemp, origcolor);
  SetBkMode(hDCTemp,OPAQUE);

}


void MapWindow::DrawProjectedTrack(HDC hdc, const RECT rc, const POINT Orig) {
  if ((ActiveWayPoint<=0) || !ValidTaskPoint(ActiveWayPoint) || !AATEnabled) {
    return;
  }
  if (DerivedDrawInfo.Circling || TaskIsTemporary()) {
    // don't display in various modes
    return;
  }

  // TODO feature: maybe have this work even if no task?
  // TODO feature: draw this also when in target pan mode

  LockTaskData();  // protect from external task changes

  double startLat = DrawInfo.Latitude;
  double startLon = DrawInfo.Longitude;
  double previousLat;
  double previousLon;
  if (AATEnabled) {
    previousLat = Task[max(0,ActiveWayPoint-1)].AATTargetLat;
    previousLon = Task[max(0,ActiveWayPoint-1)].AATTargetLon; 
  } else {
    previousLat = WayPointList[Task[max(0,ActiveWayPoint-1)].Index].Latitude;
    previousLon = WayPointList[Task[max(0,ActiveWayPoint-1)].Index].Longitude; 
  }
  UnlockTaskData();

  double distance_from_previous, bearing;
  DistanceBearing(previousLat, previousLon,
		  startLat, startLon,
		  &distance_from_previous,
		  &bearing);

  if (distance_from_previous < 100.0) {
    bearing = DrawInfo.TrackBearing;
    // too short to have valid data
  }
  POINT pt[2] = {{0,-75},{0,-400}};
  if (TargetPan) {
    double screen_range = GetApproxScreenRange();
    double flow = 0.4;
    double fhigh = 1.5;
    screen_range = max(screen_range, DerivedDrawInfo.WaypointDistance);

    double p1Lat;
    double p1Lon;
    double p2Lat;
    double p2Lon;
    FindLatitudeLongitude(startLat, startLon, 
			  bearing, flow*screen_range,
			  &p1Lat, &p1Lon);
    FindLatitudeLongitude(startLat, startLon, 
			  bearing, fhigh*screen_range,
			  &p2Lat, &p2Lon);
    LatLon2Screen(p1Lon, p1Lat, pt[0]);
    LatLon2Screen(p2Lon, p2Lat, pt[1]);
  } else if (fabs(bearing-DerivedDrawInfo.WaypointBearing)<10) {
    // too small an error to bother
    return;
  } else {
    pt[1].y = (long)(-max(MapRectBig.right-MapRectBig.left,
			  MapRectBig.bottom-MapRectBig.top)*1.2);
    PolygonRotateShift(pt, 2, Orig.x, Orig.y, 
		       bearing-DisplayAngle);
  }
  DrawDashLine(hdc, 2, pt[0], pt[1], RGB(0,0,0), rc);
}


bool MapWindow::TargetDragged(double *longitude, double *latitude) {
  bool retval = false;
  LockTaskData();
  if (TargetDrag_State==2) {
    *longitude = TargetDrag_Longitude;
    *latitude = TargetDrag_Latitude;
    TargetDrag_State = 0;
    retval = true;
  }
  UnlockTaskData();
  return retval;
}





void MapWindow::DrawTeammate(HDC hdc, RECT rc)
{
  POINT point;

  if (TeammateCodeValid)
    {
      if(PointVisible(TeammateLongitude, TeammateLatitude) )
	{
	  LatLon2Screen(TeammateLongitude, TeammateLatitude, point);

	  SelectObject(hDCTemp,hBmpTeammatePosition);
	  DrawBitmapX(hdc,
		      point.x-IBLSCALE(10), 
		      point.y-IBLSCALE(10),
		      20,20,
		      hDCTemp,0,0,SRCPAINT);
	
	  DrawBitmapX(hdc,
		      point.x-IBLSCALE(10), 
		      point.y-IBLSCALE(10),
		      20,20,
		      hDCTemp,20,0,SRCAND);
	}
    }
}



void MapWindow::DrawThermalBand(HDC hDC, const RECT rc)
{
  POINT GliderBand[5] = { {0,0},{23,0},{22,0},{24,0},{0,0} };
  
  if ((DerivedDrawInfo.TaskAltitudeDifference>50)
      &&(DisplayMode == dmFinalGlide)) {
    return;
  }

  // JMW TODO accuracy: gather proper statistics
  // note these should/may also be relative to ground
  int i;
  double mth = DerivedDrawInfo.MaxThermalHeight;
  double maxh, minh;
  double h;
  double Wt[NUMTHERMALBUCKETS];
  double ht[NUMTHERMALBUCKETS];
  double Wmax=0.0;
  int TBSCALEY = ( (rc.bottom - rc.top )/2)-IBLSCALE(30);
#define TBSCALEX 20
  
  // calculate height above safety altitude
  double hoffset = SAFETYALTITUDEBREAKOFF+DerivedDrawInfo.TerrainBase;
  h = DerivedDrawInfo.NavAltitude-hoffset;

  bool draw_start_height = ((ActiveWayPoint==0) && (ValidTaskPoint(0)) 
			    && (StartMaxHeight!=0)
			    && (DerivedDrawInfo.TerrainValid));
  double hstart=0;
  if (draw_start_height) {
    if (StartHeightRef == 0) {
      hstart = StartMaxHeight+DerivedDrawInfo.TerrainAlt;
    } else {
      hstart = StartMaxHeight;
    }
    hstart -= hoffset;
  }

  // calculate top/bottom height
  maxh = max(h, mth);
  minh = min(h, 0);

  if (draw_start_height) {
    maxh = max(maxh, hstart);
    minh = min(minh, hstart);
  }
  
  // no thermalling has been done above safety altitude
  if (mth<=1) {
    return;
  }
  if (maxh-minh<=0) {
    return;
  }

  // normalised heights
  double hglider = (h-minh)/(maxh-minh);
  hstart = (hstart-minh)/(maxh-minh);

  // calculate averages
  int numtherm = 0;

  double mc = MACCREADY;
  Wmax = max(0.5,mc);

  for (i=0; i<NUMTHERMALBUCKETS; i++) {
    double wthis = 0;
    // height of this thermal point [0,mth]
    double hi = i*mth/NUMTHERMALBUCKETS;
    double hp = ((hi-minh)/(maxh-minh));

    if (DerivedDrawInfo.ThermalProfileN[i]>5) {
      // now requires 10 items in bucket before displaying,
      // to eliminate kinks
      wthis = DerivedDrawInfo.ThermalProfileW[i]
                 /DerivedDrawInfo.ThermalProfileN[i];
    }
    if (wthis>0.0) {
      ht[numtherm]= hp;
      Wt[numtherm]= wthis;
      Wmax = max(Wmax,wthis/1.5);
      numtherm++;
    }
  }

  if ((!draw_start_height) && (numtherm<=1)) {
    return; // don't display if insufficient statistics
    // but do draw if start height needs to be drawn
  }
  
  // drawing info
  HPEN hpOld;
  
  // position of thermal band
  if (numtherm>1) {
    hpOld = (HPEN)SelectObject(hDC, hpThermalBand);
    HBRUSH hbOld = (HBRUSH)SelectObject(hDC, hbThermalBand);
  
    POINT ThermalProfile[NUMTHERMALBUCKETS+2];
    for (i=0; i<numtherm; i++) {    
      ThermalProfile[1+i].x = 
	(iround((Wt[i]/Wmax)*IBLSCALE(TBSCALEX)))+rc.left;
      
      ThermalProfile[1+i].y = 
	IBLSCALE(4)+iround(TBSCALEY*(1.0-ht[i]))+rc.top;
    }
    ThermalProfile[0].x = rc.left;
    ThermalProfile[0].y = ThermalProfile[1].y;
    ThermalProfile[numtherm+1].x = rc.left;
    ThermalProfile[numtherm+1].y = ThermalProfile[numtherm].y;

    Polygon(hDC,ThermalProfile,numtherm+2);
    SelectObject(hDC, hbOld);
  }
    
  // position of thermal band

  GliderBand[0].y = IBLSCALE(4)+iround(TBSCALEY*(1.0-hglider))+rc.top;
  GliderBand[1].y = GliderBand[0].y;
  GliderBand[1].x = max(iround((mc/Wmax)*IBLSCALE(TBSCALEX)),IBLSCALE(4))
    +rc.left;

  GliderBand[2].x = GliderBand[1].x-IBLSCALE(4);
  GliderBand[2].y = GliderBand[0].y-IBLSCALE(4);
  GliderBand[3].x = GliderBand[1].x;
  GliderBand[3].y = GliderBand[1].y;
  GliderBand[4].x = GliderBand[1].x-IBLSCALE(4);
  GliderBand[4].y = GliderBand[0].y+IBLSCALE(4);

  hpOld = (HPEN)SelectObject(hDC, hpThermalBandGlider);
  
  Polyline(hDC,GliderBand, 2);
  Polyline(hDC,GliderBand+2, 3); // arrow head

  if (draw_start_height) {
    SelectObject(hDC, hpFinalGlideBelow);
    GliderBand[0].y = IBLSCALE(4)+iround(TBSCALEY*(1.0-hstart))+rc.top;
    GliderBand[1].y = GliderBand[0].y;
    Polyline(hDC, GliderBand, 2);
  }

  SelectObject(hDC, hpOld);
  
}


void MapWindow::DrawFinalGlide(HDC hDC, const RECT rc)
{

  /*
   * VENTA NEWMAP draw finalglide bar mode:
   * - When in Final glide
   * - Only to Next Turnpoint
   * - Never
   */

   if (NewMap&&(GlideBarMode == (GlideBarMode_t)gbDisabled)) return;
  // if (DerivedDrawInfo.FinalGlide == 0 ) return; 

  /*
  POINT Scale[18] = {
    {5,-50 }, {14,-60 }, {23, -50},
    {5,-40 }, {14,-50 }, {23, -40},
    {5,-30 }, {14,-40 }, {23, -30},
    {5,-20 }, {14,-30 }, {23, -20},
    {5,-10 }, {14,-20 }, {23, -10},
    {5, 0  }, {14,-10 }, {23,   0},
  };*/

  POINT GlideBar[6] =
    { {0,0},{9,-9},{18,0},{18,0},{9,0},{0,0} };
  POINT GlideBar0[6] =
    { {0,0},{9,-9},{18,0},{18,0},{9,0},{0,0} };
  
  HPEN hpOld;
  HBRUSH hbOld;
  
  TCHAR Value[10];
  
  int Offset;
  int Offset0;
  int i;
  
  LockTaskData();  // protect from external task changes
  #ifdef HAVEEXCEPTIONS
  __try{
  #endif

    if (ValidTaskPoint(ActiveWayPoint)){
    // if (ActiveWayPoint >= 0) {

      const int y0 = ( (rc.bottom - rc.top )/2)+rc.top;

      // 60 units is size, div by 8 means 60*8 = 480 meters.
  	 if ( (GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
	      Offset = ((int)DerivedDrawInfo.TaskAltitudeDifference)/8; 
	      Offset0 = ((int)DerivedDrawInfo.TaskAltitudeDifference0)/8; 
         } else {
	      Offset = ((int)DerivedDrawInfo.NextAltitudeDifference)/8; 
	      Offset0 = ((int)DerivedDrawInfo.NextAltitudeDifference0)/8; 
         }
      // TODO feature: should be an angle if in final glide mode

      if(Offset > 60) Offset = 60;
      if(Offset < -60) Offset = -60;
      Offset = IBLSCALE(Offset);
      if(Offset<0) {
        GlideBar[1].y = IBLSCALE(9);
      }
      
      if(Offset0 > 60) Offset0 = 60;
      if(Offset0 < -60) Offset0 = -60;
      Offset0 = IBLSCALE(Offset0);
      if(Offset0<0) {
        GlideBar0[1].y = IBLSCALE(9);
      }
      
      for(i=0;i<6;i++)
        {
          GlideBar[i].y += y0;
          GlideBar[i].x = IBLSCALE(GlideBar[i].x)+rc.left;
        }
      GlideBar[0].y -= Offset;
      GlideBar[1].y -= Offset;
      GlideBar[2].y -= Offset;

      for(i=0;i<6;i++)
        {
          GlideBar0[i].y += y0;
          GlideBar0[i].x = IBLSCALE(GlideBar0[i].x)+rc.left;
        }
      GlideBar0[0].y -= Offset0;
      GlideBar0[1].y -= Offset0;
      GlideBar0[2].y -= Offset0;

      if ((Offset<0)&&(Offset0<0)) {
        // both below
        if (Offset0!= Offset) {
          int dy = (GlideBar0[0].y-GlideBar[0].y)
            +(GlideBar0[0].y-GlideBar0[3].y);
          dy = max(IBLSCALE(3), dy);
          GlideBar[3].y = GlideBar0[0].y-dy;
          GlideBar[4].y = GlideBar0[1].y-dy;
          GlideBar[5].y = GlideBar0[2].y-dy;
          
          GlideBar0[0].y = GlideBar[3].y;
          GlideBar0[1].y = GlideBar[4].y;
          GlideBar0[2].y = GlideBar[5].y;
        } else {
          Offset0 = 0;
        }

      } else if ((Offset>0)&&(Offset0>0)) {
        // both above
        GlideBar0[3].y = GlideBar[0].y;
        GlideBar0[4].y = GlideBar[1].y;
        GlideBar0[5].y = GlideBar[2].y;

        if (abs(Offset0-Offset)<IBLSCALE(4)) {
          Offset= Offset0;
        } 
      }

      // draw actual glide bar
      if (Offset<=0) {
        if (LandableReachable) {
          hpOld = (HPEN)SelectObject(hDC, hpFinalGlideBelowLandable);
          hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideBelowLandable);
        } else {
          hpOld = (HPEN)SelectObject(hDC, hpFinalGlideBelow);
          hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideBelow);
        }
      } else {
        hpOld = (HPEN)SelectObject(hDC, hpFinalGlideAbove);
        hbOld = (HBRUSH)SelectObject(hDC, hbFinalGlideAbove);
      }
      Polygon(hDC,GlideBar,6);

      // draw glide bar at mc 0
      if (Offset0<=0) {
        if (LandableReachable) {
          SelectObject(hDC, hpFinalGlideBelowLandable);
          SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
        } else {
          SelectObject(hDC, hpFinalGlideBelow);
          SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
        }
      } else {
        SelectObject(hDC, hpFinalGlideAbove);
        SelectObject(hDC, GetStockObject(HOLLOW_BRUSH));
      }
      if (Offset!=Offset0) {
        Polygon(hDC,GlideBar0,6);
      }

      // JMW draw x on final glide bar if unreachable at current Mc
      // hpAircraftBorder

   if ( (GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
      if ((DerivedDrawInfo.TaskTimeToGo>0.9*ERROR_TIME)
	  || ((MACCREADY<0.01) && (DerivedDrawInfo.TaskAltitudeDifference<0))) {
	SelectObject(hDC, hpAircraftBorder);
	POINT Cross[4] = { {-5, -5},
			   { 5,  5},
			   {-5,  5},
			   { 5, -5} };
	for (i=0; i<4; i++) {
	  Cross[i].x = IBLSCALE(Cross[i].x+9);
	  Cross[i].y = IBLSCALE(Cross[i].y+9)+y0;
	}
        Polygon(hDC,Cross,2);
        Polygon(hDC,&Cross[2],2);
      }
     } else {
      if ((MACCREADY<0.01) && (DerivedDrawInfo.NextAltitudeDifference<0)) {
	SelectObject(hDC, hpAircraftBorder);
	POINT Cross[4] = { {-5, -5},
			   { 5,  5},
			   {-5,  5},
			   { 5, -5} };
	for (i=0; i<4; i++) {
	  Cross[i].x = IBLSCALE(Cross[i].x+9);
	  Cross[i].y = IBLSCALE(Cross[i].y+9)+y0;
	}
        Polygon(hDC,Cross,2);
        Polygon(hDC,&Cross[2],2);
      }



     }

      if (Appearance.IndFinalGlide == fgFinalGlideDefault){

   if ((GlideBarMode == (GlideBarMode_t)gbFinish) || !NewMap) {
        _stprintf(Value,TEXT("%1.0f "), 
                  ALTITUDEMODIFY*DerivedDrawInfo.TaskAltitudeDifference);
      } else {
        _stprintf(Value,TEXT("%1.0f "), 
                  ALTITUDEMODIFY*DerivedDrawInfo.NextAltitudeDifference);
      }

        if (Offset>=0) {
          Offset = GlideBar[2].y+Offset+IBLSCALE(5);
        } else {
          if (Offset0>0) {
            Offset = GlideBar0[1].y-IBLSCALE(15);
          } else {
            Offset = GlideBar[2].y+Offset-IBLSCALE(15);
          }
        }
        
        TextInBoxMode_t TextInBoxMode = {1|8};
        TextInBox(hDC, Value, 0, (int)Offset, 0, TextInBoxMode);

      } else
        if (Appearance.IndFinalGlide == fgFinalGlideAltA){

          SIZE  TextSize;
          HFONT oldFont;
          int y = GlideBar[3].y;
          // was ((rc.bottom - rc.top )/2)-rc.top-
          //            Appearance.MapWindowBoldFont.CapitalHeight/2-1;
          int x = GlideBar[2].x+IBLSCALE(1);
          HBITMAP Bmp;
          POINT  BmpPos;
          POINT  BmpSize;

   if ((GlideBarMode == (GlideBarMode_t)gbFinish)||!NewMap) {
          _stprintf(Value, TEXT("%1.0f"), 
                    Units::ToUserAltitude(DerivedDrawInfo.TaskAltitudeDifference));
	} else {
          _stprintf(Value, TEXT("%1.0f"), 
                    Units::ToUserAltitude(DerivedDrawInfo.NextAltitudeDifference));
	}
          
          oldFont = (HFONT)SelectObject(hDC, MapWindowBoldFont);
          GetTextExtentPoint(hDC, Value, _tcslen(Value), &TextSize);
          
          SelectObject(hDC, GetStockObject(WHITE_BRUSH));
          SelectObject(hDC, GetStockObject(WHITE_PEN));
          Rectangle(hDC, x, y, 
                    x+IBLSCALE(1)+TextSize.cx, 
                    y+Appearance.MapWindowBoldFont.CapitalHeight+IBLSCALE(2));
          
          ExtTextOut(hDC, x+IBLSCALE(1), 
                     y+Appearance.MapWindowBoldFont.CapitalHeight
                     -Appearance.MapWindowBoldFont.AscentHeight+IBLSCALE(1), 
                     0, NULL, Value, _tcslen(Value), NULL);
          
          if (Units::GetUnitBitmap(Units::GetUserAltitudeUnit(), &Bmp, &BmpPos, &BmpSize, 0)){
            HBITMAP oldBitMap = (HBITMAP)SelectObject(hDCTemp, Bmp);
            DrawBitmapX(hDC, x+TextSize.cx+IBLSCALE(1), y, BmpSize.x, BmpSize.y, 
                        hDCTemp, BmpPos.x, BmpPos.y, SRCCOPY);
            SelectObject(hDCTemp, oldBitMap);
          }
          
          SelectObject(hDC, oldFont);
          
        }

      SelectObject(hDC, hbOld);
      SelectObject(hDC, hpOld);
    }
#ifdef HAVEEXCEPTIONS
  }__finally
#endif
     {
       UnlockTaskData();
     }
  
}


void MapWindow::DrawCompass(HDC hDC, const RECT rc)
{
  POINT Start;
  HPEN hpOld;
  HBRUSH hbOld; 

  if (Appearance.CompassAppearance == apCompassDefault){
/*
    if (NewMap&&Look8000) {
	    Start.y = rc.bottom-IBLSCALE(19);
	    Start.x = rc.right - IBLSCALE(59);
    } else {
*/
	    Start.y = IBLSCALE(19)+rc.top;
	    Start.x = rc.right - IBLSCALE(19);
//  }

    if (EnableVarioGauge && MapRectBig.right == rc.right)
        Start.x -= InfoBoxLayout::ControlWidth;

    POINT Arrow[5] = { {0,-18}, {-6,10}, {0,0}, {6,10}, {0,-18}};

    hpOld = (HPEN)SelectObject(hDC, hpCompass);
    hbOld = (HBRUSH)SelectObject(hDC, hbCompass);

    // North arrow
    PolygonRotateShift(Arrow, 5, Start.x, Start.y, -DisplayAngle);
    Polygon(hDC,Arrow,5);

    SelectObject(hDC, hbOld);
    SelectObject(hDC, hpOld);

  } else
  if (Appearance.CompassAppearance == apCompassAltA){

    static double lastDisplayAngle = 9999.9;
    static int lastRcRight = 0;
    static POINT Arrow[5] = { {0,-11}, {-5,9}, {0,3}, {5,9}, {0,-11}};
    extern bool EnableVarioGauge;

    if (lastDisplayAngle != DisplayAngle || lastRcRight != rc.right){

      Arrow[0].x  = 0;
      Arrow[0].y  = -11;
      Arrow[1].x  = -5;
      Arrow[1].y  = 9;
      Arrow[2].x  = 0;
      Arrow[2].y  = 3;
      Arrow[3].x  = 5;
      Arrow[3].y  = 9;
      Arrow[4].x  = 0;
      Arrow[4].y  = -11;
/*
	if (NewMap&&Look8000) {
	      Start.y = rc.bottom - IBLSCALE(10);
	      Start.x = rc.right - IBLSCALE(51);
	} else {
*/
	      Start.y = rc.top + IBLSCALE(10);
	      Start.x = rc.right - IBLSCALE(11);
//	}

      if (EnableVarioGauge && MapRectBig.right == rc.right) {
        Start.x -= InfoBoxLayout::ControlWidth;
      }

      // North arrow
      PolygonRotateShift(Arrow, 5, Start.x, Start.y, 
                         -DisplayAngle);

      lastDisplayAngle = DisplayAngle;
      lastRcRight = rc.right;
    }

    hpOld = (HPEN)SelectObject(hDC, hpCompassBorder);
    hbOld = (HBRUSH)SelectObject(hDC, hbCompass);
    Polygon(hDC,Arrow,5);

    SelectObject(hDC, hpCompass);
    Polygon(hDC,Arrow,5);

    SelectObject(hDC, hbOld);
    SelectObject(hDC, hpOld);

  }

}

void MapWindow::ClearAirSpace(bool fill) {
  COLORREF whitecolor = RGB(0xff,0xff,0xff);

  SetTextColor(hDCTemp, whitecolor);
  SetBkMode(hDCTemp, TRANSPARENT);	  
  SelectObject(hDCTemp, (HBITMAP)hDrawBitMapTmp);
  SetBkColor(hDCTemp, whitecolor);	  
  SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  SelectObject(hDCTemp, GetStockObject(WHITE_BRUSH));
  Rectangle(hDCTemp,MapRect.left,MapRect.top,MapRect.right,MapRect.bottom);
  if (fill) {
    SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  }
}

// TODO code: optimise airspace drawing
void MapWindow::DrawAirSpace(HDC hdc, const RECT rc)
{
  COLORREF whitecolor = RGB(0xff,0xff,0xff);
  unsigned int i;
  
  bool found = false;

  if (AirspaceCircle) {
    // draw without border
    for(i=0;i<NumberOfAirspaceCircles;i++) {
      if (AirspaceCircle[i].Visible==2) {
	if (!found) {
	  ClearAirSpace(true);
	  found = true;
	}
        // this color is used as the black bit
        SetTextColor(hDCTemp,
                     Colours[iAirspaceColour[AirspaceCircle[i].Type]]);
        // get brush, can be solid or a 1bpp bitmap
        SelectObject(hDCTemp,
                     hAirspaceBrushes[iAirspaceBrush[AirspaceCircle[i].Type]]);
        Circle(hDCTemp,
               AirspaceCircle[i].Screen.x ,
               AirspaceCircle[i].Screen.y ,
               AirspaceCircle[i].ScreenR ,rc, true, true);
      }
    }
  }

  if (AirspaceArea) {
    for(i=0;i<NumberOfAirspaceAreas;i++) {
      if(AirspaceArea[i].Visible ==2) {
	if (!found) {
	  ClearAirSpace(true);
	  found = true;
	}
        // this color is used as the black bit
        SetTextColor(hDCTemp, 
                     Colours[iAirspaceColour[AirspaceArea[i].Type]]);
        SelectObject(hDCTemp,
                     hAirspaceBrushes[iAirspaceBrush[AirspaceArea[i].Type]]);         
        ClipPolygon(hDCTemp,
                    AirspaceScreenPoint+AirspaceArea[i].FirstPoint,
                    AirspaceArea[i].NumPoints, rc, true);
      }      
    }
  }
  
  ////////// draw it again, just the outlines

  if (found) {
    SelectObject(hDCTemp, GetStockObject(HOLLOW_BRUSH));
    SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
  }

  if (AirspaceCircle) {
    for(i=0;i<NumberOfAirspaceCircles;i++) {
      if (AirspaceCircle[i].Visible) {
	if (!found) {
	  ClearAirSpace(false);
	  found = true;
	}
        if (bAirspaceBlackOutline) {
          SelectObject(hDCTemp, GetStockObject(BLACK_PEN));
        } else {
          SelectObject(hDCTemp, hAirspacePens[AirspaceCircle[i].Type]);
        }
        Circle(hDCTemp,
               AirspaceCircle[i].Screen.x ,
               AirspaceCircle[i].Screen.y ,
               AirspaceCircle[i].ScreenR ,rc, true, false);
      }
    }
  }

  if (AirspaceArea) {
    for(i=0;i<NumberOfAirspaceAreas;i++) {
      if(AirspaceArea[i].Visible) {
	if (!found) {
	  ClearAirSpace(false);
	  found = true;
	}
        if (bAirspaceBlackOutline) {
          SelectObject(hDCTemp, GetStockObject(BLACK_PEN));
        } else {
          SelectObject(hDCTemp, hAirspacePens[AirspaceArea[i].Type]);
        }

	POINT *pstart = AirspaceScreenPoint+AirspaceArea[i].FirstPoint;
        ClipPolygon(hDCTemp, pstart,
                    AirspaceArea[i].NumPoints, rc, false);

	if (AirspaceArea[i].NumPoints>2) {
	  // JMW close if open
	  if ((pstart[0].x != pstart[AirspaceArea[i].NumPoints-1].x) ||
	      (pstart[0].y != pstart[AirspaceArea[i].NumPoints-1].y)) {
	    POINT ps[2];
	    ps[0] = pstart[0];
	    ps[1] = pstart[AirspaceArea[i].NumPoints-1];
	    _Polyline(hDCTemp, ps, 2, rc);
	  }
	}

      }      
    }
  }

  if (found) {
    // need to do this to prevent drawing of colored outline
    SelectObject(hDCTemp, GetStockObject(WHITE_PEN));
#if (WINDOWSPC<1)
    TransparentImage(hdc,
                     rc.left, rc.top,
                     rc.right-rc.left,rc.bottom-rc.top,
                     hDCTemp,
                     rc.left, rc.top,
                     rc.right-rc.left,rc.bottom-rc.top,
                     whitecolor
                     );
    
#else
    TransparentBlt(hdc,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   hDCTemp,
                   rc.left,rc.top,
                   rc.right-rc.left,rc.bottom-rc.top,
                   whitecolor
                   );
  #endif
    // restore original color
    //    SetTextColor(hDCTemp, origcolor);
    SetBkMode(hDCTemp,OPAQUE);
  }
}


void MapWindow::DrawMapScale(HDC hDC, const RECT rc /* the Map Rect*/, 
                             const bool ScaleChangeFeedback)
{


  if ((Appearance.MapScale == apMsDefault) || NewMap){

    TCHAR Scale[80];
    TCHAR Scale2[80];
    TCHAR TEMP[20];
    POINT Start, End;
    COLORREF whitecolor = RGB(0xd0,0xd0, 0xd0);
    COLORREF blackcolor = RGB(0x20,0x20, 0x20);
    COLORREF origcolor = SetTextColor(hDC, whitecolor);

    HPEN hpOld;
    TextInBoxMode_t TextDisplayMode; // VENTA7
    hpOld = (HPEN)SelectObject(hDC, hpMapScale2);

    // Apparently not used, so I am changing IBLSCALE(30) to 42 for NewMap
    // I'll make this mode more readable for PNA later

    // TODO use Appearance font Hight to calculate correct offset

    Start.x = rc.right-IBLSCALE(6); End.x = rc.right-IBLSCALE(6);
    Start.y = rc.bottom-IBLSCALE(42); End.y = Start.y - IBLSCALE(42);
    DrawSolidLine(hDC,Start,End, rc);

    Start.x = rc.right-IBLSCALE(11); End.x = rc.right-IBLSCALE(6);
    End.y = Start.y;
    DrawSolidLine(hDC,Start,End, rc);

    Start.y = Start.y - IBLSCALE(42); End.y = Start.y;
    DrawSolidLine(hDC,Start,End, rc);

    SelectObject(hDC, hpOld);

    _tcscpy(Scale2,TEXT(""));

    if (AutoZoom) {
      _tcscat(Scale2,TEXT(" A"));
    }
    if (EnablePan) {
      _tcscat(Scale2,TEXT(" PAN"));
    }
    if (EnableAuxiliaryInfo) {
      _tcscat(Scale2,TEXT(" AUX"));
    }

    if (DrawBottom) {
	switch(BottomMode) {
		case 0:
      			_tcscat(Scale2,TEXT(" THERMAL"));
			break;
		case 2:
      			_tcscat(Scale2,TEXT(" AUX"));
			break;
		case 3:
      			_tcscat(Scale2,TEXT(" TSK"));
			break;
		case 4:
      			_tcscat(Scale2,TEXT(" SYS"));
			break;
		default:
			break;
	}
    }

    if (ReplayLogger::IsEnabled()) {
      _tcscat(Scale2,TEXT(" REPLAY"));
    }
    if (BallastTimerActive) {
      _stprintf(TEMP,TEXT(" BALLAST %3.0f LITERS"), WEIGHTS[2]*BALLAST);
      _tcscat(Scale2, TEMP);
    }
    TCHAR Buffer[20];
    RASP.ItemLabel(RasterTerrain::render_weather, Buffer);
    if (_tcslen(Buffer)) {
      _tcscat(Scale,TEXT(" ")); 
      _tcscat(Scale, Buffer);
    }

    _tcscpy(Scale,TEXT(""));
    if(MapScale <0.1)
    {
      _stprintf(Scale,TEXT("%1.2f"),MapScale);
    }
    else if(MapScale <3)
    {
      _stprintf(Scale,TEXT("%1.1f"),MapScale);
    }
    else
    {
      _stprintf(Scale,TEXT("%1.0f"),MapScale);
    }
    _tcscat(Scale, Units::GetDistanceName()); 


    SIZE tsize;

    TextDisplayMode.AsInt = 0;
    TextDisplayMode.AsFlag.Color = TEXTWHITE;
    TextDisplayMode.AsFlag.WhiteBold = 1;
    TextDisplayMode.AsFlag.NoSetFont = 0;
    TextDisplayMode.AsFlag.AlligneRight = 0;
    TextDisplayMode.AsFlag.AlligneCenter = 0;

    GetTextExtentPoint(hDC, Scale, _tcslen(Scale), &tsize);
    TextInBox(hDC, Scale, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7), 0, TextDisplayMode,false);

    GetTextExtentPoint(hDC, Scale2, _tcslen(Scale2), &tsize);
    TextInBox(hDC, Scale2, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(7)+tsize.cy, 0, TextDisplayMode,false);


    #ifdef DRAWLOAD
    SelectObject(hDC, MapWindowFont);
    wsprintf(Scale,TEXT("            %d %d ms"), timestats_av,
             misc_tick_count);
    ExtTextOut(hDC, rc.left, rc.top, 0, NULL, Scale, _tcslen(Scale), NULL);
    #endif

    // restore original color
    SetTextColor(hDC, origcolor);

    SelectObject(hDC, hpOld);

  }
  if ((Appearance.MapScale == apMsAltA) && !NewMap){

    static int LastMapWidth = 0;
    double MapWidth;
    TCHAR ScaleInfo[80];
    TCHAR TEMP[20];

    HFONT          oldFont;
    int            Height;
    SIZE           TextSize;
    HBRUSH         oldBrush;
    HPEN           oldPen;
    COLORREF       oldTextColor;
    HBITMAP        oldBitMap;
    Units_t        Unit;


    if (ScaleChangeFeedback)
      MapWidth = (RequestMapScale * rc.right)/DISTANCEMODIFY/GetMapResolutionFactor();
    else
      MapWidth = (MapScale * rc.right)/DISTANCEMODIFY/GetMapResolutionFactor();

    oldFont = (HFONT)SelectObject(hDC, MapWindowBoldFont);

    Units::FormatUserMapScale(&Unit, MapWidth, ScaleInfo, 
                              sizeof(ScaleInfo)/sizeof(TCHAR));
    GetTextExtentPoint(hDC, ScaleInfo, _tcslen(ScaleInfo), &TextSize);
    LastMapWidth = (int)MapWidth;

    Height = Appearance.MapWindowBoldFont.CapitalHeight+IBLSCALE(2);  

    // 2: add 1pix border

    oldBrush = (HBRUSH)SelectObject(hDC, GetStockObject(WHITE_BRUSH));
    oldPen = (HPEN)SelectObject(hDC, GetStockObject(WHITE_PEN));
    Rectangle(hDC, 0, rc.bottom-Height, 
              TextSize.cx + IBLSCALE(21), rc.bottom);

    if (ScaleChangeFeedback){
      SetBkMode(hDC, TRANSPARENT);
      oldTextColor = SetTextColor(hDC, RGB(0xff,0,0));
    }else 
       oldTextColor = SetTextColor(hDC, RGB(0,0,0));

    ExtTextOut(hDC, IBLSCALE(7), 
           rc.bottom-Appearance.MapWindowBoldFont.AscentHeight-IBLSCALE(1), 
           0, NULL, ScaleInfo, _tcslen(ScaleInfo), NULL);

    oldBitMap = (HBITMAP)SelectObject(hDCTemp, hBmpMapScale);

    DrawBitmapX(hDC, 0, rc.bottom-Height, 6, 11, hDCTemp, 0, 0, SRCCOPY);
    DrawBitmapX(hDC, 
           IBLSCALE(14)+TextSize.cx, 
           rc.bottom-Height, 8, 11, hDCTemp, 6, 0, SRCCOPY);

    if (!ScaleChangeFeedback){
      HBITMAP Bmp;
      POINT   BmpPos, BmpSize;

      if (Units::GetUnitBitmap(Unit, &Bmp, &BmpPos, &BmpSize, 0)){
        HBITMAP oldBitMapa = (HBITMAP)SelectObject(hDCTemp, Bmp);

        DrawBitmapX(hDC, 
                    IBLSCALE(8)+TextSize.cx, rc.bottom-Height, 
                    BmpSize.x, BmpSize.y, 
                    hDCTemp, BmpPos.x, BmpPos.y, SRCCOPY);
        SelectObject(hDCTemp, oldBitMapa);
      }
    }

    int y = rc.bottom-Height-
      (Appearance.TitleWindowFont.AscentHeight+IBLSCALE(2));
    if (!ScaleChangeFeedback){
      // bool FontSelected = false;
      // TODO code: gettext these
      ScaleInfo[0] = 0;
      if (AutoZoom) {
        _tcscat(ScaleInfo, TEXT("AUTO "));
      }
      if (TargetPan) {
        _tcscat(ScaleInfo, TEXT("TARGET "));
      } else if (EnablePan) {
        _tcscat(ScaleInfo, TEXT("PAN "));
      }
      if (EnableAuxiliaryInfo) {
        _tcscat(ScaleInfo, TEXT("AUX "));
      }
      if (ReplayLogger::IsEnabled()) {
        _tcscat(ScaleInfo, TEXT("REPLAY "));
      }
      if (BallastTimerActive) {
        _stprintf(TEMP,TEXT("BALLAST %3.0f LITERS"), WEIGHTS[2]*BALLAST);
        _tcscat(ScaleInfo, TEMP);
      }
      TCHAR Buffer[20];
      RASP.ItemLabel(RasterTerrain::render_weather, Buffer);
      if (_tcslen(Buffer)) {
        _tcscat(ScaleInfo, Buffer);
      }

      if (ScaleInfo[0]) {
        SelectObject(hDC, TitleWindowFont);
        // FontSelected = true;
        ExtTextOut(hDC, IBLSCALE(1), y, 0, NULL, ScaleInfo, 
                   _tcslen(ScaleInfo), NULL);
        y -= (Appearance.TitleWindowFont.CapitalHeight+IBLSCALE(1));
      }
    }

    #ifdef DRAWLOAD
    SelectObject(hDC, MapWindowFont);
    wsprintf(ScaleInfo,TEXT("    %d %d ms"), 
             timestats_av,
             misc_tick_count);

    ExtTextOut(hDC, rc.left, rc.top, 0, NULL, ScaleInfo, 
               _tcslen(ScaleInfo), NULL);
    #endif

    SetTextColor(hDC, oldTextColor);
    SelectObject(hDC, oldPen);
    SelectObject(hDC, oldFont);
    SelectObject(hDC, oldBrush);
    SelectObject(hDCTemp, oldBitMap);

  }

}


void MapWindow::DrawGlideThroughTerrain(HDC hDC, const RECT rc) {
  HPEN hpOld;

  hpOld = (HPEN)SelectObject(hDC, 
                             hpTerrainLineBg);  //sjt 02feb06 added bg line

  SelectObject(hDC,hpTerrainLineBg);
  _Polyline(hDC,Groundline,NUMTERRAINSWEEPS+1, rc);
  if ((FinalGlideTerrain==1) || 
      ((!EnableTerrain || !DerivedDrawInfo.Flying) && (FinalGlideTerrain==2))) {
    SelectObject(hDC,hpTerrainLine);
    _Polyline(hDC,Groundline,NUMTERRAINSWEEPS+1, rc);
  }

  if (DerivedDrawInfo.Flying && ValidTaskPoint(ActiveWayPoint)) {
    if ((DerivedDrawInfo.TerrainWarningLatitude != 0.0)
        &&(DerivedDrawInfo.TerrainWarningLongitude != 0.0)) {
      
      POINT sc;
      if (PointVisible(DerivedDrawInfo.TerrainWarningLongitude,
                       DerivedDrawInfo.TerrainWarningLatitude)) {
        LatLon2Screen(DerivedDrawInfo.TerrainWarningLongitude,
                      DerivedDrawInfo.TerrainWarningLatitude, sc);
        DrawBitmapIn(hDC, sc, hTerrainWarning);
      }
    }
  }

  SelectObject(hDC, hpOld);

}

void MapWindow::DrawBestCruiseTrack(HDC hdc, const POINT Orig)
{
  HPEN hpOld;
  HBRUSH hbOld;

  if (ActiveWayPoint<0) {
    return; // nothing to draw..
  }
  if (!ValidTaskPoint(ActiveWayPoint)) {
    return;
  }

  if (DerivedDrawInfo.WaypointDistance < 0.010)
    return;

  hpOld = (HPEN)SelectObject(hdc, hpBestCruiseTrack);
  hbOld = (HBRUSH)SelectObject(hdc, hbBestCruiseTrack);

  if (Appearance.BestCruiseTrack == ctBestCruiseTrackDefault){

    int dy = (long)(70); 
    POINT Arrow[7] = { {-1,-40}, {1,-40}, {1,0}, {6,8}, {-6,8}, {-1,0}, {-1,-40}};

    Arrow[2].y -= dy;
    Arrow[3].y -= dy;
    Arrow[4].y -= dy;
    Arrow[5].y -= dy;

    PolygonRotateShift(Arrow, 7, Orig.x, Orig.y, 
                       DerivedDrawInfo.BestCruiseTrack-DisplayAngle);

    Polygon(hdc,Arrow,7);

  } else
  if (Appearance.BestCruiseTrack == ctBestCruiseTrackAltA){

    POINT Arrow[] = { {-1,-40}, {-1,-62}, {-6,-62}, {0,-70}, {6,-62}, {1,-62}, {1,-40}, {-1,-40}};

    PolygonRotateShift(Arrow, sizeof(Arrow)/sizeof(Arrow[0]),
                       Orig.x, Orig.y, 
                       DerivedDrawInfo.BestCruiseTrack-DisplayAngle);
    Polygon(hdc, Arrow, (sizeof(Arrow)/sizeof(Arrow[0])));
  }

  SelectObject(hdc, hpOld);
  SelectObject(hdc, hbOld);
}
@


1.7
log
@ok
@
text
@@



1.6
log
@alfa
@
text
@d2648 20
d2695 1
a2695 1
    _tcscat(Scale, Units::GetDistanceName()); // VENTA7 trying to make it shorter for PNA
@


1.5
log
@ok
@
text
@a177 1

d2605 1
a2605 4
  if (NewMap) Appearance.MapScale = apMsDefault; else
	  Appearance.MapScale = apMsAltA;
  
  if (Appearance.MapScale == apMsDefault){
d2608 1
d2611 4
d2616 2
a2617 1
    hpOld = (HPEN)SelectObject(hDC, hpMapScale);
d2622 2
d2637 1
a2637 14
    if(MapScale <0.1)
    {
      _stprintf(Scale,TEXT("%1.2f"),MapScale);
    }
    else if(MapScale <3)
    {
      _stprintf(Scale,TEXT("%1.1f"),MapScale);
    }
    else
    {
      _stprintf(Scale,TEXT("%1.0f"),MapScale);
    }

    _tcscat(Scale, Units::GetDistanceName());
d2640 1
a2640 1
      _tcscat(Scale,TEXT(" A"));
d2643 1
a2643 1
      _tcscat(Scale,TEXT(" PAN"));
d2646 1
a2646 1
      _tcscat(Scale,TEXT(" AUX"));
d2649 1
a2649 1
      _tcscat(Scale,TEXT(" REPLAY"));
d2653 1
a2653 1
      _tcscat(Scale, TEMP);
d2658 1
a2658 1
      _tcscat(Scale,TEXT(" "));
d2662 16
d2679 8
d2688 1
d2690 2
a2691 3
    COLORREF whitecolor = RGB(0xd0,0xd0, 0xd0);
    COLORREF blackcolor = RGB(0x20,0x20, 0x20);
    COLORREF origcolor = SetTextColor(hDC, whitecolor);
a2692 7
    SetTextColor(hDC, whitecolor);
    ExtTextOut(hDC, rc.right-IBLSCALE(11)-tsize.cx, End.y+IBLSCALE(8), 0, 
               NULL, Scale, _tcslen(Scale), NULL);

    SetTextColor(hDC, blackcolor);
    ExtTextOut(hDC, rc.right-IBLSCALE(10)-tsize.cx, End.y+IBLSCALE(7), 0, 
               NULL, Scale, _tcslen(Scale), NULL);
d2707 1
a2707 1
  if (Appearance.MapScale == apMsAltA){
@


1.4
log
@ok
@
text
@d2606 3
d2617 3
d2621 1
a2621 1
    Start.y = rc.bottom-IBLSCALE(30); End.y = Start.y - IBLSCALE(30);
d2628 1
a2628 1
    Start.y = Start.y - IBLSCALE(30); End.y = Start.y;
d2715 1
d2722 1
d2729 1
d2736 1
d2740 2
a2741 2
    }else
      oldTextColor = SetTextColor(hDC, RGB(0,0,0));
d2744 2
a2745 2
               rc.bottom-Appearance.MapWindowBoldFont.AscentHeight-IBLSCALE(1), 
               0, NULL, ScaleInfo, _tcslen(ScaleInfo), NULL);
@


1.3
log
@ok
@
text
@d2096 1
a2096 1
   * VENTA draw finalglide bar mode:
d2102 1
a2102 1
   if (GlideBarMode == (GlideBarMode_t)gbDisabled) return;
d2140 1
a2140 1
   if (GlideBarMode == (GlideBarMode_t)gbFinish) {
d2143 1
a2143 1
      } else {
d2146 1
a2146 1
      }
d2244 1
a2244 1
   if (GlideBarMode == (GlideBarMode_t)gbFinish) {
d2280 1
a2280 1
   if (GlideBarMode == (GlideBarMode_t)gbFinish) {
d2314 1
a2314 1
   if (GlideBarMode == (GlideBarMode_t)gbFinish) {
d2367 1
a2367 1

d2372 1
d2375 1
a2375 1
    }
d2412 1
a2412 1

d2417 1
d2420 1
a2420 1
	}
@


1.2
log
@aghg
@
text
@d2368 7
a2374 2
    Start.y = IBLSCALE(19)+rc.top;
    Start.x = rc.right - IBLSCALE(19);
d2412 7
a2418 2
      Start.y = rc.top + IBLSCALE(10);
      Start.x = rc.right - IBLSCALE(11);
@


1.1
log
@Initial revision
@
text
@d38 1
d971 1
a971 1

d976 1
d999 17
d1027 3
d1070 3
d1088 2
d2096 10
d2140 7
a2146 3

      Offset = ((int)DerivedDrawInfo.TaskAltitudeDifference)/8; 
      Offset0 = ((int)DerivedDrawInfo.TaskAltitudeDifference0)/8; 
d2243 2
d2259 18
d2280 1
d2283 4
d2314 1
d2317 4
@
