head	8.3;
access;
symbols
	beta8:8.1;
locks
	root:8.3; strict;
comment	@// @;


8.3
date	2010.12.10.22.13.23;	author root;	state Exp;
branches;
next	8.2;

8.2
date	2009.10.07.18.46.45;	author root;	state Exp;
branches;
next	8.1;

8.1
date	2009.06.19.20.28.25;	author venta;	state Exp;
branches;
next	;


desc
@none
@


8.3
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: AirfieldDetails.cpp,v 8.2 2009/10/07 18:46:45 root Exp root $
*/


#include "StdAfx.h"
#include "Utils.h"
#include "Sizes.h"
#include "externs.h"
#include "Dialogs.h"
#include "Utils.h"
#include "options.h"

#include <aygshell.h>

#include "AirfieldDetails.h"
#include <zzip/lib.h>
#include "wcecompat/ts_string.h"

ZZIP_FILE* zAirfieldDetails = NULL;

static TCHAR  szAirfieldDetailsFile[MAX_PATH] = TEXT("\0");

void OpenAirfieldDetails() {
  char zfilename[MAX_PATH] = "\0";

  zAirfieldDetails = NULL;

  GetRegistryString(szRegistryAirfieldFile, szAirfieldDetailsFile, MAX_PATH);

  if (_tcslen(szAirfieldDetailsFile)>0) {
    ExpandLocalPath(szAirfieldDetailsFile);
    unicode2ascii(szAirfieldDetailsFile, zfilename, MAX_PATH);
    SetRegistryString(szRegistryAirfieldFile, TEXT("\0"));
  } else {
	#if 0
	LocalPathS(zfilename,_T(LKD_WAYPOINTS));
	strcat(zfilename,"\\"); 
	strcat(zfilename,LKF_AIRFIELDS);
	#else
	strcpy(zfilename,"");
	#endif
  }
  if (strlen(zfilename)>0) {
    zAirfieldDetails = zzip_fopen(zfilename,"rb");
  }
};


void CloseAirfieldDetails() {
  if (zAirfieldDetails == NULL) {
    return;
  }
  // file was OK, so save the registry
  ContractLocalPath(szAirfieldDetailsFile);
  SetRegistryString(szRegistryAirfieldFile, szAirfieldDetailsFile);

  zzip_fclose(zAirfieldDetails);
  zAirfieldDetails = NULL;
};


void LookupAirfieldDetail(TCHAR *Name, TCHAR *Details) {
  int i;
  TCHAR UName[100];
  TCHAR NameA[100];
  TCHAR NameB[100];
  TCHAR NameC[100];
  TCHAR NameD[100];
  TCHAR TmpName[100];

  bool isHome, isPreferred, isAvoid;

  if (!WayPointList) return;

  for(i=NUMRESWP;i<(int)NumberOfWayPoints;i++) {
      if (((WayPointList[i].Flags & AIRPORT) == AIRPORT) || ((WayPointList[i].Flags & LANDPOINT) == LANDPOINT)) { 
	_tcscpy(UName, WayPointList[i].Name);

	CharUpper(UName); // WP name
	CharUpper(Name);  // AIR name  If airfields name was not uppercase it was not recon

	_stprintf(NameA,TEXT("%s A/F"),Name);
	_stprintf(NameB,TEXT("%s AF"),Name);
	_stprintf(NameC,TEXT("%s A/D"),Name);
	_stprintf(NameD,TEXT("%s AD"),Name);

	isHome=false;
	isPreferred=false;
	isAvoid=false;

	_stprintf(TmpName,TEXT("%s=HOME"),UName);
	if ( (_tcscmp(Name, TmpName)==0) )  isHome=true;
	_stprintf(TmpName,TEXT("%s=PREF"),UName);
	if ( (_tcscmp(Name, TmpName)==0) )  isPreferred=true;
	_stprintf(TmpName,TEXT("%s=PREFERRED"),UName);
	if ( (_tcscmp(Name, TmpName)==0) )  isPreferred=true;

	if ( isHome==true ) {
	  WayPointCalc[i].Preferred = true;
	  HomeWaypoint = i;
	  AirfieldsHomeWaypoint = i; // make it survive a reset..
	}
	if ( isPreferred==true ) {
	  WayPointCalc[i].Preferred = true;
	}

	if ((_tcscmp(UName, Name)==0)
	    ||(_tcscmp(UName, NameA)==0)
	    ||(_tcscmp(UName, NameB)==0)
	    ||(_tcscmp(UName, NameC)==0)
	    ||(_tcscmp(UName, NameD)==0)
	    || isHome || isPreferred )
	  {
	    if (_tcslen(Details) >0 ) { // avoid setting empty details
	      if (WayPointList[i].Details) {
		free(WayPointList[i].Details);
	      }
	      WayPointList[i].Details = (TCHAR*)malloc((_tcslen(Details)+1)*sizeof(TCHAR));
	      _tcscpy(WayPointList[i].Details, Details);
	    } 
	    return;
	  }
      }
    }
}


#define DETAILS_LENGTH 5000

/*
 * fix: if empty lines, do not set details for the waypoint
 * fix: remove CR from text appearing as a spurious char in waypoint details
 */
void ParseAirfieldDetails() {

  if(zAirfieldDetails == NULL)
    return;

  TCHAR TempString[READLINE_LENGTH+1];
  TCHAR CleanString[READLINE_LENGTH+1];
  TCHAR Details[DETAILS_LENGTH+1];
  TCHAR Name[201];

  Details[0]= 0;
  Name[0]= 0;
  TempString[0]=0;
  CleanString[0]=0;

  bool inDetails = false;
  bool hasDetails = false;
  int i, n;
  unsigned int j;
  int k=0;

  while(ReadString(zAirfieldDetails,READLINE_LENGTH,TempString))
    {
      if(TempString[0]=='[') { // Look for start

	if (inDetails) {
	  LookupAirfieldDetail(Name, Details);
	  Details[0]= 0;
	  Name[0]= 0;
	  hasDetails=false;
	}

	// extract name
	for (i=1; i<200; i++) {
	  if (TempString[i]==']') {
	    break;
	  }
	  Name[i-1]= TempString[i];
	}
	Name[i-1]= 0;

	inDetails = true;

        if (k % 20 == 0) {
          StepProgressDialog();
        }
        k++;

      } else {
	// VENTA3: append text to details string
	if (inDetails)  // BUGFIX 100711
	for (j=0; j<_tcslen(TempString); j++ ) {
	  if ( TempString[j] > 0x20 ) {
	    hasDetails = true;
	    break;
	  }
	}
	// first hasDetails set TRUE for rest of details
	if (hasDetails==true) {

	  // Remove carriage returns
	  for (j=0, n=0; j<_tcslen(TempString); j++) {
	    if ( TempString[j] == 0x0d ) continue;
	    CleanString[n++]=TempString[j];
	  }
	  CleanString[n]='\0';

	  if (_tcslen(Details)+_tcslen(CleanString)+3<DETAILS_LENGTH) {
	    wcscat(Details,CleanString);
	    wcscat(Details,TEXT("\r\n"));
	  }
	}
      }
    }

  if (inDetails) {
    LookupAirfieldDetail(Name, Details);
  }

}


void ReadAirfieldFile() {

  StartupStore(TEXT(". ReadAirfieldFile%s"),NEWLINE);

  CreateProgressDialog(gettext(TEXT("Loading Waypoint Notes File...")));

  {
    OpenAirfieldDetails();
    ParseAirfieldDetails();
    CloseAirfieldDetails();
  }

}

@


8.2
log
@BOOL
@
text
@d2 3
d6 1
a6 35
Copyright_License {

  XCSoar Glide Computer - http://xcsoar.sourceforge.net/
  Copyright (C) 2000 - 2008  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  $Id: AirfieldDetails.cpp,v 8.1 2009/06/19 20:28:25 venta Exp root $
}

a14 1
#include "resource.h"
d40 7
a46 11
    static TCHAR szMapFile[MAX_PATH] = TEXT("\0");
    static TCHAR szFile[MAX_PATH] = TEXT("\0");
    GetRegistryString(szRegistryMapFile, szMapFile, MAX_PATH);
    if (_tcslen(szMapFile)>0) {
      ExpandLocalPath(szMapFile);
      _tcscpy(szFile,szMapFile);
      wcscat(szFile,TEXT(LKF_AIRFIELDS));
      unicode2ascii(szFile, zfilename, MAX_PATH);
    } else {
      zfilename[0]= 0;
    }
a66 4
/*
 * VENTA3: Home and Preferred landing points for BestAlternate 
 * Paolo Ventafridda
 */
d76 1
a76 3
  //TCHAR ventabuffer[200];

  BOOL isHome, isPreferred, isAvoid;
d80 2
a81 4
  for(i=0;i<(int)NumberOfWayPoints;i++)
    {
      if (((WayPointList[i].Flags & AIRPORT) == AIRPORT) ||
	  ((WayPointList[i].Flags & LANDPOINT) == LANDPOINT)) {
d85 1
a85 8
	CharUpper(Name);  // AIR name 
	                  // VENTA3 fix: If airfields name
			  // was not uppercase it was not recon

	/*
	  wsprintf(ventabuffer,TEXT("Name=<%s>"), UName );
	  if ((fp=_tfopen(_T("DEBUG.TXT"),_T("a")))!= NULL){;fprintf(fp,"%S\n",ventabuffer);fclose(fp);}
	*/
d92 3
a94 3
	isHome=FALSE;
	isPreferred=FALSE;
	isAvoid=FALSE;
d97 1
a97 1
	if ( (_tcscmp(Name, TmpName)==0) )  isHome=TRUE;
d99 1
a99 1
	if ( (_tcscmp(Name, TmpName)==0) )  isPreferred=TRUE;
d101 1
a101 1
	if ( (_tcscmp(Name, TmpName)==0) )  isPreferred=TRUE;
d103 2
a104 2
	if ( isHome==TRUE ) {
	  WayPointCalc[i].Preferred = TRUE;
d108 2
a109 2
	if ( isPreferred==TRUE ) {
	  WayPointCalc[i].Preferred = TRUE;
d119 1
a119 1
	    if (_tcslen(Details) >0 ) { // VENTA3 avoid setting empty details
d136 2
a137 2
 * VENTA3 fix: if empty lines, do not set details for the waypoint
 *        fix: remove CR from text appearing as a spurious char in waypoint details
d154 2
a155 2
  BOOL inDetails = FALSE;
  BOOL hasDetails = FALSE; // VENTA3
d168 1
a168 1
	  hasDetails=FALSE;
d180 1
a180 1
	inDetails = TRUE;
d189 1
d192 1
a192 1
	    hasDetails = TRUE;
d197 1
a197 1
	if (hasDetails==TRUE) {
d223 1
a223 1
  StartupStore(TEXT("ReadAirfieldFile\n"));
d225 1
a225 1
  CreateProgressDialog(gettext(TEXT("Loading Airfield Details File...")));
@


8.1
log
@beta8
@
text
@d35 1
a35 1
  $Id: AirfieldDetails.cpp,v 1.32 2009/05/23 01:25:10 jwharington Exp $
d78 1
a78 1
      wcscat(szFile,TEXT("/airfields.txt"));
d116 1
a116 1
  TCHAR ventabuffer[200];
d207 2
a208 1
  int i, j, n;
@
