head	8.24;
access;
symbols
	beta8:8.1;
locks
	root:8.24; strict;
comment	@// @;


8.24
date	2010.12.13.01.33.27;	author root;	state Exp;
branches;
next	8.23;

8.23
date	2010.02.10.19.35.09;	author root;	state Exp;
branches;
next	8.22;

8.22
date	2010.01.26.17.19.40;	author root;	state Exp;
branches;
next	8.21;

8.21
date	2009.12.01.23.24.56;	author root;	state Exp;
branches;
next	8.20;

8.20
date	2009.11.25.23.26.58;	author root;	state Exp;
branches;
next	8.19;

8.19
date	2009.11.25.16.34.18;	author root;	state Exp;
branches;
next	8.18;

8.18
date	2009.11.18.21.48.33;	author root;	state Exp;
branches;
next	8.17;

8.17
date	2009.11.09.16.16.07;	author root;	state Exp;
branches;
next	8.16;

8.16
date	2009.10.31.22.58.33;	author root;	state Exp;
branches;
next	8.15;

8.15
date	2009.10.19.22.31.13;	author root;	state Exp;
branches;
next	8.14;

8.14
date	2009.10.12.13.25.02;	author root;	state Exp;
branches;
next	8.13;

8.13
date	2009.09.25.00.10.26;	author root;	state Exp;
branches;
next	8.12;

8.12
date	2009.09.21.12.16.42;	author root;	state Exp;
branches;
next	8.11;

8.11
date	2009.09.07.19.08.43;	author root;	state Exp;
branches;
next	8.10;

8.10
date	2009.07.30.13.38.31;	author root;	state Exp;
branches;
next	8.9;

8.9
date	2009.07.24.14.32.05;	author root;	state Exp;
branches;
next	8.8;

8.8
date	2009.07.22.10.54.08;	author root;	state Exp;
branches;
next	8.7;

8.7
date	2009.07.17.15.26.25;	author root;	state Exp;
branches;
next	8.6;

8.6
date	2009.07.05.22.57.16;	author root;	state Exp;
branches;
next	8.5;

8.5
date	2009.07.01.22.26.02;	author root;	state Exp;
branches;
next	8.4;

8.4
date	2009.06.28.21.32.44;	author root;	state Exp;
branches;
next	8.3;

8.3
date	2009.06.27.17.18.55;	author root;	state Exp;
branches;
next	8.2;

8.2
date	2009.06.24.10.04.03;	author root;	state Exp;
branches;
next	8.1;

8.1
date	2009.06.19.20.28.25;	author venta;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.16.14.07.59;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.11.19.50.31;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.08.13.28.08;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.02.14.48.01;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.01.21.19.50;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.25.12.59.35;	author root;	state Exp;
branches;
next	;


desc
@@

8.24
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: XCSoar.cpp,v 8.23 2010/02/10 19:35:09 root Exp root $
*/

#include "StdAfx.h"
#include "options.h"
#include "compatibility.h"
#include "XCSoar.h"
#include "buildnumber.h"
#include "Cpustats.h"
#include "MapWindow.h"
#include "Parser.h"
#include "Calculations.h"
#include "Calculations2.h"
#include "Task.h"
#include "Dialogs.h"

#ifdef OLDPPCx
#include "XCSoarProcess.h"
#else
#include "Process.h"
#endif

#include "Utils.h"
#include "Utils2.h"
#include "Port.h"
#include "Waypointparser.h"
#include "Airspace.h"
#include "Logger.h"
#include "McReady.h"
#include "AirfieldDetails.h"
#include "InfoBoxLayout.h"

#include <commctrl.h>
#include <aygshell.h>
#if (WINDOWSPC<1)
#include <sipapi.h>
#endif

#include "Terrain.h"
#include "VarioSound.h"
#include "device.h"

#include "devCAI302.h"
#include "devCaiGpsNav.h"
#include "devEW.h"
#include "devAltairPro.h"
#include "devGeneric.h"
#include "devVega.h"
#include "devNmeaOut.h"
#include "devPosiGraph.h"
#include "devBorgeltB50.h"
#include "devVolkslogger.h"
#include "devEWMicroRecorder.h"
#include "devLX.h"
#include "devZander.h"
#include "devFlymasterF1.h"
#include "devCompeo.h"
#include "devDigifly.h"
#include "devXCOM760.h"
#include "devCondor.h"
#include "devIlec.h"

#include "externs.h"
#include "Units.h"
#include "InputEvents.h"
#include "Message.h"
#include "Atmosphere.h"
#include "Geoid.h"

#include "InfoBox.h"
#include "RasterTerrain.h"
#if LKOBJ
extern void LKObjects_Create();
extern void LKObjects_Delete();
#include "LKMainObjects.h"
#endif

#ifdef DEBUG_TRANSLATIONS
#include <map>
static std::map<TCHAR*, TCHAR*> unusedTranslations;
#endif

#if !defined(MapScale2)
  #define MapScale2  apMs2Default
#endif

#if SAMGI
Appearance_t Appearance = {
  apMsAltA,
  apMs2None,
  true,
  206,
  {0,-13},
  apFlightModeIconAltA,
  //apFlightModeIconDefault,
  {10,3},
  apCompassAltA,
  {0,0,0},
  {0,0,0},
  {0,0,0},
  {0,0,0},
  {0,0,0},
  ctBestCruiseTrackAltA,
  afAircraftAltA,
  true,
  fgFinalGlideAltA,
  wpLandableAltA,
  true,
  true,
  true,
  smAlligneTopLeft,
  true,
  true,
  true,
  true,
  true,
  gvnsDefault, 
  false,
  apIbBox,
  false,
  true,
  false
};
#else

Appearance_t Appearance = {
  apMsAltA, // mapscale
  MapScale2, 
  false, // don't show logger indicator
  206,
  {0,-13},
  apFlightModeIconDefault,
  {0,0},
  apCompassAltA,
  {0,0,0},
  {0,0,0},
  {0,0,0},
  {0,0,0},
  {0,0,0},
  {0,0,0},
  {0,0,0},
  {0,0,0},
  ctBestCruiseTrackAltA,
  afAircraftAltA,
  true, // don't show speed to fly
  fgFinalGlideDefault,
  wpLandableDefault,
  true,
  false,
  true,
  smAlligneCenter,
  tiHighScore,
  false,
  false,
  false,
  false,
  false,
  gvnsLongNeedle,
  true,
  apIbBox,
#if defined(PNA) || defined(FIVV)  // VENTA-ADDON Model type
  apIg0,  // VENTA-ADDON GEOM
  apImPnaGeneric,
#endif
  false,
  true,
  false
};

#endif


TCHAR XCSoar_Version[256] = TEXT("");

bool ForceShutdown = false;

HINSTANCE hInst; // The current instance
//HWND hWndCB; // The command bar handle
HWND hWndMainWindow; // Main Windows
HWND hWndMapWindow;  // MapWindow

#ifdef CPUSTATS
HANDLE hCalculationThread;
DWORD dwCalcThreadID;
HANDLE hInstrumentThread;
DWORD dwInstThreadID;
#endif

int numInfoWindows = 9;



InfoBox *InfoBoxes[MAXINFOWINDOWS];

int                                     InfoType[MAXINFOWINDOWS] = 
#ifdef GNAV
  {
    873336334,
    856820491,
    822280982,
    2829105,
    103166000,
    421601569,
    657002759,
    621743887,
    439168301
  };
#else
  {1008146198,
   1311715074,
   923929365,
   975776319,
   956959267,
   1178420506,
   1410419993,
   1396384771,
   387389207};
#endif
/* OLD
  {921102,
   725525,
   262144,
   74518,
   657930,
   2236963,
   394758,
   1644825,
   1644825};
*/


bool RequestAirspaceWarningDialog= false;
bool RequestAirspaceWarningForce=false;
bool                                    DisplayLocked = true;
bool                                    InfoWindowActive = true;
bool                                    EnableAuxiliaryInfo = false;
int                                     InfoBoxFocusTimeOut = 0;
int                                     MenuTimeOut = 0;
int                                     DisplayTimeOut = 0;
int                                     MenuTimeoutMax = MENUTIMEOUTMAX;


HBRUSH hBrushSelected;
HBRUSH hBrushUnselected;
HBRUSH hBrushButton;
COLORREF ColorSelected = RGB(0xC0,0xC0,0xC0);
COLORREF ColorUnselected = RGB(0xFF,0xFF,0xFF);
COLORREF ColorWarning = RGB(0xFF,0x00,0x00);
COLORREF ColorOK = RGB(0x00,0x00,0xFF);
COLORREF ColorButton = RGB(0xA0,0xE0,0xA0);
//COLORREF ColorButton = RGB_BUTTONS; // 091230

// Display Gobals
HFONT                                   InfoWindowFont;
HFONT                                   TitleWindowFont;
HFONT                                   MapWindowFont;
HFONT                                   TitleSmallWindowFont;
HFONT                                   MapWindowBoldFont;
HFONT                                   CDIWindowFont; // New
HFONT                                   MapLabelFont;
HFONT                                   StatisticsFont;

HFONT                                   LK8UnitFont;
HFONT                                   LK8TitleFont;
HFONT                                   LK8MapFont;
HFONT                                   LK8TitleNavboxFont;
HFONT                                   LK8ValueFont;
HFONT                                   LK8TargetFont;
HFONT                                   LK8BigFont;
HFONT                                   LK8MediumFont;
HFONT                                   LK8SmallFont;
HFONT					LK8SymbolFont;
HFONT					LK8InfoBigFont;
HFONT					LK8InfoBigItalicFont;
HFONT					LK8InfoNormalFont;
HFONT					LK8InfoSmallFont;
HFONT					LK8PanelBigFont;
HFONT					LK8PanelMediumFont;
HFONT					LK8PanelSmallFont;
HFONT					LK8PanelUnitFont;

LOGFONT                                   autoInfoWindowLogFont; // these are the non-custom parameters
LOGFONT                                   autoTitleWindowLogFont;
LOGFONT                                   autoMapWindowLogFont;
LOGFONT                                   autoTitleSmallWindowLogFont;
LOGFONT                                   autoMapWindowBoldLogFont;
LOGFONT                                   autoCDIWindowLogFont; // New
LOGFONT                                   autoMapLabelLogFont;
LOGFONT                                   autoStatisticsLogFont;

int  UseCustomFonts;
int                                             CurrentInfoType;
int                                             InfoFocus = 0;
int                                             DisplayOrientation = TRACKUP;
#if AUTORIENT
int                                             OldDisplayOrientation = TRACKUP;
int AutoOrientScale = 10;
#endif
int                                             DisplayTextType = DISPLAYNONE;

int                                             AltitudeMode = ALLON;
int                                             ClipAltitude = 1000;
int                                             AltWarningMargin = 100;
int                                             AutoAdvance = 1;
bool                                            AdvanceArmed = false;

int                                             SafetyAltitudeMode = 0;
short	ScreenSize=0; // VENTA6

bool EnableBlockSTF = false;

bool GlobalRunning = false; 

#if defined(PNA) || defined(FIVV)  // VENTA-ADDON we call it model and not PNA for possible future usage even for custom PDAs
int	GlobalModelType=MODELTYPE_PNA_PNA;
TCHAR	GlobalModelName[MAX_PATH]; // there are currently no checks.. TODO check it fits here
float	GlobalEllipse=1.1f;	// default ellipse type VENTA2-ADDON
#endif


// this controls all displays, to make sure everything is
// properly initialised.


//SI to Local Units
double        SPEEDMODIFY = TOKNOTS;
double        LIFTMODIFY  = TOKNOTS;
double        DISTANCEMODIFY = TONAUTICALMILES;
double        ALTITUDEMODIFY = TOFEET;
double        TASKSPEEDMODIFY = TOKPH;

//Flight Data Globals
double        MACCREADY = 0; // JMW now in SI units (m/s) for consistency
double        QNH = (double)1013.25; // 100413 changed to .25
double        BUGS = 1;
double        BALLAST = 0;

bool          AutoMacCready = false;

int          NettoSpeed = 1000;

NMEA_INFO     GPS_INFO;
DERIVED_INFO  CALCULATED_INFO;

BOOL GPSCONNECT = FALSE;
BOOL extGPSCONNECT = FALSE; // this one used by external functions

#ifndef NOTASKABORT
bool          TaskAborted = false;
#endif

bool InfoBoxesDirty= false;
bool DialogActive = false;

// 091011 Used by TakeoffLanding inside Calculation.cpp - limited values careful 
int time_in_flight=0;
int time_on_ground=0;
double TakeOffSpeedThreshold=0.0;

#if LKSTARTUP
BYTE RUN_MODE=RUN_WELCOME;
#endif

DWORD EnableFLARMMap = 1;

#ifdef COMDIAG
// 100210 Comport diagnostics, see Utils2.h
// Using 0,1, plus +1 for safety 
int ComPortStatus[NUMDEV+1];
long ComPortRx[NUMDEV+1];
long ComPortTx[NUMDEV+1];
long ComPortErrRx[NUMDEV+1];
long ComPortErrTx[NUMDEV+1];
long ComPortErrors[NUMDEV+1];
#endif
// Com ports hearth beats, based on LKHearthBeats
double ComPortHB[NUMDEV+1];

//Local Static data
static int iTimerID= 0;

// Final Glide Data
double SAFETYALTITUDEARRIVAL = 300;
double SAFETYALTITUDEBREAKOFF = 0;
double SAFETYALTITUDETERRAIN = 50;
double SAFTEYSPEED = 50.0;

// polar info
int              POLARID = 0;
double POLAR[POLARSIZE] = {0,0,0};
double POLARV[POLARSIZE] = {21,27,40};
double POLARLD[POLARSIZE] = {33,30,20};
double WEIGHTS[POLARSIZE] = {250,70,100};

// Team code info
int TeamCodeRefWaypoint = -1;
TCHAR TeammateCode[10];
bool TeamFlarmTracking = false;
TCHAR TeamFlarmCNTarget[4]; // CN of the glider to track
int TeamFlarmIdTarget;      // FlarmId of the glider to track
double TeammateLatitude;
double TeammateLongitude;
bool TeammateCodeValid = false;


// Waypoint Database
WAYPOINT *WayPointList = NULL;
WPCALC *WayPointCalc = NULL; // VENTA3 additional infos calculated, parallel to WPs
unsigned int NumberOfWayPoints = 0;
int SectorType = 1; // FAI sector
DWORD SectorRadius = 500;
int StartLine = TRUE;
DWORD StartRadius = 3000;

int HomeWaypoint = -1;
bool TakeOffWayPoint=false;
int AirfieldsHomeWaypoint = -1; // VENTA3 force Airfields home to be HomeWaypoint if
                                // an H flag in waypoints file is not available..
// Alternates
int Alternate1 = -1; // VENTA3
int Alternate2 = -1; // VENTA3
int BestAlternate = -1; // VENTA3
int ActiveAlternate = -1; // VENTA3
bool OnBestAlternate=false;
bool OnAlternate1=false;
bool OnAlternate2=false;

// Specials
double GPSAltitudeOffset = 0; // VENTA3
bool	UseGeoidSeparation=false;
bool	PressureHg=false;
// 100413 shortcut on aircraft icon for ibox switching with medium click
// bool	ShortcutIbox=true;
int	CustomKeyTime=700;
int	CustomKeyModeCenter=(CustomKeyMode_t)ckDisabled;
int	CustomKeyModeLeft=(CustomKeyMode_t)ckDisabled;
int	CustomKeyModeRight=(CustomKeyMode_t)ckDisabled;
int	CustomKeyModeAircraftIcon=(CustomKeyMode_t)ckDisabled;
int	CustomKeyModeLeftUpCorner=(CustomKeyMode_t)ckDisabled;
int	CustomKeyModeRightUpCorner=(CustomKeyMode_t)ckDisabled;
bool ResumeSession=false;
double QFEAltitudeOffset = 0;
int OnAirSpace=1; // VENTA3 toggle DrawAirSpace, normal behaviour is "true"
bool WasFlying = false; // VENTA3 used by auto QFE: do not reset QFE if previously in flight. So you can check QFE
			//   on the ground, otherwise it turns to zero at once!
double LastFlipBoxTime = 0; // VENTA3 need this global for slowcalculations cycle
double LastRangeLandableTime=0;
#if defined(PNA) || defined(FIVV)
bool needclipping=false; // flag to activate extra clipping for some PNAs
#endif
bool EnableAutoBacklight=true;
bool EnableAutoSoundVolume=true;
short AircraftCategory=0;
bool ExtendedVisualGlide=false;
short Look8000=lxcAdvanced;
bool HideUnits=false;
bool VirtualKeys=false;
bool NewMap=true;
bool CheckSum=true;
short OutlinedTp=0;
int  OverColor=0;
COLORREF OverColorRef;
int  TpFilter=0;
short MapBox=0;
bool MapLock=false;
bool UseMapLock=false;
bool ActiveMap=true;
short GlideBarMode=0;
short ArrivalValue=0;
short NewMapDeclutter=0;
short Shading=1;
short AverEffTime=0;
bool DrawBottom=false; // new map's bottom line in landscape mode fullscreen condition
short BottomMode=BM_FIRST; 
short BottomSize=1; // Init by MapWindow3  091213 0 to 1
short TopSize=0;
short BottomGeom=0; 
// coordinates of the 5 (0-4) sort boxes. 6 for safety
short SortBoxX[6];
short SortBoxY;
// default initialization for gestures. InitLK8000 will fine tune it.
short GestureSize=60;
// xml dlgconfiguration value replacing 246 which became 278
int   LKwdlgConfig=0;
// normally we do it the unusual way
bool IphoneGestures=false;

int PGClimbZoom=1;
int PGCruiseZoom=1;
// This is the gauge bar on the left for variometer
int LKVarioBar=0;
// moving map is all black and need white painting - not much used 091109
bool BlackScreen=false; 
// if true, LK specific text on map is painted black, otherwise white
bool LKTextBlack=false;;
// enumerated value for map background when no terrain is painted, valid for both normal and inverted mode
// note that all topology text is in black, so this should be a light colour in any case
short BgMapColor=0;
bool  BgMapColorTextBlack[LKMAXBACKGROUNDS]={ false, false, false, false, true, true, true, true, true, true };  // 101009
int LKVarioSize=2; // init by InitLK8000
// activated by Utils2 in virtual keys, used inside RenderMapWindowBg
bool PGZoomTrigger=false;
bool BestWarning=false;
bool ThermalBar=false;
bool McOverlay=true; // 101031 fixed true
bool TrackBar=false;

double WindCalcSpeed=0;
int WindCalcTime=WCALC_TIMEBACK; 
bool RepeatWindCalc=false;
// FLARM Traffic is real if <=1min, Shadow if <= etc. If >Zombie it is removed
int LKTime_Real=15, LKTime_Ghost=60, LKTime_Zombie=180;
// Copy of runtime traffic for instant use 
FLARM_TRAFFIC LKTraffic[FLARM_MAX_TRAFFIC+1];
// Number of IDs (items) of existing traffic updated from DoTraffic
int LKNumTraffic=0;
// Pointer to FLARM struct, ordered by DoTraffic, from 0 to LKNumTraffic-1
int LKSortedTraffic[FLARM_MAX_TRAFFIC+1];

// 100404 index inside FLARM_Traffic of our target, and its type as defined in Utils2
int LKTargetIndex=-1;
int LKTargetType=LKT_TYPE_NONE;

// type of file format for waypoints files
int WpFileType[3];
TCHAR WpHome_Name[NAME_SIZE+1];
double WpHome_Lat=0;
double WpHome_Lon=0;

// LK8000 Hearth beats at 2Hz
double LKHearthBeats=0;
// number of reporting messages from Portmonitor.
int PortMonitorMessages=0;

// Time in use by Nmea parser, updated realtime
double NmeaTime=0;
int NmeaHours=0, NmeaMinutes=0, NmeaSeconds=0;
// Polling Mode flag required #define POLLINGMODE to be functional
bool PollingMode=false;
#if  (LK_CACHECALC && LK_CACHECALC_MCA_STAT)
int  Cache_Calls_MCA=0;
int  Cache_Hits_MCA=0;
int  Cache_Fail_MCA=0;
int  Cache_False_MCA=0;
int  Cache_Incomplete_MCA=0;
#endif
#if (LK_CACHECALC)
int  Cache_Calls_DBE=0;
int  Cache_Hits_DBE=0;
int  Cache_Fail_DBE=0;
int  Cache_False_DBE=0;
#endif

short GlideBarOffset=0;
bool	EngineeringMenu=false; // never saved to registry
short splitter=1; // 091213 0 to 1
bool iboxtoclick=true; // do a click on a new ibox focus
// it is called DeclutterMode but it has nothing to do with MapSpaces
short DeclutterMode;

// current mapspacemode: the internal identifier of a page type
// should not be used for turning pages, only for direct access
short MapSpaceMode; 
// telling you if you are in wpmode, infomode etc..
short ModeIndex;
// See Utils2.h for relationship
// pointers to MapSpacemodes
// MSM_TOP is used as max size also for each subsets
short ModeTable[LKMODE_TOP+1][MSM_TOP+1];
// top of the list inside each table. Could be a struct with ModeTable
short ModeTableTop[LKMODE_TOP+1];
// remembers for each mode (wp, infopage, map , etc.) the current type
short ModeType[LKMODE_TOP+1];

// current selected raw in mapspacemodes
short SelectedRaw[MSM_TOP+1]; 
// current page in each mapspacemode, reset entering new mapspace: no memory
// since it doesnt eat memory, it is also used for pages with currently no subpages
short SelectedPage[MSM_TOP+1];
// number of raws in mapspacemode screen
short Numraws;
short CommonNumraws;
short TurnpointNumraws;
// number of pages in mapspacemode depending on MAXNEAREST and Numraws
short Numpages;
short CommonNumpages;
short TurnpointNumpages;
short TrafficNumpages;
//  mapspace sort mode: 0 wp name  1 distance  2 bearing  3 reff  4 altarr
//  UNUSED on MSM_COMMON etc. however it is dimensioned on mapspacemodes
short SortedMode[MSM_TOP+1];

TCHAR LKLangSuffix[4];
bool WarningHomeDir=false;

// Fixed Screen Parameters, initialised by InitScreen. Size
int  ScreenSizeX=0;
int  ScreenSizeY=0;
RECT ScreenSizeR;
bool ScreenLandscape=false;

// Default arrival mode calculation type
// 091016 currently not changed anymore
short AltArrivMode=ALTA_MC;

// zoomout trigger time handled by MapWindow
double  LastZoomTrigger=0;

// traffic DoTraffic interval, also reset during key up and down to prevent wrong selections
double  LastDoTraffic=0;
double  LastDoNearest=0;
double  LastDoNearestTp=0;
double  LastDoCommon=0;
// double  LastDoTarget=0; unused 

// These are not globals to allow SetMapScales in Utils2 operate..
double  CruiseMapScale=1;
double  ClimbMapScale=1;

// Paraglider's time gates
// ------------------------------
// Open and close time, gate 0  ex. 12:00
// M and H for registry
int  PGOpenTimeH=0;
int  PGOpenTimeM=0;
int  PGOpenTime=0;
int  PGCloseTime=0;
// Interval, in minutes
int	PGGateIntervalTime=0;
// How many gates, 1-x
int	PGNumberOfGates=0;
// Start out or start in?
bool	PGStartOut=false;
// Current assigned gate 
int ActiveGate=-1;

#if LKTOPO
// LKMAPS flag for topology: >0 means ON, and indicating how many topo files are loaded
int  LKTopo=0;
// This threshold used in Terrain.cpp to distinguish water altitude
short  LKWaterThreshold=0;
double LKTopoZoomCat05=0;
double LKTopoZoomCat10=0;
double LKTopoZoomCat20=0;
double LKTopoZoomCat30=0;
double LKTopoZoomCat40=0;
double LKTopoZoomCat50=0;
double LKTopoZoomCat60=0;
double LKTopoZoomCat70=0;
double LKTopoZoomCat80=0;
double LKTopoZoomCat90=0;
double LKTopoZoomCat100=0;
double LKTopoZoomCat110=0;
#endif
// max number of topo and wp labels painted on map, defined by default in Utils
int  LKMaxLabels=0;

#if OVERTARGET
// current mode of overtarget 0=task 1=alt1, 2=alt2, 3=best alt
short OvertargetMode=0;
#endif
double SimTurn=0;
double ThLatitude=1;
double ThLongitude=1;
double ThermalRadius=0;
double SinkRadius=0;

// LK8000 sync flags
bool NearestDataReady=false;
bool CommonDataReady=false;
bool RecentDataReady=false;
bool NearestTurnpointDataReady=false;
bool LKForceDoNearest=false;
bool LKForceDoCommon=false;
bool LKForceDoRecent=false;
bool LKForceDoNearestTurnpoint=false;
short LKevent=LKEVENT_NONE;
bool LKForceComPortReset=false; // 100214
ldrotary_s rotaryLD;
windrotary_s rotaryWind;

// Optimization  preprocessing
int  RangeLandableIndex[MAXRANGELANDABLE+1]; 
int  RangeLandableNumber=0;
int  RangeAirportIndex[MAXRANGELANDABLE+1];
int  RangeAirportNumber=0;
int  RangeTurnpointIndex[MAXRANGETURNPOINT+1];
int  RangeTurnpointNumber=0;
// This list is sorted out of RangeLandableIndex, used by DoNearest
// cannot be used elsewhere, since it's only updated when in Nearest MapSpaceMode.
// +1 is for safety...  
// Also in DoNearestTurnpoint for MSM_NEARTPS 
int  SortedLandableIndex[MAXNEAREST+1];
int  SortedAirportIndex[MAXNEAREST+1];
int  SortedTurnpointIndex[MAXNEARTURNPOINT+1];
// Real number of NEAREST items contained in array after removing duplicates, or not enough to fill MAXNEAREST/MAX..
int  SortedNumber=0;
// as above, for nearest turnpoints
int  SortedTurnpointNumber=0;

// Commons are Home, best alternate, alternate1, 2, and task waypoints , all up to MAXCOMMON.
// It is reset when changing wp file
int  CommonIndex[MAXCOMMON+1];
// Number of items 0-n inside CommonIndex
int  CommonNumber=0;

// History of recent waypoints
int RecentIndex[MAXCOMMON+1];
unsigned int RecentChecksum[MAXCOMMON+1];
int RecentNumber=0;
// Cpu stats
#ifdef CPUSTATS
int Cpu_Draw=0;
int Cpu_Calc=0;
int Cpu_Instrument=0;
int Cpu_Port=0;
int Cpu_Aver=0;
#endif

#ifdef NEWIBLSCALE
int LKIBLSCALE[MAXIBLSCALE+1];
#endif
double Experimental1=0, Experimental2=0;

double NearestAirspaceHDist=-1;
double NearestAirspaceVDist=-1;
TCHAR NearestAirspaceName[NAME_SIZE+1]; // TODO INITIALISE IT!

// Flarmnet tools
int FlarmNetCount=0;

// Airspace Database
AIRSPACE_AREA *AirspaceArea = NULL;
AIRSPACE_POINT *AirspacePoint = NULL;
POINT *AirspaceScreenPoint = NULL;
AIRSPACE_CIRCLE *AirspaceCircle = NULL;
unsigned int NumberOfAirspacePoints = 0;
unsigned int NumberOfAirspaceAreas = 0;
unsigned int NumberOfAirspaceCircles = 0;

//Airspace Warnings
int AIRSPACEWARNINGS = TRUE;
int WarningTime = 30;
int AcknowledgementTime = 30;

// Registration Data
TCHAR strAssetNumber[MAX_LOADSTRING] = TEXT(""); //4G17DW31L0HY");
TCHAR strRegKey[MAX_LOADSTRING] = TEXT("");

// Interface Files
StatusMessageSTRUCT StatusMessageData[MAXSTATUSMESSAGECACHE];
int StatusMessageData_Size = 0;

//Snail Trial
SNAIL_POINT SnailTrail[TRAILSIZE];
int SnailNext = 0;

// user interface settings
bool CircleZoom = true;
int WindUpdateMode = 0;
bool EnableTopology = true; // 091105
bool EnableTerrain = true;  // 091105
int FinalGlideTerrain = 1;
bool EnableSoundVario = true;
bool EnableSoundModes = true;
bool EnableSoundTask = true;
bool OverlayClock = false;
int SoundVolume = 80;
int SoundDeadband = 5;
bool EnableVarioGauge = false;
bool EnableAutoBlank = false;
bool ScreenBlanked = false;



//IGC Logger
bool LoggerActive = false;

// Others

BOOL COMPORTCHANGED = FALSE;
BOOL MAPFILECHANGED = FALSE;
BOOL AIRSPACEFILECHANGED = FALSE;
BOOL AIRFIELDFILECHANGED = FALSE;
BOOL WAYPOINTFILECHANGED = FALSE;
BOOL TERRAINFILECHANGED = FALSE;
BOOL TOPOLOGYFILECHANGED = FALSE;
BOOL POLARFILECHANGED = FALSE;
BOOL LANGUAGEFILECHANGED = FALSE;
BOOL STATUSFILECHANGED = FALSE;
BOOL INPUTFILECHANGED = FALSE;
static bool MenuActive = false;

//Task Information
Task_t Task = {{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0},{-1,0,0,0,0,0,0,0,0}};
Start_t StartPoints;
TaskStats_t TaskStats;
int ActiveWayPoint = -1;

// Assigned Area Task
double AATTaskLength = 120;
BOOL AATEnabled = FALSE;
DWORD FinishMinHeight = 0;
DWORD StartMaxHeight = 0;
DWORD StartMaxSpeed = 0;
DWORD StartMaxHeightMargin = 0;
DWORD StartMaxSpeedMargin = 0;


// Statistics
Statistics flightstats;

#if (((UNDER_CE >= 300)||(_WIN32_WCE >= 0x0300)) && (WINDOWSPC<1))
#define HAVE_ACTIVATE_INFO
static SHACTIVATEINFO s_sai;
#endif

BOOL InfoBoxesHidden = false; 

void PopupBugsBallast(int updown);

// System boot specific flags 
// Give me a go/no-go 
bool goInstallSystem=false;
bool goCalculationThread=false;
bool goInstrumentThread=false;
bool goInitDevice=false; 
// bool goCalculating=false;

#include "GaugeCDI.h"
#include "GaugeFLARM.h"
#include "GaugeVario.h"

// Battery status for SIMULATOR mode
//	30% reminder, 20% exit, 30 second reminders on warnings

#ifndef GNAV
#define BATTERY_WARNING 30
#define BATTERY_EXIT 20
#define BATTERY_REMINDER 30000
DWORD BatteryWarningTime = 0;
#endif

char dedicated[]="Dedicated to my father Vittorio";

// Groups:
//   Altitude 0,1,20,33
//   Aircraft info 3,6,23,32,37,47,54
//   LD 4,5,19,38,53, 66    VENTA-ADDON added 66 for GR final
//   Vario 2,7,8,9,21,22,24,44
//   Wind 25,26,48,49,50
//   Mcready 10,34,35,43
//   Nav 11,12,13,15,16,17,18,27,28,29,30,31
//   Waypoint 14,36,39,40,41,42,45,46
SCREEN_INFO Data_Options[] = {
          // 0
	  {ugAltitude,        TEXT("Altitude QNH"), TEXT("Alt"), new InfoBoxFormatter(TEXT("%2.0f")), AltitudeProcessing, 1, 33},
	  // 1
	  {ugAltitude,        TEXT("Altitude AGL"), TEXT("HAGL"), new FormatterLowWarning(TEXT("%2.0f"),0.0), NoProcessing, 20, 0},
	  // 2
	  {ugVerticalSpeed,   TEXT("Thermal last 30 sec"), TEXT("TC.30\""), new FormatterLowWarning(TEXT("%-2.1f"),0.0), NoProcessing, 7, 44},
	  // 3
#ifdef FIVV
	  {ugNone,            TEXT("Bearing"), TEXT("Brg"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)), NoProcessing, 6, 54},
#else
	  {ugNone,            TEXT("Bearing"), TEXT("Brg"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)TEXT("T")), NoProcessing, 6, 54},
#endif
	  // 4
	  {ugNone,            TEXT("Eff.last 20 sec"), TEXT("E.20\""), new InfoBoxFormatter(TEXT("%2.0f")), PopupBugsBallast, 5, 38},
	  // 5
	  {ugNone,            TEXT("Eff.cruise last therm"), TEXT("E.Cru"), new InfoBoxFormatter(TEXT("%2.0f")), PopupBugsBallast, 19, 4},
	  // 6
	  {ugHorizontalSpeed, TEXT("Speed ground"), TEXT("GS"), new InfoBoxFormatter(TEXT("%2.0f")), SpeedProcessing, 23, 3},
	  // 7
	  {ugVerticalSpeed,   TEXT("Thermal Average Last"), TEXT("TL.Avg"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 8, 2},
	  // 8
	  {ugAltitude,        TEXT("Thermal Gain Last"), TEXT("TL.Gain"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 9, 7},
	  // 9
	  {ugNone,            TEXT("Thermal Time Last"), TEXT("TL.Time"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 21, 8},
	  // 10
	  {ugVerticalSpeed,   TEXT("MacCready Setting"), TEXT("MCready"), new InfoBoxFormatter(TEXT("%2.1f")), MacCreadyProcessing, 34, 43},
	  // 11
	  {ugDistance,        TEXT("Next Distance"), TEXT("Dist"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 12, 31},
	  // 12
	  {ugAltitude,        TEXT("Next Alt.Arrival"), TEXT("NxtArr"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 13, 11},
	  // 13
	  {ugAltitude,        TEXT("Next Alt.Required"), TEXT("NxtAltR"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 15, 12},
	  // 14
	  {ugNone,            TEXT("Next Waypoint"), TEXT("Next"), new FormatterWaypoint(TEXT("\0")), NextUpDown, 36, 46},
	  // 15
	  {ugAltitude,        TEXT("Task Alt.Arrival"), TEXT("TskArr"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 16, 13},
	  // 16
	  {ugAltitude,        TEXT("Task Alt.Required"), TEXT("TskAltR"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 17, 15},
	  // 17
	  {ugTaskSpeed, TEXT("Task Speed Average"), TEXT("TskSpAv"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
	  // 18
	  {ugDistance,        TEXT("Task Distance"), TEXT("TskDis"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 27, 17},
	  // 19	              old Final LD, obsoleted
	  {ugNone,            TEXT("_Reserved 1"), TEXT("OLD fLD"), new InfoBoxFormatter(TEXT("%1.0f")), NoProcessing, 38, 5},
	  // 20
	  {ugAltitude,        TEXT("Terrain Elevation"), TEXT("Gnd"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 33, 1},
	  // 21
	  {ugVerticalSpeed,   TEXT("Thermal Average"), TEXT("TC.Avg"), new FormatterLowWarning(TEXT("%-2.1f"),0.0), NoProcessing, 22, 9},
	  // 22
	  {ugAltitude,        TEXT("Thermal Gain"), TEXT("TC.Gain"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 24, 21},
	  // 23
#ifdef FIVV
	  {ugNone,            TEXT("Track"), TEXT("Track"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)), DirectionProcessing, 32, 6},
#else
	  {ugNone,            TEXT("Track"), TEXT("Track"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)TEXT("T")), DirectionProcessing, 32, 6},
#endif
	  // 24
	  {ugVerticalSpeed,   TEXT("Vario"), TEXT("Vario"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 44, 22},
	  // 25
	  {ugWindSpeed,       TEXT("Wind Speed"), TEXT("WindV"), new InfoBoxFormatter(TEXT("%2.0f")), WindSpeedProcessing, 26, 50},
	  // 26
#ifdef FIVV
	  {ugNone,            TEXT("Wind Bearing"), TEXT("WindB"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)), WindDirectionProcessing, 48, 25},
#else
	  {ugNone,            TEXT("Wind Bearing"), TEXT("WindB"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)TEXT("T")), WindDirectionProcessing, 48, 25},
#endif
	  // 27
	  {ugNone,            TEXT("AA Time"), TEXT("AATime"), new FormatterAATTime(TEXT("%2.0f")), NoProcessing, 28, 18},
	  // 28
	  {ugDistance,        TEXT("AA Distance Max"), TEXT("AADmax"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 29, 27},
	  // 29
	  {ugDistance,        TEXT("AA Distance Min"), TEXT("AADmin"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 30, 28},
	  // 30
	  {ugTaskSpeed, TEXT("AA Speed Max"), TEXT("AAVmax"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 31, 29},
	  // 31
	  {ugTaskSpeed, TEXT("AA Speed Min"), TEXT("AAVmin"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 51, 30},
	  // 32
	  {ugHorizontalSpeed, TEXT("Airspeed IAS"), TEXT("IAS"), new InfoBoxFormatter(TEXT("%2.0f")), AirspeedProcessing, 37, 23},
	  // 33
	  {ugAltitude,        TEXT("Altitude BARO"), TEXT("HBAR"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 0, 20},
	  // 34
	  {ugHorizontalSpeed, TEXT("Speed MacReady"), TEXT("SpMc"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 35, 10},
	  // 35
	  {ugNone,            TEXT("Percentage climb"), TEXT("%Climb"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 43, 34},
	  // 36
	  {ugNone,            TEXT("Time of flight"), TEXT("FlyTime"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 39, 14},
	  // 37
	  {ugNone,            TEXT("G load"), TEXT("G"), new InfoBoxFormatter(TEXT("%2.2f")), AccelerometerProcessing, 47, 32},
	  // 38
	  {ugNone,            TEXT("_Reserved 2"), TEXT("OLD nLD"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 53, 19},
	  // 39
	  {ugNone,            TEXT("Time local"), TEXT("Time"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 40, 36},
	  // 40
	  {ugNone,            TEXT("Time UTC"), TEXT("UTC"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 41, 39},
	  // 41
	  {ugNone,            TEXT("Task Time To Go"), TEXT("TskETE"), new FormatterAATTime(TEXT("%04.0f")), NoProcessing, 42, 40},
	  // 42
	  {ugNone,            TEXT("Next Time To Go"), TEXT("NextETE"), new FormatterAATTime(TEXT("%04.0f")), NoProcessing, 45, 41},
	  // 43
	  {ugHorizontalSpeed, TEXT("Speed To Fly"), TEXT("STF"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 10, 35},
	  // 44
	  {ugVerticalSpeed,   TEXT("Netto Vario"), TEXT("Netto"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 2, 24},
	  // 45
	  {ugNone,            TEXT("Task Arrival Time"), TEXT("TskETA"), new FormatterAATTime(TEXT("%04.0f")), NoProcessing, 46, 42},
	  // 46
	  {ugNone,            TEXT("Next Arrival Time"), TEXT("NextETA"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 14, 45},
	  // 47
	  {ugNone,            TEXT("Bearing Difference"), TEXT("To"), new FormatterDiffBearing(TEXT("")), NoProcessing, 54, 37},
	  // 48
	  {ugNone,            TEXT("Outside Air Temperature"), TEXT("OAT"), new InfoBoxFormatter(TEXT("%2.1f")TEXT(DEG)), NoProcessing, 49, 26},
	  // 49
	  {ugNone,            TEXT("Relative Humidity"), TEXT("RelHum"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 50, 48},
	  // 50
	  {ugNone,            TEXT("Forecast Temperature"), TEXT("MaxTemp"), new InfoBoxFormatter(TEXT("%2.1f")TEXT(DEG)), ForecastTemperatureProcessing, 49, 25},
	  // 51
	  {ugDistance,        TEXT("AA Distance Tgt"), TEXT("AADtgt"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 52, 31},
	  // 52
	  {ugTaskSpeed, TEXT("AA Speed Tgt"), TEXT("AAVtgt"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 11, 51},
	  // 53
	  {ugNone,            TEXT("L/D vario"), TEXT("L/D vario"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 4, 38},
	  // 54
	  {ugHorizontalSpeed, TEXT("Airspeed TAS"), TEXT("TAS"), new InfoBoxFormatter(TEXT("%2.0f")), AirspeedProcessing, 3, 47},
	  // 55
	  {ugNone,            TEXT("Team Code"), TEXT("TeamCode"), new FormatterTeamCode(TEXT("\0")), TeamCodeProcessing, 56, 54},
	  // 56
#ifdef FIVV
	  {ugNone,            TEXT("Team Bearing"), TEXT("TmBrng"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)), NoProcessing, 57, 55},
#else
	  {ugNone,            TEXT("Team Bearing"), TEXT("TmBrng"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)TEXT("T")), NoProcessing, 57, 55},
#endif
	  // 57
	  {ugNone,            TEXT("Team Bearing Diff"), TEXT("TeamBd"), new FormatterDiffTeamBearing(TEXT("")), NoProcessing, 58, 56},	  
	  // 58
	  {ugNone,            TEXT("Team Range"), TEXT("TeamDis"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 55, 57},
          // 59
	  {ugTaskSpeed, TEXT("Task Speed Instantaneous"), TEXT("TskSpI"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
          // 60
	  {ugDistance, TEXT("Home Distance"), TEXT("HomeDis"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
	  // 61
	  {ugTaskSpeed, TEXT("Task Speed"), TEXT("TskSp"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
          // 62
	  {ugNone,            TEXT("AA Delta Time"), TEXT("AAdT"), new FormatterAATTime(TEXT("%2.0f")), NoProcessing, 28, 18},
          // 63
	  {ugVerticalSpeed,   TEXT("Thermal All"), TEXT("Th.All"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 8, 2},
          // 64
	  {ugVerticalSpeed,   TEXT("Distance Vario"), TEXT("DVario"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 8, 2},
	  // 65
#ifndef GNAV
	  {ugNone,            TEXT("Battery Percent"), TEXT("Battery"), new InfoBoxFormatter(TEXT("%2.0f%%")), NoProcessing, 49, 26},
#else
	  {ugNone,            TEXT("Battery Voltage"), TEXT("Batt"), new InfoBoxFormatter(TEXT("%2.1fV")), NoProcessing, 49, 26},
#endif
	  // 66 
	  {ugNone,            TEXT("Task Req.Efficiency"), TEXT("TskReqE"), new InfoBoxFormatter(TEXT("%1.1f")), NoProcessing, 38, 5},

	  // 67 
	  {ugNone,            TEXT("Alternate1 Req.Efficiency"), TEXT("Atn1.E"), new FormatterAlternate(TEXT("\0")), Alternate1Processing, 36, 46},
	  // 68 Alternate 2
	  {ugNone,            TEXT("Alternate2 Req.Efficiency"), TEXT("Atn2.E"), new FormatterAlternate(TEXT("\0")), Alternate2Processing, 36, 46},
	  // 69
	  {ugNone,            TEXT("BestAltern Req.Efficiency"), TEXT("BAtn.E"), new FormatterAlternate(TEXT("\0")), BestAlternateProcessing, 36, 46},
          // 70
	  {ugAltitude,        TEXT("Altitude QFE"), TEXT("QFE"), new InfoBoxFormatter(TEXT("%2.0f")), QFEAltitudeProcessing, 1, 33},
          // 71 
	  {ugNone,            TEXT("Average Efficiency"), TEXT("E.Avg"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 19, 4},
	  // 72  
	  {ugNone,            TEXT("Next Req.Efficiency"), TEXT("Req.E"), new InfoBoxFormatter(TEXT("%1.1f")), NoProcessing, 38, 5},
	  // 73  
	  {ugNone,            TEXT("Flight Level"), TEXT("FL"), new InfoBoxFormatter(TEXT("%1.1f")), NoProcessing, 38, 5},
	  // 74  
	  {ugDistance,            TEXT("Task Covered distance"), TEXT("TskCov"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 38, 5},
	  // 75 
	  {ugAltitude,            TEXT("Alternate1 Arrival"), TEXT("Atn1Arr"), new FormatterAlternate(TEXT("%2.0f")), Alternate1Processing, 36, 46},
	  // 76
	  {ugAltitude,            TEXT("Alternate2 Arrival"), TEXT("Atn2Arr"), new FormatterAlternate(TEXT("%2.0f")), Alternate2Processing, 36, 46},
	  // 77
	  {ugAltitude,            TEXT("BestAlternate Arrival"), TEXT("BAtnArr"), new FormatterAlternate(TEXT("%2.0f")), BestAlternateProcessing, 36, 46},
	  // 78
	  {ugNone,            TEXT("Home Radial"), TEXT("Radial"), new InfoBoxFormatter(TEXT("%.0f")TEXT(DEG)), NoProcessing, 6, 54},
	  // 79 
	  {ugDistance,            TEXT("Airspace Distance"), TEXT("AirSpace"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 38, 5},
	  // 80 
	  {ugNone,            TEXT("Ext.Batt.Bank"), TEXT("xBnk#"), new InfoBoxFormatter(TEXT("%1.0f")), NoProcessing, 38, 5},
	  // 81 
	  {ugNone,            TEXT("Ext.Batt.1 Voltage"), TEXT("xBat1"), new InfoBoxFormatter(TEXT("%2.1fV")), NoProcessing, 49, 26},
	  // 82 
	  {ugNone,            TEXT("Ext.Batt.2 Voltage"), TEXT("xBat2"), new InfoBoxFormatter(TEXT("%2.1fV")), NoProcessing, 49, 26},
	  // 83 
	  {ugDistance,            TEXT("Odometer"), TEXT("Odom"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 49, 26},
          // 84 
	  {ugInvAltitude,        TEXT("Altern QNH"), TEXT("aAlt"), new InfoBoxFormatter(TEXT("%2.0f")), AltitudeProcessing, 1, 33},
	  // 85
	  {ugInvAltitude,        TEXT("Altern AGL"), TEXT("aHAGL"), new FormatterLowWarning(TEXT("%2.0f"),0.0), NoProcessing, 20, 0},
          // 86 
	  {ugAltitude,        TEXT("Altitude GPS"), TEXT("HGPS"), new InfoBoxFormatter(TEXT("%2.0f")), AltitudeProcessing, 1, 33},
          // 87 
	  {ugVerticalSpeed,   TEXT("MacCready Equivalent"), TEXT("eqMC"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 34, 43},
	  // 88 // 
	  {ugNone,   TEXT("_Experimental1"), TEXT("Exp1"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 8, 2},
	  // 89 // 
	  {ugNone,   TEXT("_Experimental2"), TEXT("Exp2"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 8, 2},
	};
// counting from 0 so add 1 !
const int NUMSELECTSTRINGS = 90; 


CRITICAL_SECTION  CritSec_FlightData;
bool csFlightDataInitialized = false;
CRITICAL_SECTION  CritSec_EventQueue;
bool csEventQueueInitialized = false;
CRITICAL_SECTION  CritSec_TerrainDataGraphics;
bool csTerrainDataGraphicsInitialized = false;
CRITICAL_SECTION  CritSec_TerrainDataCalculations;
bool csTerrainDataCalculationsInitialized = false;
CRITICAL_SECTION  CritSec_NavBox;
bool csNavBoxInitialized = false;
CRITICAL_SECTION  CritSec_Comm;
bool csCommInitialized = false;
CRITICAL_SECTION  CritSec_TaskData;
bool csTaskDataInitialized = false;


static BOOL GpsUpdated;
static HANDLE dataTriggerEvent;
static BOOL VarioUpdated;
static HANDLE varioTriggerEvent;

// Forward declarations of functions included in this code module:
ATOM                                                    MyRegisterClass (HINSTANCE, LPTSTR);
BOOL                                                    InitInstance    (HINSTANCE, int);
LRESULT CALLBACK        WndProc                 (HWND, UINT, WPARAM, LPARAM);
LRESULT                                         MainMenu(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
void                                                    AssignValues(void);
void                                                    DisplayText(void);

void CommonProcessTimer    (void);
#if NOSIM
void SIMProcessTimer(void);
void ProcessTimer    (void);
#else
#ifdef _SIM_
void SIMProcessTimer(void);
#else
void ProcessTimer    (void);
#endif
#endif
void                                                    PopUpSelect(int i);

//HWND CreateRpCommandBar(HWND hwnd);

#ifdef DEBUG
void                                            DebugStore(char *Str);
#endif


void TriggerGPSUpdate()
{
  GpsUpdated = true;
  SetEvent(dataTriggerEvent);
}

void TriggerVarioUpdate()
{
  VarioUpdated = true;
  PulseEvent(varioTriggerEvent);
}

void HideMenu() {
  // ignore this if the display isn't locked -- must keep menu visible
  if (DisplayLocked) {
    MenuTimeOut = MenuTimeoutMax;
    DisplayTimeOut = 0;
  }
}

void ShowMenu() {
#if !defined(GNAV) && !defined(PCGNAV)
  // Popup exit button if in .xci
  //InputEvents::setMode(TEXT("Exit"));
  InputEvents::setMode(TEXT("Menu")); // VENTA3
#endif
  MenuTimeOut = 0;
  DisplayTimeOut = 0;
}


#if (EXPERIMENTAL > 0)
BlueDialupSMS bsms;
#endif

void SettingsEnter() {
  MenuActive = true;

  MapWindow::SuspendDrawingThread();
  // This prevents the map and calculation threads from doing anything
  // with shared data while it is being changed.

  MAPFILECHANGED = FALSE;
  AIRSPACEFILECHANGED = FALSE;
  AIRFIELDFILECHANGED = FALSE;
  WAYPOINTFILECHANGED = FALSE;
  TERRAINFILECHANGED = FALSE;
  TOPOLOGYFILECHANGED = FALSE;
  POLARFILECHANGED = FALSE;
  LANGUAGEFILECHANGED = FALSE;
  STATUSFILECHANGED = FALSE;
  INPUTFILECHANGED = FALSE;
  COMPORTCHANGED = FALSE;
}


void SettingsLeave() {
  if (!GlobalRunning) return; 

  SwitchToMapWindow();

  // Locking everything here prevents the calculation thread from running,
  // while shared data is potentially reloaded.
 
  LockFlightData();
  LockTaskData();
  LockNavBox();

  MenuActive = false;

#if FIX_RELOADCONFIG
  // 101020 LKmaps contain only topology , so no need to force total reload!
  if(MAPFILECHANGED) {
	if (LKTopo==0) {
		AIRSPACEFILECHANGED = TRUE;
		AIRFIELDFILECHANGED = TRUE;
		WAYPOINTFILECHANGED = TRUE;
		TERRAINFILECHANGED  = TRUE;
	}
	TOPOLOGYFILECHANGED = TRUE;
  } 

  if (TERRAINFILECHANGED) {
	RasterTerrain::CloseTerrain();
	RasterTerrain::OpenTerrain();
	SetHome(WAYPOINTFILECHANGED==TRUE);
	RasterTerrain::ServiceFullReload(GPS_INFO.Latitude, GPS_INFO.Longitude);
	MapWindow::ForceVisibilityScan = true;
  }

  if((WAYPOINTFILECHANGED) || (AIRFIELDFILECHANGED)) {
	SaveDefaultTask(); //@@ 101020 BUGFIX
	ClearTask();
	ReadWayPoints();
	InitWayPointCalc();
	ReadAirfieldFile();
	SetHome(true); // force home reload

	if (WAYPOINTFILECHANGED) {
		SaveRecentList();
		LoadRecentList();
		RangeLandableNumber=0;
		RangeAirportNumber=0;
		RangeTurnpointNumber=0;
		CommonNumber=0;
		SortedNumber=0;
		SortedTurnpointNumber=0;
		LKForceDoCommon=true;
		LKForceDoNearest=true;
		LKForceDoRecent=true;
		LKForceDoNearestTurnpoint=true;
	}
	InputEvents::eventTaskLoad(_T(LKF_DEFAULTASK)); //@@ BUGFIX 101020
  } 

#else // old stuff
  if(MAPFILECHANGED) {
	TOPOLOGYFILECHANGED = TRUE;
	AIRSPACEFILECHANGED = TRUE;
	AIRFIELDFILECHANGED = TRUE;
	WAYPOINTFILECHANGED = TRUE;
	TERRAINFILECHANGED = TRUE;
  }
    
  if((WAYPOINTFILECHANGED) || (TERRAINFILECHANGED) || (AIRFIELDFILECHANGED)) {
	ClearTask();
	RasterTerrain::CloseTerrain();
	RasterTerrain::OpenTerrain();
	ReadWayPoints();
	InitWayPointCalc();
	ReadAirfieldFile();
     
	if (WAYPOINTFILECHANGED || TERRAINFILECHANGED) {
		SetHome(WAYPOINTFILECHANGED==TRUE);
	}

	if (WAYPOINTFILECHANGED) {
		SaveRecentList();
		LoadRecentList();
		RangeLandableNumber=0;
		RangeAirportNumber=0;
		RangeTurnpointNumber=0;
		CommonNumber=0;
		SortedNumber=0;
		SortedTurnpointNumber=0;
		LKForceDoCommon=true;
		LKForceDoNearest=true;
		LKForceDoRecent=true;
		LKForceDoNearestTurnpoint=true;
	}

	RasterTerrain::ServiceFullReload(GPS_INFO.Latitude, GPS_INFO.Longitude);
	MapWindow::ForceVisibilityScan = true;
  }
#endif // end old stuff
  
  if (TOPOLOGYFILECHANGED) {
	CloseTopology();
	OpenTopology();
	MapWindow::ForceVisibilityScan = true;
  }
  
  if(AIRSPACEFILECHANGED) {
	CloseAirspace();
	ReadAirspace();
	SortAirspace();
	MapWindow::ForceVisibilityScan = true;
  }  
  
  if (POLARFILECHANGED) {
	CalculateNewPolarCoef();
	GlidePolar::SetBallast();
  }
  
  if (AIRFIELDFILECHANGED
      || AIRSPACEFILECHANGED
      || WAYPOINTFILECHANGED
      || TERRAINFILECHANGED
      || TOPOLOGYFILECHANGED
      ) {
	CloseProgressDialog();
	SetFocus(hWndMapWindow);
  }
  
  UnlockNavBox();
  UnlockTaskData();
  UnlockFlightData();

  #if NOSIM
  if(!SIMMODE && COMPORTCHANGED) {
      RestartCommPorts();
  }
  #else
  #ifndef _SIM_
  if(COMPORTCHANGED) {
      RestartCommPorts();
  }
  #endif
  #endif

  MapWindow::ResumeDrawingThread();
  // allow map and calculations threads to continue on their merry way
}


void SystemConfiguration(void) {
#if NOSIM
  if (!SIMMODE) {
  	if (LockSettingsInFlight && CALCULATED_INFO.Flying) {
		DoStatusMessage(TEXT("Settings locked in flight"));
		return;
	}
  }
#else
#ifndef _SIM_
  if (LockSettingsInFlight && CALCULATED_INFO.Flying) {
    DoStatusMessage(TEXT("Settings locked in flight"));
    return;
  }
#endif
#endif

  SettingsEnter();
  dlgConfigurationShowModal(); 
  SettingsLeave();
}



void FullScreen() {
  if (!MenuActive) {
    SetForegroundWindow(hWndMainWindow);
#if (WINDOWSPC>0)
    SetWindowPos(hWndMainWindow,HWND_TOP,
                 0, 0, 0, 0,
                 SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE);
#else
#ifndef CECORE
    SHFullScreen(hWndMainWindow, SHFS_HIDETASKBAR|SHFS_HIDESIPBUTTON|SHFS_HIDESTARTICON);
#endif
    SetWindowPos(hWndMainWindow,HWND_TOP,
                 0,0,
                 GetSystemMetrics(SM_CXSCREEN),
                 GetSystemMetrics(SM_CYSCREEN),
                 SWP_SHOWWINDOW);
#endif
  }
  MapWindow::RequestFastRefresh();
  InfoBoxesDirty = true;
}


void LockComm() {
#ifdef HAVEEXCEPTIONS
  if (!csCommInitialized) throw TEXT("LockComm Error");
#endif
  EnterCriticalSection(&CritSec_Comm);
}

void UnlockComm() {
#ifdef HAVEEXCEPTIONS
  if (!csCommInitialized) throw TEXT("LockComm Error");
#endif
  LeaveCriticalSection(&CritSec_Comm);
}


void RestartCommPorts() {
  static bool first = true;
 /*
#if (WINDOWSPC>0)
  if (!first) {
    NMEAParser::Reset();
    return;
  }
#endif
 */
  StartupStore(TEXT(". RestartCommPorts%s"),NEWLINE);

  while(!goInitDevice) Sleep(50); // 100118
  LockComm();

  devClose(devA());
  devClose(devB());

  NMEAParser::Reset();

  first = false;

  devInit(TEXT(""));      

  UnlockComm();

}



void DefocusInfoBox() {
  FocusOnWindow(InfoFocus,false);
  InfoFocus = -1;
  if (MapWindow::isPan() && !MapWindow::isTargetPan()) {
    InputEvents::setMode(TEXT("pan"));
  } else {
    InputEvents::setMode(TEXT("default"));
  }
  InfoWindowActive = FALSE;
}


void FocusOnWindow(int i, bool selected) {
    //hWndTitleWindow

  if (i<0) return; // error

  InfoBoxes[i]->SetFocus(selected);
  // todo defocus all other?

}


void TriggerRedraws(NMEA_INFO *nmea_info,
		    DERIVED_INFO *derived_info) {
	(void)nmea_info;
	(void)derived_info;
  if (MapWindow::IsDisplayRunning()) {
    if (GpsUpdated) {
      MapWindow::MapDirty = true;
      PulseEvent(drawTriggerEvent); 
      // only ask for redraw if the thread was waiting,
      // this causes the map thread to try to synchronise
      // with the calculation thread, which is desirable
      // to reduce latency
      // it also ensures that if the display is lagging,
      // it will have a chance to catch up.
    }
  }
}

#ifndef NOINSTHREAD
// this thread currently does nothing. Soon used for background parallel calculations or new gauges
DWORD InstrumentThread (LPVOID lpvoid) {
	(void)lpvoid;
  #ifdef CPUSTATS
  FILETIME CreationTime, ExitTime, StartKernelTime, EndKernelTime, StartUserTime, EndUserTime ;
  #endif

  // watch out for a deadlock here. This has to be done before waiting for DisplayRunning..
  goInstrumentThread=true; // 091119

  // wait for proper startup signal
  while (!MapWindow::IsDisplayRunning()) {
	Sleep(100);
  }

  while (!MapWindow::CLOSETHREAD) {

	#ifdef CPUSTATS
	GetThreadTimes( hInstrumentThread, &CreationTime, &ExitTime,&StartKernelTime,&StartUserTime);
	#endif
	WaitForSingleObject(varioTriggerEvent, 5000);
	ResetEvent(varioTriggerEvent);
	if (MapWindow::CLOSETHREAD) break; // drop out on exit

#ifndef NOVARIOGAUGE
	// VNT This thread was eating cpu in landscape mode although vario not used. 
	#ifdef LK8000_OPTIMIZE
	if ( (InfoBoxLayout::landscape == true) && ( InfoBoxLayout::InfoBoxGeometry == 6) ) {
		if (VarioUpdated && !InfoBoxLayout::fullscreen) { // VNT 090814 fix 
	#else
	if (VarioUpdated) { 
	#endif
		VarioUpdated = false;
		if (MapWindow::IsDisplayRunning()) {
			if (EnableVarioGauge) {
				GaugeVario::Render();
			}
		}
	}
	#ifdef LK8000_OPTIMIZE
		} else {
			// VNT Not sure this is busy-wait, but normally the thread could even be suspended
			Sleep(1000);
		}
	#endif
#else
	// DO NOTHING BY NOW
	Sleep(10000);
#endif
	#ifdef CPUSTATS
	if ( (GetThreadTimes( hInstrumentThread, &CreationTime, &ExitTime,&EndKernelTime,&EndUserTime)) == 0) {
		Cpu_Instrument=9999;
	} else {
		Cpustats(&Cpu_Instrument,&StartKernelTime, &EndKernelTime, &StartUserTime, &EndUserTime);
	}
	#endif
  }
  return 0;
}
#endif

DWORD CalculationThread (LPVOID lpvoid) {
	(void)lpvoid;
  bool needcalculationsslow;

  NMEA_INFO     tmp_GPS_INFO;
  DERIVED_INFO  tmp_CALCULATED_INFO;
#ifdef CPUSTATS
  FILETIME CreationTime, ExitTime, StartKernelTime, EndKernelTime, StartUserTime, EndUserTime ;
#endif
  needcalculationsslow = false;

  // let's not create a deadlock here, setting the go after another race condition
  goCalculationThread=true; // 091119 CHECK
  // wait for proper startup signal
  while (!MapWindow::IsDisplayRunning()) {
    Sleep(100);
  }

  // while (!goCalculating) Sleep(100);
  Sleep(1000); // 091213  BUGFIX need to syncronize !!! TOFIX02 TODO

  while (!MapWindow::CLOSETHREAD) {

    WaitForSingleObject(dataTriggerEvent, 5000);
    ResetEvent(dataTriggerEvent);
    if (MapWindow::CLOSETHREAD) break; // drop out on exit

#ifdef CPUSTATS
    GetThreadTimes( hCalculationThread, &CreationTime, &ExitTime,&StartKernelTime,&StartUserTime);
#endif
    // set timer to determine latency (including calculations)
    // the UpdateTimeStats was unused and commented, so no reason to keep the if
    // if (GpsUpdated) { 
      //      MapWindow::UpdateTimeStats(true);
    // }
    // make local copy before editing...
    LockFlightData();
    if (GpsUpdated) { // timeout on FLARM objects
      FLARM_RefreshSlots(&GPS_INFO);
    }
    memcpy(&tmp_GPS_INFO,&GPS_INFO,sizeof(NMEA_INFO));
    memcpy(&tmp_CALCULATED_INFO,&CALCULATED_INFO,sizeof(DERIVED_INFO));

    UnlockFlightData();

    // Do vario first to reduce audio latency
    if (GPS_INFO.VarioAvailable) {
      // if (VarioUpdated) {  20060511/sgi commented out dueto asynchronus reset of VarioUpdate in InstrumentThread
      if (DoCalculationsVario(&tmp_GPS_INFO,&tmp_CALCULATED_INFO)) {
	        
      }
      // assume new vario data has arrived, so infoboxes
      // need to be redrawn
      //} 20060511/sgi commented out 
    } else {
      // run the function anyway, because this gives audio functions
      // if no vario connected
      if (GpsUpdated) {
	if (DoCalculationsVario(&tmp_GPS_INFO,&tmp_CALCULATED_INFO)) {
	}
	TriggerVarioUpdate(); // emulate vario update
      }
    }
    
    if (GpsUpdated) {
      if(DoCalculations(&tmp_GPS_INFO,&tmp_CALCULATED_INFO)){

        DisplayMode_t lastDisplayMode = DisplayMode;

        MapWindow::MapDirty = true;
        needcalculationsslow = true;

        switch (UserForceDisplayMode){
		case dmCircling:
			DisplayMode = dmCircling;
			break;
		case dmCruise:
			DisplayMode = dmCruise;
			break;
		case dmFinalGlide:
			DisplayMode = dmFinalGlide;
			break;
		case dmNone:
			if (tmp_CALCULATED_INFO.Circling) {
				DisplayMode = dmCircling;
			} else if (tmp_CALCULATED_INFO.FinalGlide){
				DisplayMode = dmFinalGlide;
			} else
				DisplayMode = dmCruise;

			break;
	}

        if (lastDisplayMode != DisplayMode){
		MapWindow::SwitchZoomClimb();
        }

      }
      InfoBoxesDirty = true;
    }
        
    if (MapWindow::CLOSETHREAD) break; // drop out on exit

    TriggerRedraws(&tmp_GPS_INFO, &tmp_CALCULATED_INFO);

    if (MapWindow::CLOSETHREAD) break; // drop out on exit

#if NOSIM
    if (SIMMODE) {
	if (needcalculationsslow || ( (OnBestAlternate == true) && (ReplayLogger::IsEnabled()) )) { 
		DoCalculationsSlow(&tmp_GPS_INFO,&tmp_CALCULATED_INFO);
		needcalculationsslow = false;
	}
    } else {
	if (needcalculationsslow) {
		DoCalculationsSlow(&tmp_GPS_INFO,&tmp_CALCULATED_INFO);
		needcalculationsslow = false;
	}
    }
#else
#if defined(_SIM_)
    if (needcalculationsslow || ( (OnBestAlternate == true) && (ReplayLogger::IsEnabled()) )) { // VENTA3, needed for BestAlternate SIM
#else
    if (needcalculationsslow) {
#endif
      DoCalculationsSlow(&tmp_GPS_INFO,&tmp_CALCULATED_INFO);
      needcalculationsslow = false;
    }
#endif

    if (MapWindow::CLOSETHREAD) break; // drop out on exit

    // values changed, so copy them back now: ONLY CALCULATED INFO
    // should be changed in DoCalculations, so we only need to write
    // that one back (otherwise we may write over new data)
    LockFlightData();
    memcpy(&CALCULATED_INFO,&tmp_CALCULATED_INFO,sizeof(DERIVED_INFO));
    UnlockFlightData();

    GpsUpdated = false;

#ifdef CPUSTATS
    if ( (GetThreadTimes( hCalculationThread, &CreationTime, &ExitTime,&EndKernelTime,&EndUserTime)) == 0) {
               Cpu_Calc=9999;
    } else {
               Cpustats(&Cpu_Calc,&StartKernelTime, &EndKernelTime, &StartUserTime, &EndUserTime);
    }
#endif
  }
  return 0;
}

// Since the calling function want to be sure that threads are created, they now flag a go status
// and we save 500ms at startup. 
// At the end of thread creation, we expect goCalc and goInst flags are true
void CreateCalculationThread() {
  #ifndef CPUSTATS
  // Need to keep them global to make them accessible from GetThreadTimes if in use
  HANDLE hCalculationThread;
  DWORD dwCalcThreadID;
  #endif

  // Create a read thread for performing calculations
  if ((hCalculationThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE )CalculationThread, 0, 0, &dwCalcThreadID)) != NULL)
  {
	SetThreadPriority(hCalculationThread, THREAD_PRIORITY_NORMAL); 
	#ifndef CPUSTATS
	// Do not close if we need to use the handle 
	CloseHandle (hCalculationThread); 
	#endif
  } else {
	ASSERT(1);
  }

#ifndef NOINSTHREAD

  #ifndef CPUSTATS
  HANDLE hInstrumentThread;
  DWORD dwInstThreadID;
  #endif

  if ((hInstrumentThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE )InstrumentThread, 0, 0, &dwInstThreadID)) != NULL)
  {
	SetThreadPriority(hInstrumentThread, THREAD_PRIORITY_NORMAL); 
	#ifndef CPUSTATS
	CloseHandle (hInstrumentThread);
	#endif
  } else {
	ASSERT(1);
  }
#endif

}


void PreloadInitialisation(bool ask) {
  //SetToRegistry(TEXT("XCV"), 1);
  SetToRegistry(TEXT("LKV"), 3);

  LKReadLanguageFile();

  // Registery (early)

  if (ask) {
    RestoreRegistry();
    ReadRegistrySettings();
    StatusFileInit();


  } else {
    #if LKSTARTUP
    FullScreen();
    while (dlgStartupShowModal());
    #else
    dlgStartupShowModal();
    #endif
    RestoreRegistry();
    ReadRegistrySettings();

    CreateProgressDialog(TEXT("Initialising"));
  }

  // Interface (before interface)
  if (!ask) {
    LKReadLanguageFile();
    ReadStatusFile();
    InputEvents::readFile();
  }

}

HANDLE drawTriggerEvent;

StartupState_t ProgramStarted = psInitInProgress; 
// 0: not started at all
// 1: everything is alive
// 2: done first draw
// 3: normal operation

void AfterStartup() {

  StartupStore(TEXT(". CloseProgressDialog%s"),NEWLINE);
  CloseProgressDialog();

  // NOTE: Must show errors AFTER all windows ready
  int olddelay = StatusMessageData[0].delay_ms;
  StatusMessageData[0].delay_ms = 20000; // 20 seconds

#if NOSIM
  if (SIMMODE) {
	StartupStore(TEXT(". GCE_STARTUP_SIMULATOR%s"),NEWLINE);
	InputEvents::processGlideComputer(GCE_STARTUP_SIMULATOR);
  } else {
	StartupStore(TEXT(". GCE_STARTUP_REAL%s"),NEWLINE);
	InputEvents::processGlideComputer(GCE_STARTUP_REAL);
  }
#else
#ifdef _SIM_
  StartupStore(TEXT(". GCE_STARTUP_SIMULATOR%s"),NEWLINE);
  InputEvents::processGlideComputer(GCE_STARTUP_SIMULATOR);
#else
  StartupStore(TEXT(". GCE_STARTUP_REAL%s"),NEWLINE);
  InputEvents::processGlideComputer(GCE_STARTUP_REAL);
#endif
#endif
  StatusMessageData[0].delay_ms = olddelay; 

#ifdef _INPUTDEBUG_
  InputEvents::showErrors();
#endif

  // Create default task if none exists
  StartupStore(TEXT(". Create default task%s"),NEWLINE);
//  Sleep(500); // 091212
  DefaultTask();

  // Trigger first redraw
  GpsUpdated = true;
  MapWindow::MapDirty = true;
  FullScreen();
  SetEvent(drawTriggerEvent);
}


extern int testmain();

void StartupLogFreeRamAndStorage() {
  unsigned long freeram = CheckFreeRam()/1024;
  TCHAR buffer[MAX_PATH];
  LocalPath(buffer);
  unsigned long freestorage = FindFreeSpace(buffer);
  StartupStore(TEXT(". Free ram=%ld  storage=%ld%s"), freeram,freestorage,NEWLINE);
}


int WINAPI WinMain(     HINSTANCE hInstance,
                        HINSTANCE hPrevInstance,
                        LPTSTR    lpCmdLine,
                        int       nCmdShow)
{
  MSG msg;
  HACCEL hAccelTable;
  INITCOMMONCONTROLSEX icc;
  (void)hPrevInstance;

  // use mutex to avoid multiple instances of lk8000 be running
  CreateMutex(NULL,FALSE,_T("LOCK8000"));
  if (GetLastError() == ERROR_ALREADY_EXISTS) return(0);
  
  wsprintf(XCSoar_Version,_T("%S v%S.%S "), LKFORK, LKVERSION,LKRELEASE);
  wcscat(XCSoar_Version, TEXT(__DATE__));
  StartupStore(_T("%s------------------------------------------------------------%s"),NEWLINE,NEWLINE);
  #ifdef PNA
  StartupStore(TEXT(". Starting %s %s build#%d%s"), XCSoar_Version,_T("PNA"),BUILDNUMBER,NEWLINE);
  #else
  #if (WINDOWSPC>0)
  StartupStore(TEXT(". Starting %s %s build#%d%s"), XCSoar_Version,_T("PC"),BUILDNUMBER,NEWLINE);
  #else
  StartupStore(TEXT(". Starting %s %s build#%d%s"), XCSoar_Version,_T("PDA"),BUILDNUMBER,NEWLINE);
  #endif
  #endif


  #if NOSIM
  #else
  #ifdef _SIM_
  StartupStore(TEXT(". Running mode Simulator%s"),NEWLINE);
  #endif
  #endif

  StartupLogFreeRamAndStorage();

  // PRELOAD ANYTHING HERE
  LKRun(_T("PRELOAD_00.EXE"),1,0);
  LKRun(_T("PRELOAD_05.EXE"),1,5000);
  LKRun(_T("PRELOAD_30.EXE"),1,30000);
  LKRun(_T("PRELOAD_60.EXE"),1,60000);
  LKRun(_T("PRELOAD_99.EXE"),1,INFINITE);
  // END OF PRELOAD, PROGRAM GO!

  #ifdef PNA 
  //  LocalPath is called for the very first time by CreateDirectoryIfAbsent.
  //  In order to be able in the future to behave differently for each PNA device
  //  and maybe also for common PDAs, we need to know the PNA/PDA Model Type 
  //  BEFORE calling LocalPath. This was critical.
  //  First we check the exec filename, which has priority over registry values.
  SmartGlobalModelType();

  // Huston we have a problem
  // At this point we still havent loaded profile. Loading profile will also reload registry.
  // If registry was deleted in PNA, model type is not configured. It is configured in profile, but
  // it is too early here. So no ModelType .
  //
  // if we found no embedded name, try from registry
  if (  !wcscmp(GlobalModelName, _T("UNKNOWN")) ) {
	if (  !SetModelType() ) {
		// last chance: try from default profile
		LoadModelFromProfile();
	}
  }
  #endif
  

  // registry deleted at startup also for PC
  StartupStore(_T(". Deleting registry key%s"),NEWLINE);
  if ( RegDeleteKey(HKEY_CURRENT_USER, _T(REGKEYNAME))== ERROR_SUCCESS )  // 091213
	StartupStore(_T(". Registry key was correctly deleted%s"),NEWLINE);
  else
	StartupStore(_T(". Registry key could NOT be deleted, this is normal after a reset.%s"),NEWLINE);


  bool datadir;
  datadir=CheckDataDir();
  if (!datadir) {
	// we cannot call startupstore, no place to store log!
	WarningHomeDir=true;
  }

  #if ( !defined(WINDOWSPC) || WINDOWSPC==0 )
  #if ALPHADEBUG
  StartupStore(TEXT(". Install/copy system objects in device memory%s"),NEWLINE);
  #endif
  short didsystem;
  didsystem=InstallSystem(); 
  goInstallSystem=true;
  #if ALPHADEBUG
  StartupStore(_T(". InstallSystem ended, code=%d%s"),didsystem,NEWLINE);
  #endif
  #endif

  CreateDirectoryIfAbsent(TEXT(""));  // RLD make sure the LocalPath folder actually exists
  CreateDirectoryIfAbsent(TEXT(LKD_LOGS));
  CreateDirectoryIfAbsent(TEXT(LKD_SYSTEM));
  CreateDirectoryIfAbsent(TEXT(LKD_CONF));
  CreateDirectoryIfAbsent(TEXT(LKD_TASKS));
  CreateDirectoryIfAbsent(TEXT(LKD_AIRSPACES));
  CreateDirectoryIfAbsent(TEXT(LKD_POLARS));
  CreateDirectoryIfAbsent(TEXT(LKD_MAPS));
  CreateDirectoryIfAbsent(TEXT(LKD_WAYPOINTS));

  XCSoarGetOpts(lpCmdLine);

  icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
  icc.dwICC = ICC_UPDOWN_CLASS;
  InitCommonControls();
  InitSineTable();

  StartupStore(TEXT(". Initialize application instance%s"),NEWLINE);

  // Perform application initialization: also ScreenGeometry and LKIBLSCALE, and Objects
  if (!InitInstance (hInstance, nCmdShow))
    {
	StartupStore(_T("++++++ InitInstance failed, program terminated!%s"),NEWLINE);
	return FALSE;
    }

  hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_XCSOAR);

  #ifdef HAVE_ACTIVATE_INFO
  SHSetAppKeyWndAssoc(VK_APP1, hWndMainWindow);
  SHSetAppKeyWndAssoc(VK_APP2, hWndMainWindow);
  SHSetAppKeyWndAssoc(VK_APP3, hWndMainWindow);
  SHSetAppKeyWndAssoc(VK_APP4, hWndMainWindow);
  // Typical Record Button
  //	Why you can't always get this to work
  //	http://forums.devbuzz.com/m_1185/mpage_1/key_/tm.htm
  //	To do with the fact it is a global hotkey, but you can with code above
  //	Also APPA is record key on some systems
  SHSetAppKeyWndAssoc(VK_APP5, hWndMainWindow);
  SHSetAppKeyWndAssoc(VK_APP6, hWndMainWindow);
  #endif

  StartupStore(TEXT(". Initializing critical sections and events%s"),NEWLINE);

  InitializeCriticalSection(&CritSec_EventQueue);
  csEventQueueInitialized = true;
  InitializeCriticalSection(&CritSec_TaskData);
  csTaskDataInitialized = true;
  InitializeCriticalSection(&CritSec_FlightData);
  csFlightDataInitialized = true;
  InitializeCriticalSection(&CritSec_NavBox);
  csNavBoxInitialized = true;
  InitializeCriticalSection(&CritSec_Comm);
  csCommInitialized = true;
  InitializeCriticalSection(&CritSec_TerrainDataGraphics);
  csTerrainDataGraphicsInitialized = true;
  InitializeCriticalSection(&CritSec_TerrainDataCalculations);
  csTerrainDataCalculationsInitialized = true;

  drawTriggerEvent = CreateEvent(NULL, TRUE, FALSE, TEXT("drawTriggerEvent"));
  dataTriggerEvent = CreateEvent(NULL, TRUE, FALSE, TEXT("dataTriggerEvent"));
  varioTriggerEvent = CreateEvent(NULL, TRUE, FALSE, TEXT("varioTriggerEvent"));

  // Initialise main blackboard data

  memset( &(Task), 0, sizeof(Task_t));
  memset( &(StartPoints), 0, sizeof(Start_t));
  StartupStore(_T(". ClearTask%s"),NEWLINE);
  ClearTask();
  memset( &(GPS_INFO), 0, sizeof(GPS_INFO));
  memset( &(CALCULATED_INFO), 0,sizeof(CALCULATED_INFO));
  memset( &SnailTrail[0],0,TRAILSIZE*sizeof(SNAIL_POINT));

  InitCalculations(&GPS_INFO,&CALCULATED_INFO);

  LinkGRecordDLL(); // try to link DLL if it exists

  OpenGeoid();

  PreloadInitialisation(false); // calls dlgStartup

  #ifndef NOCDIGAUGE
  GaugeCDI::Create();
  #endif
  #ifndef NOVARIOGAUGE
  GaugeVario::Create();
  #endif

  GPS_INFO.NAVWarning = true; // default, no gps at all!

  GPS_INFO.SwitchState.AirbrakeLocked = false;
  GPS_INFO.SwitchState.FlapPositive = false;
  GPS_INFO.SwitchState.FlapNeutral = false;
  GPS_INFO.SwitchState.FlapNegative = false;
  GPS_INFO.SwitchState.GearExtended = false;
  GPS_INFO.SwitchState.Acknowledge = false;
  GPS_INFO.SwitchState.Repeat = false;
  GPS_INFO.SwitchState.SpeedCommand = false;
  GPS_INFO.SwitchState.UserSwitchUp = false;
  GPS_INFO.SwitchState.UserSwitchMiddle = false;
  GPS_INFO.SwitchState.UserSwitchDown = false;
  GPS_INFO.SwitchState.VarioCircling = false;

  SYSTEMTIME pda_time;
  GetSystemTime(&pda_time);
  GPS_INFO.Time  = pda_time.wHour*3600+pda_time.wMinute*60+pda_time.wSecond;
  GPS_INFO.Year  = pda_time.wYear;
  GPS_INFO.Month = pda_time.wMonth;
  GPS_INFO.Day	 = pda_time.wDay;
  GPS_INFO.Hour  = pda_time.wHour;
  GPS_INFO.Minute = pda_time.wMinute;
  GPS_INFO.Second = pda_time.wSecond;

#if !NOSIM
#ifdef _SIM_
  #if _SIM_STARTUPSPEED
  GPS_INFO.Speed = _SIM_STARTUPSPEED;
  #endif
  #if _SIM_STARTUPALTITUDE
  GPS_INFO.Altitude = _SIM_STARTUPALTITUDE;
  #endif
#endif
#endif

#ifdef DEBUG
  DebugStore("# Start\r\n");
#endif
  #ifndef NOWINDREGISTRY	// 100404
  LoadWindFromRegistry();
  #endif
  CalculateNewPolarCoef();
  StartupStore(TEXT(". GlidePolar::SetBallast%s"),NEWLINE);
  GlidePolar::SetBallast();

// VENTA-ADDON
#ifdef VENTA_DEBUG_KEY
  CreateProgressDialog(TEXT("DEBUG KEY MODE ACTIVE"));
  Sleep(1000);
#endif
#ifdef VENTA_DEBUG_EVENT
  CreateProgressDialog(TEXT("DEBUG EVENT MODE ACTIVE"));
  Sleep(1000);
#endif


if (ScreenSize==0) {
CreateProgressDialog(TEXT("ERROR UNKNOWN RESOLUTION!"));
 Sleep(3000);
}
#ifdef PNA // VENTA-ADDON 

	TCHAR sTmp[MAX_PATH];
	wsprintf(sTmp,TEXT("Conf=%s%S"), gmfpathname(),XCSDATADIR ); // VENTA2 FIX double backslash
	CreateProgressDialog(sTmp); 

	wsprintf(sTmp, TEXT("PNA MODEL=%s (%d)"), GlobalModelName, GlobalModelType);
	CreateProgressDialog(sTmp); Sleep(300);
#else
  TCHAR sTmpA[MAX_PATH], sTmpB[MAX_PATH];
  LocalPath(sTmpA,_T(""));
#if defined(FIVV) && ( !defined(WINDOWSPC) || WINDOWSPC==0 )
  if ( !datadir ) {
    CreateProgressDialog(TEXT("ERROR NO DIRECTORY:"));
    Sleep(3000);
  }
#endif
  wsprintf(sTmpB, TEXT("Conf=%s"),sTmpA);
  CreateProgressDialog(sTmpB); 
#if defined(FIVV) && ( !defined(WINDOWSPC) || WINDOWSPC==0 )
  if ( !datadir ) {
    Sleep(3000);
    CreateProgressDialog(TEXT("CHECK INSTALLATION!"));
    Sleep(3000);
  }
#endif
#endif // non PNA

// TODO until startup graphics are settled, no need to delay PC start
  if ( AircraftCategory == (AircraftCategory_t)umParaglider )
	CreateProgressDialog(TEXT("PARAGLIDING MODE")); 
#if NOSIM
  if (SIMMODE) CreateProgressDialog(TEXT("SIMULATION")); 
#else
#ifdef _SIM_  
  CreateProgressDialog(TEXT("SIMULATION")); 
#endif
#endif


#ifdef PNA
  if ( SetBacklight() == true ) 
	CreateProgressDialog(TEXT("AUTOMATIC BACKLIGHT CONTROL"));
  else
	CreateProgressDialog(TEXT("NO BACKLIGHT CONTROL"));

  // this should work ok for all pdas as well
  if ( SetSoundVolume() == true ) 
	CreateProgressDialog(TEXT("AUTOMATIC SOUND LEVEL CONTROL"));
  else
	CreateProgressDialog(TEXT("NO SOUND LEVEL CONTROL"));
#endif

  RasterTerrain::OpenTerrain();

  ReadWayPoints();
  InitWayPointCalc(); 
  InitLDRotary(&rotaryLD); 
  InitWindRotary(&rotaryWind); // 100103
  // InitNewMap(); was moved in InitInstance 
  InitAircraftCategory();
  InitLK8000();
  ReadAirfieldFile();
  SetHome(false);
  LKReadLanguageFile();

  RasterTerrain::ServiceFullReload(GPS_INFO.Latitude, 
                                   GPS_INFO.Longitude);

  CreateProgressDialog(TEXT("Scanning weather forecast"));
  StartupStore(TEXT(". RASP load%s"),NEWLINE);
  RASP.Scan(GPS_INFO.Latitude, GPS_INFO.Longitude);

  ReadAirspace();
  SortAirspace();

  OpenTopology();
  TopologyInitialiseMarks();

  OpenFLARMDetails();


#ifndef DISABLEAUDIOVARIO
  /*
  VarioSound_Init();
  VarioSound_EnableSound(EnableSoundVario);
  VarioSound_SetVdead(SoundDeadband);
  VarioSound_SetV(0);
  VarioSound_SetSoundVolume(SoundVolume);
  */
#endif

  // ... register all supported devices
  // IMPORTANT: ADD NEW ONES TO BOTTOM OF THIS LIST
  CreateProgressDialog(TEXT("Starting devices"));
  StartupStore(TEXT(". Register serial devices%s"),NEWLINE);
  genRegister(); // MUST BE FIRST
  cai302Register();
  ewRegister();
  atrRegister();
  vgaRegister();
  caiGpsNavRegister();
  nmoRegister();
  pgRegister();
  b50Register();
  vlRegister();
  ewMicroRecorderRegister();
  lxRegister();
  zanderRegister();
  flymasterf1Register();
  CompeoRegister();
  xcom760Register();
  condorRegister();
  DigiflyRegister(); // 100209
  IlecRegister();
  // we want to be sure that RestartCommPort works on startup ONLY after all devices are inititalized
  goInitDevice=true; // 100118

#if NOSIM
  if (!NOSIM) {
	StartupStore(TEXT(". RestartCommPorts%s"),NEWLINE);
	RestartCommPorts();
  }
#else
#ifndef _SIM_
  StartupStore(TEXT(". RestartCommPorts%s"),NEWLINE);
  RestartCommPorts();
#endif
#endif
// WINDOWSPC _SIM_ devInit called twice missing devA name
// on PC nonSIM we cannot use devInit here! Generic device is used until next port reset!
#if NOSIM

#if (WINDOWSPC>0)
  if (SIMMODE) devInit(TEXT(""));      
#endif

#else

#if ((WINDOWSPC>0) && _SIM_) 
  devInit(TEXT(""));      
#endif

#endif

  // re-set polar in case devices need the data
  StartupStore(TEXT(". GlidePolar::SetBallast%s"),NEWLINE);
  GlidePolar::SetBallast();

#if (EXPERIMENTAL > 0)
  CreateProgressDialog(TEXT("Bluetooth dialup SMS"));
  bsms.Initialise();
#endif

  CreateProgressDialog(TEXT("Initialising display"));

  // just about done....

  DoSunEphemeris(GPS_INFO.Longitude, GPS_INFO.Latitude);

  // Finally ready to go
  StartupStore(TEXT(". CreateDrawingThread%s"),NEWLINE);
  MapWindow::CreateDrawingThread();
  Sleep(100);
  StartupStore(TEXT(". ShowInfoBoxes%s"),NEWLINE);
  #ifndef NOIBOX
  ShowInfoBoxes();
  #endif

  SwitchToMapWindow();
  StartupStore(TEXT(". CreateCalculationThread%s"),NEWLINE);
  CreateCalculationThread();
  #ifndef NOINSTHREAD
  while(!(goCalculationThread && goInstrumentThread)) Sleep(50); // 091119
  #else
  while(!(goCalculationThread)) Sleep(50); // 091119
  #endif
  // Sleep(500); 091119

  StartupStore(TEXT(". AirspaceWarnListInit%s"),NEWLINE);
  AirspaceWarnListInit();
  StartupStore(TEXT(". dlgAirspaceWarningInit%s"),NEWLINE);
  dlgAirspaceWarningInit();

  // find unique ID of this PDA
  ReadAssetNumber();


  MapWindow::RequestOnFullScreen(); // VENTA10 EXPERIMENTAL

  // Da-da, start everything now
  StartupStore(TEXT(". ProgramStarted=1%s"),NEWLINE);
  ProgramStarted = psInitDone;

  GlobalRunning = true;

#if _DEBUG
 // _crtBreakAlloc = -1;     // Set this to the number in {} brackets to
                           // break on a memory leak
#endif

  // Main message loop:
  /* GlobalRunning && */
  while ( GetMessage(&msg, NULL, 0, 0)) {
	if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
  }
  #if LKOBJ
  LKObjects_Delete(); //@@ 101124
  #endif
  StartupStore(_T(". WinMain terminated%s"),NEWLINE);

#if (WINDOWSPC>0)
#if _DEBUG
  _CrtCheckMemory();
  _CrtDumpMemoryLeaks();
#endif
#endif

  return msg.wParam;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    It is important to call this function so that the application
//    will get 'well formed' small icons associated with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance, LPTSTR szWindowClass)
{

  WNDCLASS wc;
  WNDCLASS dc;

  GetClassInfo(hInstance,TEXT("DIALOG"),&dc);

   wc.style                      = CS_HREDRAW | CS_VREDRAW;
//  wc.style                      = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS; // VENTA3 NO USE
  wc.lpfnWndProc                = (WNDPROC) WndProc;
  wc.cbClsExtra                 = 0;
#if (WINDOWSPC>0)
  wc.cbWndExtra = 0;
#else
  wc.cbWndExtra                 = dc.cbWndExtra ;
#endif
  wc.hInstance                  = hInstance;
#if defined(GNAV) && !defined(PCGNAV)
  wc.hIcon = NULL;
#else
  wc.hIcon                      = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_XCSOARSWIFT));
#endif
  wc.hCursor                    = 0;
  wc.hbrBackground              = (HBRUSH) GetStockObject(BLACK_BRUSH); 
  wc.lpszMenuName               = 0;
  wc.lpszClassName              = szWindowClass;

  if (!RegisterClass (&wc))
    return FALSE;

  // disabling DBLCLK here will make it not working in map window and maplocking failure
  wc.style = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
  wc.lpfnWndProc = (WNDPROC)MapWindow::MapWndProc;
  wc.cbClsExtra = 0;

#if (WINDOWSPC>0)
  wc.cbWndExtra = 0 ;
#else
  wc.cbWndExtra = dc.cbWndExtra ;
#endif

  wc.hInstance = hInstance;
  wc.hIcon = (HICON)NULL;
  wc.hCursor = NULL;
  wc.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH); // refixed 100101
  wc.lpszMenuName = 0;
  wc.lpszClassName = TEXT("MapWindowClass");

  return RegisterClass(&wc);

}


void ApplyClearType(LOGFONT *logfont) {
  logfont->lfQuality = ANTIALIASED_QUALITY;
  if (0) {
    logfont->lfQuality = CLEARTYPE_COMPAT_QUALITY; // VENTA TODO FIX HERE. WHY NOT LANDSCAPE? cleartype is not native, but better than nothing!
#ifndef NOCLEARTYPE
  if (!InfoBoxLayout::landscape) {
    logfont->lfQuality = CLEARTYPE_COMPAT_QUALITY; // VENTA TODO FIX HERE. WHY NOT LANDSCAPE? cleartype is not native, but better than nothing!
  }
#endif
  }
}

bool IsNullLogFont(LOGFONT logfont) {
  bool bRetVal=false;

  LOGFONT LogFontBlank;
  memset ((char *)&LogFontBlank, 0, sizeof (LOGFONT));

  if ( memcmp(&logfont, &LogFontBlank, sizeof(LOGFONT)) == 0) {
    bRetVal=true;
  }
  return bRetVal;
}

void InitializeOneFont (HFONT * theFont, 
                               const TCHAR FontRegKey[] , 
                               LOGFONT autoLogFont, 
                               LOGFONT * LogFontUsed)
{
  LOGFONT logfont;
  int iDelStatus = 0;
  if (GetObjectType(*theFont) == OBJ_FONT) {
    iDelStatus=DeleteObject(*theFont); // RLD the EditFont screens use the Delete
  }

  memset ((char *)&logfont, 0, sizeof (LOGFONT));

  if (UseCustomFonts) {
    propGetFontSettings((TCHAR * )FontRegKey, &logfont);
    if (!IsNullLogFont(logfont)) {
      *theFont = CreateFontIndirect (&logfont);
      if (GetObjectType(*theFont) == OBJ_FONT) {
        if (LogFontUsed != NULL) *LogFontUsed = logfont; // RLD save for custom font GUI
      }
    }
  }

  if (GetObjectType(*theFont) != OBJ_FONT) {
    if (!IsNullLogFont(autoLogFont)) {
      ApplyClearType(&autoLogFont);
      *theFont = CreateFontIndirect (&autoLogFont);
      if (GetObjectType(*theFont) == OBJ_FONT) {
        if (LogFontUsed != NULL) *LogFontUsed = autoLogFont; // RLD save for custom font GUI
      }
    }
  }
}

void InitialiseFontsHardCoded(RECT rc,
                        LOGFONT * ptrhardInfoWindowLogFont,
                        LOGFONT * ptrhardTitleWindowLogFont,
                        LOGFONT * ptrhardMapWindowLogFont,
                        LOGFONT * ptrhardTitleSmallWindowLogFont,
                        LOGFONT * ptrhardMapWindowBoldLogFont,
                        LOGFONT * ptrhardCDIWindowLogFont, // New
                        LOGFONT * ptrhardMapLabelLogFont,
                        LOGFONT * ptrhardStatisticsLogFont) {



  memset ((char *)ptrhardInfoWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrhardTitleWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrhardMapWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrhardTitleSmallWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrhardMapWindowBoldLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrhardCDIWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrhardMapLabelLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrhardStatisticsLogFont, 0, sizeof (LOGFONT));


/*
 * VENTA-ADDON 2/2/08 
 * Adding custom font settings for PNAs
 *
 * InfoWindowFont	= values inside infoboxes  like numbers, etc.
 * TitleWindowFont	= Titles of infoboxes like Next, WP L/D etc.
 * TitleSmallWindowFont = 
 * CDIWindowFont	= vario display, runway informations
 * MapLabelFont		= Flarm Traffic draweing and stats, map labels in italic
 * StatisticsFont
 * MapWindowFont	= text names on the map
 * MapWindowBoldFont = menu buttons, waypoint selection, messages, etc.
 *
 *
 */

#if ( (WINDOWSPC==0) || ((WINDOWSPC>0)&&_REALTHING_)) // 091120  091202 removed _SIM_ need

   // If you set a font here for a specific resolution, no automatic font generation is used.
  if (ScreenSize==(ScreenSize_t)ss480x272) { // WQVGA  e.g. MIO
    propGetFontSettingsFromString(TEXT("34,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont); // 28 091120
    propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont); // 16 091120
    propGetFontSettingsFromString(TEXT("28,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont); 
    propGetFontSettingsFromString(TEXT("15,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,700,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // 100709
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    // propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont); 091120
    propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    // propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont); 091120
    propGetFontSettingsFromString(TEXT("20,0,0,0,700,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
    if (Appearance.InfoBoxGeom == 5) {
      GlobalEllipse=1.32f; // We don't use vario gauge in landscape geo5 anymore.. but doesn't hurt.
    }
    else {
      GlobalEllipse=1.1f;
    }
  }
  else if (ScreenSize==(ScreenSize_t)ss720x408) { // WQVGA  e.g. MIO
    propGetFontSettingsFromString(TEXT("51,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont); // 28 091120
    propGetFontSettingsFromString(TEXT("21,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont); // 16 091120
    propGetFontSettingsFromString(TEXT("42,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont); 
    propGetFontSettingsFromString(TEXT("23,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("23,0,0,0,600,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // 100709
    propGetFontSettingsFromString(TEXT("30,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    propGetFontSettingsFromString(TEXT("33,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("30,0,0,0,700,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
    if (Appearance.InfoBoxGeom == 5) {
      GlobalEllipse=1.32f; // We don't use vario gauge in landscape geo5 anymore.. but doesn't hurt.
    }
    else {
      GlobalEllipse=1.1f;
    }
  }

  else if (ScreenSize==(ScreenSize_t)ss480x234) { // e.g. Messada 2440
    propGetFontSettingsFromString(TEXT("32,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
    propGetFontSettingsFromString(TEXT("28,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
    propGetFontSettingsFromString(TEXT("15,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    //propGetFontSettingsFromString(TEXT("13,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // 14 091120
    propGetFontSettingsFromString(TEXT("16,0,0,0,600,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // 100709
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    // propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont); 091120
    propGetFontSettingsFromString(TEXT("20,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    // propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont); 091120
    propGetFontSettingsFromString(TEXT("15,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
    GlobalEllipse=1.1f; // to be checked, TODO
  }

  else if (ScreenSize==(ScreenSize_t)ss800x480) {// e.g. ipaq 31x {

    switch (Appearance.InfoBoxGeom) {	
      case 0:
      case 1:
      case 2:
      case 3:
      case 6: // standard landscape
            propGetFontSettingsFromString(TEXT("56,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
            propGetFontSettingsFromString(TEXT("20,0,0,0,200,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
            GlobalEllipse=1.1f;	// standard VENTA2-addon
            break;
      case 4:       
      case 5:   
            propGetFontSettingsFromString(TEXT("62,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont); // 64 091120
            propGetFontSettingsFromString(TEXT("24,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont); // 26 091120
            GlobalEllipse=1.32f;	// VENTA2-addon
            break;
      case 7:
            propGetFontSettingsFromString(TEXT("66,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
            propGetFontSettingsFromString(TEXT("23,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
		  break;

       // This is a failsafe with an impossible setting so that you know 
      // something is going very wrong.
       default:
            propGetFontSettingsFromString(TEXT("30,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
            propGetFontSettingsFromString(TEXT("10,0,0,0,200,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
          //}
            break;
    } // special geometry cases for 31x


    propGetFontSettingsFromString(TEXT("16,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
    propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardCDIWindowLogFont);
    // propGetFontSettingsFromString(TEXT("26,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); pre 100709
    propGetFontSettingsFromString(TEXT("28,0,0,0,600,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // 100709
    propGetFontSettingsFromString(TEXT("48,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);
    propGetFontSettingsFromString(TEXT("36,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("32,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);


  }
  // added 091204
  else if (ScreenSize==(ScreenSize_t)ss400x240) {

    switch (Appearance.InfoBoxGeom) {	
      case 0:
      case 1:
      case 2:
      case 3:
      case 6: // standard landscape
            propGetFontSettingsFromString(TEXT("28,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
            propGetFontSettingsFromString(TEXT("10,0,0,0,200,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
            GlobalEllipse=1.1f;	// standard VENTA2-addon
            break;
      case 4:       
      case 5:   
            propGetFontSettingsFromString(TEXT("31,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont); // 64 091120
            propGetFontSettingsFromString(TEXT("12,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont); // 26 091120
            GlobalEllipse=1.32f;	// VENTA2-addon
            break;
      case 7:
            propGetFontSettingsFromString(TEXT("33,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
            propGetFontSettingsFromString(TEXT("11,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
		  break;

       // This is a failsafe with an impossible setting so that you know 
      // something is going very wrong.
       default:
            propGetFontSettingsFromString(TEXT("15,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
            propGetFontSettingsFromString(TEXT("5,0,0,0,200,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
          //}
            break;
    } 


    propGetFontSettingsFromString(TEXT("8,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("13,0,0,0,600,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont);
    propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);
    propGetFontSettingsFromString(TEXT("18,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("18,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowBoldLogFont);


  }
  else if (ScreenSize==(ScreenSize_t)ss640x480) { // real VGA, not fake VGA
    propGetFontSettingsFromString(TEXT("54,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont); // infobox values
    propGetFontSettingsFromString(TEXT("19,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);  // infobox titles
    propGetFontSettingsFromString(TEXT("40,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont); // teamcode?
    propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont); // waynotes
    // propGetFontSettingsFromString(TEXT("23,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // old topo labels
    propGetFontSettingsFromString(TEXT("26,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // 100709 topo labels
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    propGetFontSettingsFromString(TEXT("32,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);  // wps and mapscale
    propGetFontSettingsFromString(TEXT("28,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont); // bold version of MapW
										// and all messages and menus
    GlobalEllipse=1.1f; // to be checked, TODO but unused, now
  }
  else if (ScreenSize==(ScreenSize_t)ss896x672) { // real VGA, not fake VGA
    propGetFontSettingsFromString(TEXT("75,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont); // infobox values
    propGetFontSettingsFromString(TEXT("25,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);  // infobox titles
    propGetFontSettingsFromString(TEXT("56,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont); // teamcode?
    propGetFontSettingsFromString(TEXT("33,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont); // waynotes
    propGetFontSettingsFromString(TEXT("32,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // topo labels
    propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    propGetFontSettingsFromString(TEXT("44,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);  // wps and mapscale
    propGetFontSettingsFromString(TEXT("39,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont); // bold version of MapW
										// and all messages and menus
    GlobalEllipse=1.1f; // to be checked, TODO but unused, now
  }
  else if (ScreenSize==(ScreenSize_t)ss320x240) { // also applies for fake VGA where all values are doubled stretched
    propGetFontSettingsFromString(TEXT("26,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
    propGetFontSettingsFromString(TEXT("21,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,600,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // 100819
    propGetFontSettingsFromString(TEXT("10,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    propGetFontSettingsFromString(TEXT("18,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("13,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
    GlobalEllipse=1.1f; // to be checked, TODO
  }
  else if (ScreenSize==(ScreenSize_t)ss240x320) { // also applies for fake VGA where all values are doubled stretched
    propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
    propGetFontSettingsFromString(TEXT("21,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
    propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("12,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // RLD 16 works well too
    propGetFontSettingsFromString(TEXT("10,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    propGetFontSettingsFromString(TEXT("16,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("15,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
    GlobalEllipse=1.1f; // to be checked, TODO
  }
  else if (ScreenSize==(ScreenSize_t)ss272x480) { 
    propGetFontSettingsFromString(TEXT("24,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("12,0,0,0,100,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
    propGetFontSettingsFromString(TEXT("21,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
    propGetFontSettingsFromString(TEXT("12,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("12,0,0,0,600,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); 
    propGetFontSettingsFromString(TEXT("10,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);
    propGetFontSettingsFromString(TEXT("18,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("18,0,0,0,800,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowBoldLogFont);
    GlobalEllipse=1.1f; 
  }
  else if (ScreenSize==(ScreenSize_t)ss480x640) { // real VGA, not fake VGA
    propGetFontSettingsFromString(TEXT("48,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont); // infobox values
    propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);  // infobox titles
    propGetFontSettingsFromString(TEXT("40,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont); // teamcode?
    propGetFontSettingsFromString(TEXT("26,0,0,0,100,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont); // waynotes
    propGetFontSettingsFromString(TEXT("23,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // topo labels
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    propGetFontSettingsFromString(TEXT("32,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);  // wps and mapscale
    propGetFontSettingsFromString(TEXT("30,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont); // bold version of MapW
										// and all messages and menus
    GlobalEllipse=1.1f; // to be checked, TODO but unused, now
  }
  else if (ScreenSize==(ScreenSize_t)ss480x800) { // real VGA, not fake VGA
    propGetFontSettingsFromString(TEXT("48,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont); // infobox values
    propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);  // infobox titles
    propGetFontSettingsFromString(TEXT("40,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont); // teamcode?
    propGetFontSettingsFromString(TEXT("26,0,0,0,100,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont); // waynotes
    propGetFontSettingsFromString(TEXT("23,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // topo labels
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);//  (RLD is this used?)
    propGetFontSettingsFromString(TEXT("32,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);  // wps and mapscale
    propGetFontSettingsFromString(TEXT("30,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont); // bold version of MapW
										// and all messages and menus
    GlobalEllipse=1.1f; // to be checked, TODO but unused, now
  }


/* VENTA5 TEST automatic fallback for 320x240,640x480 and unusual resolutions  091120 REMOVE 
//  THESE RESOLUTIONS ARE *NOT* MANAGED FOR PDA here
  // Fallback for any other resolution
  else if (InfoBoxLayout::landscape) {

    propGetFontSettingsFromString(TEXT("28,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("13,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont);
    propGetFontSettingsFromString(TEXT("10,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);
    propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,500,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
  }
  else { // portrait

    propGetFontSettingsFromString(TEXT("28,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
    propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont);
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);
    propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
  }
*/

#endif // not WindowsPC or RealThing


}

void InitialiseFontsAuto(RECT rc,
                        LOGFONT * ptrautoInfoWindowLogFont,
                        LOGFONT * ptrautoTitleWindowLogFont,
                        LOGFONT * ptrautoMapWindowLogFont,
                        LOGFONT * ptrautoTitleSmallWindowLogFont,
                        LOGFONT * ptrautoMapWindowBoldLogFont,
                        LOGFONT * ptrautoCDIWindowLogFont, // New
                        LOGFONT * ptrautoMapLabelLogFont,
                        LOGFONT * ptrautoStatisticsLogFont) {
  LOGFONT logfont;
  int FontHeight, FontWidth;
  int fontsz1 = (rc.bottom - rc.top );
  int fontsz2 = (rc.right - rc.left );

  memset ((char *)ptrautoInfoWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrautoTitleWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrautoMapWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrautoTitleSmallWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrautoMapWindowBoldLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrautoCDIWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrautoMapLabelLogFont, 0, sizeof (LOGFONT));
  memset ((char *)ptrautoStatisticsLogFont, 0, sizeof (LOGFONT));

  if (fontsz1<fontsz2) { // portrait
    FontHeight = (int)(fontsz1/FONTHEIGHTRATIO*1.33);  // use small dimension, to work for widscreens and adjust so it works for 4x3 screens too.
    FontWidth = (int)(FontHeight*0.4);
  } 
  else if (fontsz1==fontsz2)
  {  // square
    FontHeight = (int)(fontsz2/FONTHEIGHTRATIO);
    FontWidth = (int)(FontHeight*0.4);
  }
  else 
  { // landscape 
    FontHeight = (int)(fontsz2/FONTHEIGHTRATIO*1.33);
    FontWidth = (int)(FontHeight*0.4);
  }

  int iFontHeight = (int)(FontHeight*1.4);
  // oversize first so can then scale down

  FontWidth = 0; // JMW this should be done so closest font is found

  // sgi todo

  memset ((char *)&logfont, 0, sizeof (logfont));

// #if defined(PNA) || defined(FIVV)  // Only for PNA, since we still do not copy Fonts in their Windows memory.
				      // though we could already do it automatically. 
// #if defined(PNA) //FIX 090925 QUI
#if NOSIM
  _tcscpy(logfont.lfFaceName, _T("Tahoma")); 
#else
#if defined(PNA) || ((WINDOWSPC>0)&&_REALTHING_&&_SIM_)  // 091118
//#if (1)
	_tcscpy(logfont.lfFaceName, _T("Tahoma")); 
#else
  _tcscpy(logfont.lfFaceName, _T("DejaVu Sans Condensed"));
#endif
#endif


  logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE  ;
  logfont.lfHeight = iFontHeight;
  logfont.lfWidth =  FontWidth;
  logfont.lfWeight = FW_BOLD;
  logfont.lfItalic = TRUE;
  logfont.lfCharSet = ANSI_CHARSET;
  ApplyClearType(&logfont);

  // JMW algorithm to auto-size info window font.
  // this is still required in case title font property doesn't exist.
  SIZE tsize;
  HDC iwhdc = GetDC(hWndMainWindow);
  do {
    HFONT TempWindowFont;
    HFONT hfOld;

    iFontHeight--;
    logfont.lfHeight = iFontHeight;
//    InfoWindowFont = CreateFontIndirect (&logfont);
//    SelectObject(iwhdc, InfoWindowFont);

    TempWindowFont = CreateFontIndirect (&logfont);
    hfOld=(HFONT)SelectObject(iwhdc, TempWindowFont);


    GetTextExtentPoint(iwhdc, TEXT("00:00"), 5, &tsize);
//    DeleteObject(InfoWindowFont);
    SelectObject(iwhdc, hfOld); // unselect it before deleting it
    DeleteObject(TempWindowFont);

  } while (tsize.cx>InfoBoxLayout::ControlWidth);
  ReleaseDC(hWndMainWindow, iwhdc);

  iFontHeight++;
  logfont.lfHeight = iFontHeight;

//  propGetFontSettings(TEXT("InfoWindowFont"), &logfont);
//  InfoWindowFont = CreateFontIndirect (&logfont);
 memcpy ((void *)ptrautoInfoWindowLogFont, &logfont, sizeof (LOGFONT));


  // next font..

#if NOSIM

#else
#if (WINDOWSPC>0)&& (!(_REALTHING_&&_SIM_) )
  FontHeight= (int)(FontHeight/1.35);
  FontWidth= (int)(FontWidth/1.35);
#endif
#endif

  memset ((char *)&logfont, 0, sizeof (logfont));

  _tcscpy(logfont.lfFaceName, _T("Tahoma"));
  logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE  ;
  logfont.lfHeight = (int)(FontHeight/TITLEFONTHEIGHTRATIO);
  logfont.lfWidth =  (int)(FontWidth/TITLEFONTWIDTHRATIO);
  logfont.lfWeight = FW_BOLD;
  //  ApplyClearType(&logfont);
  // RLD this was the only auto font to not have "ApplyClearType()".  It does not apply to very small fonts
  // we now apply ApplyClearType to all fonts in CreateOneFont(). 

//  propGetFontSettings(TEXT("TitleWindowFont"), &logfont);
//  TitleWindowFont = CreateFontIndirect (&logfont);
  memcpy ((void *)ptrautoTitleWindowLogFont, &logfont, sizeof (LOGFONT));

  memset ((char *)&logfont, 0, sizeof (logfont));

  // new font for CDI Scale

  _tcscpy(logfont.lfFaceName, _T(GLOBALFONT));
  logfont.lfPitchAndFamily = FIXED_PITCH | FF_DONTCARE  ;
  logfont.lfHeight = (int)(FontHeight*CDIFONTHEIGHTRATIO);
  logfont.lfWidth =  (int)(FontWidth*CDIFONTWIDTHRATIO);
  logfont.lfWeight = FW_MEDIUM;
//  ApplyClearType(&logfont);

//  propGetFontSettings(TEXT("CDIWindowFont"), &logfont);
//  CDIWindowFont = CreateFontIndirect (&logfont);
  memcpy ((void *)ptrautoCDIWindowLogFont, &logfont, sizeof (LOGFONT));

  // new font for map labels
  memset ((char *)&logfont, 0, sizeof (logfont));

  _tcscpy(logfont.lfFaceName, _T("Tahoma"));
  logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE  ;
  logfont.lfHeight = (int)(FontHeight*MAPFONTHEIGHTRATIO);
  logfont.lfWidth =  (int)(FontWidth*MAPFONTWIDTHRATIO);
  logfont.lfWeight = FW_MEDIUM;
  logfont.lfItalic = TRUE; 
//  ApplyClearType(&logfont);

//  propGetFontSettings(TEXT("MapLabelFont"), &logfont);
//  MapLabelFont = CreateFontIndirect (&logfont);
  memcpy ((void *)ptrautoMapLabelLogFont, &logfont, sizeof (LOGFONT));


  // Font for map other text
  memset ((char *)&logfont, 0, sizeof (logfont));

  _tcscpy(logfont.lfFaceName, _T("Tahoma"));
  logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE  ;
  logfont.lfHeight = (int)(FontHeight*STATISTICSFONTHEIGHTRATIO);
  logfont.lfWidth =  (int)(FontWidth*STATISTICSFONTWIDTHRATIO);
  logfont.lfWeight = FW_MEDIUM;
//  ApplyClearType(&logfont);

//  propGetFontSettings(TEXT("StatisticsFont"), &logfont);
//  StatisticsFont = CreateFontIndirect (&logfont);
  memcpy ((void *)ptrautoStatisticsLogFont, &logfont, sizeof (LOGFONT));

  // new font for map labels

  _tcscpy(logfont.lfFaceName, _T("Tahoma"));
  logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE  ;
  logfont.lfHeight = (int)(FontHeight*MAPFONTHEIGHTRATIO*1.3);
  logfont.lfWidth =  (int)(FontWidth*MAPFONTWIDTHRATIO*1.3);
  logfont.lfWeight = FW_MEDIUM;
//  ApplyClearType(&logfont);

//  propGetFontSettings(TEXT("MapWindowFont"), &logfont);
//  MapWindowFont = CreateFontIndirect (&logfont);

//  SendMessage(hWndMapWindow,WM_SETFONT,
//        (WPARAM)MapWindowFont,MAKELPARAM(TRUE,0));
  memcpy ((void *)ptrautoMapWindowLogFont, &logfont, sizeof (LOGFONT));

  // Font for map bold text

  _tcscpy(logfont.lfFaceName, _T("Tahoma"));
  logfont.lfWeight = FW_BOLD;
  logfont.lfWidth =  0; // JMW (int)(FontWidth*MAPFONTWIDTHRATIO*1.3) +2;

//  propGetFontSettings(TEXT("MapWindowBoldFont"), &logfont);
//  MapWindowBoldFont = CreateFontIndirect (&logfont);
  memcpy ((void *)ptrautoMapWindowBoldLogFont, &logfont, sizeof (LOGFONT));

  // TODO code: create font settings for this one...
  memset((char *)&logfont, 0, sizeof (logfont));
  _tcscpy(logfont.lfFaceName, _T(GLOBALFONT));
  
  logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE  ;
  logfont.lfHeight = IBLSCALE(20);
  logfont.lfWidth =  IBLSCALE(8);
  logfont.lfWeight = FW_MEDIUM;
  
  memcpy ((void *)ptrautoTitleSmallWindowLogFont, &logfont, sizeof (LOGFONT));
}

//  propGetFontSettings(TEXT("TeamCodeFont"), &logfont);
//  TitleSmallWindowFont = CreateFontIndirect (&logfont);


void InitialiseFonts(RECT rc)
{ //this routine must be called only at start/restart of XCSoar b/c there are many pointers to these fonts
 
  DeleteObject(InfoWindowFont);  
  DeleteObject(TitleWindowFont);
  DeleteObject(MapWindowFont);
  DeleteObject(TitleSmallWindowFont);
  DeleteObject(MapWindowBoldFont);
  DeleteObject(CDIWindowFont);
  DeleteObject(MapLabelFont);
  DeleteObject(StatisticsFont);

  memset ((char *)&autoInfoWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&autoTitleWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&autoMapWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&autoTitleSmallWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&autoMapWindowBoldLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&autoCDIWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&autoMapLabelLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&autoStatisticsLogFont, 0, sizeof (LOGFONT));


  InitialiseFontsAuto(rc, 
                        &autoInfoWindowLogFont,
                        &autoTitleWindowLogFont,
                        &autoMapWindowLogFont,
                        &autoTitleSmallWindowLogFont,
                        &autoMapWindowBoldLogFont,
                        &autoCDIWindowLogFont, // New
                        &autoMapLabelLogFont,
                        &autoStatisticsLogFont);


  LOGFONT hardInfoWindowLogFont;
  LOGFONT hardTitleWindowLogFont;
  LOGFONT hardMapWindowLogFont;
  LOGFONT hardTitleSmallWindowLogFont;
  LOGFONT hardMapWindowBoldLogFont;
  LOGFONT hardCDIWindowLogFont; 
  LOGFONT hardMapLabelLogFont;
  LOGFONT hardStatisticsLogFont;

  memset ((char *)&hardInfoWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&hardTitleWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&hardMapWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&hardTitleSmallWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&hardMapWindowBoldLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&hardCDIWindowLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&hardMapLabelLogFont, 0, sizeof (LOGFONT));
  memset ((char *)&hardStatisticsLogFont, 0, sizeof (LOGFONT));

  InitialiseFontsHardCoded(rc,
                        &hardInfoWindowLogFont,
                        &hardTitleWindowLogFont,
                        &hardMapWindowLogFont,
                        &hardTitleSmallWindowLogFont,
                        &hardMapWindowBoldLogFont,
                        &hardCDIWindowLogFont, // New
                        &hardMapLabelLogFont,
                        &hardStatisticsLogFont);

// for PNA & GNAV, merge the "hard" into the "auto" if one exists 
  if (!IsNullLogFont(hardInfoWindowLogFont))
    autoInfoWindowLogFont = hardInfoWindowLogFont;

  if (!IsNullLogFont(hardTitleWindowLogFont))
    autoTitleWindowLogFont = hardTitleWindowLogFont;

  if (!IsNullLogFont(hardMapWindowLogFont))
    autoMapWindowLogFont = hardMapWindowLogFont;

  if (!IsNullLogFont(hardTitleSmallWindowLogFont))
    autoTitleSmallWindowLogFont = hardTitleSmallWindowLogFont;

  if (!IsNullLogFont(hardMapWindowBoldLogFont))
    autoMapWindowBoldLogFont = hardMapWindowBoldLogFont;

  if (!IsNullLogFont(hardCDIWindowLogFont))
    autoCDIWindowLogFont = hardCDIWindowLogFont;

  if (!IsNullLogFont(hardMapLabelLogFont))
    autoMapLabelLogFont = hardMapLabelLogFont;

  if (!IsNullLogFont(hardStatisticsLogFont))
    autoStatisticsLogFont = hardStatisticsLogFont;


  InitializeOneFont (&InfoWindowFont, 
                        szRegistryFontInfoWindowFont, 
                        autoInfoWindowLogFont,
                        NULL);

  InitializeOneFont (&TitleWindowFont, 
                        szRegistryFontTitleWindowFont, 
                        autoTitleWindowLogFont,
                        NULL);

  InitializeOneFont (&CDIWindowFont, 
                        szRegistryFontCDIWindowFont, 
                        autoCDIWindowLogFont,
                        NULL);

  InitializeOneFont (&MapLabelFont, 
                        szRegistryFontMapLabelFont, 
                        autoMapLabelLogFont,
                        NULL);

  InitializeOneFont (&StatisticsFont, 
                        szRegistryFontStatisticsFont, 
                        autoStatisticsLogFont,
                        NULL);

  InitializeOneFont (&MapWindowFont, 
                        szRegistryFontMapWindowFont, 
                        autoMapWindowLogFont,
                        NULL);
  SendMessage(hWndMapWindow,WM_SETFONT,
              (WPARAM)MapWindowFont,MAKELPARAM(TRUE,0));

  InitializeOneFont (&MapWindowBoldFont, 
                        szRegistryFontMapWindowBoldFont, 
                        autoMapWindowBoldLogFont,
                        NULL);

  InitializeOneFont (&TitleSmallWindowFont, 
                        szRegistryFontTitleSmallWindowFont, 
                        autoTitleSmallWindowLogFont,
                        NULL);
}


#if (WINDOWSPC>0) 
int SCREENWIDTH=640;
int SCREENHEIGHT=480;
#endif

//
//  FUNCTION: InitInstance(HANDLE, int)
//
//  PURPOSE: Saves instance handle and creates main window
//
//  COMMENTS:
//
//    In this function, we save the instance handle in a global variable and
//    create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
  TCHAR szTitle[MAX_LOADSTRING];                        // The title bar text
  TCHAR szWindowClass[MAX_LOADSTRING];                  // The window class name
  RECT rc;

  hInst = hInstance;            // Store instance handle in our global variable


  LoadString(hInstance, IDC_XCSOAR, szWindowClass, MAX_LOADSTRING);
  LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);

  // If it is already running, then focus on the window
  // problem was  that if two instances are started within a few seconds, both will survive!
  // We enforceed this with mutex at the beginning of WinMain
  hWndMainWindow = FindWindow(szWindowClass, szTitle);
  if (hWndMainWindow)
    {
      SetForegroundWindow((HWND)((ULONG) hWndMainWindow | 0x00000001));
      return 0;
    }
  InitScreenSize();
  InitNewMap(); // causing problems with CreateButtonLabels?
  PreloadInitialisation(true);

  MyRegisterClass(hInst, szWindowClass);

  RECT WindowSize;

  WindowSize.left = 0;
  WindowSize.top = 0;
  WindowSize.right = GetSystemMetrics(SM_CXSCREEN);
  WindowSize.bottom = GetSystemMetrics(SM_CYSCREEN);


#if (WINDOWSPC>0)
  WindowSize.right = SCREENWIDTH 
    + 2*GetSystemMetrics( SM_CXFIXEDFRAME);
  WindowSize.left = (GetSystemMetrics(SM_CXSCREEN) - WindowSize.right) / 2;
  WindowSize.bottom = SCREENHEIGHT 
    + 2*GetSystemMetrics( SM_CYFIXEDFRAME) + GetSystemMetrics(SM_CYCAPTION);
  WindowSize.top = (GetSystemMetrics(SM_CYSCREEN) - WindowSize.bottom) / 2;
#endif

  if (!goInstallSystem) Sleep(50); // 091119
  StartupStore(TEXT(". Create main window%s"),NEWLINE);

  hWndMainWindow = CreateWindow(szWindowClass, szTitle,
                                WS_SYSMENU
                                | WS_CLIPCHILDREN
				| WS_CLIPSIBLINGS,
                                WindowSize.left, WindowSize.top,
				WindowSize.right, WindowSize.bottom,
                                NULL, NULL,
				hInstance, NULL);

  if (!hWndMainWindow)
    {
      return FALSE;
    }

#if defined(GNAV) && !defined(PCGNAV)
  // TODO code: release the handle?
  HANDLE hTmp = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_XCSOARSWIFT));
  SendMessage(hWndMainWindow, WM_SETICON,
	      (WPARAM)ICON_BIG, (LPARAM)hTmp);
  SendMessage(hWndMainWindow, WM_SETICON,
	      (WPARAM)ICON_SMALL, (LPARAM)hTmp);
#endif

  hBrushSelected = (HBRUSH)CreateSolidBrush(ColorSelected);
  hBrushUnselected = (HBRUSH)CreateSolidBrush(ColorUnselected);
  hBrushButton = (HBRUSH)CreateSolidBrush(ColorButton);

  GetClientRect(hWndMainWindow, &rc);

#if (WINDOWSPC>0)
  rc.left = 0;
  rc.right = SCREENWIDTH;
  rc.top = 0;
  rc.bottom = SCREENHEIGHT;
#endif

  StartupStore(TEXT(". InfoBox geometry%s"),NEWLINE);

  InfoBoxLayout::ScreenGeometry(rc);
  #if LKOBJ
  StartupStore(TEXT(". Create Objects%s"),NEWLINE);
  LKObjects_Create(); //@@ 101124
  #endif

  StartupStore(TEXT(". Load unit bitmaps%s"),NEWLINE);

  Units::LoadUnitBitmap(hInstance);

  StartupStore(TEXT(". Create info boxes%s"),NEWLINE);

  #ifndef NOIBOX
  InfoBoxLayout::CreateInfoBoxes(rc);
  #endif

  #ifndef NOFLARMGAUGE
  StartupStore(TEXT(". Create FLARM gauge%s"),NEWLINE);
  GaugeFLARM::Create();
  #endif

  StartupStore(TEXT(". Create button labels%s"),NEWLINE);
  ButtonLabel::CreateButtonLabels(rc);
  ButtonLabel::SetLabelText(0,TEXT("MODE"));

  StartupStore(TEXT(". Initialize fonts%s"),NEWLINE);
  InitialiseFonts(rc);

  ButtonLabel::SetFont(MapWindowBoldFont);

  StartupStore(TEXT(". Initialise message system%s"),NEWLINE);
  Message::Initialize(rc); // creates window, sets fonts

  ShowWindow(hWndMainWindow, SW_SHOW);

  StartupStore(TEXT(". Create map window%s"),NEWLINE);

  hWndMapWindow = CreateWindow(TEXT("MapWindowClass"),NULL,
			       WS_VISIBLE | WS_CHILD
			       | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                               0, 0, (rc.right - rc.left),
			       (rc.bottom-rc.top) ,
                               hWndMainWindow, NULL ,hInstance,NULL);

  // JMW gauge creation was here
  ShowWindow(hWndMainWindow, nCmdShow);

  UpdateWindow(hWndMainWindow);
    
  return TRUE;
}


// Obfuscated C code contest winner
int getInfoType(int i) {
  int retval = 0;
  if (i<0) return 0; // error

  if (EnableAuxiliaryInfo) {
    retval = (InfoType[i] >> 24) & 0xff; // auxiliary
  } else {
    if (DisplayMode == dmCircling)
      retval = InfoType[i] & 0xff; // climb
    else if (DisplayMode == dmFinalGlide) {
      retval = (InfoType[i] >> 16) & 0xff; //final glide
    } else {
      retval = (InfoType[i] >> 8) & 0xff; // cruise
    }
  }
  return min(NUMSELECTSTRINGS-1,retval);
}


void setInfoType(int i, char j) {
  if (i<0) return; // error

  if (EnableAuxiliaryInfo) {
    InfoType[i] &= 0x00ffffff;
    InfoType[i] += (j<<24);
  } else {
    if (DisplayMode == dmCircling) {
      InfoType[i] &= 0xffffff00;
      InfoType[i] += (j);
    } else if (DisplayMode == dmFinalGlide) {
      InfoType[i] &= 0xff00ffff;
      InfoType[i] += (j<<16);
    } else {
      InfoType[i] &= 0xffff00ff;
      InfoType[i] += (j<<8);
    }
  }
}


void DoInfoKey(int keycode) {
  int i;

  if (InfoFocus<0) return; // paranoid

  HideMenu();

  LockNavBox();
  i = getInfoType(InfoFocus);

  // XXX This could crash if MapWindow does not capture

  LockFlightData();
  Data_Options[min(NUMSELECTSTRINGS-1,i)].Process(keycode);
  UnlockFlightData();

  UnlockNavBox();

  InfoBoxesDirty = true;

  TriggerGPSUpdate(); // emulate update to trigger calculations

  InfoBoxFocusTimeOut = 0;
  DisplayTimeOut = 0;

}


// Debounce input buttons (does not matter which button is pressed)
// VNT 090702 FIX Careful here: synthetic double clicks and virtual keys require some timing.
//				See Defines.h DOUBLECLICKINTERVAL . Not sure they are 100% independent.

int debounceTimeout=200;

bool Debounce(void) {
  static DWORD fpsTimeLast= 0;
  DWORD fpsTimeThis = ::GetTickCount();
  DWORD dT = fpsTimeThis-fpsTimeLast;

  DisplayTimeOut = 0;
  InterfaceTimeoutReset();

  if (ScreenBlanked) {
    // prevent key presses working if screen is blanked,
    // so a key press just triggers turning the display on again
    return false;
  }

  if (dT>(unsigned int)debounceTimeout) {
    fpsTimeLast = fpsTimeThis;
    return true;
  } else {
    return false;
  }
}


void Shutdown(void) {
  int i;

  LKSound(_T("LK_DISCONNECT.WAV")); Sleep(500); // real WAV length is 410+ms
  if (!GlobalRunning) { // shutdown on startup clicking on the X
	StartupStore(_T(". Quick shutdown requested before terminating startup%s"),NEWLINE);
	exit(0);
  }

  CreateProgressDialog(TEXT("Shutdown, please wait..."));

  StartupStore(TEXT(". Entering shutdown...%s"),NEWLINE);
  StartupLogFreeRamAndStorage();

  // turn off all displays
  GlobalRunning = false;

  StartupStore(TEXT(". dlgAirspaceWarningDeInit%s"),NEWLINE);
  dlgAirspaceWarningDeInit();
  StartupStore(TEXT(". AirspaceWarnListDeInit%s"),NEWLINE);
  AirspaceWarnListDeInit();

  CreateProgressDialog(TEXT("Shutdown, saving logs..."));
  // stop logger
  guiStopLogger(true);

  CreateProgressDialog(TEXT("Shutdown, saving profile..."));
  // Save settings
  StoreRegistry();

  StartupStore(TEXT(". Save_Recent_WP_history%s"),NEWLINE);
  SaveRecentList();
  // Stop sound

  StartupStore(TEXT(". SaveSoundSettings%s"),NEWLINE);
  SaveSoundSettings();

#ifndef DISABLEAUDIOVARIO  
  //  VarioSound_EnableSound(false);
  //  VarioSound_Close();
#endif

  // Stop SMS device
#if (EXPERIMENTAL > 0)
  bsms.Shutdown();
#endif

  // Stop drawing
  CreateProgressDialog(TEXT("Shutdown, please wait..."));
  
  StartupStore(TEXT(". CloseDrawingThread%s"),NEWLINE);
  // 100526 this is creating problem in SIM mode when quit is called from X button, and we are in waypoint details
  // or probably in other menu related screens. However it cannot happen from real PNA or PDA because we don't have
  // that X button.
  MapWindow::CloseDrawingThread();

  // Stop calculating too (wake up)
  SetEvent(dataTriggerEvent);
  SetEvent(drawTriggerEvent);
  #ifndef NOVARIOGAUGE
  SetEvent(varioTriggerEvent);
  #endif

  // Clear data

  CreateProgressDialog(TEXT("Shutdown, saving task..."));
  StartupStore(TEXT(". Save default task%s"),NEWLINE);
  LockTaskData();
  #ifndef NOTASKABORT
  ResumeAbortTask(-1); // turn off abort if it was on.
  #endif
  UnlockTaskData();
  SaveDefaultTask();

  StartupStore(TEXT(". Clear task data%s"),NEWLINE);

  LockTaskData();
  Task[0].Index = -1;  ActiveWayPoint = -1; 
  AATEnabled = FALSE;
  NumberOfAirspacePoints = 0; NumberOfAirspaceAreas = 0; 
  NumberOfAirspaceCircles = 0;
  CloseWayPoints();
  UnlockTaskData();

  CreateProgressDialog(TEXT("Shutdown, please wait..."));
  StartupStore(TEXT(". CloseTerrainTopology%s"),NEWLINE);

  RASP.Close();
  RasterTerrain::CloseTerrain();

  CloseTopology();

  TopologyCloseMarks();

  CloseTerrainRenderer();

  // Stop COM devices
  StartupStore(TEXT(". Stop COM devices%s"),NEWLINE);
  devCloseAll();

  // SaveCalculationsPersist(&CALCULATED_INFO); // 091119 DISABLED
#if (EXPERIMENTAL > 0)
  //  CalibrationSave();
#endif

  #if defined(GNAV) && !defined(PCGNAV)
    StartupStore(TEXT(". Altair shutdown%s"),NEWLINE);
    Sleep(2500);
    StopHourglassCursor();
    InputEvents::eventDLLExecute(TEXT("altairplatform.dll SetShutdown 1"));
    while(1) {
      Sleep(100); // free time up for processor to perform shutdown
    }
  #endif

  CloseFLARMDetails();

  ProgramStarted = psInitInProgress;

  // Kill windows

  #ifndef LK8000_OPTIMIZE
  StartupStore(TEXT(". Close Gauges%s"),NEWLINE);
  #endif
  #ifndef NOCDIGAUGE
  GaugeCDI::Destroy();
  #endif
  #ifndef NOVARIOGAUGE
  GaugeVario::Destroy();
  #endif
  #ifndef NOFLARMGAUGE
  GaugeFLARM::Destroy();
  #endif
  
  StartupStore(TEXT(". Close Messages%s"),NEWLINE);
  Message::Destroy();
  
  Units::UnLoadUnitBitmap();

  #ifndef NOIBOX  
  StartupStore(TEXT(". Destroy Info Boxes%s"),NEWLINE);
  InfoBoxLayout::DestroyInfoBoxes();
  #endif
  
  StartupStore(TEXT(". Destroy Button Labels%s"),NEWLINE);
  ButtonLabel::Destroy();

  StartupStore(TEXT(". Delete Objects%s"),NEWLINE);
  
  //  CommandBar_Destroy(hWndCB);
  for (i=0; i<NUMSELECTSTRINGS; i++) {
    delete Data_Options[i].Formatter;
  }

  // Kill graphics objects

  DeleteObject(hBrushSelected);
  DeleteObject(hBrushUnselected);
  DeleteObject(hBrushButton);
  
  DeleteObject(InfoWindowFont);
  DeleteObject(TitleWindowFont);
  DeleteObject(CDIWindowFont);
  DeleteObject(MapLabelFont);
  DeleteObject(MapWindowFont);
  DeleteObject(MapWindowBoldFont);
  DeleteObject(StatisticsFont);  
  DeleteObject(TitleSmallWindowFont);
  
  if(AirspaceArea != NULL)   LocalFree((HLOCAL)AirspaceArea);
  if(AirspacePoint != NULL)  LocalFree((HLOCAL)AirspacePoint);
  if(AirspaceScreenPoint != NULL)  LocalFree((HLOCAL)AirspaceScreenPoint);
  if(AirspaceCircle != NULL) LocalFree((HLOCAL)AirspaceCircle);

  StartupStore(TEXT(". Delete Critical Sections%s"),NEWLINE);
  
  DeleteCriticalSection(&CritSec_EventQueue);
  csEventQueueInitialized = false;
  #if ALPHADEBUG
  StartupStore(TEXT(". Deleted EventQueue%s"),NEWLINE); // REMOVE 101121
  #endif
  DeleteCriticalSection(&CritSec_TaskData);
  csTaskDataInitialized = false;
  #if ALPHADEBUG
  StartupStore(TEXT(". Deleted TaskData%s"),NEWLINE); // REMOVE 101121
  #endif
  DeleteCriticalSection(&CritSec_FlightData);
  csFlightDataInitialized = false;
  #if ALPHADEBUG
  StartupStore(TEXT(". Deleted FlightData%s"),NEWLINE); // REMOVE 101121
  #endif
  DeleteCriticalSection(&CritSec_NavBox);
  csNavBoxInitialized = false;
  #if ALPHADEBUG
  StartupStore(TEXT(". Deleted NavBox%s"),NEWLINE); // REMOVE 101121
  #endif
  DeleteCriticalSection(&CritSec_Comm);
  csCommInitialized = false;
  #if ALPHADEBUG
  StartupStore(TEXT(". Deleted Comm%s"),NEWLINE); // REMOVE 101121
  #endif
  DeleteCriticalSection(&CritSec_TerrainDataCalculations);
  csTerrainDataGraphicsInitialized = false;
  #if ALPHADEBUG
  StartupStore(TEXT(". Deleted TerrainData%s"),NEWLINE); // REMOVE 101121
  #endif
  DeleteCriticalSection(&CritSec_TerrainDataGraphics);
  csTerrainDataCalculationsInitialized = false;

  StartupStore(TEXT(". Close Progress Dialog%s"),NEWLINE);

  CloseProgressDialog();

  StartupStore(TEXT(". Close Calculations%s"),NEWLINE);
  CloseCalculations();

  CloseGeoid();

  StartupStore(TEXT(". Close Windows%s"),NEWLINE);
  DestroyWindow(hWndMapWindow);
  DestroyWindow(hWndMainWindow);
      
  StartupStore(TEXT(". Close Event Handles%s"),NEWLINE);
  CloseHandle(drawTriggerEvent);
  CloseHandle(dataTriggerEvent);
  CloseHandle(varioTriggerEvent);

#ifdef DEBUG_TRANSLATIONS
  StartupStore(TEXT(".. Writing missing translations%s"),NEWLINE);
  WriteMissingTranslations();
#endif

  StartupLogFreeRamAndStorage();
  #ifdef COMDIAG
  for (i=0;i<NUMDEV;i++) {
	if (ComPortStatus[i]!=0) {
		StartupStore(_T(". ComPort %d: status=%d Rx=%d Tx=%d ErrRx=%d + ErrTx=%d (==%d)%s"), i,
		ComPortStatus[i], ComPortRx[i],ComPortTx[i], ComPortErrRx[i],ComPortErrTx[i],ComPortErrors[i],NEWLINE);
	}
  }
  #endif
  StartupStore(TEXT(". Finished shutdown%s"),NEWLINE);
  LKRun(_T("ENDLOAD_00.EXE"),1,0);
  LKRun(_T("ENDLOAD_05.EXE"),1,5000);
  LKRun(_T("ENDLOAD_30.EXE"),1,30000);
  LKRun(_T("ENDLOAD_60.EXE"),1,60000);
  LKRun(_T("ENDLOAD_99.EXE"),1,INFINITE);
  // quitting PC version while menus are up will not terminate correctly. this is a workaround
  #if (WINDOWSPC>0)
  StartupStore(TEXT(". Program terminated%s"),NEWLINE); 
  exit(0);
  #endif 

#ifdef DEBUG
  TCHAR foop[80];
  TASK_POINT wp;
  TASK_POINT *wpr = &wp;
  _stprintf(foop,TEXT(". Sizes %d %d %d%s"),
	    sizeof(TASK_POINT), 
	    ((long)&wpr->AATTargetLocked)-((long)wpr),
	    ((long)&wpr->Target)-((long)wpr), NEWLINE
	    );
  StartupStore(foop);
#endif
}



LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  long wdata;

  switch (message)
    {

    case WM_ERASEBKGND:
      return TRUE; // JMW trying to reduce screen flicker
      break;
    case WM_COMMAND:
      return MainMenu(hWnd, message, wParam, lParam);
      break;
    case WM_CTLCOLORSTATIC:
      wdata = GetWindowLong((HWND)lParam, GWL_USERDATA);
      switch(wdata) {
      case 0:
        SetBkColor((HDC)wParam, ColorUnselected);
        SetTextColor((HDC)wParam, RGB(0x00,0x00,0x00));
        return (LRESULT)hBrushUnselected;
      case 1:
        SetBkColor((HDC)wParam, ColorSelected);
        SetTextColor((HDC)wParam, RGB(0x00,0x00,0x00));
        return (LRESULT)hBrushSelected;
      case 2:
	SetBkColor((HDC)wParam, ColorUnselected);
        SetTextColor((HDC)wParam, ColorWarning);
	return (LRESULT)hBrushUnselected;
      case 3:
	SetBkColor((HDC)wParam, ColorUnselected);
        SetTextColor((HDC)wParam, ColorOK);
	return (LRESULT)hBrushUnselected;
      case 4:
	// black on light green
	SetBkColor((HDC)wParam, ColorButton);
        SetTextColor((HDC)wParam, RGB(0x00,0x00,0x00));
	return (LRESULT)hBrushButton;
      case 5:
	// grey on light green
	SetBkColor((HDC)wParam, ColorButton);
        SetTextColor((HDC)wParam, RGB(0x80,0x80,0x80));
	return (LRESULT)hBrushButton;
/*
      default: // added 091230
	SetBkColor((HDC)wParam, ColorButton);
        SetTextColor((HDC)wParam, RGB(0xff,0xbe,0x00));
	return (LRESULT)hBrushButton;
*/
      }
      break;
    case WM_CREATE:
#ifdef HAVE_ACTIVATE_INFO
      memset (&s_sai, 0, sizeof (s_sai));
      s_sai.cbSize = sizeof (s_sai);
#endif
      //if (hWnd==hWndMainWindow) {
      if (iTimerID == 0) {
        iTimerID = SetTimer(hWnd,1000,500,NULL); // 500ms  2 times per second
      }

      //      hWndCB = CreateRpCommandBar(hWnd);

      break;

    case WM_ACTIVATE:
      if(LOWORD(wParam) != WA_INACTIVE)
        {
          SetWindowPos(hWndMainWindow,HWND_TOP,
                 0, 0, 0, 0,
                 SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE);

#ifdef HAVE_ACTIVATE_INFO
	  SHFullScreen(hWndMainWindow,SHFS_HIDETASKBAR|SHFS_HIDESIPBUTTON|SHFS_HIDESTARTICON);
#endif

        }
#ifdef HAVE_ACTIVATE_INFO
      SHHandleWMActivate(hWnd, wParam, lParam, &s_sai, FALSE);
#endif
      break;

    case WM_SETTINGCHANGE:
#ifdef HAVE_ACTIVATE_INFO
      SHHandleWMSettingChange(hWnd, wParam, lParam, &s_sai);
#endif
      break;

    case WM_SETFOCUS:
      // JMW not sure this ever does anything useful..
      if (ProgramStarted > psInitInProgress) {

	if(InfoWindowActive) {
	  
	  if(DisplayLocked) {
	    FocusOnWindow(InfoFocus,true);
	  } else {
	    FocusOnWindow(InfoFocus,true);
	  }
	} else {
	  DefocusInfoBox();
	  HideMenu();
	  SetFocus(hWndMapWindow);
	}
      }
      break;
      // TODO enhancement: Capture KEYDOWN time
      // 	- Pass that (otpionally) to processKey, allowing
      // 	  processKey to handle long events - at any length
      // 	- Not sure how to do double click... (need timer call back
      // 	process unless reset etc... tricky)
      // we do this in WindowControls
#if defined(GNAV) || defined(PCGNAV)
    case WM_KEYDOWN: // JMW was keyup
#else
    case WM_KEYUP: // JMW was keyup
#endif

      InterfaceTimeoutReset();

      /* DON'T PROCESS KEYS HERE WITH NEWINFOBOX, IT CAUSES CRASHES! */
      break;
	  //VENTA DBG
#ifdef VENTA_DEBUG_EVENT
	case WM_KEYDOWN:	

		DoStatusMessage(TEXT("DBG KDOWN 1")); // VENTA
		InterfaceTimeoutReset();
	      break;
	case WM_SYSKEYDOWN:	
		DoStatusMessage(TEXT("DBG SYSKDOWN 1")); // VENTA
		InterfaceTimeoutReset();
	      break;
#endif
	//END VENTA DBG

    case WM_TIMER:
	// WM_TIMER is run at about 2hz.
	LKHearthBeats++; // 100213
      //      ASSERT(hWnd==hWndMainWindow);
      if (ProgramStarted > psInitInProgress) {
#if NOSIM
	if (SIMMODE)
		SIMProcessTimer();
	else
		ProcessTimer();
#else
#ifdef _SIM_
	SIMProcessTimer();
#else
	ProcessTimer();
#endif
#endif
	if (ProgramStarted==psFirstDrawDone) {
	  AfterStartup();
	  ProgramStarted = psNormalOp;
          StartupStore(TEXT(". ProgramStarted=3%s"),NEWLINE);
          StartupLogFreeRamAndStorage();
	}
      }
      break;

    case WM_INITMENUPOPUP:
      if (ProgramStarted > psInitInProgress) {
	if(DisplayLocked)
	  CheckMenuItem((HMENU) wParam,IDM_FILE_LOCK,MF_CHECKED|MF_BYCOMMAND);
	else
	  CheckMenuItem((HMENU) wParam,IDM_FILE_LOCK,MF_UNCHECKED|MF_BYCOMMAND);
	
	if(LoggerActive)
	  CheckMenuItem((HMENU) wParam,IDM_FILE_LOGGER,MF_CHECKED|MF_BYCOMMAND);
	else
	  CheckMenuItem((HMENU) wParam,IDM_FILE_LOGGER,MF_UNCHECKED|MF_BYCOMMAND);
      }
      break;

    case WM_CLOSE:

#ifndef GNAV
      ASSERT(hWnd==hWndMainWindow);
      if(ForceShutdown || ((hWnd==hWndMainWindow) && 
         (MessageBoxX(hWndMainWindow,
                      TEXT("Confirm Exit?"),
                      TEXT("LK8000"),
                      MB_YESNO|MB_ICONQUESTION) == IDYES))) 
#endif
        {
          if(iTimerID) {
            KillTimer(hWnd,iTimerID);
            iTimerID = 0;
          }
          
          Shutdown();
        }
      break;

    case WM_DESTROY:
      if (hWnd==hWndMainWindow) {
        PostQuitMessage(0);
      }
      break;

    default:
      return DefWindowProc(hWnd, message, wParam, lParam);
    }
  return 0;
}


/* JMW no longer needed
HWND CreateRpCommandBar(HWND hwnd)
{
  SHMENUBARINFO mbi;

  memset(&mbi, 0, sizeof(SHMENUBARINFO));
  mbi.cbSize     = sizeof(SHMENUBARINFO);
  mbi.hwndParent = hwnd;
  mbi.dwFlags = SHCMBF_EMPTYBAR|SHCMBF_HIDDEN;
  mbi.nToolBarId = IDM_MENU;
  mbi.hInstRes   = hInst;
  mbi.nBmpId     = 0;
  mbi.cBmpImages = 0;

  if (!SHCreateMenuBar(&mbi))
    return NULL;

  return mbi.hwndMB;
}
*/

LRESULT MainMenu(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  int wmId, wmEvent;
  HWND wmControl;
  int i;

  wmId    = LOWORD(wParam);
  wmEvent = HIWORD(wParam);
  wmControl = (HWND)lParam;

  if(wmControl != NULL) {
    if (ProgramStarted==psNormalOp) {

      DialogActive = false;

      FullScreen();
      
      InfoBoxFocusTimeOut = 0;
      /*
      if (!InfoWindowActive) {
        ShowMenu();
      }
      */
      #ifndef NOIBOX 
      for(i=0;i<numInfoWindows;i++) {
        if(wmControl == InfoBoxes[i]->GetHandle()) {
          InfoWindowActive = TRUE;
                
          if(DisplayLocked) {
            if( i!= InfoFocus) {
              FocusOnWindow(i,true);
              FocusOnWindow(InfoFocus,false);
              
              InfoFocus = i;
              InfoWindowActive = TRUE;
            }
            DisplayText();
            InputEvents::setMode(TEXT("infobox"));
            //InputEvents::setMode(TEXT("fullscreen")); 091128 to test
                    
          } else {
            PopUpSelect(i);
            DisplayText();
          }
          return 0;
        }
      }
      #endif
      Message::CheckTouch(wmControl);
        
      if (ButtonLabel::CheckButtonPress(wmControl)) {
        return TRUE; // don't continue processing..
      }
      
    }
  }
  return DefWindowProc(hWnd, message, wParam, lParam);
}


void    AssignValues(void)
{
  if (InfoBoxesHidden) {
    // no need to assign values
    return;
  }

  //  DetectStartTime(); moved to Calculations

  // nothing to do here now!
}

extern int PDABatteryTemperature;
void DisplayText(void)
{
#ifdef NOIBOX
  return;
#endif
  if (InfoBoxesHidden)
    return;

  int i;
  static int DisplayType[MAXINFOWINDOWS];
  static bool first=true;
  static int InfoFocusLast = -1;
  static int DisplayTypeLast[MAXINFOWINDOWS];
// static double LastFlipBoxTime = 0; //  now global for SlowCalculations
  static bool FlipBoxValue = false;


  // VENTA3 - Dynamic box values
  if ( GPS_INFO.Time > LastFlipBoxTime + DYNABOXTIME ) {
/*
	static TCHAR ventabuffer[200];
	FILE *fp;
        wsprintf(ventabuffer,TEXT("GPS_INFO.Time=%d LastFlipBoxTime=%d Flip=%d"),(int)GPS_INFO.Time, (int)LastFlipBoxTime,
	FlipBoxValue == true ? 1 : 0);
        if ((fp=_tfopen(_T("DEBUG.TXT"),_T("a")))!= NULL){;fprintf(fp,"%S\n",ventabuffer);fclose(fp)
;}
*/
	FlipBoxValue = ( FlipBoxValue == false );
	LastFlipBoxTime = GPS_INFO.Time;
  }
	
  

  LockNavBox();

  // JMW note: this is updated every GPS time step

  if (InfoFocus != InfoFocusLast) {
    first = true; // force re-setting title
  }
  if ((InfoFocusLast>=0)&&(!InfoWindowActive)) {
    first = true;
  }
  InfoFocusLast = InfoFocus;

  for(i=0;i<numInfoWindows;i++) {

    // VENTA3
    // All calculations are made in a separate thread. Slow calculations should apply to
    // the function DoCalculationsSlow() . Do not put calculations here! 
    
    DisplayType[i] = getInfoType(i);
    Data_Options[DisplayType[i]].Formatter->AssignValue(DisplayType[i]);
    
    TCHAR sTmp[32];
    
    int color = 0;

    bool needupdate = ((DisplayType[i] != DisplayTypeLast[i])||first);
    
    int theactive = ActiveWayPoint;
    if (!ValidTaskPoint(theactive)) {
      theactive = -1;
    }

    //
    // Set Infobox title and middle value. Bottom line comes next
    //
    switch (DisplayType[i]) {

    case 67: // VENTA3 alternate1 and 2
    case 68: 
    case 69:
    case 75: // VENTA3 alternate1 and 2
    case 76: 
    case 77:
	if (DisplayType[i]==67 || DisplayType[i]==75) ActiveAlternate=Alternate1; else
	if (DisplayType[i]==68 || DisplayType[i]==76) ActiveAlternate=Alternate2; 
		else ActiveAlternate=BestAlternate;
	InfoBoxes[i]->SetSmallerFont(false);
	if ( ActiveAlternate != -1 ) {
		InfoBoxes[i]->SetTitle(Data_Options[DisplayType[i]].Formatter->
			   RenderTitle(&color));
		InfoBoxes[i]->SetColor(color);
		InfoBoxes[i]->SetValue(Data_Options[DisplayType[i]].Formatter->
			   Render(&color));
		InfoBoxes[i]->SetColor(color);
	} else {
		switch(DisplayType[i]) {
			case 67:
				InfoBoxes[i]->SetTitle(TEXT("Alt1.GR"));
				break;
			case 68:
				InfoBoxes[i]->SetTitle(TEXT("Alt2.GR"));
				break;
			case 69:
				InfoBoxes[i]->SetTitle(TEXT("BAlt.GR"));
				break;
			case 75:
				InfoBoxes[i]->SetTitle(TEXT("Alt1.Arr"));
				break;
			case 76:
				InfoBoxes[i]->SetTitle(TEXT("Alt2.Arr"));
				break;
			case 77:
				InfoBoxes[i]->SetTitle(TEXT("BAlt.Arr"));
				break;
			default:
				InfoBoxes[i]->SetTitle(TEXT("ERR234"));
				break;
		}
		InfoBoxes[i]->SetValue(TEXT("---"));
		InfoBoxes[i]->SetColor(-1);
	}
      if (needupdate)
	InfoBoxes[i]->SetValueUnit(Units::GetUserUnitByGroup(
          Data_Options[DisplayType[i]].UnitGroup));
	break;	
/*
    case 75: // VENTA3 alternate1 and 2
    case 76: 
    case 77:
	if (DisplayType[i]==75) ActiveAlternate=Alternate1; else
	if (DisplayType[i]==76) ActiveAlternate=Alternate2; 
		else ActiveAlternate=BestAlternate;
	InfoBoxes[i]->SetSmallerFont(false);
	if ( ActiveAlternate != -1 ) {
		InfoBoxes[i]->SetTitle(Data_Options[DisplayType[i]].Formatter->
			   RenderTitle(&color));
		InfoBoxes[i]->SetColor(color);
		InfoBoxes[i]->SetValue(Data_Options[DisplayType[i]].Formatter->
			   Render(&color));
		InfoBoxes[i]->SetColor(color);
	} else {
		if ( DisplayType[i]==75 ) 
			InfoBoxes[i]->SetTitle(TEXT("Alt1Arr"));
		else if ( DisplayType[i]==76 ) 
			InfoBoxes[i]->SetTitle(TEXT("Alt2Arr"));
		else	InfoBoxes[i]->SetTitle(TEXT("BAltArr"));
		InfoBoxes[i]->SetValue(TEXT("---"));
		InfoBoxes[i]->SetColor(-1);
	}
      if (needupdate)
	InfoBoxes[i]->SetValueUnit(Units::GetUserUnitByGroup(
          Data_Options[DisplayType[i]].UnitGroup));
	break;	
*/
    case 55:
      InfoBoxes[i]->SetSmallerFont(true);
      if (needupdate)
	InfoBoxes[i]->SetTitle(Data_Options[DisplayType[i]].Title);
      
      InfoBoxes[i]->
	SetValue(Data_Options[DisplayType[i]].Formatter->Render(&color));
      
      // to be optimized!
      if (needupdate)
	InfoBoxes[i]->
	  SetValueUnit(Units::GetUserUnitByGroup(
              Data_Options[DisplayType[i]].UnitGroup)
	  );
      InfoBoxes[i]->SetColor(color);
      break; 
    case 14: // Next waypoint
      InfoBoxes[i]->SetSmallerFont(false);
      if (theactive != -1){
	InfoBoxes[i]->
	  SetTitle(Data_Options[DisplayType[i]].Formatter->
		   Render(&color));
	InfoBoxes[i]->SetColor(color);
	InfoBoxes[i]->
	  SetValue(Data_Options[47].Formatter->Render(&color));
      }else{
	InfoBoxes[i]->SetTitle(TEXT("Next"));
	InfoBoxes[i]->SetValue(TEXT("---"));
	InfoBoxes[i]->SetColor(-1);
      }
      if (needupdate)
	InfoBoxes[i]->SetValueUnit(Units::GetUserUnitByGroup(
          Data_Options[DisplayType[i]].UnitGroup)
      );
      break;
    default:
      InfoBoxes[i]->SetSmallerFont(false);
      if (needupdate)
	InfoBoxes[i]->SetTitle(Data_Options[DisplayType[i]].Title);
      
      InfoBoxes[i]->
          SetValue(Data_Options[DisplayType[i]].Formatter->Render(&color));
      
      // to be optimized!
      if (needupdate)
	InfoBoxes[i]->
	  SetValueUnit(Units::GetUserUnitByGroup(
            Data_Options[DisplayType[i]].UnitGroup)
	  );

      InfoBoxes[i]->SetColor(color);
    };
  
    // 
    // Infobox bottom line
    //
    switch (DisplayType[i]) {
    case 14: // Next waypoint
      
      if (theactive != -1){
        int index;
        index = Task[theactive].Index;
        if (index>=0) {
          InfoBoxes[i]->
            SetComment(WayPointList[index].Comment);
        }
        break;
      }
      InfoBoxes[i]->SetComment(TEXT(""));
      break;
    case 79:
	if (NearestAirspaceHDist>0)
          InfoBoxes[i]->SetComment(NearestAirspaceName);
	  break;

    case 10:
      if (CALCULATED_INFO.AutoMacCready)
	InfoBoxes[i]->SetComment(TEXT("AUTO"));
      else
	InfoBoxes[i]->SetComment(TEXT("MANUAL"));
      break;
    case 0: // GPS Alt
      Units::FormatAlternateUserAltitude(GPS_INFO.Altitude, 
					 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
      InfoBoxes[i]->SetComment(sTmp);
      break;
    case 1: // AGL
      Units::FormatAlternateUserAltitude(CALCULATED_INFO.AltitudeAGL, 
					 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
      InfoBoxes[i]->SetComment(sTmp);
      break;
    case 33:
      Units::FormatAlternateUserAltitude(GPS_INFO.BaroAltitude, 
					 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
      InfoBoxes[i]->SetComment(sTmp);
      break;
    case 27: // AAT time to go
    case 36: // flight time
    case 39: // current time
    case 40: // gps time
    case 41: // task time to go
    case 42: // task time to go
    case 45: // ete 
    case 46: // leg ete 
    case 62: // ete 
      if (Data_Options[DisplayType[i]].Formatter->isValid()) {
        InfoBoxes[i]->
          SetComment(Data_Options[DisplayType[i]].Formatter->GetCommentText());
      } else {
        InfoBoxes[i]->
          SetComment(TEXT(""));
      }
      break;
    case 43:
      if (EnableBlockSTF) {
	InfoBoxes[i]->SetComment(TEXT("BLOCK"));
      } else {
	InfoBoxes[i]->SetComment(TEXT("DOLPHIN"));
      }
      break;
    case 55: // own team code      
      InfoBoxes[i]->SetComment(TeammateCode);
      if (TeamFlarmTracking)
	{
	  if (IsFlarmTargetCNInRange())
	    {				
	      InfoBoxes[i]->SetColorBottom(2);
	    }
	  else
	    {
	      InfoBoxes[i]->SetColorBottom(1);
	    }
	}
      else
	{
	  InfoBoxes[i]->SetColorBottom(0);
	}           
      break;
    case 56: // team bearing

      if (TeamFlarmIdTarget != 0)
	{
	  if (wcslen(TeamFlarmCNTarget) != 0)
	    {
	      InfoBoxes[i]->SetComment(TeamFlarmCNTarget);
	    }
	  else
	    {
	      InfoBoxes[i]->SetComment(TEXT("???"));
	    }
	}
      else
	{
	  InfoBoxes[i]->SetComment(TEXT("---"));
	}

      if (IsFlarmTargetCNInRange())
	{				
	  InfoBoxes[i]->SetColorBottom(2);
	}
      else
	{
	  InfoBoxes[i]->SetColorBottom(1);
	}

      break;
    case 57: // team bearing dif

      if (TeamFlarmIdTarget != 0)
	{
	  if (wcslen(TeamFlarmCNTarget) != 0)
	    {
	      InfoBoxes[i]->SetComment(TeamFlarmCNTarget);
	    }
	  else
	    {
	      InfoBoxes[i]->SetComment(TEXT("???"));
	    }
	}
      else
	{
	  InfoBoxes[i]->SetComment(TEXT("---"));
	}
      if (IsFlarmTargetCNInRange())
	{				
	  InfoBoxes[i]->SetColorBottom(2);
	}
      else
	{
	  InfoBoxes[i]->SetColorBottom(1);
	}

      break;
    case 58: // team range

      if (TeamFlarmIdTarget != 0)
	{
	  if (wcslen(TeamFlarmCNTarget) != 0)
	    {
	      InfoBoxes[i]->SetComment(TeamFlarmCNTarget);
	    }
	  else
	    {
	      InfoBoxes[i]->SetComment(TEXT("???"));
	    }
	}
      else
	{
	  InfoBoxes[i]->SetComment(TEXT("---"));
	}
      if (IsFlarmTargetCNInRange())
	{				
	  InfoBoxes[i]->SetColorBottom(2);
	}
      else
	{
	  InfoBoxes[i]->SetColorBottom(1);
	}

      break;
	// VENTA3 wind speed + bearing bottom line
	case 25:
		if ( CALCULATED_INFO.WindBearing == 0 )
		wsprintf(sTmp,_T("0%s"),_T(DEG)); else
		wsprintf(sTmp,_T("%1.0d%s"),(int)CALCULATED_INFO.WindBearing,_T(DEG));
		InfoBoxes[i]->SetComment(sTmp);
		break;
		
	// VENTA3 radial
	case 60: 
		if ( HomeWaypoint == -1 ) {  // should be redundant
      			InfoBoxes[i]->SetComment(TEXT(""));
			break; 
		}
		if ( CALCULATED_INFO.HomeRadial == 0 )
		wsprintf(sTmp,_T("0%s"),_T(DEG)); else
		wsprintf(sTmp,_T("%1.0d%s"),(int)CALCULATED_INFO.HomeRadial,_T(DEG));
		InfoBoxes[i]->SetComment(sTmp);
		break;

	// VENTA3 battery temperature under voltage. There is a good reason to see the temperature,
	// if available: many PNA/PDA will switch OFF during flight under direct sunlight for several
	// hours due to battery temperature too high!! The 314 does!

	// TODO: check temperature too high and set a warning flag to be used by an event or something
	#if (WINDOWSPC<1)
	case 65:
		if ( PDABatteryTemperature >0 ) {
			wsprintf(sTmp,_T("%1.0d%SC"),(int)PDABatteryTemperature,_T(DEG));
			InfoBoxes[i]->SetComment(sTmp);
		} else
      			InfoBoxes[i]->SetComment(TEXT(""));
		break;
	#endif

	// VENTA3 alternates
	case 67:
	case 68:
	case 69: 
		if ( ActiveAlternate == -1 ) {  // should be redundant
      			InfoBoxes[i]->SetComment(TEXT(""));
			break; 
		}
		if (FlipBoxValue == true) {
			Units::FormatUserDistance(WayPointCalc[ActiveAlternate].Distance,
					 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
			InfoBoxes[i]->SetComment(sTmp);
		} else {
			Units::FormatUserArrival(WayPointCalc[ActiveAlternate].AltArriv[AltArrivMode],
					 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
			InfoBoxes[i]->SetComment(sTmp);
		}
		break;
	// VENTA3 alternates
	case 75:
	case 76:
	case 77: 
		if ( ActiveAlternate == -1 ) {  // should be redundant
      			InfoBoxes[i]->SetComment(TEXT(""));
			break; 
		}
		if (FlipBoxValue == true) {
			Units::FormatUserDistance(WayPointCalc[ActiveAlternate].Distance,
					 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
			InfoBoxes[i]->SetComment(sTmp);
		} else {
			if (WayPointCalc[ActiveAlternate].GR == INVALID_GR) 
				wsprintf(sTmp,_T("---"));
			else
				wsprintf(sTmp,_T("%d"),(int)WayPointCalc[ActiveAlternate].GR);
/*
			Units::FormatUserArrival(WayPointCalc[ActiveAlternate].GR,
					 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
*/
			InfoBoxes[i]->SetComment(sTmp);
		}
		break;
	case 70: // QFE
		/*
		 // Showing the diff value offset was just interesting ;-)
		if (FlipBoxValue == true) {
			//Units::FormatUserArrival(QFEAltitudeOffset,
			Units::FormatUserAltitude(QFEAltitudeOffset,
				 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
			InfoBoxes[i]->SetComment(sTmp);
		} else {
		*/
		//Units::FormatUserArrival(GPS_INFO.Altitude,
		Units::FormatUserAltitude(GPS_INFO.Altitude,
			 sTmp, sizeof(sTmp)/sizeof(sTmp[0]));
		InfoBoxes[i]->SetComment(sTmp);
		break;

    default:
      InfoBoxes[i]->SetComment(TEXT(""));
    };

    DisplayTypeLast[i] = DisplayType[i];
    
  }
  InfoBoxLayout::Paint();

  first = false;

  UnlockNavBox();

}

#include "winbase.h"


void CommonProcessTimer()
{

  // service the GCE and NMEA queue
  if (ProgramStarted==psNormalOp) {
    InputEvents::DoQueuedEvents();
    if (RequestAirspaceWarningDialog) {
      DisplayTimeOut=0;
      RequestAirspaceWarningDialog= false;
      dlgAirspaceWarningShowDlg(RequestAirspaceWarningForce);
      RequestAirspaceWarningForce = false;
    }
    #ifndef NOFLARMGAUGE
    // update FLARM display (show/hide)
    GaugeFLARM::Show();
    #endif
  }

#if (WINDOWSPC<1)
  SystemIdleTimerReset();
#endif

  // VNT Maplock now has full control on focus/defocus on infoboxes
  if(InfoWindowActive && !UseMapLock) 
    {
      if (!dlgAirspaceWarningVisible()) {
	// JMW prevent switching to map window if in airspace warning dialog

	if(InfoBoxFocusTimeOut >= FOCUSTIMEOUTMAX)
	  {
	    SwitchToMapWindow();
	  }
	InfoBoxFocusTimeOut ++;
      }
    }

  if (DisplayLocked) {
    if(MenuTimeOut==MenuTimeoutMax) {
      if (!MapWindow::isPan()) {
	InputEvents::setMode(TEXT("default"));
      }
    }
    MenuTimeOut++;
  }

  if (DisplayTimeOut >= DISPLAYTIMEOUTMAX) {
    BlankDisplay(true);
  } else {
    BlankDisplay(false);
  }
  if (!DialogActive) {
    DisplayTimeOut++;
  } else {
    // JMW don't let display timeout while a dialog is active,
    // but allow button presses to trigger redisplay
    if (DisplayTimeOut>1) {
      DisplayTimeOut=1;
    }
  }

  if (MapWindow::IsDisplayRunning()) {
    // No need to redraw map or infoboxes if screen is blanked.
    // This should save lots of battery power due to CPU usage
    // of drawing the screen
    if (InfoBoxesDirty) {
      //JMWTEST    LockFlightData();
      AssignValues();
      DisplayText();
      InfoBoxesDirty = false;
      //JMWTEST    UnlockFlightData();
    }
  }

  //
  // maybe block/delay this if a dialog is active?
  // JMW: is done in the message function now.
  if (!dlgAirspaceWarningVisible()) {
    if (Message::Render()) {
      // turn screen on if blanked and receive a new message 
      DisplayTimeOut=0;
    }
  }

#if (EXPERIMENTAL > 0)

  if (bsms.Poll()) {
    // turn screen on if blanked and receive a new message
    DisplayTimeOut = 0;
  }

#endif

  static int iheapcompact = 0;
  // called 2 times per second, compact heap every minute.
  iheapcompact++;
  if (iheapcompact == 120) {
    MyCompactHeaps();
    iheapcompact = 0;
  }
}

// this part should be rewritten
int ConnectionProcessTimer(int itimeout) {
  LockComm();
  NMEAParser::UpdateMonitor();
  UnlockComm();
  
  static BOOL LastGPSCONNECT = FALSE;
  static BOOL CONNECTWAIT = FALSE;
  static BOOL LOCKWAIT = FALSE;
  
  //
  // replace bool with BOOL to correct warnings and match variable
  // declarations RB
  //
  BOOL gpsconnect = GPSCONNECT;
  
  if (GPSCONNECT) {
    extGPSCONNECT = TRUE;
  } 

  if (!extGPSCONNECT) {
    // if gps is not connected, set navwarning to true so
    // calculations flight timers don't get updated
    LockFlightData();
    GPS_INFO.NAVWarning = true;
    UnlockFlightData();
  }

  GPSCONNECT = FALSE;
  BOOL navwarning = (BOOL)(GPS_INFO.NAVWarning);

  if (gpsconnect && navwarning) {
    // If GPS connected but no lock, must be in hangar 
    if (InterfaceTimeoutCheck()) {
#ifdef GNAV
      // TODO feature: ask question about shutdown or give warning
      // then shutdown if no activity.
      //     Shutdown();
#endif
    }
  }

  if((gpsconnect == FALSE) && (LastGPSCONNECT == FALSE))
    {
      // re-draw screen every five seconds even if no GPS
      TriggerGPSUpdate();
      
      devLinkTimeout(devAll());

      if(LOCKWAIT == TRUE)
	{
	  // gps was waiting for fix, now waiting for connection
	  LOCKWAIT = FALSE;
	}
      if(!CONNECTWAIT)
	{
	  // gps is waiting for connection first time
	  
	  extGPSCONNECT = FALSE;
#ifndef NEWWARNINGS
          InputEvents::processGlideComputer(GCE_GPS_CONNECTION_WAIT);	// 100210
#endif
  
	  CONNECTWAIT = TRUE;
#ifndef DISABLEAUDIO
	if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_GREEN")); // 100404

#endif
	  FullScreen();
	    
	} else {

	if (itimeout % 30 == 0) {
	  // we've been waiting for connection a long time
	  
	  // no activity for 30 seconds, so assume PDA has been
	  // switched off and on again
	  //
#if (1)
	extGPSCONNECT = FALSE;
	InputEvents::processGlideComputer(GCE_COMMPORT_RESTART);
	RestartCommPorts();
#endif
	  
#if (EXPERIMENTAL > 0)
	  // if comm port shut down, probably so did bluetooth dialup
	  // so restart it here also.
	  bsms.Shutdown();
	  bsms.Initialise();
#endif
	  
	  itimeout = 0;
	}
      }
    }

  // Force RESET of comm ports on demand
  if (LKForceComPortReset) {
	StartupStore(_T(". ComPort RESET ordered%s"),NEWLINE);
	LKForceComPortReset=false;
	#if NOSIM
	if (MapSpaceMode != MSM_WELCOME)
	#endif
	InputEvents::processGlideComputer(GCE_COMMPORT_RESTART);
	RestartCommPorts();
  }
  
  if((gpsconnect == TRUE) && (LastGPSCONNECT == FALSE))
    {
      itimeout = 0; // reset timeout
      
      if(CONNECTWAIT)
	{
	  TriggerGPSUpdate();
	  CONNECTWAIT = FALSE;
	}
    }
  
  if((gpsconnect == TRUE) && (LastGPSCONNECT == TRUE))
    {
      if((navwarning == TRUE) && (LOCKWAIT == FALSE))
	{
#ifndef NEWWARNINGS
	  InputEvents::processGlideComputer(GCE_GPS_FIX_WAIT); // NEWWARNINGS 100209
#endif

	  TriggerGPSUpdate();
	  
	  LOCKWAIT = TRUE;
#ifndef DISABLEAUDIO
	  if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_GREEN")); // 100404
#endif
	  FullScreen();
	  
	}
      else if((navwarning == FALSE) && (LOCKWAIT == TRUE))
	{
	  TriggerGPSUpdate();
	  LOCKWAIT = FALSE;
	}
    }
  
  LastGPSCONNECT = gpsconnect;
  return itimeout;
}

#if  !_SIM_ || NOSIM
void ProcessTimer(void)
{

  if (!GPSCONNECT && (DisplayTimeOut==0)) {
    // JMW 20071207
    // re-draw screen every five seconds even if no GPS
    // this prevents sluggish screen when inside hangar..
    TriggerGPSUpdate();
    DisplayTimeOut=1;
  }

  CommonProcessTimer();

  // now check GPS status

  static int itimeout = -1;
  itimeout++;
  
  // write settings to vario every second
  if (itimeout % 2==0) {
    VarioWriteSettings();
  }
    
  // also service replay logger
  ReplayLogger::Update();
  if (ReplayLogger::IsEnabled()) {
    static double timeLast = 0;
	if (GPS_INFO.Time-timeLast>=1.0) {
	TriggerGPSUpdate();
    }
    timeLast = GPS_INFO.Time;
    GPSCONNECT = TRUE;
    extGPSCONNECT = TRUE;
    GPS_INFO.NAVWarning = FALSE;
    GPS_INFO.SatellitesUsed = 6;
    return;
  }
  
  if (itimeout % 10 == 0) {
    // check connection status every 5 seconds
    itimeout = ConnectionProcessTimer(itimeout);
  }
}
#endif // end processing of non-simulation mode

#if _SIM_ || NOSIM
void SIMProcessTimer(void)
{

  CommonProcessTimer();

  GPSCONNECT = TRUE;
  extGPSCONNECT = TRUE;
  static int i=0;
  i++;

  if (!ReplayLogger::Update()) {

    // Process timer is run at 2hz, so this is bringing it back to 1hz
    if (i%2==0) return;

#if 101015
    extern void LKSimulator(void);
    LKSimulator();
#else
    LockFlightData();

    GPS_INFO.NAVWarning = FALSE;
    GPS_INFO.SatellitesUsed = 6;
    FindLatitudeLongitude(GPS_INFO.Latitude, GPS_INFO.Longitude, 
                          GPS_INFO.TrackBearing, GPS_INFO.Speed*1.0,
                          &GPS_INFO.Latitude,
                          &GPS_INFO.Longitude);
    GPS_INFO.Time+= 1.0;
    long tsec = (long)GPS_INFO.Time;
    GPS_INFO.Hour = tsec/3600;
    GPS_INFO.Minute = (tsec-GPS_INFO.Hour*3600)/60;
    GPS_INFO.Second = (tsec-GPS_INFO.Hour*3600-GPS_INFO.Minute*60);

    UnlockFlightData();
#endif
  }

  if (i%2==0) return;

#ifdef DEBUG
  // use this to test FLARM parsing/display
#ifndef GNAV
  NMEAParser::TestRoutine(&GPS_INFO);
#endif
#endif

  TriggerGPSUpdate();

  VarioWriteSettings();
}
#endif


void SwitchToMapWindow(void)
{
  DefocusInfoBox();

  SetFocus(hWndMapWindow);
  if (  MenuTimeOut< MenuTimeoutMax) {
    MenuTimeOut = MenuTimeoutMax;
  }
  if (  InfoBoxFocusTimeOut< FOCUSTIMEOUTMAX) {
    InfoBoxFocusTimeOut = FOCUSTIMEOUTMAX;
  }
}


void PopupAnalysis()
{
  DialogActive = true;
  dlgAnalysisShowModal();
  DialogActive = false;
}


void PopupWaypointDetails()
{
  if (dlgWayQuickShowModal()) {
	dlgWayPointDetailsShowModal();
  }
}


void PopupBugsBallast(int UpDown)
{
	(void)UpDown;
  DialogActive = true;
  //  ShowWindow(hWndCB,SW_HIDE);
  FullScreen();
  SwitchToMapWindow();
  DialogActive = false;
}


void PopUpSelect(int Index)
{
  DialogActive = true;
  CurrentInfoType = InfoType[Index];
  StoreType(Index, InfoType[Index]);
  //  ShowWindow(hWndCB,SW_HIDE);
  FullScreen();
  SwitchToMapWindow();
  DialogActive = false;
}

#include <stdio.h>

void DebugStore(const char *Str, ...)
{
#if defined(DEBUG) && !defined(GNAV)
  char buf[MAX_PATH];
  va_list ap;
  int len;

  va_start(ap, Str);
  len = vsprintf(buf, Str, ap);
  va_end(ap);

  LockFlightData();
  FILE *stream;
  TCHAR szFileName[] = TEXT(LKF_DEBUG);
  static bool initialised = false;
  if (!initialised) {
    initialised = true;
    stream = _wfopen(szFileName,TEXT("w"));
  } else {
    stream = _wfopen(szFileName,TEXT("a+"));
  }

  fwrite(buf,len,1,stream);

  fclose(stream);
  UnlockFlightData();
#endif
}

void FailStore(const TCHAR *Str, ...)
{
  TCHAR buf[MAX_PATH];
  va_list ap;

  va_start(ap, Str);
  _vstprintf(buf, Str, ap);
  va_end(ap);

  FILE *stream=NULL;
  static TCHAR szFileName[MAX_PATH];
  static bool initialised = false;

  if (!initialised) {
	LocalPath(szFileName, TEXT(LKF_FAILLOG));
	stream = _tfopen(szFileName, TEXT("ab+"));
	if (stream) {
		fclose(stream);
	}
	initialised = true;
  } 
  stream = _tfopen(szFileName,TEXT("ab+"));
  if (stream == NULL) {
	StartupStore(_T("------ FailStore failed, cannot open <%s>%s"), szFileName, NEWLINE);
	return;
  }
#ifdef GTCFIX
  fprintf(stream, "------%s%04d%02d%02d-%02d:%02d:%02d [%09u] FailStore Start, Version %s%s (%s %s) FreeRam=%ld %s",SNEWLINE,
	GPS_INFO.Year,GPS_INFO.Month,GPS_INFO.Day, GPS_INFO.Hour,GPS_INFO.Minute,GPS_INFO.Second,
	(unsigned int)GetTickCount(),LKVERSION, LKRELEASE,
#else
  fprintf(stream, "------%s%04d%02d%02d-%02d:%02d:%02d [%09d] FailStore Start, Version %s%s (%s %s) FreeRam=%ld %s",SNEWLINE,
	GPS_INFO.Year,GPS_INFO.Month,GPS_INFO.Day, GPS_INFO.Hour,GPS_INFO.Minute,GPS_INFO.Second,
	(int)GetTickCount(),LKVERSION, LKRELEASE,
#endif
#if NOSIM
	"",
#else
#ifdef _SIM_
	"SIM",
#else
	"",
#endif
#endif
#if WINDOWSPC >0
	"PC",
#else
	#ifdef PNA
	"PNA",
	#else
	"PDA",
	#endif
#endif

CheckFreeRam(),SNEWLINE); 
  fprintf(stream, "Message: %S%s", buf, SNEWLINE);
  fprintf(stream, "GPSINFO: Latitude=%f Longitude=%f Altitude=%f Speed=%f %s", 
	GPS_INFO.Latitude, GPS_INFO.Longitude, GPS_INFO.Altitude, GPS_INFO.Speed, SNEWLINE);

  fclose(stream);
  StartupStore(_T("------ %s%s"),buf,NEWLINE);
}



void StartupStore(const TCHAR *Str, ...)
{
  TCHAR buf[(MAX_PATH*2)+1]; // 260 chars normally  FIX 100205
  va_list ap;

  va_start(ap, Str);
  _vstprintf(buf, Str, ap);
  va_end(ap);

  if (csFlightDataInitialized) {
	LockFlightData();
  }
  FILE *startupStoreFile = NULL;
  static TCHAR szFileName[MAX_PATH];

  static bool initialised = false;
  if (!initialised) {
	LocalPath(szFileName, TEXT(LKF_RUNLOG));
  	#if 0
	startupStoreFile = _tfopen(szFileName, TEXT("wb")); 100422
	if (startupStoreFile) {
		fclose(startupStoreFile);
	}
  	#endif
	initialised = true;
  } 

  startupStoreFile = _tfopen(szFileName, TEXT("ab+"));
  if (startupStoreFile != NULL) {
	// add linefeed to StartupStore until we fixed all occurencies
	char sbuf[(MAX_PATH*2)+1]; // FIX 100205
	sprintf(sbuf,"%S",buf);
	int i=strlen(sbuf)-1;
	if (i>=0) {
		if (i>0 && sbuf[i-1]!=0x0d && sbuf[i]==0x0a) {
			sbuf[i]=0x0;
			fprintf(startupStoreFile, "[%09u] %s%s", (unsigned int)GetTickCount(),sbuf,SNEWLINE);
		} else
			// i==0 will not translate 0x0a , no problems
			fprintf(startupStoreFile, "[%09u] %s", (unsigned int)GetTickCount(), sbuf);
	}
	fclose(startupStoreFile);
  }
  if (csFlightDataInitialized) {
	UnlockFlightData();
  }
}


void LockNavBox() {
}

void UnlockNavBox() {
}

static int csCount_TaskData = 0;
static int csCount_FlightData = 0;
static int csCount_EventQueue = 0;

void LockTaskData() {
#ifdef HAVEEXCEPTIONS
  if (!csTaskDataInitialized) throw TEXT("LockTaskData Error");
#endif
  EnterCriticalSection(&CritSec_TaskData);
  csCount_TaskData++;
}

void UnlockTaskData() {
#ifdef HAVEEXCEPTIONS
  if (!csTaskDataInitialized) throw TEXT("LockTaskData Error");
#endif
  if (csCount_TaskData) 
    csCount_TaskData--;
  LeaveCriticalSection(&CritSec_TaskData);
}


void LockFlightData() {
#ifdef HAVEEXCEPTIONS
  if (!csFlightDataInitialized) throw TEXT("LockFlightData Error");
#endif
  EnterCriticalSection(&CritSec_FlightData);
  csCount_FlightData++;
}

void UnlockFlightData() {
#ifdef HAVEEXCEPTIONS
  if (!csFlightDataInitialized) throw TEXT("LockFlightData Error");
#endif
  if (csCount_FlightData)
    csCount_FlightData--;
  LeaveCriticalSection(&CritSec_FlightData);
}

void LockTerrainDataCalculations() {
#ifdef HAVEEXCEPTIONS
  if (!csTerrainDataCalculationsInitialized) throw TEXT("LockTerrainDataCalculations Error");
#endif
  EnterCriticalSection(&CritSec_TerrainDataCalculations);
}

void UnlockTerrainDataCalculations() {
#ifdef HAVEEXCEPTIONS
  if (!csTerrainDataCalculationsInitialized) throw TEXT("LockTerrainDataCalculations Error");
#endif
  LeaveCriticalSection(&CritSec_TerrainDataCalculations);
}

void LockTerrainDataGraphics() {
#ifdef HAVEEXCEPTIONS
  if (!csTerrainDataGraphicsInitialized) throw TEXT("LockTerrainDataGraphics Error");
#endif
  EnterCriticalSection(&CritSec_TerrainDataGraphics);
}

void UnlockTerrainDataGraphics() {
#ifdef HAVEEXCEPTIONS
  if (!csTerrainDataGraphicsInitialized) throw TEXT("LockTerrainDataGraphics Error");
#endif
  LeaveCriticalSection(&CritSec_TerrainDataGraphics);
}


void LockEventQueue() {
#ifdef HAVEEXCEPTIONS
  if (!csEventQueueInitialized) throw TEXT("LockEventQueue Error");
#endif
  EnterCriticalSection(&CritSec_EventQueue);
  csCount_EventQueue++;
}

void UnlockEventQueue() {
#ifdef HAVEEXCEPTIONS
  if (!csEventQueueInitialized) throw TEXT("LockEventQueue Error");
#endif
  if (csCount_EventQueue) 
    csCount_EventQueue--;
  LeaveCriticalSection(&CritSec_EventQueue);
}



void HideInfoBoxes() {
  int i;
  InfoBoxesHidden = true;
  for (i=0; i<numInfoWindows+1; i++) {
    InfoBoxes[i]->SetVisible(false);
  }
}


void ShowInfoBoxes() {
  int i;
  InfoBoxesHidden = false;
  for (i=0; i<numInfoWindows; i++) {
    InfoBoxes[i]->SetVisible(true);
  }
}

#if (WINDOWSPC<1)
#ifndef GNAV
DWORD GetBatteryInfo(BATTERYINFO* pBatteryInfo)
{
    // set default return value
    DWORD result = 0;

    // check incoming pointer
    if(NULL == pBatteryInfo)
    {
        return 0;
    }

    SYSTEM_POWER_STATUS_EX2 sps;

    // request the power status
    result = GetSystemPowerStatusEx2(&sps, sizeof(sps), TRUE);

    // only update the caller if the previous call succeeded
    if(0 != result)
    {
        pBatteryInfo->acStatus = sps.ACLineStatus;
        pBatteryInfo->chargeStatus = sps.BatteryFlag;
        pBatteryInfo->BatteryLifePercent = sps.BatteryLifePercent;
	// VENTA get everything ready for PNAs battery control
	pBatteryInfo->BatteryVoltage = sps.BatteryVoltage;
	pBatteryInfo->BatteryAverageCurrent = sps.BatteryAverageCurrent;
	pBatteryInfo->BatteryCurrent = sps.BatteryCurrent;
	pBatteryInfo->BatterymAHourConsumed = sps.BatterymAHourConsumed;
	pBatteryInfo->BatteryTemperature = sps.BatteryTemperature;
    }

    return result;
}
#endif
#endif

// GDI Escapes for ExtEscape()
#define QUERYESCSUPPORT    8
// The following are unique to CE
#define GETVFRAMEPHYSICAL   6144
#define GETVFRAMELEN    6145
#define DBGDRIVERSTAT    6146
#define SETPOWERMANAGEMENT   6147
#define GETPOWERMANAGEMENT   6148


typedef enum _VIDEO_POWER_STATE {
    VideoPowerOn = 1,
    VideoPowerStandBy,
    VideoPowerSuspend,
    VideoPowerOff
} VIDEO_POWER_STATE, *PVIDEO_POWER_STATE;


typedef struct _VIDEO_POWER_MANAGEMENT {
    ULONG Length;
    ULONG DPMSVersion;
    ULONG PowerState;
} VIDEO_POWER_MANAGEMENT, *PVIDEO_POWER_MANAGEMENT;

int PDABatteryPercent = 100;
int PDABatteryTemperature = 0;
int PDABatteryStatus=0; // 100125
int PDABatteryFlag=0;

void BlankDisplay(bool doblank) {

#if (WINDOWSPC>0)
  return;
#else
#ifdef GNAV
  return;
#else
  static bool oldblank = false;

  BATTERYINFO BatteryInfo; 
  BatteryInfo.acStatus = 0; // JMW initialise

  if (GetBatteryInfo(&BatteryInfo)) {
    PDABatteryPercent = BatteryInfo.BatteryLifePercent;
    PDABatteryTemperature = BatteryInfo.BatteryTemperature; 
    PDABatteryStatus=BatteryInfo.acStatus; // 100125
    PDABatteryFlag=BatteryInfo.chargeStatus; // 100125
/*
	// All you need to display extra Battery informations...

	TCHAR vtemp[1000];
	_stprintf(vtemp,_T("Battpercent=%d Volt=%d Curr=%d AvCurr=%d mAhC=%d Temp=%d Lifetime=%d Fulllife=%d\n"),
 		BatteryInfo.BatteryLifePercent, BatteryInfo.BatteryVoltage, 
 		BatteryInfo.BatteryCurrent, BatteryInfo.BatteryAverageCurrent,
 		BatteryInfo.BatterymAHourConsumed,
		BatteryInfo.BatteryTemperature, BatteryInfo.BatteryLifeTime, BatteryInfo.BatteryFullLifeTime);
	StartupStore( vtemp );
 */
  } 

  if (!EnableAutoBlank) {
    return;
  }
  if (doblank == oldblank) {
    return;
  }

  HDC gdc;
  int iESC=SETPOWERMANAGEMENT;

  gdc = ::GetDC(NULL);
  if (ExtEscape(gdc, QUERYESCSUPPORT, sizeof(int), (LPCSTR)&iESC,
                0, NULL)==0) {
    // can't do it, not supported
  } else {

    VIDEO_POWER_MANAGEMENT vpm;
    vpm.Length = sizeof(VIDEO_POWER_MANAGEMENT);
    vpm.DPMSVersion = 0x0001;

    // TODO feature: Trigger a GCE (Glide Computer Event) when
    // switching to battery mode This can be used to warn users that
    // power has been lost and you are now on battery power - ie:
    // something else is wrong

    if (doblank) {

      /* Battery status - simulator only - for safety of battery data
         note: Simulator only - more important to keep running in your plane
      */

      // JMW, maybe this should be active always...
      // we don't want the PDA to be completely depleted.

      if (BatteryInfo.acStatus==0) {
#if NOSIM

#else
#ifdef _SIM_
        if ((PDABatteryPercent < BATTERY_EXIT) && !ForceShutdown) {
          StartupStore(TEXT("........ Battery low exit...%s"),NEWLINE);
          // TODO feature: Warning message on battery shutdown
	  ForceShutdown = true;
          SendMessage(hWndMainWindow, WM_CLOSE, 0, 0);
        } else
#endif
#endif
          if (PDABatteryPercent < BATTERY_WARNING) {
            DWORD LocalWarningTime = ::GetTickCount();
            if ((LocalWarningTime - BatteryWarningTime) > BATTERY_REMINDER) {
              BatteryWarningTime = LocalWarningTime;
              // TODO feature: Show the user what the batt status is.
              DoStatusMessage(TEXT("..... Organiser Battery Low"));
            }
          } else {
            BatteryWarningTime = 0;
          }
      }

      if (BatteryInfo.acStatus==0) {

        // Power off the display
        vpm.PowerState = VideoPowerOff;
        ExtEscape(gdc, SETPOWERMANAGEMENT, vpm.Length, (LPCSTR) &vpm,
                  0, NULL);
        oldblank = true;
        ScreenBlanked = true;
      } else {
        DisplayTimeOut = 0;
      }
    } else {
      if (oldblank) { // was blanked
        // Power on the display
        vpm.PowerState = VideoPowerOn;
        ExtEscape(gdc, SETPOWERMANAGEMENT, vpm.Length, (LPCSTR) &vpm,
                  0, NULL);
        oldblank = false;
        ScreenBlanked = false;
      }
    }

  }
  ::ReleaseDC(NULL, gdc);
#endif
#endif
}



void Event_SelectInfoBox(int i) {
//  int oldinfofocus = InfoFocus;

  // must do this
  InfoBoxFocusTimeOut = 0;

  if (InfoFocus>= 0) {
    FocusOnWindow(InfoFocus,false);
  }
  InfoFocus+= i;
  if (InfoFocus>=numInfoWindows) {
    InfoFocus = -1; // deactivate if wrap around
  }
  if (InfoFocus<0) {
    InfoFocus = -1; // deactivate if wrap around
  }
  if (InfoFocus<0) {
    DefocusInfoBox();
    SwitchToMapWindow();
    return;
  }

  //  SetFocus(hWndInfoWindow[InfoFocus]);
  FocusOnWindow(InfoFocus,true);
  InfoWindowActive = TRUE;
  DisplayText();

  InputEvents::setMode(TEXT("infobox"));
}


void Event_ChangeInfoBoxType(int i) {
  int j=0, k;

  if (InfoFocus<0) {
    return;
  }

  k = getInfoType(InfoFocus);
  if (i>0) {
    j = Data_Options[k].next_screen;
  }
  if (i<0) {
    j = Data_Options[k].prev_screen;
  }

  // TODO code: if i==0, go to default or reset

  setInfoType(InfoFocus, j);
  DisplayText();

}



static void ReplaceInString(TCHAR *String, TCHAR *ToReplace, 
                            TCHAR *ReplaceWith, size_t Size){
  TCHAR TmpBuf[MAX_PATH];
  int   iR, iW;
  TCHAR *pC;

  while((pC = _tcsstr(String, ToReplace)) != NULL){
    iR = _tcsclen(ToReplace);
    iW = _tcsclen(ReplaceWith);
    _tcscpy(TmpBuf, pC + iR);
    _tcscpy(pC, ReplaceWith);
    _tcscat(pC, TmpBuf);
  }

}

static void CondReplaceInString(bool Condition, TCHAR *Buffer, 
                                TCHAR *Macro, TCHAR *TrueText, 
                                TCHAR *FalseText, size_t Size){
  if (Condition)
    ReplaceInString(Buffer, Macro, TrueText, Size);
  else
    ReplaceInString(Buffer, Macro, FalseText, Size);
}

bool ExpandMacros(const TCHAR *In, TCHAR *OutBuffer, size_t Size){
  // ToDo, check Buffer Size
  bool invalid = false;
  _tcsncpy(OutBuffer, In, Size);
  OutBuffer[Size-1] = '\0';
  TCHAR *a;
  short items=1;

#if 100517
  if (_tcsstr(OutBuffer, TEXT("$(")) == NULL) return false;
  a =_tcsstr(OutBuffer, TEXT("&("));
  if (a != NULL) {
	*a=_T('$');
	items=2;
  }
#else
  if (_tcsstr(OutBuffer, TEXT("$(")) == NULL) return false;
#endif

  if (_tcsstr(OutBuffer, TEXT("$(MacCreadyValue)"))) { // 091214

	TCHAR tbuf[10];
	_stprintf(tbuf,_T("%2.1lf"), iround(LIFTMODIFY*MACCREADY*10)/10.0);
	ReplaceInString(OutBuffer, TEXT("$(MacCreadyValue)"), tbuf, Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(MacCreadyMode)"))) { // 091214

	TCHAR tbuf[10];
	_stprintf(tbuf,_T("%s"), CALCULATED_INFO.AutoMacCready ? _T("Auto") : _T("Man") );
	ReplaceInString(OutBuffer, TEXT("$(MacCreadyMode)"), tbuf, Size);
	if (--items<=0) goto label_ret; // 100517
  }

  #ifndef NOTASKABORT
  if (TaskAborted) {
    if (_tcsstr(OutBuffer, TEXT("$(WaypointNext)"))) {
      // Waypoint\nNext
      invalid = !ValidTaskPoint(ActiveWayPoint+1);
      CondReplaceInString(!ValidTaskPoint(ActiveWayPoint+2), 
                          OutBuffer,
                          TEXT("$(WaypointNext)"), 
                          TEXT("Landpoint\nFurthest"), 
                          TEXT("Landpoint\nNext"), Size);
	if (--items<=0) goto label_ret; // 100517
      
    } else
    if (_tcsstr(OutBuffer, TEXT("$(WaypointPrevious)"))) {
      // Waypoint\nNext
      invalid = !ValidTaskPoint(ActiveWayPoint-1);
      CondReplaceInString(!ValidTaskPoint(ActiveWayPoint-2), 
                          OutBuffer,
                          TEXT("$(WaypointPrevious)"), 
                          TEXT("Landpoint\nClosest"), 
                          TEXT("Landpoint\nPrevious"), Size);
	if (--items<=0) goto label_ret; // 100517
    }
  } else {
  #endif
    if (_tcsstr(OutBuffer, TEXT("$(WaypointNext)"))) {
      // Waypoint\nNext
      invalid = !ValidTaskPoint(ActiveWayPoint+1);
      CondReplaceInString(!ValidTaskPoint(ActiveWayPoint+2), 
                          OutBuffer,
                          TEXT("$(WaypointNext)"), 
                          gettext(TEXT("Waypoint\nFinish")), 
                          gettext(TEXT("Waypoint\nNext")), Size);
	if (--items<=0) goto label_ret; // 100517
      
    } else
    if (_tcsstr(OutBuffer, TEXT("$(WaypointPrevious)"))) {
      if (ActiveWayPoint==1) {
        invalid = !ValidTaskPoint(ActiveWayPoint-1);
        ReplaceInString(OutBuffer, TEXT("$(WaypointPrevious)"), 
                        gettext(TEXT("Waypoint\nStart")), Size);
	if (--items<=0) goto label_ret; // 100517
      } else if (EnableMultipleStartPoints) {
        invalid = !ValidTaskPoint(0);
        CondReplaceInString((ActiveWayPoint==0), 
                            OutBuffer, 
                            TEXT("$(WaypointPrevious)"), 
                            TEXT("StartPoint\nCycle"), gettext(TEXT("Waypoint\nPrevious")), Size);
	if (--items<=0) goto label_ret; // 100517
      } else {
        invalid = (ActiveWayPoint<=0);
        ReplaceInString(OutBuffer, TEXT("$(WaypointPrevious)"), gettext(TEXT("Waypoint\nPrevious")), Size);
	if (--items<=0) goto label_ret; // 100517
      }
    }
  #ifndef NOTASKABORT
  }
  #endif

  if (_tcsstr(OutBuffer, TEXT("$(RealTask)"))) {
	if (! (ValidTaskPoint(ActiveWayPoint) && ValidTaskPoint(1))) {
		invalid=true;
	}
	ReplaceInString(OutBuffer, TEXT("$(RealTask)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }


  if (_tcsstr(OutBuffer, TEXT("$(AdvanceArmed)"))) {
    switch (AutoAdvance) {
    case 0:
      ReplaceInString(OutBuffer, TEXT("$(AdvanceArmed)"), TEXT("(manual)"), Size);
      invalid = true;
      break;
    case 1:
      ReplaceInString(OutBuffer, TEXT("$(AdvanceArmed)"), TEXT("(auto)"), Size);
      invalid = true;
      break;
    case 2:
      if (ActiveWayPoint>0) {
        if (ValidTaskPoint(ActiveWayPoint+1)) {
          CondReplaceInString(AdvanceArmed, OutBuffer, TEXT("$(AdvanceArmed)"), 
                              gettext(TEXT("Cancel")), 
				gettext(TEXT("TURN")), Size);
        } else {
          ReplaceInString(OutBuffer, TEXT("$(AdvanceArmed)"), 
                          gettext(TEXT("(finish)")), Size);
          invalid = true;
        }
      } else {
        CondReplaceInString(AdvanceArmed, OutBuffer, TEXT("$(AdvanceArmed)"), 
                            gettext(TEXT("Cancel")), 
			gettext(TEXT("START")), Size);
      }
      break;
    case 3:
      if (ActiveWayPoint==0) {
        CondReplaceInString(AdvanceArmed, OutBuffer, TEXT("$(AdvanceArmed)"), 
                            gettext(TEXT("Cancel")), 
			gettext(TEXT("START")), Size);
      } else if (ActiveWayPoint==1) {
        CondReplaceInString(AdvanceArmed, OutBuffer, TEXT("$(AdvanceArmed)"), 
                            gettext(TEXT("Cancel")), 
			gettext(TEXT("RESTART")), Size);
      } else {
        ReplaceInString(OutBuffer, TEXT("$(AdvanceArmed)"), TEXT("(auto)"), Size);
        invalid = true;
      }
      // TODO bug: no need to arm finish
    default:
      break;
    }
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(CheckFlying)"))) { // 100203
    if (!CALCULATED_INFO.Flying) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckFlying)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(CheckNotFlying)"))) { // 100223
    if (CALCULATED_INFO.Flying) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckNotFlying)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(CheckReplay)"))) {
    if (!ReplayLogger::IsEnabled() && GPS_INFO.MovementDetected) {
      invalid = true;
    } 
    ReplaceInString(OutBuffer, TEXT("$(CheckReplay)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(NotInReplay)"))) {
    if (ReplayLogger::IsEnabled()) {
      invalid = true;
    } 
    ReplaceInString(OutBuffer, TEXT("$(NotInReplay)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(CheckWaypointFile)"))) {
    if (!ValidWayPoint(NUMRESWP)) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckWaypointFile)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(CheckSettingsLockout)"))) {
#if NOSIM
    if (LockSettingsInFlight && CALCULATED_INFO.Flying) {
      invalid = true;
    }
#else
#ifndef _SIM_
    if (LockSettingsInFlight && CALCULATED_INFO.Flying) {
      invalid = true;
    }
#endif
#endif
    ReplaceInString(OutBuffer, TEXT("$(CheckSettingsLockout)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  #ifndef NOTASKABORT
  if (_tcsstr(OutBuffer, TEXT("$(CheckTaskResumed)"))) {
    if (TaskAborted) {
      // TODO code: check, does this need to be set with temporary task?
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckTaskResumed)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  #endif
  if (_tcsstr(OutBuffer, TEXT("$(CheckTask)"))) {
    if (!ValidTaskPoint(ActiveWayPoint)) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckTask)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(CheckAirspace)"))) {
    if (!ValidAirspace()) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckAirspace)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(CheckFLARM)"))) {
    if (!GPS_INFO.FLARM_Available) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckFLARM)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(CheckTerrain)"))) {
    if (!CALCULATED_INFO.TerrainValid) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckTerrain)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(TerrainVisible)"))) {
    if (CALCULATED_INFO.TerrainValid && EnableTerrain && !LKVarioBar) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(TerrainVisible)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  // If it is not SIM mode, it is invalid
  if (_tcsstr(OutBuffer, TEXT("$(OnlyInSim)"))) {
	#if NOSIM
	if (!SIMMODE) invalid = true;
	#else
	#ifndef _SIM_
	invalid = true;
	#endif
	#endif
	ReplaceInString(OutBuffer, TEXT("$(OnlyInSim)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(OnlyInFly)"))) {
	#if NOSIM
	if (SIMMODE) invalid = true;
	#else
	#ifdef _SIM_
	invalid = true;
	#endif
	#endif
	ReplaceInString(OutBuffer, TEXT("$(OnlyInFly)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(DISABLED)"))) {
	invalid = true;
	ReplaceInString(OutBuffer, TEXT("$(DISABLED)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  // if using Final glide or "both", available only when we have a goto active
  if (_tcsstr(OutBuffer, TEXT("$(CheckAutoMc)"))) {
    if (!ValidTaskPoint(ActiveWayPoint) 
        && ((AutoMcMode==0)
	    || (AutoMcMode==2))) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(CheckAutoMc)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(HBARAVAILABLE)"))) {
    if (!GPS_INFO.BaroAltitudeAvailable) {
      invalid = true;
    }
    ReplaceInString(OutBuffer, TEXT("$(HBARAVAILABLE)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; 
  }
  if (_tcsstr(OutBuffer, TEXT("$(TOGGLEHBAR)"))) {
	if (!GPS_INFO.BaroAltitudeAvailable) {
		ReplaceInString(OutBuffer, TEXT("$(TOGGLEHBAR)"), TEXT("HBAR"), Size);
	} else {
		if (EnableNavBaroAltitude)
			ReplaceInString(OutBuffer, TEXT("$(TOGGLEHBAR)"), TEXT("HGPS"), Size);
		else
			ReplaceInString(OutBuffer, TEXT("$(TOGGLEHBAR)"), TEXT("HBAR"), Size);
	}
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(BoxMode)"))) {
	if ( MapWindow::IsMapFullScreen() ) invalid = true;
	ReplaceInString(OutBuffer, TEXT("$(BoxMode)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(WCSpeed)"))) {
	TCHAR tbuf[10];
	_stprintf(tbuf,_T("%.0f%s"),SPEEDMODIFY*WindCalcSpeed,Units::GetUnitName(Units::GetUserHorizontalSpeedUnit()) );
	ReplaceInString(OutBuffer, TEXT("$(WCSpeed)"), tbuf, Size);
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(GS"))) {
	TCHAR tbuf[10];
	_stprintf(tbuf,_T("%.0f%s"),SPEEDMODIFY*GPS_INFO.Speed,Units::GetUnitName(Units::GetUserHorizontalSpeedUnit()) );
	ReplaceInString(OutBuffer, TEXT("$(GS)"), tbuf, Size);
	if (--items<=0) goto label_ret;
  }
  if (_tcsstr(OutBuffer, TEXT("$(HGPS"))) {
	TCHAR tbuf[10];
	_stprintf(tbuf,_T("%.0f%s"),ALTITUDEMODIFY*GPS_INFO.Altitude,Units::GetUnitName(Units::GetUserAltitudeUnit()) );
	ReplaceInString(OutBuffer, TEXT("$(HGPS)"), tbuf, Size);
	if (--items<=0) goto label_ret;
  }
  if (_tcsstr(OutBuffer, TEXT("$(TURN"))) {
	TCHAR tbuf[10];
	_stprintf(tbuf,_T("%.0f"),SimTurn);
	ReplaceInString(OutBuffer, TEXT("$(TURN)"), tbuf, Size);
	if (--items<=0) goto label_ret;
  }

  // This will make the button invisible
  if (_tcsstr(OutBuffer, TEXT("$(SIMONLY"))) {
	#if NOSIM
	if (SIMMODE) {
		TCHAR tbuf[10];
		_tcscpy(tbuf,_T(""));
		ReplaceInString(OutBuffer, TEXT("$(SIMONLY)"), tbuf, Size);
	} else {
		_tcscpy(OutBuffer,_T(""));
	}
	#else
	#ifndef _SIM_
	_tcscpy(OutBuffer,_T(""));
	#else
	TCHAR tbuf[10];
	_tcscpy(tbuf,_T(""));
	ReplaceInString(OutBuffer, TEXT("$(SIMONLY)"), tbuf, Size);
	#endif
	#endif
	if (--items<=0) goto label_ret;
  }

  if (_tcsstr(OutBuffer, TEXT("$(LoggerActive)"))) {
	CondReplaceInString(LoggerActive, OutBuffer, TEXT("$(LoggerActive)"), TEXT("Stop"), TEXT("Start"), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(SnailTrailToggleName)"))) {
    switch(TrailActive) {
    case 0:
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), gettext(TEXT("Long")), Size);
      break;
    case 1:
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), gettext(TEXT("Short")), Size);
      break;
    case 2:
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), gettext(TEXT("Full")), Size);
      break;
    case 3:
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), gettext(TEXT("OFF")), Size);
      break;
    }
	if (--items<=0) goto label_ret; // 100517
  }
// VENTA3 VisualGlide
  if (_tcsstr(OutBuffer, TEXT("$(VisualGlideToggleName)"))) {
    switch(VisualGlide) {
    case 0:
      ReplaceInString(OutBuffer, TEXT("$(VisualGlideToggleName)"), TEXT("ON"), Size);
      break;
    case 1:
	if (ExtendedVisualGlide)
		ReplaceInString(OutBuffer, TEXT("$(VisualGlideToggleName)"), TEXT("Moving"), Size);
	else
		ReplaceInString(OutBuffer, TEXT("$(VisualGlideToggleName)"), TEXT("OFF"), Size);
      break;
    case 2:
      ReplaceInString(OutBuffer, TEXT("$(VisualGlideToggleName)"), TEXT("OFF"), Size);
      break;
    }
	if (--items<=0) goto label_ret; // 100517
  }

// VENTA3 AirSpace event
  if (_tcsstr(OutBuffer, TEXT("$(AirSpaceToggleName)"))) {
    switch(OnAirSpace) {
    case 0:
      ReplaceInString(OutBuffer, TEXT("$(AirSpaceToggleName)"), TEXT("ON"), Size);
      break;
    case 1:
      ReplaceInString(OutBuffer, TEXT("$(AirSpaceToggleName)"), TEXT("OFF"), Size);
      break;
    }
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(SHADING)"))) {
    if ( Shading )
      ReplaceInString(OutBuffer, TEXT("$(SHADING)"), TEXT("OFF"), Size);
    else
      ReplaceInString(OutBuffer, TEXT("$(SHADING)"), TEXT("ON"), Size);
	if (--items<=0) goto label_ret;
  }

  if (_tcsstr(OutBuffer, TEXT("$(PanModeStatus)"))) {
    if ( MapWindow::isPan() )
      ReplaceInString(OutBuffer, TEXT("$(PanModeStatus)"), TEXT("OFF"), Size);
    else
      ReplaceInString(OutBuffer, TEXT("$(PanModeStatus)"), TEXT("ON"), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(EnableSoundModes)"))) {
    if (EnableSoundModes)
      ReplaceInString(OutBuffer, TEXT("$(EnableSoundModes)"), TEXT("OFF"), Size);
    else
      ReplaceInString(OutBuffer, TEXT("$(EnableSoundModes)"), TEXT("ON"), Size);
	if (--items<=0) goto label_ret; // 100517
  }

  if (_tcsstr(OutBuffer, TEXT("$(ActiveMap)"))) {
    if (ActiveMap)
      ReplaceInString(OutBuffer, TEXT("$(ActiveMap)"), TEXT("OFF"), Size);
    else
      ReplaceInString(OutBuffer, TEXT("$(ActiveMap)"), TEXT("ON"), Size);
	if (--items<=0) goto label_ret; // 100517
  }


  if (_tcsstr(OutBuffer, TEXT("$(NoSmart)"))) {
	if (DisplayOrientation == NORTHSMART) invalid = true;
	ReplaceInString(OutBuffer, TEXT("$(NoSmart)"), TEXT(""), Size);
	if (--items<=0) goto label_ret; // 100517
  }
  if (_tcsstr(OutBuffer, TEXT("$(OVERLAY"))) {
	if (Look8000==(Look8000_t)lxcNoOverlay)
		ReplaceInString(OutBuffer, TEXT("$(OVERLAY)"), TEXT("ON"), Size);
	else
		ReplaceInString(OutBuffer, TEXT("$(OVERLAY)"), TEXT("OFF"), Size);
	if (--items<=0) goto label_ret; 
  }
#if ORBITER
  if (_tcsstr(OutBuffer, TEXT("$(Orbiter"))) {
	if (!Orbiter)
		ReplaceInString(OutBuffer, TEXT("$(Orbiter)"), TEXT("ON"), Size);
	else
		ReplaceInString(OutBuffer, TEXT("$(Orbiter)"), TEXT("OFF"), Size);

	if (!EnableThermalLocator) invalid = true;
	if (--items<=0) goto label_ret; 
  }
#endif

#if 0 // 100517
  if (_tcsstr(OutBuffer, TEXT("$(TerrainTopologyToggleName)"))) {
    char val;
    val = 0;
    if (EnableTopology) val++;
    if (EnableTerrain) val += (char)2;
    switch(val) {
    case 0:
      ReplaceInString(OutBuffer, TEXT("$(TerrainTopologyToggleName)"), 
                      TEXT("Topology\nON"), Size);
      break;
    case 1:
      ReplaceInString(OutBuffer, TEXT("$(TerrainTopologyToggleName)"), 
                      TEXT("Terrain\nON"), Size);
      break;
    case 2:
      ReplaceInString(OutBuffer, TEXT("$(TerrainTopologyToggleName)"), 
                      TEXT("Terrain\nTopology"), Size);
      break;
    case 3:
      ReplaceInString(OutBuffer, TEXT("$(TerrainTopologyToggleName)"), 
                      gettext(TEXT("Terrain\nOFF")), Size);
      break;
    }
	if (--items<=0) goto label_ret; // 100517
  }
  #endif

  #ifndef NOTASKABORT
  CondReplaceInString(TaskIsTemporary(), 
		      OutBuffer, TEXT("$(TaskAbortToggleActionName)"), 
		      TEXT("Resume"), TEXT("Suspend"), Size); // 091125 Abort is now Suspend
  #endif

  if (_tcsstr(OutBuffer, TEXT("$(FinalForceToggleActionName)"))) {
    CondReplaceInString(ForceFinalGlide, OutBuffer, 
                        TEXT("$(FinalForceToggleActionName)"), 
                        TEXT("Unforce"), 
                        TEXT("Force"), Size);
    if (AutoForceFinalGlide) {
      invalid = true;
    }
	if (--items<=0) goto label_ret; // 100517
  }

  CondReplaceInString(MapWindow::IsMapFullScreen(), OutBuffer, TEXT("$(FullScreenToggleActionName)"), TEXT("ON"), TEXT("OFF"), Size);
  CondReplaceInString(MapWindow::isAutoZoom(), OutBuffer, TEXT("$(ZoomAutoToggleActionName)"), TEXT("Manual"), TEXT("Auto"), Size);
  CondReplaceInString(EnableTopology, OutBuffer, TEXT("$(TopologyToggleActionName)"), TEXT("OFF"), TEXT("ON"), Size);
  CondReplaceInString(EnableTerrain, OutBuffer, TEXT("$(TerrainToggleActionName)"), TEXT("OFF"), TEXT("ON"), Size);

  if (_tcsstr(OutBuffer, TEXT("$(MapLabelsToggleActionName)"))) {
    switch(MapWindow::DeclutterLabels) {
    case MAPLABELS_ALLON:
	//#if LKTOPO
      ReplaceInString(OutBuffer, TEXT("$(MapLabelsToggleActionName)"), 
                      TEXT("WPTS"), Size);

      break;
    case MAPLABELS_ONLYWPS:
      ReplaceInString(OutBuffer, TEXT("$(MapLabelsToggleActionName)"), 
                      TEXT("TOPO"), Size);
      break;
    case MAPLABELS_ONLYTOPO:
	//#endif
      ReplaceInString(OutBuffer, TEXT("$(MapLabelsToggleActionName)"), 
                      TEXT("ALL OFF"), Size);
      break;
    case MAPLABELS_ALLOFF:
      ReplaceInString(OutBuffer, TEXT("$(MapLabelsToggleActionName)"), 
                      TEXT("ALL ON"), Size);
      break;
    }
	if (--items<=0) goto label_ret; // 100517
  }

  CondReplaceInString(CALCULATED_INFO.AutoMacCready != 0, OutBuffer, TEXT("$(MacCreadyToggleActionName)"), TEXT("Manual"), TEXT("Auto"), Size);
  CondReplaceInString(EnableAuxiliaryInfo, OutBuffer, TEXT("$(AuxInfoToggleActionName)"), TEXT("OFF"), TEXT("ON"), Size);

  CondReplaceInString(UserForceDisplayMode == dmCircling, OutBuffer, TEXT("$(DispModeClimbShortIndicator)"), TEXT("_"), TEXT(""), Size);
  CondReplaceInString(UserForceDisplayMode == dmCruise, OutBuffer, TEXT("$(DispModeCruiseShortIndicator)"), TEXT("_"), TEXT(""), Size);
  CondReplaceInString(UserForceDisplayMode == dmNone, OutBuffer, TEXT("$(DispModeAutoShortIndicator)"), TEXT("_"), TEXT(""), Size);
  CondReplaceInString(UserForceDisplayMode == dmFinalGlide, OutBuffer, TEXT("$(DispModeFinalShortIndicator)"), TEXT("_"), TEXT(""), Size);

#if 0
  CondReplaceInString(AltitudeMode == ALLON, OutBuffer, TEXT("$(AirspaceModeAllShortIndicator)"), TEXT("|"), TEXT(""), Size);

  CondReplaceInString(AltitudeMode == CLIP,  OutBuffer, TEXT("$(AirspaceModeClipShortIndicator)"), TEXT("()"), TEXT(""), Size);
  CondReplaceInString(AltitudeMode == AUTO,  OutBuffer, TEXT("$(AirspaceModeAutoShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(AltitudeMode == ALLBELOW, OutBuffer, TEXT("$(AirspaceModeBelowShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(AltitudeMode == ALLOFF, OutBuffer, TEXT("$(AirspaceModeAllOffIndicator)"), TEXT("(*)"), TEXT(""), Size);
#else  // 091211
  if (_tcsstr(OutBuffer, TEXT("$(AirspaceMode)"))) {
    switch(AltitudeMode) {
    case 0:
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), gettext(TEXT("Clip")), Size);
      break;
    case 1:
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), TEXT("Auto"), Size);
      break;
    case 2:
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), gettext(TEXT("Below")), Size);
      break;
    case 3:
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), gettext(TEXT("Inside")), Size);
      break;
    case 4:
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), gettext(TEXT("All OFF")), Size);
      break;
    case 5:
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), gettext(TEXT("All ON")), Size);
      break;
    }
	if (--items<=0) goto label_ret; // 100517
  }
#endif

#if 0  //  100517 NOUSE
  CondReplaceInString(TrailActive == 0, OutBuffer, TEXT("$(SnailTrailOffShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(TrailActive == 2, OutBuffer, TEXT("$(SnailTrailShortShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(TrailActive == 1, OutBuffer, TEXT("$(SnailTrailLongShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(TrailActive == 3, OutBuffer, TEXT("$(SnailTrailFullShortIndicator)"), TEXT("(*)"), TEXT(""), Size);

// VENTA3 VisualGlide
  CondReplaceInString(VisualGlide == 0, OutBuffer, TEXT("$(VisualGlideOffShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(VisualGlide == 1, OutBuffer, TEXT("$(VisualGlideLightShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(VisualGlide == 2, OutBuffer, TEXT("$(VisualGlideHeavyShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
// VENTA3 AirSpace
  CondReplaceInString(OnAirSpace  == 0, OutBuffer, TEXT("$(AirSpaceOffShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(OnAirSpace  == 1, OutBuffer, TEXT("$(AirSpaceOnShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
#endif

  #ifndef NOFLARMGAUGE
  CondReplaceInString(EnableFLARMGauge != 0, OutBuffer, TEXT("$(FlarmDispToggleActionName)"), TEXT("OFF"), TEXT("ON"), Size);
  #endif

label_ret:

  return invalid;
}

@


8.23
log
@*** empty log message ***
@
text
@d1 4
a4 2
/*  
Copyright_License {
d6 2
a7 29
  XCSoar Glide Computer - http://xcsoar.sourceforge.net/
  Copyright (C) 2000 - 2008  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
a8 3
  $Id: XCSoar.cpp,v 8.22 2010/01/26 17:19:40 root Exp root $
}
*/
d66 1
d77 5
d300 4
d339 1
a339 1
double        QNH = (double)1013.2;
d353 1
d355 1
d360 1
a360 1
///: 091011 Used by TakeoffLanding inside Calculation.cpp - limited values careful 
d365 19
d390 1
a390 1
double SAFETYALTITUDETERRAIN = 100;
d436 10
a445 1
///:
d452 1
d464 1
d466 3
d472 1
d476 1
d483 1
a483 1
///: coordinates of the 5 (0-4) sort boxes. 6 for safety
d486 1
a486 1
///: default initialization for gestures. InitLK8000 will fine tune it.
d488 3
a490 1
///: normally we do it the unusual way
d495 1
a495 1
///: This is the gauge bar on the left for variometer
d497 1
a497 1
///: moving map is all black and need white painting - not much used 091109
d499 1
a499 1
///: if true, LK specific text on map is painted black, otherwise white
d501 2
a502 2
///: enumerated value for map background when no terrain is painted, valid for both normal and inverted mode
///: note that all topology text is in black, so this should be a light colour in any case
d504 1
a504 1
bool  BgMapColorTextBlack[LKMAXBACKGROUNDS]={ true, true, true, true, false, false, false, false, false, false };
d506 1
a506 1
///: activated by Utils2 in virtual keys, used inside RenderMapWindowBg
d510 1
a510 1
bool McOverlay=false;
d516 12
a527 2
///: Traffic is real if <=1min, Shadow if <= etc.
int LKTime_Real=60, LKTime_Shadow=180, LKTime_Ghost=600;
d529 1
a529 1
///: type of file format for waypoints files
d531 8
d540 1
a540 1
///: Time in use by Nmea parser, updated realtime
d543 1
a543 1
///: Polling Mode flag required #define POLLINGMODE to be functional
d563 1
a563 1
///: it is called DeclutterMode but it has nothing to do with MapSpaces
d566 2
a567 2
///: current mapspacemode: the internal identifier of a page type
///: should not be used for turning pages, only for direct access
d569 1
a569 1
///: telling you if you are in wpmode, infomode etc..
d571 3
a573 3
///: See Utils2.h for relationship
///: pointers to MapSpacemodes
///: MSM_TOP is used as max size also for each subsets
d575 1
a575 1
///: top of the list inside each table. Could be a struct with ModeTable
d577 1
a577 1
///: remembers for each mode (wp, infopage, map , etc.) the current type
d580 1
a580 1
///: current selected raw in mapspacemodes
d582 2
a583 2
///: current page in each mapspacemode, reset entering new mapspace: no memory
///: since it doesnt eat memory, it is also used for pages with currently no subpages
d585 1
a585 1
///: number of raws in mapspacemode screen
d589 1
a589 1
///: number of pages in mapspacemode depending on MAXNEAREST and Numraws
d593 3
a595 3
///:  mapspace sort mode: 0 wp name  1 distance  2 bearing  3 reff  4 altarr
///:  UNUSED on MSM_COMMON etc. however it is dimensioned on mapspacemodes
//short SortedMode[MAXNUMPAGES]; BUG! REMOVE
d598 11
a608 2
///: Default arrival mode calculation type
///: 091016 currently not changed anymore
d611 63
a673 1
///: LK8000 sync flags
d683 1
a683 1

d687 1
a687 1
///: Optimization  preprocessing
d694 4
a697 4
///: This list is sorted out of RangeLandableIndex, used by DoNearest
///: cannot be used elsewhere, since it's only updated when in Nearest MapSpaceMode.
///: +1 is for safety...  
///: 090924 now also in DoNearestTurnpoint for MSM_NEARTPS 
d701 1
a701 1
///: Real number of NEAREST items contained in array after removing duplicates, or not enough to fill MAXNEAREST/MAX..
d703 1
a703 1
///: as above, for nearest turnpoints
d706 2
a707 2
///: Commons are Home, best alternate, alternate1, 2, and task waypoints , all up to MAXCOMMON.
///: It is reset when changing wp file
d709 1
a709 1
///: Number of items 0-n inside CommonIndex
d712 1
a712 1
///: History of recent waypoints
d716 1
a716 1
///: Cpu stats
d725 4
a728 1
double Experimental1=2222, Experimental2=0;
d734 3
d768 1
a768 1
int FinalGlideTerrain = 0;
d772 1
d827 2
a828 2
///: 091119 System boot specific flags 
///: Gimme a go/no-go 
d832 2
a833 2
bool goInitDevice=false; // 100118
///: bool goCalculating=false; // 100207
d849 2
d864 1
a864 1
	  {ugAltitude,        TEXT("Altitude AGL"), TEXT("AltAGL"), new FormatterLowWarning(TEXT("%2.0f"),0.0), NoProcessing, 20, 0},
d960 1
a960 1
	  {ugHorizontalSpeed, TEXT("Speed Dolphin"), TEXT("SpOpt"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 10, 35},
d1053 1
a1053 1
	  {ugInvAltitude,        TEXT("Altern AGL"), TEXT("aAGL"), new FormatterLowWarning(TEXT("%2.0f"),0.0), NoProcessing, 20, 0},
d1056 3
a1058 1
	  // 87 // 
d1060 1
a1060 1
	  // 88 // 
d1063 2
a1064 2
///: counting from 0 so add 1 !
const int NUMSELECTSTRINGS = 89; 
d1097 4
d1106 1
a1171 1

d1186 46
d1233 5
a1237 5
    AIRSPACEFILECHANGED = TRUE;
    AIRFIELDFILECHANGED = TRUE;
    WAYPOINTFILECHANGED = TRUE;
    TERRAINFILECHANGED = TRUE;
    TOPOLOGYFILECHANGED = TRUE;
d1240 7
a1246 12
  if((WAYPOINTFILECHANGED) || (TERRAINFILECHANGED) || (AIRFIELDFILECHANGED))
    {
      ClearTask();

      // re-load terrain
      RasterTerrain::CloseTerrain();
      RasterTerrain::OpenTerrain();

      // re-load waypoints
      ReadWayPoints();
      InitWayPointCalc(); // VENTA3
      ReadAirfieldFile();
d1248 3
a1250 4
      // re-set home
      if (WAYPOINTFILECHANGED || TERRAINFILECHANGED) {
	SetHome(WAYPOINTFILECHANGED==TRUE);
      }
d1252 14
a1265 14
      if (WAYPOINTFILECHANGED) {
	SaveRecentList();
	LoadRecentList();
	RangeLandableNumber=0;
	RangeAirportNumber=0;
	RangeTurnpointNumber=0;
	CommonNumber=0;
	SortedNumber=0;
	SortedTurnpointNumber=0;
	LKForceDoCommon=true;
	LKForceDoNearest=true;
	LKForceDoRecent=true;
	LKForceDoNearestTurnpoint=true;
      }
d1267 4
a1270 6
      // 
      RasterTerrain::ServiceFullReload(GPS_INFO.Latitude, 
                                       GPS_INFO.Longitude);

      MapWindow::ForceVisibilityScan = true;
    }
d1272 5
a1276 6
  if (TOPOLOGYFILECHANGED)
    {
      CloseTopology();
      OpenTopology();
      MapWindow::ForceVisibilityScan = true;
    }
d1278 6
a1283 7
  if(AIRSPACEFILECHANGED)
    {
      CloseAirspace();
      ReadAirspace();
      SortAirspace();
      MapWindow::ForceVisibilityScan = true;
    }  
d1286 2
a1287 2
    CalculateNewPolarCoef();
    GlidePolar::SetBallast();
d1296 2
a1297 2
    CloseProgressDialog();
    SetFocus(hWndMapWindow);
d1304 7
a1310 4
#ifndef _SIM_
  if(COMPORTCHANGED)
    {
      // JMW disabled com opening in sim mode
d1312 3
a1314 3
    }

#endif
d1322 8
d1336 1
a1337 2
  ///: REMOVE! 100101
  //StartupStore(_T("... Before settingsEnter%s"),NEWLINE);
a1338 1
  //StartupStore(_T("... After settingsEnter%s"),NEWLINE);
a1339 1
  //StartupStore(_T("... After showmodal%s"),NEWLINE);
a1340 1
  //StartupStore(_T("... After settingsLeave%s"),NEWLINE);
a1345 1

d1354 1
a1354 2
    SHFullScreen(hWndMainWindow,
                 SHFS_HIDETASKBAR|SHFS_HIDESIPBUTTON|SHFS_HIDESTARTICON);
d1454 2
a1455 1

d1462 1
a1462 1
  ///: watch out for a deadlock here. This has to be done before waiting for DisplayRunning...hehe
d1479 1
d1500 4
d1514 1
a1514 1

d1527 1
a1527 1
  ///: 091119 let's not create a deadlock here, setting the go after another race condition
d1534 1
a1534 1
  ///: while (!goCalculating) Sleep(100); // 100207
a1545 1

d1547 2
a1548 2
    ///: 091201 the UpdateTimeStats was unused and commented, so no reason to keep the if
    ///: if (GpsUpdated) { 
d1550 1
a1550 2
    ///: }

d1623 13
d1644 1
d1668 3
a1670 3
///: 091119 Since the calling function want to be sure that threads are created, they now flag a go status
///: and we save 500ms at startup. 
///: At the end of thread creation, we expect goCalc and goInst flags are true
d1673 1
a1673 1
  ///: Need to keep them global to make them accessible from GetThreadTimes if in use
d1683 1
a1683 1
	///: Do not close if we need to use the handle 
d1690 2
d1706 1
d1715 1
a1715 3
#ifdef DEBUG_TRANSLATIONS
  ReadLanguageFile();
#endif
a1723 1
    //    CreateProgressDialog(gettext(TEXT("Initialising")));
d1726 4
d1731 1
d1735 1
a1735 1
    CreateProgressDialog(gettext(TEXT("Initialising")));
d1740 1
a1740 3
#ifndef DEBUG_TRANSLATIONS
    ReadLanguageFile();
#endif
d1764 9
d1780 1
d1803 1
a1803 1
  int freeram = CheckFreeRam()/1024;
d1806 2
a1807 2
  int freestorage = FindFreeSpace(buffer);
  StartupStore(TEXT(". Free ram=%d  storage=%d%s"), freeram,freestorage,NEWLINE);
d1821 1
a1821 1
  ///: 091119 use mutex to avoid multiple instances of lk8000 be running
a1824 15
  StartHourglassCursor(); // 091119


/* 091119 REMOVE USELESS
#ifdef PNA
  wcscat(XCSoar_Version, TEXT("(PNA) "));
#else
#if (WINDOWSPC>0)
  wcscat(XCSoar_Version, TEXT("(PC) "));
#else
  wcscat(XCSoar_Version, TEXT("(PDA) "));
#endif
#endif
*/

d1827 2
a1828 2

#ifdef PNA
d1830 2
a1831 2
#else
#if (WINDOWSPC>0)
d1833 1
a1833 1
#else
d1835 3
a1837 2
#endif
#endif
d1839 3
a1841 1
#ifdef _SIM_
d1843 2
a1844 1
#endif
d1848 30
a1877 18
///: 091109 Why we can't move later on here after PreloadInit  this stuff:
///: because in Utils2 globalmodeltype is used for init fonts and geometry. A solution could be to get it from the registry
///: and then remove the registry as well
/*
#if defined(FIVV) && ( !defined(WINDOWSPC) || WINDOWSPC==0 )
#ifndef PNA
RegDeleteKey(HKEY_CURRENT_USER, _T(REGKEYNAME));
#endif
#endif
*/

#ifdef PNA // VENTA2-ADDON MODEL TYPE
/*
  LocalPath is called for the very first time by CreateDirectoryIfAbsent.
  In order to be able in the future to behave differently for each PNA device
  and maybe also for common PDAs, we need to know the PNA/PDA Model Type 
  BEFORE calling LocalPath. This was critical.
*/
d1879 1
a1879 12
  SmartGlobalModelType(); // First we check the exec filename, which
			  // has priority over registry values

  if (  !wcscmp(GlobalModelName, _T("UNKNOWN")) ) // Then if there is no smart name...
    SetModelType();                         // get the modeltype from
					    // the registry as usual
#endif

///: 091109 TESTFIX moved here forcing registry deletion also for PNAs. We only needed to get the modeltype, overall.
///: 
///: 091213 TESTFIX registry deleted at startup also for PC
//#if defined(FIVV) && ( !defined(WINDOWSPC) || WINDOWSPC==0 )
d1884 1
a1884 2
	StartupStore(_T("++++++ Registry key could NOT be deleted%s"),NEWLINE);
//#endif
a1885 1
#if defined(FIVV) && ( !defined(WINDOWSPC) || WINDOWSPC==0 )
d1887 5
a1891 8
  bool datadir=CheckDataDir();
  if (datadir)
	StartupStore(TEXT(". CheckDataDir successful, data directory found%s"),NEWLINE);
  else {
	StartupStore(TEXT("++++++ CRITICAL ERROR: NO LK8000 DATA DIRECTORY FOUND!%s"),NEWLINE);
	StartupStore(TEXT("++++++ Probably software is running for the first time with no manual installation%s"),NEWLINE);
	StartupStore(TEXT("++++++ Fonts will not be available, among many other things. That's bad!%s"),NEWLINE);
	StartupStore(TEXT("++++++ Attempting to go ahead, nevertheless...%s"),NEWLINE);
d1894 2
d1897 3
a1899 1
  short didsystem=InstallSystem(); 
d1901 1
d1903 2
a1904 3

#endif

a1914 24
  ///: CreateDirectoryIfAbsent(TEXT("Persist")); 091101 REMOVE TESTFIX
  ///: CreateDirectoryIfAbsent(TEXT(LKD_TEMP));
  ///: CreateDirectoryIfAbsent(TEXT(LKD_DEBUG));

/* REMOVE 091119
#ifdef PNA
  StartupStore(TEXT(". Starting %s %s"), XCSoar_Version,_T("PNA"));
#else
#if (WINDOWSPC>0)
  StartupStore(TEXT(". Starting %s %s"), XCSoar_Version,_T("PC"));
#else
  StartupStore(TEXT(". Starting %s %s"), XCSoar_Version,_T("PDA"));
#endif
#endif
//  StartupStore(TEXT(". Starting %s"), XCSoar_Version);
#ifdef _SIM_
  StartupStore(TEXT(" (SIM) build#%d%s"),BUILDNUMBER,NEWLINE);
#else
  StartupStore(TEXT(" build#%d%s"),BUILDNUMBER,NEWLINE);
#endif
*/

  // 
  // StartupLogFreeRamAndStorage(); 091119 REMOVE
d1925 1
a1925 1
  // Perform application initialization:
d1934 1
a1934 1
#ifdef HAVE_ACTIVATE_INFO
d1946 1
a1946 1
#endif
d1985 1
a1985 1
  PreloadInitialisation(false);
d1987 1
d1989 2
d1992 1
d2019 1
d2028 1
d2033 1
a2033 1

d2035 1
d2042 2
a2043 2
  CreateProgressDialog(gettext(TEXT("DEBUG KEY MODE ACTIVE")));
  Sleep(2000);
d2046 2
a2047 2
  CreateProgressDialog(gettext(TEXT("DEBUG EVENT MODE ACTIVE")));
  Sleep(2000);
d2052 2
a2053 2
CreateProgressDialog(gettext(TEXT("ERROR UNKNOWN RESOLUTION!")));
 Sleep(1000);
d2059 1
a2059 1
	CreateProgressDialog(sTmp); Sleep(500);
a2060 3
/*
	if (  !wcscmp(GlobalModelName, _T("UNKNOWN")) ) SetModelType();
*/
d2062 1
a2062 1
	CreateProgressDialog(sTmp); Sleep(500);
a2063 10
/* 091117 this is wrong
#if defined(FIVV) && ( !defined(WINDOWSPC) || WINDOWSPC==0 )
  if ( didsystem == 0 ) {
    CreateProgressDialog(TEXT("NEW FONTS INSTALLED!")); Sleep(1000);
  } else
    if ( didsystem == 5 ) {
      CreateProgressDialog(TEXT("ERROR, PROBABLY NO FONTS!")); Sleep(3000);
    }
#endif
*/
d2083 1
a2083 1
///: 091109 TODO until startup graphics are settled, no need to delay PC start
d2086 3
a2088 1

d2092 1
a2099 1
  //Sleep(500);
a2105 1
  //Sleep(500);
a2109 2
  ///: Virtual Waypoints must be initialized before real waypoints
  ///: InitVirtualWaypoints();  // 091102 NO moved to readwaypoints()
d2114 1
a2114 1
///:  InitNewMap(); 091203 moved in InitInstance 
d2119 1
d2124 1
a2124 1
  CreateProgressDialog(gettext(TEXT("Scanning weather forecast")));
d2136 1
d2149 1
a2149 1
  CreateProgressDialog(gettext(TEXT("Starting devices")));
d2169 2
a2170 1
  ///: 100118 we want to be sure that RestartCommPort works on startup ONLY after all devices are inititalized
a2171 4
  ///: 100207 dont let calculation thread work until we are done with initialisations!
  ///: goCalculating=true; // 100207

  //JMW disabled  devInit(lpCmdLine);
d2173 6
d2183 11
a2193 3
///: CHECK 091021 WINDOWSPC _SIM_ devInit called twice missing devA name
///: #if ((WINDOWSPC>0) && _SIM_)    possible alternative, unchecked
///: CONFIRMED 100118: on PC nonSIM we cannot use devInit here! Generic device is used until next port reset!  BUGFIX
a2194 1
///: #if (WINDOWSPC>0) // 100118 BUGFIX
d2198 2
d2205 1
a2205 1
  CreateProgressDialog(gettext(TEXT("Bluetooth dialup SMS")));
d2209 1
a2209 1
  CreateProgressDialog(gettext(TEXT("Initialising display")));
d2220 1
d2222 1
d2227 1
d2229 3
d2264 3
a2312 1
  ///: wc.hbrBackground              = (HBRUSH) GetStockObject(WHITE_BRUSH); 091130
d2320 1
a2320 1
  ///: disabling DBLCLK here will make it not working in map window and maplocking failure
a2333 1
  ///: wc.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH); 091230
d2441 1
a2441 5
   ///: 091125 If you set a font here for a specific resolution, no automatic font generation is used.

///: #if defined(PNA) || ((WINDOWSPC>0)&&_REALTHING_&&_SIM_)  091120 choose it everytime  REMOVE
///: #if defined(PNA) // FIX TEST TODO 090925     TEST 091118 REMOVE

d2447 1
a2447 1
    propGetFontSettingsFromString(TEXT("13,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // RLD 16 works well too
d2460 16
d2482 2
a2483 1
    propGetFontSettingsFromString(TEXT("13,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // 14 091120
d2527 2
a2528 1
    propGetFontSettingsFromString(TEXT("26,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont);
d2571 1
a2571 1
    propGetFontSettingsFromString(TEXT("13,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont);
d2573 2
a2574 2
    propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
a2577 1
  ///: added and tune 091120
d2583 2
a2584 1
    propGetFontSettingsFromString(TEXT("23,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // topo labels
a2590 1
  ///: added and tune 091204
d2608 1
a2608 1
    propGetFontSettingsFromString(TEXT("12,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // RLD 16 works well too
d2610 1
a2610 1
    propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
d2625 11
a2635 1
  ///: added portrait mode 091125
d2648 13
d2744 3
d2753 1
d2799 3
a2801 1
///: 091118
d2806 1
a2995 1
/////////////////////////////////////////////////////////
d3068 3
a3070 4
  //If it is already running, then focus on the window
  ///: 091119 problem is that if two instances are started within a few seconds, both will survive!
  ///: We now enforce this with mutex at the beginning of WinMain
  ///: 
a3076 5

///: CleanRegistry cleans only fonts, but now we can remove the registry so it is useless... 091109
///: #ifdef PNA
	///: CleanRegistry(); // VENTA2-FIX for PNA we can't delete all registries..by now (YES we can TESTFIX 091109)
///: #endif
d3078 1
a3078 1
  InitNewMap(); // 091203 moved here NO this is causing problems with CreateButtonLabels
a3099 1
  ///: Sleep(2000); // 091109 delay for letting InstallSystem perform actions  091119 slowdown too much
d3142 4
a3145 2

  ///////////////////////////////////////// create infoboxes
d3153 1
d3155 1
d3157 1
d3160 1
d3166 1
a3166 2
  ////////////////// do fonts
  StartupStore(TEXT(". Initialise fonts%s"),NEWLINE);
a3167 1
  //InitNewMap(); // 091203 moved here
a3175 3
  ///////////////////////////////////////////////////////
  //// create map window 

a3185 1
  StopHourglassCursor(); // 091119
d3194 1
a3194 1
///: Congratulations for the Most Obfuscated C code contest winner!!! But hey we saved some bytes here!
d3295 7
a3301 2
  CreateProgressDialog(gettext(TEXT("Shutdown, please wait...")));
  StartHourglassCursor();
d3314 1
a3314 1
  CreateProgressDialog(gettext(TEXT("Shutdown, saving logs...")));
d3318 1
a3318 1
  CreateProgressDialog(gettext(TEXT("Shutdown, saving profile...")));
d3338 1
a3338 1
  
d3340 1
a3340 1
  CreateProgressDialog(gettext(TEXT("Shutdown, please wait...")));
d3343 3
d3351 1
d3353 1
d3357 1
a3357 1
  CreateProgressDialog(gettext(TEXT("Shutdown, saving task...")));
d3360 1
d3362 1
d3376 1
a3376 1
  CreateProgressDialog(gettext(TEXT("Shutdown, please wait...")));
d3413 1
d3415 2
a3416 1

d3418 2
d3421 2
d3424 1
d3430 2
a3431 1
  
d3434 1
d3470 3
d3475 3
d3480 3
d3485 3
d3490 3
d3495 3
d3525 8
d3534 7
a3540 3
  StopHourglassCursor();
  ///: 091128 BUGFIX quitting PC version while menus are up will not terminate correctly. this is a workaround
#if (WINDOWSPC>0)
d3543 1
a3543 1
#endif 
d3617 1
a3617 1
        iTimerID = SetTimer(hWnd,1000,500,NULL); // 2 times per second
d3696 2
d3700 6
d3711 1
d3741 2
a3742 2
                      gettext(TEXT("Quit program?")),
                      gettext(TEXT("LK8000")),
d3812 1
a3812 1
      
d3836 1
d3864 3
d4352 1
d4355 1
d4441 1
a4441 3
////////////////


d4506 2
a4507 1
	  MessageBeep(MB_ICONEXCLAMATION);
a4518 4
///: #if (WINDOWSPC<1) 091021 TESTFIX let RestartCommPort also for PC upon inactivity
///:	  On PC, if a port was unavailable and then available, without restart generic device was used
///: 100118 verified that on PC, if a port was available it was not using correct device until reset
///: nothing to do here, fixed other position 
d4520 3
a4522 3
	  extGPSCONNECT = FALSE;
	  InputEvents::processGlideComputer(GCE_COMMPORT_RESTART);
	  RestartCommPorts();
d4536 11
d4571 1
a4571 1
	  MessageBeep(MB_ICONEXCLAMATION);
d4587 1
a4587 2

#ifndef _SIM_
d4615 2
a4616 2
    if (GPS_INFO.Time-timeLast>=1.0) {
      TriggerGPSUpdate();
d4633 1
a4633 2

#ifdef _SIM_
d4646 1
d4649 4
d4668 1
d4711 3
a4713 1
  dlgWayPointDetailsShowModal();
a4769 1
///: 100101
d4796 5
d4804 4
d4813 1
a4827 1
  fprintf(stream, "------ FailStore END %s",SNEWLINE);
d4830 1
d4849 1
d4853 2
a4854 1
	startupStoreFile = _tfopen(szFileName, TEXT("wb"));
d4858 1
d4861 1
d4864 1
a4864 1
	///: 091118 add linefeed to StartupStore until we fixed all occurencies
d4869 1
a4869 1
		if (i>0 && sbuf[i-1]!=0x0d && sbuf[i]==0x0a) {	// 091119
d4871 1
a4871 1
			fprintf(startupStoreFile, "[%09d] %s%s", (int)GetTickCount(),sbuf,SNEWLINE); // 091118 DEBUG MODE
d4873 2
a4874 2
			///: i==0 will not translate 0x0a , no problems
			fprintf(startupStoreFile, "[%09d] %s", (int)GetTickCount(), sbuf);
a4875 1
	///: fprintf(startupStoreFile, "%S", buf); 091118 
a4993 4


/////////////////////

a5030 2
//////////////

d5126 3
d5137 1
d5265 2
d5268 1
d5270 23
d5294 1
d5304 1
d5315 1
d5318 1
d5325 3
a5327 2
                          TEXT("Waypoint\nFinish"), 
                          TEXT("Waypoint\nNext"), Size);
d5334 2
a5335 1
                        TEXT("Waypoint\nStart"), Size);
d5341 2
a5342 1
                            TEXT("StartPoint\nCycle"), TEXT("Waypoint\nPrevious"), Size);
d5345 2
a5346 1
        ReplaceInString(OutBuffer, TEXT("$(WaypointPrevious)"), TEXT("Waypoint\nPrevious"), Size);
d5349 1
d5351 1
a5352 1
  ///: 100120
d5358 1
d5376 2
a5377 1
                              TEXT("Cancel"), TEXT("TURN"), Size);
d5380 1
a5380 1
                          TEXT("(finish)"), Size);
d5385 2
a5386 1
                            TEXT("Cancel"), TEXT("START"), Size);
d5392 2
a5393 1
                            TEXT("Cancel"), TEXT("START"), Size);
d5396 2
a5397 1
                            TEXT("Cancel"), TEXT("RESTART"), Size);
d5406 1
d5414 8
d5429 8
d5440 1
a5440 1
    if (!ValidWayPoint(0)) {
d5444 1
d5447 5
d5457 1
d5459 1
d5461 1
d5468 1
d5470 1
d5476 1
d5483 1
d5490 1
d5497 1
d5501 1
a5501 1
    if (CALCULATED_INFO.TerrainValid && EnableTerrain) {
d5505 30
d5537 1
d5545 19
d5566 58
a5623 1
  CondReplaceInString(LoggerActive, OutBuffer, TEXT("$(LoggerActive)"), TEXT("Stop"), TEXT("Start"), Size);
d5628 1
a5628 1
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), TEXT("Long"), Size);
d5631 1
a5631 1
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), TEXT("Short"), Size);
d5634 1
a5634 1
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), TEXT("Full"), Size);
d5637 1
a5637 1
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), TEXT("OFF"), Size);
d5640 1
d5658 1
d5671 8
a5680 1
  ///: 091211
d5686 1
a5688 1
  ///: 091211
d5694 9
a5704 2
  ///: 091214
  if (_tcsstr(OutBuffer, TEXT("$(MacCreadyValue)"))) { // 091214
d5706 11
a5716 3
	TCHAR tbuf[10];
	_stprintf(tbuf,_T("%2.1lf"), iround(LIFTMODIFY*MACCREADY*10)/10.0);
	ReplaceInString(OutBuffer, TEXT("$(MacCreadyValue)"), tbuf, Size);
d5718 6
a5723 1
  if (_tcsstr(OutBuffer, TEXT("$(MacCreadyMode)"))) { // 091214
d5725 2
a5726 3
	TCHAR tbuf[10];
	_stprintf(tbuf,_T("%s"), CALCULATED_INFO.AutoMacCready ? _T("Auto") : _T("Man") );
	ReplaceInString(OutBuffer, TEXT("$(MacCreadyMode)"), tbuf, Size);
d5728 1
d5730 1
d5754 1
d5756 1
d5758 1
a5758 2
  //////

d5762 1
d5772 1
d5782 2
a5783 2
    case 0:
/*
d5785 1
a5785 1
                      TEXT("MID"), Size);
d5788 6
a5793 2
    case 1:
*/
d5795 1
a5795 1
                      TEXT("OFF"), Size);
d5797 1
a5797 1
    case 2:
d5799 1
a5799 1
                      TEXT("ON"), Size);
d5802 1
d5824 1
a5824 1
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), TEXT("Clip"), Size);
d5830 1
a5830 1
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), TEXT("Below"), Size);
d5833 1
a5833 1
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), TEXT("Inside"), Size);
d5836 1
a5836 1
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), TEXT("All OFF"), Size);
d5839 1
a5839 1
      ReplaceInString(OutBuffer, TEXT("$(AirspaceMode)"), TEXT("All ON"), Size);
d5842 1
d5845 2
d5859 1
d5861 1
d5863 3
@


8.22
log
@pre add
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.21 2009/12/01 23:24:56 root Exp root $
d91 1
d236 11
d256 2
a257 1
#endif
d494 1
d498 3
d578 1
a578 1
int  RangeLandableIndex[MAXRANGELANDABLE]; 
d580 1
a580 1
int  RangeAirportIndex[MAXRANGELANDABLE];
d582 1
a582 1
int  RangeTurnpointIndex[MAXRANGETURNPOINT];
a605 1

d615 1
a615 1
double Experimental1=0, Experimental2=0;
d716 1
d785 1
a785 1
	  {ugNone,            TEXT("_OLD Final LD"), TEXT("OLD fLD"), new InfoBoxFormatter(TEXT("%1.0f")), NoProcessing, 38, 5},
d821 1
a821 1
	  {ugAltitude,        TEXT("Pressure Altitude"), TEXT("HBar"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 0, 20},
d831 1
a831 1
	  {ugNone,            TEXT("_OLD Next LD"), TEXT("OLD nLD"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 53, 19},
d931 7
a937 1
	  // 84 // 
d939 1
a939 1
	  // 85 // 
d943 1
a943 1
const int NUMSELECTSTRINGS = 86; 
d1362 2
a1363 1
  Sleep(1000); // 091213  BUGFIX need to syncronize !!! TOFIX02
d2011 1
d2014 2
d2983 1
a2983 1
// Congratulations for the Most Obfuscated C code contest winner!!! But hey we saved some bytes here!
d4225 4
a4228 4
          InputEvents::processGlideComputer(GCE_GPS_CONNECTION_WAIT);

	  //            SetDlgItemText(hGPSStatus,IDC_GPSMESSAGE,szLoadText);
	  
d4280 3
a4282 1
	  InputEvents::processGlideComputer(GCE_GPS_FIX_WAIT);
d4539 1
a4539 1
  TCHAR buf[MAX_PATH]; // 260 chars normally
d4563 1
a4563 1
	char sbuf[MAX_PATH];
d5069 7
@


8.21
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.20 2009/11/25 23:26:58 root Exp $
d38 1
d265 1
d294 1
d325 1
a325 1
int	GlobalModelType=0;	// see XCSoar.h for modeltype definitions
d448 1
a448 1
short BottomSize=0; // Init by MapWindow3
d479 24
d505 1
a505 1
short splitter=0;
d558 2
d695 1
a695 1
///: Gimme a go/no-go baby
d699 1
a699 1

d848 1
a848 1
	  {ugNone,            TEXT("Own Team Code"), TEXT("TeamCode"), new FormatterTeamCode(TEXT("\0")), TeamCodeProcessing, 56, 54},
d912 3
a914 1
	  // 83 // 
d916 1
a916 1
	  // 84 // 
d920 1
a920 1
const int NUMSELECTSTRINGS = 85; 
d1142 2
d1145 1
d1147 1
d1149 1
d1206 1
d1311 1
a1311 1
		Cpu_Calc=9999;
d1339 2
d1352 2
a1353 1
    if (GpsUpdated) { 
d1355 1
a1355 1
    }
d1501 2
a1502 1
  SetToRegistry(TEXT("XCV"), 1);
d1568 1
d1667 2
a1668 1
#if defined(FIVV) && ( !defined(WINDOWSPC) || WINDOWSPC==0 )
d1670 5
a1674 3
  RegDeleteKey(HKEY_CURRENT_USER, _T(REGKEYNAME)); // 091118 TESTFIX DEBUG UNCOMMENT
  StartupStore(_T(". Registry key was correctly deleted%s"),NEWLINE);
#endif
d1742 2
a1743 1
      return FALSE;
d1787 1
a1855 4
#ifdef VENTA_NOREGFONT
  CreateProgressDialog(gettext(TEXT("NO REGISTRY FONT LOAD")));
  Sleep(2000);
#endif
d1860 1
a1860 1
 Sleep(4000);
d1932 1
a1932 1
  InitWayPointCalc(); // VENTA3
d1934 2
a1935 1
  InitNewMap();
d1987 2
d1998 3
a2000 1
#if (WINDOWSPC>0)
d2108 2
a2109 1
  wc.hbrBackground              = (HBRUSH) GetStockObject(WHITE_BRUSH);
d2130 2
a2131 1
  wc.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH);
d2236 1
a2236 1
#if ( (WINDOWSPC==0) || ((WINDOWSPC>0)&&_REALTHING_&&_SIM_)) // 091120
d2318 43
d2374 13
d2839 1
d2861 1
a2861 1
  // Sleep(2000); // 091109 delay for letting InstallSystem perform actions  091119 slowdown too much
d2925 1
d3313 6
d4218 2
d4452 55
d4733 2
d4751 3
a4753 1
    PDABatteryTemperature = BatteryInfo.BatteryTemperature; // VENTA3
d4989 9
d5092 8
d5123 1
a5123 1
      ReplaceInString(OutBuffer, TEXT("$(SnailTrailToggleName)"), TEXT("Off"), Size);
d5131 1
a5131 1
      ReplaceInString(OutBuffer, TEXT("$(VisualGlideToggleName)"), TEXT("Steady"), Size);
d5137 1
a5137 1
		ReplaceInString(OutBuffer, TEXT("$(VisualGlideToggleName)"), TEXT("Off"), Size);
d5140 1
a5140 1
      ReplaceInString(OutBuffer, TEXT("$(VisualGlideToggleName)"), TEXT("Off"), Size);
d5157 30
d5195 1
a5195 1
                      TEXT("Topology\nOn"), Size);
d5199 1
a5199 1
                      TEXT("Terrain\nOn"), Size);
d5207 1
a5207 1
                      gettext(TEXT("Terrain\nOff")), Size);
d5228 1
a5228 1
  CondReplaceInString(MapWindow::IsMapFullScreen(), OutBuffer, TEXT("$(FullScreenToggleActionName)"), TEXT("Off"), TEXT("On"), Size);
d5230 2
a5231 2
  CondReplaceInString(EnableTopology, OutBuffer, TEXT("$(TopologyToggleActionName)"), TEXT("Off"), TEXT("On"), Size);
  CondReplaceInString(EnableTerrain, OutBuffer, TEXT("$(TerrainToggleActionName)"), TEXT("Off"), TEXT("On"), Size);
d5236 1
d5239 1
d5242 1
d5254 6
a5259 1
  CondReplaceInString(EnableAuxiliaryInfo, OutBuffer, TEXT("$(AuxInfoToggleActionName)"), TEXT("Off"), TEXT("On"), Size);
d5261 2
a5262 4
  CondReplaceInString(UserForceDisplayMode == dmCircling, OutBuffer, TEXT("$(DispModeClimbShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(UserForceDisplayMode == dmCruise, OutBuffer, TEXT("$(DispModeCruiseShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(UserForceDisplayMode == dmNone, OutBuffer, TEXT("$(DispModeAutoShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(UserForceDisplayMode == dmFinalGlide, OutBuffer, TEXT("$(DispModeFinalShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
d5264 1
a5264 2
  CondReplaceInString(AltitudeMode == ALLON, OutBuffer, TEXT("$(AirspaceModeAllShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
  CondReplaceInString(AltitudeMode == CLIP,  OutBuffer, TEXT("$(AirspaceModeClipShortIndicator)"), TEXT("(*)"), TEXT(""), Size);
d5268 24
a5291 1

d5305 1
a5305 1
  CondReplaceInString(EnableFLARMGauge != 0, OutBuffer, TEXT("$(FlarmDispToggleActionName)"), TEXT("Off"), TEXT("On"), Size);
@


8.20
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.19 2009/11/25 16:34:18 root Exp root $
d89 1
d1940 1
d2007 8
a2014 9
  while (/* GlobalRunning && */
         GetMessage(&msg, NULL, 0, 0))
    {
      if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
        {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
        }
    }
d2848 1
a2848 1
// Congratulations for the Most Obfuscated C code contest winner!!!
d3142 5
d3415 1
a4366 1
		//if (sbuf[i]==0x0a) { REMOVE
@


8.19
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.18 2009/11/18 21:48:33 root Exp root $
d2186 5
a2190 2
///: #if defined(PNA) || ((WINDOWSPC>0)&&_REALTHING_&&_SIM_)  091120 choose it everytime 
///: #if defined(PNA) // FIX TEST TODO 090925     TEST 091118
d2195 1
a2195 1
    propGetFontSettingsFromString(TEXT("16,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont); 
d2213 2
a2214 2
    propGetFontSettingsFromString(TEXT("10,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
d2219 1
a2219 1
    propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
d2221 1
a2221 1
    propGetFontSettingsFromString(TEXT("19,0,0,0,700,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
a2279 1
  ///: added and tune 091120
d2281 14
a2294 3
    propGetFontSettingsFromString(TEXT("30,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("11,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,1,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleSmallWindowLogFont);
d2296 1
a2296 1
    propGetFontSettingsFromString(TEXT("11,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // RLD 16 works well too
d2298 2
a2299 2
    propGetFontSettingsFromString(TEXT("18,0,0,0,500,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
d2302 13
@


8.18
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.17 2009/11/09 16:16:07 root Exp root $
d470 4
d664 7
d1167 1
a1167 1
  StartupStore(TEXT(". RestartCommPorts\n"));
d1230 1
a1230 1
#ifdef CPUSTATS
d1232 5
a1236 1
#endif
d1239 1
a1239 1
    Sleep(100);
d1244 34
a1277 34
#ifdef CPUSTATS
    GetThreadTimes( hInstrumentThread, &CreationTime, &ExitTime,&StartKernelTime,&StartUserTime);
#endif
    WaitForSingleObject(varioTriggerEvent, 5000);
    ResetEvent(varioTriggerEvent);
    if (MapWindow::CLOSETHREAD) break; // drop out on exit

    // VNT This thread was eating cpu in landscape mode although vario not used. 
#ifdef LK8000_OPTIMIZE
    if ( (InfoBoxLayout::landscape == true) && ( InfoBoxLayout::InfoBoxGeometry == 6) ) {
       if (VarioUpdated && !InfoBoxLayout::fullscreen) { // VNT 090814 fix 
#else
       if (VarioUpdated) { 
#endif
         VarioUpdated = false;
         if (MapWindow::IsDisplayRunning()) {
           if (EnableVarioGauge) {
             GaugeVario::Render();
           }
         }
       }
#ifdef LK8000_OPTIMIZE
    } else {
	// VNT Not sure this is busy-wait, but normally the thread could even be suspended
	Sleep(1000);
    }
#endif
#ifdef CPUSTATS
    if ( (GetThreadTimes( hInstrumentThread, &CreationTime, &ExitTime,&EndKernelTime,&EndUserTime)) == 0) {
               Cpu_Calc=9999;
    } else {
               Cpustats(&Cpu_Instrument,&StartKernelTime, &EndKernelTime, &StartUserTime, &EndUserTime);
    }
#endif
d1294 2
d1419 3
a1421 1

d1423 1
a1423 1
#ifndef CPUSTATS
d1427 1
a1427 1
#endif
d1430 1
a1430 4
  if ((hCalculationThread =
      CreateThread (NULL, 0,
        (LPTHREAD_START_ROUTINE )CalculationThread,
         0, 0, &dwCalcThreadID)) != NULL)
d1432 5
a1436 5
    SetThreadPriority(hCalculationThread, THREAD_PRIORITY_NORMAL); 
#ifndef CPUSTATS
    ///: Do not close if we need to use the handle 
    CloseHandle (hCalculationThread); 
#endif
d1438 1
a1438 1
    ASSERT(1);
d1441 1
a1441 1
#ifndef CPUSTATS
d1444 1
a1444 1
#endif
d1446 1
a1446 4
  if ((hInstrumentThread =
      CreateThread (NULL, 0,
       (LPTHREAD_START_ROUTINE )InstrumentThread,
        0, 0, &dwInstThreadID)) != NULL)
d1448 4
a1451 4
    SetThreadPriority(hInstrumentThread, THREAD_PRIORITY_NORMAL); 
#ifndef CPUSTATS
    CloseHandle (hInstrumentThread);
#endif
d1453 1
a1453 1
    ASSERT(1);
d1504 1
a1504 1
  StartupStore(TEXT(". CloseProgressDialog\n"));
d1512 1
a1512 1
  StartupStore(TEXT(". GCE_STARTUP_SIMULATOR\n"));
d1515 1
a1515 1
  StartupStore(TEXT(". GCE_STARTUP_REAL\n"));
d1525 1
a1525 1
  StartupStore(TEXT(". Create default task\n"));
d1543 1
a1543 1
  StartupStore(TEXT(". Free ram %d\n. Free storage %d\n"), freeram, freestorage);
d1557 8
d1574 1
d1577 1
d1579 15
a1593 1
  wcscat(XCSoar_Version, TEXT(__DATE__));
d1625 3
a1627 1
RegDeleteKey(HKEY_CURRENT_USER, _T(REGKEYNAME));
d1634 1
a1634 1
	StartupStore(TEXT(". CheckDataDir successful\n"));
d1636 4
a1639 4
	StartupStore(TEXT("++++++ CRITICAL ERROR: NO LK8000 DATA DIRECTORY FOUND!\n"));
	StartupStore(TEXT("++++++ Probably software is running for the first time with no manual installation\n"));
	StartupStore(TEXT("++++++ Fonts will not be available, among many other things. That's bad!\n"));
	StartupStore(TEXT("++++++ Attempting to go ahead, nevertheless...\n"));
d1642 1
a1642 1
  StartupStore(TEXT(". Install/copy system objects in device memory\n"));
d1644 2
a1645 1
  StartupStore(_T(". InstallSystem ended, code=%d\n"),didsystem);
d1663 17
a1679 2
  StartupStore(TEXT(". Starting %s"), XCSoar_Version);
  StartupStore(TEXT(" build#%d\n"),BUILDNUMBER);
d1682 1
a1682 1
  StartupLogFreeRamAndStorage();
d1691 1
a1691 1
  StartupStore(TEXT(". Initialize application instance\n"));
d1715 1
a1715 1
  StartupStore(TEXT(". Initializing critical sections and events\n"));
d1796 1
a1796 1
  StartupStore(TEXT(". GlidePolar::SetBallast\n"));
d1900 1
a1900 1
  StartupStore(TEXT(". RASP load\n"));
d1924 1
a1924 1
  StartupStore(TEXT(". Register serial devices\n"));
d1945 1
a1945 1
  StartupStore(TEXT(". RestartCommPorts\n"));
d1955 1
a1955 1
  StartupStore(TEXT(". GlidePolar::SetBallast\n"));
d1970 1
a1970 1
  StartupStore(TEXT(". CreateDrawingThread\n"));
d1973 1
a1973 1
  StartupStore(TEXT(". ShowInfoBoxes\n"));
d1977 1
a1977 1
  StartupStore(TEXT(". CreateCalculationThread\n"));
d1979 2
a1980 1
  Sleep(500);
d1982 1
a1982 1
  StartupStore(TEXT(". AirspaceWarnListInit\n"));
d1984 1
a1984 1
  StartupStore(TEXT(". dlgAirspaceWarningInit\n"));
d1994 1
a1994 1
  StartupStore(TEXT(". ProgramStarted=1\n"));
d2185 3
a2187 2
#if defined(PNA) // FIX TEST TODO 090925
//#if (1)		// QUI
d2190 2
a2191 2
    propGetFontSettingsFromString(TEXT("28,0,0,0,800,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
d2193 2
a2194 2
    propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // RLD 16 works well too
d2196 4
a2199 2
    propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
d2209 2
a2210 2
    propGetFontSettingsFromString(TEXT("22,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
    propGetFontSettingsFromString(TEXT("18,0,0,0,500,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
d2212 2
a2213 2
    propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont); // RLD 16 works well too
d2215 4
a2218 2
    propGetFontSettingsFromString(TEXT("18,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardMapWindowLogFont);
    propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
d2236 2
a2237 2
            propGetFontSettingsFromString(TEXT("64,0,0,0,600,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardInfoWindowLogFont);
            propGetFontSettingsFromString(TEXT("26,0,0,0,600,0,0,0,0,0,0,3,2,Tahoma"), ptrhardTitleWindowLogFont);
d2256 2
a2257 2
    propGetFontSettingsFromString(TEXT("36,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("28,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont);
d2264 25
d2290 2
a2291 1
/* VENTA5 TEST automatic fallback for 320x240,640x480 and unusual resolutions
d2298 3
a2300 3
    propGetFontSettingsFromString(TEXT("28,0,0,0,400,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardCDIWindowLogFont);
    propGetFontSettingsFromString(TEXT("14,0,0,0,100,1,0,0,0,0,0,3,2,Tahoma"), ptrhardMapLabelLogFont);
    propGetFontSettingsFromString(TEXT("20,0,0,0,400,0,0,0,0,0,0,3,2,Tahoma"), ptrhardStatisticsLogFont);
d2302 1
a2302 1
    propGetFontSettingsFromString(TEXT("16,0,0,0,500,0,0,0,0,0,0,3,2,TahomaBD"), ptrhardMapWindowBoldLogFont);
d2317 1
a2317 15
#endif //PNA

#if defined(GNAV) || defined(PCGNAV) || defined(GNAV_FONTEST)  // RLD Altair also loads these in registry and by default, uses the registry
   propGetFontSettingsFromString(TEXT("24,0,0,0,700,0,0,0,0,0,0,3,2,RasterGothicTwentyFourCond"), ptrhardInfoWindowLogFont);
   propGetFontSettingsFromString(TEXT("10,0,0,0,500,0,0,0,0,0,0,3,2,RasterGothicNineCond"), ptrhardTitleWindowLogFont);
   propGetFontSettingsFromString(TEXT("19,0,0,0,700,0,0,0,0,0,0,3,2,RasterGothicEighteenCond"), ptrhardCDIWindowLogFont);
   propGetFontSettingsFromString(TEXT("13,0,0,0,500,0,0,0,0,0,0,3,2,RasterGothicTwelveCond"), ptrhardMapLabelLogFont);
   propGetFontSettingsFromString(TEXT("15,0,0,0,500,0,0,0,0,0,0,3,2,RasterGothicFourteenCond"), ptrhardStatisticsLogFont);
   propGetFontSettingsFromString(TEXT("15,0,0,0,500,0,0,0,0,0,0,3,2,RasterGothicFourteenCond"), ptrhardMapWindowLogFont);
   propGetFontSettingsFromString(TEXT("15,0,0,0,700,0,0,0,0,0,0,3,2,RasterGothicFourteenCond"), ptrhardMapWindowBoldLogFont);
   propGetFontSettingsFromString(TEXT("19,0,0,0,700,0,0,0,0,0,0,3,2,RasterGothicEighteenCond"), ptrhardTitleSmallWindowLogFont);

#endif //Altair


a2344 1
  // VENTA TODO : reconsider all algorithms for unconventional screen resolutions, expecially wide screens where 1.66 and 2.03 multipliers apply
d2371 2
a2372 1
#if defined(PNA) //FIX 090925 QUI
d2374 1
a2374 1
	_tcscpy(logfont.lfFaceName, _T("Tahoma")); // VENTA TODO copy DejaVu fonts also for PNA like for PDAs in SD version
d2423 2
a2424 1
#if (WINDOWSPC>0)
d2691 3
d2727 3
a2729 2
  Sleep(2000); // 091109 delay for letting InstallSystem perform actions
  StartupStore(TEXT(". Create main window\n"));
d2767 1
a2767 1
  StartupStore(TEXT(". InfoBox geometry\n"));
d2773 1
a2773 1
  StartupStore(TEXT(". Load unit bitmaps\n"));
d2777 1
a2777 1
  StartupStore(TEXT(". Create info boxes\n"));
d2781 1
a2781 1
  StartupStore(TEXT(". Create FLARM gauge\n"));
d2784 1
a2784 1
  StartupStore(TEXT(". Create button labels\n"));
d2789 1
a2789 1
  StartupStore(TEXT(". Initialise fonts\n"));
d2794 1
a2794 1
  StartupStore(TEXT(". Initialise message system\n"));
d2802 1
a2802 1
  StartupStore(TEXT(". Create map window\n"));
d2812 1
a2812 1

d2925 1
a2925 1
  StartupStore(TEXT(". Entering shutdown...\n"));
d2931 1
a2931 1
  StartupStore(TEXT(". dlgAirspaceWarningDeInit\n"));
d2933 1
a2933 1
  StartupStore(TEXT(". AirspaceWarnListDeInit\n"));
d2944 1
a2944 1
  StartupStore(TEXT(". Save_Recent_WP_history\n"));
d2948 1
a2948 1
  StartupStore(TEXT(". SaveSoundSettings\n"));
d2964 1
a2964 1
  StartupStore(TEXT(". CloseDrawingThread\n"));
d2975 1
a2975 1
  StartupStore(TEXT(". Save default task\n"));
d2981 1
a2981 1
  StartupStore(TEXT(". Clear task data\n"));
d2992 1
a2992 1
  StartupStore(TEXT(". CloseTerrainTopology\n"));
d3004 1
a3004 1
  StartupStore(TEXT(". Stop COM devices\n"));
d3007 1
a3007 1
  SaveCalculationsPersist(&CALCULATED_INFO);
d3013 1
a3013 1
    StartupStore(TEXT(". Altair shutdown\n"));
d3028 1
a3028 1
  StartupStore(TEXT(". Close Gauges\n"));
d3034 1
a3034 1
  StartupStore(TEXT(". Close Messages\n"));
d3039 1
a3039 1
  StartupStore(TEXT(". Destroy Info Boxes\n"));
d3042 1
a3042 1
  StartupStore(TEXT(". Destroy Button Labels\n"));
d3045 1
a3045 1
  StartupStore(TEXT(". Delete Objects\n"));
d3072 1
a3072 1
  StartupStore(TEXT(". Delete Critical Sections\n"));
d3089 1
a3089 1
  StartupStore(TEXT(". Close Progress Dialog\n"));
d3093 1
a3093 1
  StartupStore(TEXT(". Close Calculations\n"));
d3098 1
a3098 1
  StartupStore(TEXT(". Close Windows\n"));
d3102 1
a3102 1
  StartupStore(TEXT(". Close Event Handles\n"));
d3108 1
a3108 1
  StartupStore(TEXT(".. Writing missing translations\n"));
d3113 1
a3113 1
  StartupStore(TEXT(". Finished shutdown\n"));
d3120 1
a3120 1
  _stprintf(foop,TEXT(". Sizes %d %d %d\n"),
d3123 1
a3123 1
	    ((long)&wpr->Target)-((long)wpr)
d3271 1
a3271 1
          StartupStore(TEXT(". ProgramStarted=3\n"));
d4306 1
a4306 1
  TCHAR buf[MAX_PATH];
d4314 1
a4314 1
    LockFlightData();
d4320 6
a4325 6
    LocalPath(szFileName, TEXT(LKF_RUNLOG));
    startupStoreFile = _tfopen(szFileName, TEXT("wb"));
    if (startupStoreFile) {
      fclose(startupStoreFile);
    }
    initialised = true;
d4329 15
a4343 2
    fprintf(startupStoreFile, "%S", buf);
    fclose(startupStoreFile);
d4346 1
a4346 1
    UnlockFlightData();
d4597 1
a4597 1
          StartupStore(TEXT("........ Battery low exit...\n"));
d4962 1
a4962 1
		      TEXT("Resume"), TEXT("Abort"), Size);
@


8.17
log
@pre1.17
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.16 2009/10/31 22:58:33 root Exp root $
d457 13
d1558 4
a1561 1
///: 091109 TESTFIX DELETE REGISTRY FOR ALL PLATFORMS EXCEPT PC
d1563 1
a1563 1
//#ifndef PNA  091109
a1564 1
//#endif
d1566 2
d1585 6
d1767 1
a1767 1
	CreateProgressDialog(sTmp); Sleep(2000);
d1773 1
a1773 1
	CreateProgressDialog(sTmp); Sleep(2000);
d1775 1
d1778 1
a1778 1
    CreateProgressDialog(TEXT("NEW FONTS INSTALLED!")); Sleep(3000);
d1784 1
d1794 1
a1794 1
  CreateProgressDialog(sTmpB); Sleep(3000);
d1797 1
a1804 1
#ifndef WINDOWSPC
d1806 1
a1806 1
	CreateProgressDialog(TEXT("PARAGLIDING MODE")); Sleep(1000);
d1809 1
a1809 2
        CreateProgressDialog(TEXT("SIMULATION")); Sleep(1000);
#endif
d1818 1
a1818 1
  Sleep(1500);
d1825 1
a1825 1
  Sleep(1500);
d2612 1
d2624 4
a2627 3
#ifdef PNA
	CleanRegistry(); // VENTA2-FIX for PNA we can't delete all registries..by now
#endif
d2650 1
@


8.16
log
@1.15b
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.15 2009/10/19 22:31:13 root Exp root $
d40 1
d359 5
d401 1
d452 2
d455 2
d585 1
a585 1
bool CircleZoom = false;
d587 2
a588 2
bool EnableTopology = false;
bool EnableTerrain = false;
d853 1
a853 1
	  {ugNone,            TEXT("Ext.Batt.Bank"), TEXT("xBat#"), new InfoBoxFormatter(TEXT("%1.0f")), NoProcessing, 38, 5},
d1143 1
a1143 1
  StartupStore(TEXT("RestartCommPorts\n"));
d1478 1
a1478 1
  StartupStore(TEXT("CloseProgressDialog\n"));
d1486 1
a1486 1
  StartupStore(TEXT("GCE_STARTUP_SIMULATOR\n"));
d1489 1
a1489 1
  StartupStore(TEXT("GCE_STARTUP_REAL\n"));
d1499 1
a1499 1
  StartupStore(TEXT("Create default task\n"));
d1517 1
a1517 1
  StartupStore(TEXT("Free ram %d\nFree storage %d\n"), freeram, freestorage);
d1545 1
a1545 1
// VENTA2- delete registries at startup, but not on PC!
d1547 1
a1547 1
#ifndef PNA
d1549 1
a1549 1
#endif
a1567 1
// VENTA2-ADDON install fonts on PDAs and check XCSoarData existance
a1568 1
//#ifndef PNA
d1570 13
a1582 9
bool datadir=CheckDataDir(); // VENTA3 changed to bool
if (datadir) StartupStore(TEXT("XCSoarData directory found.\n"));
else StartupStore(TEXT("ERROR: NO XCSOARDATA DIRECTORY FOUND!\n"));

StartupStore(TEXT("Check for installing fonts\n"));
short didfonts=InstallFonts();  // check if really did it, and maybe restart
TCHAR nTmp[100];
_stprintf(nTmp,TEXT("InstallFonts() result=%d (0=installed >0 not installed)\n"), didfonts);
StartupStore(nTmp);
a1583 1
//#endif
a1586 1
// VENTA2- TODO fix these directories are not used always!
a1587 1
  CreateDirectoryIfAbsent(TEXT("persist"));
d1589 10
a1598 1
  CreateDirectoryIfAbsent(TEXT("config"));
d1600 2
a1601 1
  StartupStore(TEXT("Starting XCSoar %s\n"), XCSoar_Version);
d1613 1
a1613 1
  StartupStore(TEXT("Initialise application instance\n"));
d1637 1
a1637 1
  StartupStore(TEXT("Initialising critical sections and events\n"));
d1718 1
a1718 1
  StartupStore(TEXT("GlidePolar::SetBallast\n"));
d1744 1
a1744 1
	CreateProgressDialog(sTmp); Sleep(3000);
d1750 1
a1750 1
	CreateProgressDialog(sTmp); Sleep(3000);
d1753 1
a1753 1
  if ( didfonts == 0 ) {
d1756 2
a1757 2
    if ( didfonts == 5 ) {
      CreateProgressDialog(TEXT("ERROR NO FONTS!")); Sleep(3000);
d1778 2
d1781 1
a1781 1
	CreateProgressDialog(TEXT("PARAGLIDING MODE")); Sleep(2000);
d1784 2
a1785 1
        CreateProgressDialog(TEXT("SIMULATION")); Sleep(2000);
d1794 1
a1794 1
  Sleep(3000);
d1801 1
a1801 1
  Sleep(3000);
d1806 2
a1813 5
/*
  for (int i=0; i< NumberOfWayPoints; i++) WayPointList[i].Preferred = false;
*/


d1821 1
a1821 1
  StartupStore(TEXT("RASP load\n"));
d1845 1
a1845 1
  StartupStore(TEXT("Register serial devices\n"));
d1866 1
a1866 1
  StartupStore(TEXT("RestartCommPorts\n"));
d1876 1
a1876 1
  StartupStore(TEXT("GlidePolar::SetBallast\n"));
d1891 1
a1891 1
  StartupStore(TEXT("CreateDrawingThread\n"));
d1894 1
a1894 1
  StartupStore(TEXT("ShowInfoBoxes\n"));
d1898 1
a1898 1
  StartupStore(TEXT("CreateCalculationThread\n"));
d1902 1
a1902 1
  StartupStore(TEXT("AirspaceWarnListInit\n"));
d1904 1
a1904 1
  StartupStore(TEXT("dlgAirspaceWarningInit\n"));
d1914 1
a1914 1
  StartupStore(TEXT("ProgramStarted=1\n"));
d2624 1
a2624 1
  StartupStore(TEXT("Create main window\n"));
d2662 1
a2662 1
  StartupStore(TEXT("InfoBox geometry\n"));
d2668 1
a2668 1
  StartupStore(TEXT("Load unit bitmaps\n"));
d2672 1
a2672 1
  StartupStore(TEXT("Create info boxes\n"));
d2676 1
a2676 1
  StartupStore(TEXT("Create FLARM gauge\n"));
d2679 1
a2679 1
  StartupStore(TEXT("Create button labels\n"));
d2684 1
a2684 1
  StartupStore(TEXT("Initialise fonts\n"));
d2689 1
a2689 1
  StartupStore(TEXT("Initialise message system\n"));
d2697 1
a2697 1
  StartupStore(TEXT("Create map window\n"));
d2820 1
a2820 1
  StartupStore(TEXT("Entering shutdown...\n"));
d2826 1
a2826 1
  StartupStore(TEXT("dlgAirspaceWarningDeInit\n"));
d2828 1
a2828 1
  StartupStore(TEXT("AirspaceWarnListDeInit\n"));
d2839 1
a2839 1
  StartupStore(TEXT("Save_Recent_WP_history\n"));
d2843 1
a2843 1
  StartupStore(TEXT("SaveSoundSettings\n"));
d2859 1
a2859 1
  StartupStore(TEXT("CloseDrawingThread\n"));
d2870 1
a2870 1
  StartupStore(TEXT("Save default task\n"));
d2876 1
a2876 1
  StartupStore(TEXT("Clear task data\n"));
d2887 1
a2887 1
  StartupStore(TEXT("CloseTerrainTopology\n"));
d2899 1
a2899 1
  StartupStore(TEXT("Stop COM devices\n"));
d2908 1
a2908 1
    StartupStore(TEXT("Altair shutdown\n"));
d2923 1
a2923 1
  StartupStore(TEXT("Close Gauges\n"));
d2929 1
a2929 1
  StartupStore(TEXT("Close Messages\n"));
d2934 1
a2934 1
  StartupStore(TEXT("Destroy Info Boxes\n"));
d2937 1
a2937 1
  StartupStore(TEXT("Destroy Button Labels\n"));
d2940 1
a2940 1
  StartupStore(TEXT("Delete Objects\n"));
d2967 1
a2967 1
  StartupStore(TEXT("Delete Critical Sections\n"));
d2984 1
a2984 1
  StartupStore(TEXT("Close Progress Dialog\n"));
d2988 1
a2988 1
  StartupStore(TEXT("Close Calculations\n"));
d2993 1
a2993 1
  StartupStore(TEXT("Close Windows\n"));
d2997 1
a2997 1
  StartupStore(TEXT("Close Event Handles\n"));
d3003 1
a3003 1
  StartupStore(TEXT("Writing missing translations\n"));
d3008 1
a3008 1
  StartupStore(TEXT("Finished shutdown\n"));
d3015 1
a3015 1
  _stprintf(foop,TEXT("Sizes %d %d %d\n"),
d3166 1
a3166 1
          StartupStore(TEXT("ProgramStarted=3\n"));
d3193 1
a3193 1
                      gettext(TEXT("XCSoar")),
d4479 1
a4479 1
          StartupStore(TEXT("Battery low exit...\n"));
d4490 1
a4490 1
              DoStatusMessage(TEXT("Organiser Battery Low"));
@


8.15
log
@1.14b
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.14 2009/10/12 13:25:02 root Exp root $
a406 1
#ifdef FIVV
d408 1
a408 1
#endif
d423 1
a423 1
short Look8000=0;
d426 1
a426 1
bool NewMap=false;
d841 10
a850 4
	  // 80 // 
	  {ugNone,   TEXT("_OLD Experimental1"), TEXT("Exp1"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 8, 2},
	  // 81 // 
	  {ugNone,   TEXT("_OLD Experimental2"), TEXT("Exp2"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 8, 2},
d853 1
a853 1
const int NUMSELECTSTRINGS = 82; 
d1124 1
a1124 1
  /*
d1131 1
a1131 1
  */
d1313 19
a1331 18
          case dmCircling:
            DisplayMode = dmCircling;
          break;
          case dmCruise:
            DisplayMode = dmCruise;
          break;
          case dmFinalGlide:
            DisplayMode = dmFinalGlide;
          break;
          case dmNone:
            if (tmp_CALCULATED_INFO.Circling){
              DisplayMode = dmCircling;
            } else if (tmp_CALCULATED_INFO.FinalGlide){
              DisplayMode = dmFinalGlide;
            } else
              DisplayMode = dmCruise;
          break;
        }
d1334 1
a1334 1
          MapWindow::SwitchZoomClimb();
a1714 4
#ifdef CREDITS_FIVV
CreateProgressDialog(gettext(TEXT("Special ITA version")));
 Sleep(1000);
#endif
d1849 2
d3944 3
a3946 3
#if (WINDOWSPC<1)
#ifndef GNAV

a3947 1
	  
a3948 1
	  
a3950 1
#endif
@


8.14
log
@1.12b
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.13 2009/09/25 00:10:26 root Exp root $
d212 1
a212 1
int numInfoWindows = 8;
d239 1
d488 2
a489 1
short AltArrivMode=ALTA_SMC;
d823 1
a823 1
	  {ugAltitude,        TEXT("QFE"), TEXT("QFE"), new InfoBoxFormatter(TEXT("%2.0f")), QFEAltitudeProcessing, 1, 33},
@


8.13
log
@tpt
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.12 2009/09/21 12:16:42 root Exp root $
d311 1
d361 3
a363 3
double SAFETYALTITUDEARRIVAL = 500;
double SAFETYALTITUDEBREAKOFF = 700;
double SAFETYALTITUDETERRAIN = 200;
d409 2
d483 1
a483 1
//short SortedMode[MAXNUMPAGES]; BUG!
d486 2
a487 1
char  spaziovuoto[300];
d631 1
a631 1
BOOL InfoBoxesHidden = false; // VENTA FIX QUI false
d660 1
a660 1
	  {ugAltitude,        TEXT("Height GPS"), TEXT("H GPS"), new InfoBoxFormatter(TEXT("%2.0f")), AltitudeProcessing, 1, 33},
d662 1
a662 1
	  {ugAltitude,        TEXT("Height AGL"), TEXT("H AGL"), new FormatterLowWarning(TEXT("%2.0f"),0.0), NoProcessing, 20, 0},
d664 1
a664 1
	  {ugVerticalSpeed,   TEXT("Thermal last 30 sec"), TEXT("TC 30s"), new FormatterLowWarning(TEXT("%-2.1f"),0.0), NoProcessing, 7, 44},
d667 1
a667 1
	  {ugNone,            TEXT("Bearing"), TEXT("Bearing"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)), NoProcessing, 6, 54},
d669 1
a669 1
	  {ugNone,            TEXT("Bearing"), TEXT("Bearing"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)TEXT("T")), NoProcessing, 6, 54},
d672 1
a672 1
	  {ugNone,            TEXT("L/D instantaneous"), TEXT("L/D Inst"), new InfoBoxFormatter(TEXT("%2.0f")), PopupBugsBallast, 5, 38},
d674 1
a674 1
	  {ugNone,            TEXT("L/D cruise"), TEXT("L/D Cru"), new InfoBoxFormatter(TEXT("%2.0f")), PopupBugsBallast, 19, 4},
d676 1
a676 1
	  {ugHorizontalSpeed, TEXT("Speed ground"), TEXT("V Gnd"), new InfoBoxFormatter(TEXT("%2.0f")), SpeedProcessing, 23, 3},
d678 1
a678 1
	  {ugVerticalSpeed,   TEXT("Last Thermal Average"), TEXT("TL Avg"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 8, 2},
d680 1
a680 1
	  {ugAltitude,        TEXT("Last Thermal Gain"), TEXT("TL Gain"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 9, 7},
d682 1
a682 1
	  {ugNone,            TEXT("Last Thermal Time"), TEXT("TL Time"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 21, 8},
d684 1
a684 1
	  {ugVerticalSpeed,   TEXT("MacCready Setting"), TEXT("MacCready"), new InfoBoxFormatter(TEXT("%2.1f")), MacCreadyProcessing, 34, 43},
d686 1
a686 1
	  {ugDistance,        TEXT("Next Distance"), TEXT("WP Dist"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 12, 31},
d688 1
a688 1
	  {ugAltitude,        TEXT("Next Altitude Difference"), TEXT("WP AltD"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 13, 11},
d690 1
a690 1
	  {ugAltitude,        TEXT("Next Altitude Required"), TEXT("WP AltR"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 15, 12},
d694 1
a694 1
	  {ugAltitude,        TEXT("Final Altitude Difference"), TEXT("Fin AltD"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 16, 13},
d696 1
a696 1
	  {ugAltitude,        TEXT("Final Altitude Required"), TEXT("Fin AltR"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 17, 15},
d698 1
a698 1
	  {ugTaskSpeed, TEXT("Speed Task Average"), TEXT("V Task Av"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
d700 3
a702 3
	  {ugDistance,        TEXT("Final Distance"), TEXT("Fin Dis"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 27, 17},
	  // 19
	  {ugNone,            TEXT("Final LD"), TEXT("Fin LD"), new InfoBoxFormatter(TEXT("%1.0f")), NoProcessing, 38, 5},
d704 1
a704 1
	  {ugAltitude,        TEXT("Terrain Elevation"), TEXT("H Gnd"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 33, 1},
d706 1
a706 1
	  {ugVerticalSpeed,   TEXT("Thermal Average"), TEXT("TC Avg"), new FormatterLowWarning(TEXT("%-2.1f"),0.0), NoProcessing, 22, 9},
d708 1
a708 1
	  {ugAltitude,        TEXT("Thermal Gain"), TEXT("TC Gain"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 24, 21},
d718 1
a718 1
	  {ugWindSpeed,       TEXT("Wind Speed"), TEXT("Wind V"), new InfoBoxFormatter(TEXT("%2.0f")), WindSpeedProcessing, 26, 50},
d721 1
a721 1
	  {ugNone,            TEXT("Wind Bearing"), TEXT("Wind B"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)), WindDirectionProcessing, 48, 25},
d723 1
a723 1
	  {ugNone,            TEXT("Wind Bearing"), TEXT("Wind B"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)TEXT("T")), WindDirectionProcessing, 48, 25},
d726 1
a726 1
	  {ugNone,            TEXT("AA Time"), TEXT("AA Time"), new FormatterAATTime(TEXT("%2.0f")), NoProcessing, 28, 18},
d728 1
a728 1
	  {ugDistance,        TEXT("AA Distance Max"), TEXT("AA Dmax"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 29, 27},
d730 1
a730 1
	  {ugDistance,        TEXT("AA Distance Min"), TEXT("AA Dmin"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 30, 28},
d732 1
a732 1
	  {ugTaskSpeed, TEXT("AA Speed Max"), TEXT("AA Vmax"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 31, 29},
d734 1
a734 1
	  {ugTaskSpeed, TEXT("AA Speed Min"), TEXT("AA Vmin"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 51, 30},
d736 1
a736 1
	  {ugHorizontalSpeed, TEXT("Airspeed IAS"), TEXT("V IAS"), new InfoBoxFormatter(TEXT("%2.0f")), AirspeedProcessing, 37, 23},
d738 1
a738 1
	  {ugAltitude,        TEXT("Pressure Altitude"), TEXT("H Baro"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 0, 20},
d740 1
a740 1
	  {ugHorizontalSpeed, TEXT("Speed MacReady"), TEXT("V Mc"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 35, 10},
d742 1
a742 1
	  {ugNone,            TEXT("Percentage climb"), TEXT("% Climb"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 43, 34},
d744 1
a744 1
	  {ugNone,            TEXT("Time of flight"), TEXT("Time flt"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 39, 14},
d748 1
a748 1
	  {ugNone,            TEXT("Next LD"), TEXT("WP LD"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 53, 19},
d750 1
a750 1
	  {ugNone,            TEXT("Time local"), TEXT("Time loc"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 40, 36},
d752 1
a752 1
	  {ugNone,            TEXT("Time UTC"), TEXT("Time UTC"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 41, 39},
d754 1
a754 1
	  {ugNone,            TEXT("Task Time To Go"), TEXT("Fin ETE"), new FormatterAATTime(TEXT("%04.0f")), NoProcessing, 42, 40},
d756 1
a756 1
	  {ugNone,            TEXT("Next Time To Go"), TEXT("WP ETE"), new FormatterAATTime(TEXT("%04.0f")), NoProcessing, 45, 41},
d758 1
a758 1
	  {ugHorizontalSpeed, TEXT("Speed Dolphin"), TEXT("V Opt"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 10, 35},
d762 1
a762 1
	  {ugNone,            TEXT("Task Arrival Time"), TEXT("Fin ETA"), new FormatterAATTime(TEXT("%04.0f")), NoProcessing, 46, 42},
d764 1
a764 1
	  {ugNone,            TEXT("Next Arrival Time"), TEXT("WP ETA"), new FormatterTime(TEXT("%04.0f")), NoProcessing, 14, 45},
d766 1
a766 1
	  {ugNone,            TEXT("Bearing Difference"), TEXT("Brng D"), new FormatterDiffBearing(TEXT("")), NoProcessing, 54, 37},
d774 1
a774 1
	  {ugDistance,        TEXT("AA Distance Tgt"), TEXT("AA Dtgt"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 52, 31},
d776 1
a776 1
	  {ugTaskSpeed, TEXT("AA Speed Tgt"), TEXT("AA Vtgt"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 11, 51},
d780 1
a780 1
	  {ugHorizontalSpeed, TEXT("Airspeed TAS"), TEXT("V TAS"), new InfoBoxFormatter(TEXT("%2.0f")), AirspeedProcessing, 3, 47},
d785 1
a785 1
	  {ugNone,            TEXT("Team Bearing"), TEXT("Tm Brng"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)), NoProcessing, 57, 55},
d787 1
a787 1
	  {ugNone,            TEXT("Team Bearing"), TEXT("Tm Brng"), new InfoBoxFormatter(TEXT("%2.0f")TEXT(DEG)TEXT("T")), NoProcessing, 57, 55},
d790 1
a790 1
	  {ugNone,            TEXT("Team Bearing Diff"), TEXT("Team Bd"), new FormatterDiffTeamBearing(TEXT("")), NoProcessing, 58, 56},	  
d792 1
a792 1
	  {ugNone,            TEXT("Team Range"), TEXT("Team Dis"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 55, 57},
d794 1
a794 1
	  {ugTaskSpeed, TEXT("Speed Task Instantaneous"), TEXT("V Tsk Ins"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
d796 1
a796 1
	  {ugDistance, TEXT("Home Distance"), TEXT("Home Dis"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
d798 1
a798 1
	  {ugTaskSpeed, TEXT("Speed Task Achieved"), TEXT("V Tsk Ach"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
d800 1
a800 1
	  {ugNone,            TEXT("AA Delta Time"), TEXT("AA dT"), new FormatterAATTime(TEXT("%2.0f")), NoProcessing, 28, 18},
d802 1
a802 1
	  {ugVerticalSpeed,   TEXT("Thermal All"), TEXT("TC All"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 8, 2},
d804 1
a804 1
	  {ugVerticalSpeed,   TEXT("Distance Vario"), TEXT("D Vario"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 8, 2},
d809 1
a809 1
	  {ugNone,            TEXT("Battery Voltage"), TEXT("Battery"), new InfoBoxFormatter(TEXT("%2.1fV")), NoProcessing, 49, 26},
d812 1
a812 1
	  {ugNone,            TEXT("Final GR"), TEXT("Fin GR"), new InfoBoxFormatter(TEXT("%1.1f")), NoProcessing, 38, 5},
d815 1
a815 1
	  {ugNone,            TEXT("Alternate1 GR"), TEXT("Alt1.GR"), new FormatterAlternate(TEXT("\0")), Alternate1Processing, 36, 46},
d817 1
a817 1
	  {ugNone,            TEXT("Alternate2 GR"), TEXT("Alt2.GR"), new FormatterAlternate(TEXT("\0")), Alternate2Processing, 36, 46},
d819 1
a819 1
	  {ugNone,            TEXT("Best Alternate"), TEXT("BAlt.GR"), new FormatterAlternate(TEXT("\0")), BestAlternateProcessing, 36, 46},
d821 1
a821 1
	  {ugAltitude,        TEXT("QFE GPS"), TEXT("QFE GPS"), new InfoBoxFormatter(TEXT("%2.0f")), QFEAltitudeProcessing, 1, 33},
d823 1
a823 3
	  {ugNone,            TEXT("L/D Average"), TEXT("L/D Avg"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 19, 4},


d825 1
a825 1
	  {ugNone,            TEXT("Next GR"), TEXT("WP GR"), new InfoBoxFormatter(TEXT("%1.1f")), NoProcessing, 38, 5},
d829 1
a829 1
	  {ugDistance,            TEXT("Task Dist Covered"), TEXT("DistCov"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 38, 5},
d831 1
a831 1
	  {ugAltitude,            TEXT("Alternate1 Arriv.Diff"), TEXT("Alt1.Dif"), new FormatterAlternate(TEXT("%2.0f")), Alternate1Processing, 36, 46},
d833 1
a833 1
	  {ugAltitude,            TEXT("Alternate2 Arriv.Diff"), TEXT("Alt2.Dif"), new FormatterAlternate(TEXT("%2.0f")), Alternate2Processing, 36, 46},
d835 1
a835 1
	  {ugAltitude,            TEXT("BestAlternate Arriv.Diff"), TEXT("BAlt.Dif"), new FormatterAlternate(TEXT("%2.0f")), BestAlternateProcessing, 36, 46},
d837 1
a837 1
	  {ugNone,            TEXT("Home Radial"), TEXT("Home Rad"), new InfoBoxFormatter(TEXT("%.0f")TEXT(DEG)), NoProcessing, 6, 54},
d841 1
a841 1
	  {ugNone,   TEXT("Experimental1"), TEXT("Exp1"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 8, 2},
d843 1
a843 1
	  {ugNone,   TEXT("Experimental2"), TEXT("Exp2"), new InfoBoxFormatter(TEXT("%2.1f")), NoProcessing, 8, 2},
a844 1

d1512 2
a1513 12
#ifdef GNAV
#ifdef FORCEPORTRAIT
  // JMW testing only for portrait mode of Altair
  RotateScreen();
#endif
#endif

  // Version String
#ifdef GNAV
  wcscat(XCSoar_Version, TEXT("Altair "));
#elif PNA  // VENTA-ADDON
wcscat(XCSoar_Version, TEXT("PNA "));
d1516 1
a1516 1
  wcscat(XCSoar_Version, TEXT("PC "));
d1518 1
a1518 2
  wcscat(XCSoar_Version, TEXT("PPC "));
  // TODO code: consider adding PPC, 2002, 2003 (not enough room now)
d1522 1
a1522 11
///: versioning:
///: a9a a9z  alfa versions 9
///: b9a b9z  beta versions 9
///: LK8000-9.0  9.1 9.2   release versions and updates (no new features)
#ifdef FIVV
  wcscat(XCSoar_Version, TEXT("LK8000-a10e "));
#elif defined(__MINGW32__)
  wcscat(XCSoar_Version, TEXT("LK8000-a10e"));
#else
  wcscat(XCSoar_Version, TEXT("LK8000-a10e "));
#endif
d1570 1
a1570 1
  CreateDirectoryIfAbsent(TEXT("logs")); // VENTA3 we use this one for logging 
d1960 1
d2079 2
a2080 1
#if defined(PNA)  // VENTA4
d2249 2
a2250 1
#if defined(PNA)
d3697 1
a3697 1
			Units::FormatUserArrival(WayPointCalc[ActiveAlternate].AltArriv,
d4159 1
a4159 1
  TCHAR szFileName[] = TEXT("xcsoar-debug.log");
d4192 1
a4192 5
#ifdef GNAV
    LocalPath(szFileName, TEXT("persist/xcsoar-startup.log"));
#else
    LocalPath(szFileName, TEXT("xcsoar-startup.log"));
#endif
a4313 1
	// return; // VENTA FIX QUI remove return
@


8.12
log
@precleaning
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.11 2009/09/07 19:08:43 root Exp root $
d274 2
d473 1
d477 1
d489 1
d493 1
d502 2
d506 2
a507 1
///: +1 is for safety...
d510 2
a511 1
///: Real number of items contained in array after removing duplicates, or not enough to fill MAXNEAREST
d513 2
d994 1
d997 1
d1001 1
a2096 31
// VENTA2-ADDON  different infobox fonts for different geometries on HP31X.
// VENTA2-ADDON	 different ELLIPSE values for different geometries!
// RLD this loads the elipses each time and handles the fonts with the new font system
// VENTA4  ok but should apply only for PNAs, not for PC and PDAs..  For PDA there was a font registry problem,
//         but RLD fontsystem should have fixed it once forever.
// 
//#if defined(PNA) || defined(FIVV)

/* REMOVE QUI  
  //int iWidth=GetSystemMetrics(SM_CXSCREEN);
  //int iHeight=GetSystemMetrics(SM_CYSCREEN);

  int iWidth=rc.right-rc.left;
  int iHeight=rc.bottom-rc.top;

  if (iWidth == 240 && iHeight == 320) ScreenSize=(ScreenSize_t)ss240x320; // QVGA	portrait
  if (iWidth == 480 && iHeight == 640) ScreenSize=(ScreenSize_t)ss480x640; //  VGA
  if (iWidth == 480 && iHeight == 800) ScreenSize=(ScreenSize_t)ss480x800; 

  if (iWidth == 480 && iHeight == 272) ScreenSize=(ScreenSize_t)ss480x272; // WQVGA	landscape
  if (iWidth == 320 && iHeight == 240) ScreenSize=(ScreenSize_t)ss320x240; //  QVGA
  if (iWidth == 480 && iHeight == 234) ScreenSize=(ScreenSize_t)ss480x234; //   iGo 
  if (iWidth == 640 && iHeight == 480) ScreenSize=(ScreenSize_t)ss640x480; //   VGA
  if (iWidth == 800 && iHeight == 480) ScreenSize=(ScreenSize_t)ss800x480; //  WVGA

  TCHAR tbuf[80];
  if (ScreenSize==0) {
	wsprintf(tbuf,_T("--- ERROR UNKNOWN RESOLUTION %dx%d !\r\n"),iWidth,iHeight);
	StartupStore(tbuf);
  }
*/
@


8.11
log
@ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.10 2009/07/30 13:38:31 root Exp root $
d431 1
a431 1
short BottomMode=1; // init to cruise mode
d438 2
a439 1

d524 6
d780 1
a780 1
	  {ugDistance, TEXT("Distance Home"), TEXT("Home Dis"), new InfoBoxFormatter(TEXT("%2.0f")), NoProcessing, 18, 16},
d795 1
a795 2
	  // 66  VENTA-ADDON added Final GR
	  // VENTA-TODO: fix those 38,5 numbers to point correctly menu items
d798 2
a799 2
	  // 67 VENTA3-ADDON Alternate1 destinations infoboxes  TODO> fix 36 46 to something correct
	  {ugNone,            TEXT("Alternate1 GR"), TEXT("Altern 1"), new FormatterAlternate(TEXT("\0")), Alternate1Processing, 36, 46},
d801 3
a803 3
	  {ugNone,            TEXT("Alternate2 GR"), TEXT("Altern 2"), new FormatterAlternate(TEXT("\0")), Alternate2Processing, 36, 46},
	  // 69 BestAlternate aka BestLanding
	  {ugNone,            TEXT("Best Alternate"), TEXT("BestAltr"), new FormatterAlternate(TEXT("\0")), BestAlternateProcessing, 36, 46},
d806 1
a806 1
          // 71 TODO FIX those 19,4 values
d808 22
a829 4
	  // 72 // 
	  {ugNone,   TEXT("Experimental1"), TEXT("Exp1"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 8, 2},
	  // 73 // 
	  {ugNone,   TEXT("Experimental2"), TEXT("Exp2"), new InfoBoxFormatter(TEXT("%-2.1f")), NoProcessing, 8, 2},
d832 2
a833 1
const int NUMSELECTSTRINGS = 74; 
d1522 1
a1522 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9j "));
d1524 1
a1524 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9j "));
d1526 1
a1526 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9j "));
d2723 1
d3388 51
a3438 2
	if (DisplayType[i]==67) ActiveAlternate=Alternate1; else
	if (DisplayType[i]==68) ActiveAlternate=Alternate2; 
d3449 5
a3453 5
		if ( DisplayType[i]==67 ) 
			InfoBoxes[i]->SetTitle(TEXT("Altern1"));
		else if ( DisplayType[i]==68 ) 
			InfoBoxes[i]->SetTitle(TEXT("Altern2"));
		else	InfoBoxes[i]->SetTitle(TEXT("BestAltr"));
d3461 1
d3532 5
d3735 24
@


8.10
log
@9i
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.9 2009/07/24 14:32:05 root Exp root $
d40 1
d205 7
d284 3
d439 2
d445 1
d447 3
a449 1
///: current mapspacemode
d451 11
d463 1
a463 1
short SelectedRaw[MAXBOTTOMMODES]; 
d465 2
a466 1
short SelectedPage[MAXBOTTOMMODES];
d469 1
d472 1
d474 3
a476 1
short SortedMode[MAXNUMPAGES];
d478 1
d482 2
d485 2
d500 2
d503 19
d608 1
a608 1
BOOL InfoBoxesHidden = false;
d952 12
d1147 3
d1157 3
d1164 25
a1188 7
    if (VarioUpdated) {
      VarioUpdated = false;
      if (MapWindow::IsDisplayRunning()) {
        if (EnableVarioGauge) {
          GaugeVario::Render();
        }
      }
d1190 1
d1202 3
a1204 1

d1218 4
d1318 7
d1331 2
d1335 1
d1344 4
a1347 1
    CloseHandle (hCalculationThread);
d1352 1
d1355 1
d1363 1
d1365 1
d1497 1
a1497 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9i "));
d1499 1
a1499 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9i "));
d1501 1
a1501 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9i "));
d2820 2
d4246 1
@


8.9
log
@9g
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.8 2009/07/22 10:54:08 root Exp root $
d273 1
d424 4
d443 3
d1379 1
a1379 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9g "));
d1381 1
a1381 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9g "));
d1383 1
a1383 1
  wcscat(XCSoar_Version, TEXT("LK8000-a9g "));
@


8.8
log
@ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.7 2009/07/17 15:26:25 root Exp root $
d272 3
d431 3
a433 1
short SelectedRaw[4]; 
d436 2
d1366 4
a1369 2
  // experimental CVS 

d1371 1
a1371 1
  wcscat(XCSoar_Version, TEXT("LK8000-B9f "));
d1373 1
a1373 1
  wcscat(XCSoar_Version, TEXT("LK8000-B9f "));
d1375 1
a1375 1
  wcscat(XCSoar_Version, TEXT("LK8000-B9f "));
d1638 1
@


8.7
log
@ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.6 2009/07/05 22:57:16 root Exp root $
d418 1
d425 6
a430 1
short MapSpaceMode; // current MapSpace mode
d432 1
a432 1
// LK8000 sync flags
d434 2
d438 1
a438 1
// Optimization  preprocessing
d440 3
a442 1
int  RangeLandableNumber;
d447 1
d1362 1
a1362 1
  wcscat(XCSoar_Version, TEXT("5.2.3Fb9c "));
d1364 1
a1364 1
  wcscat(XCSoar_Version, TEXT("5.2.3b9 "));
d1366 1
a1366 1
  wcscat(XCSoar_Version, TEXT("5.2.3b9 "));
@


8.6
log
@ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.5 2009/07/01 22:26:02 root Exp root $
d423 5
d430 8
d1351 1
a1351 1
  wcscat(XCSoar_Version, TEXT("5.2.3Fb9b "));
d1385 1
a1385 1
#ifndef PNA
d1397 1
a1397 1
#endif
d1591 2
a1592 2
#ifdef _SIM_	// VENTA-ADDON
	CreateProgressDialog(TEXT("SIMULATION")); Sleep(2000);
d1595 1
d1918 1
a1918 1
  
a1920 12
/*
// VENTA REMOVE
  HDC dc;
  dc = ::GetDC(NULL);
  int dpix = ::GetDeviceCaps(dc,LOGPIXELSX);
  int dpiy = ::GetDeviceCaps(dc,LOGPIXELSY);
char ventabuffer[200];
FILE *fp;
 sprintf(ventabuffer,"screensize get =%d %d dpix=%d dpiy=%d\r\n",iWidth,iHeight,dpix,dpiy);
       if ((fp=fopen("DEBUG.TXT","a"))!= NULL)
                    {;fprintf(fp,"%s\n",ventabuffer);fclose(fp);}
*/
d1940 1
d2437 1
@


8.5
log
@wip ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.4 2009/06/28 21:32:44 root Exp root $
d422 1
d1338 1
a1338 1
  wcscat(XCSoar_Version, TEXT("5.2.3Fb9a "));
d1532 5
d1703 3
d1904 3
a1906 2
  int iWidth=GetSystemMetrics(SM_CXSCREEN);
  int iHeight=GetSystemMetrics(SM_CYSCREEN);
d1908 1
a1908 1
// VENTA FIX REMOVE
d1920 3
d1933 6
a1940 3
//  int iWidth = rc.right-rc.left;
//  int iHeight=rc.bottom-rc.top;

d2616 2
@


8.4
log
@ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.3 2009/06/27 17:18:55 root Exp root $
d418 1
d421 1
d1337 1
a1337 1
  wcscat(XCSoar_Version, TEXT("5.2.3Fb9 "));
d1795 1
d1798 1
a1798 1
    logfont->lfQuality = CLEARTYPE_COMPAT_QUALITY;
d1895 24
a1918 12
  // These are the only known geometries, for both portrait and landscape
  int iWidth = rc.right-rc.left;
  int iHeight=rc.bottom-rc.top;
  if (iWidth == 240 && iHeight == 320) ScreenSize=(ScreenSize_t)ss240x320; // portrait
  if (iWidth == 480 && iHeight == 640) ScreenSize=(ScreenSize_t)ss480x640;
  if (iWidth == 480 && iHeight == 800) ScreenSize=(ScreenSize_t)ss480x800;

  if (iWidth == 480 && iHeight == 272) ScreenSize=(ScreenSize_t)ss480x272; // landscape
  if (iWidth == 320 && iHeight == 240) ScreenSize=(ScreenSize_t)ss320x240;
  if (iWidth == 480 && iHeight == 234) ScreenSize=(ScreenSize_t)ss480x234;
  if (iWidth == 640 && iHeight == 480) ScreenSize=(ScreenSize_t)ss640x480;
  if (iWidth == 800 && iHeight == 480) ScreenSize=(ScreenSize_t)ss800x480;
d2065 1
a2247 1
//}  FIX DA TOGLIERE??
d2429 1
@


8.3
log
@ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.2 2009/06/24 10:04:03 root Exp root $
d418 2
@


8.2
log
@*** empty log message ***
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 8.1 2009/06/19 20:28:25 venta Exp root $
d403 1
a403 1
bool Look8000=false;
d1898 1
a1898 1
  if (iWidth == 320 && iHeight == 242) ScreenSize=(ScreenSize_t)ss320x240;
@


8.1
log
@beta8
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 1.6 2009/06/16 14:07:59 root Exp $
d269 3
d405 1
d409 2
d1593 1
d3519 2
a3520 2
  if(InfoWindowActive && !(AircraftCategory == (AircraftCategory_t)umParaglider)) 
    // VNT let paraglider maplock working forever
d3893 1
a3893 1
  len = _vsprintf(buf, Str, ap);
@


1.6
log
@incorso
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 1.5 2009/06/11 19:50:31 root Exp root $
d1327 1
a1327 1
  wcscat(XCSoar_Version, TEXT("5.2.3Fb8 "));
d1329 1
a1329 1
  wcscat(XCSoar_Version, TEXT("5.2.3b7 "));
d1331 1
a1331 1
  wcscat(XCSoar_Version, TEXT("5.2.3b7 "));
@


1.5
log
@alfa
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 1.4 2009/06/08 13:28:08 root Exp root $
d264 6
d411 1
d1327 1
a1327 1
  wcscat(XCSoar_Version, TEXT("5.2.3Fb7 "));
d1586 1
d1883 1
d1901 1
a1901 1
  if (iWidth == 480 && iHeight == 272) { // WQVGA  e.g. MIO
d1918 1
a1918 1
  else if (iWidth == 480 && iHeight == 234) { // e.g. Messada 2440
d1930 1
a1930 1
  else if (iWidth == 800 && iHeight == 480) {// e.g. ipaq 31x {
@



1.4
log
@ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 1.3 2009/06/02 14:48:01 root Exp root $
d396 1
a396 1
bool NewMap=true;
d404 1
@


1.3
log
@ok
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 1.2 2009/06/01 21:19:50 root Exp root $
d162 3
d285 2
d403 1
a1872 1
#if defined(PNA)  // VENTA4
d1876 14
d1959 2
@


1.2
log
@funziona
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 1.1 2009/05/25 12:59:35 root Exp root $
d392 2
a393 1
bool OutlinedTp=false;
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
  $Id: XCSoar.cpp,v 1.300 2009/05/24 11:00:39 jwharington Exp $
a38 2
#include "Defines.h" // VENTA3

d54 1
d393 6
d520 3
d524 1
d564 3
d568 1
d574 3
d578 1
d638 3
d642 1
d677 3
a679 1
	  // 71 // 
d681 1
a681 1
	  // 72 // 
d685 1
a685 1
const int NUMSELECTSTRINGS = 73; 
d1570 1
@
