head	1.10;
access;
symbols;
locks
	root:1.10; strict;
comment	@// @;


1.10
date	2010.12.11.14.42.56;	author root;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.03.21.17.31;	author root;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.11.00.59.13;	author root;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.04.14.00.11;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.16.11.14.41;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.06.13.11.18;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.13.15.28.30;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.22.01.21.34;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.19.00.08.55;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.15.14.34.01;	author root;	state Exp;
branches;
next	;


desc
@@


1.10
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: LKDrawLook8000.cpp,v 1.9 2010/12/03 21:17:31 root Exp root $
*/

#include "StdAfx.h"
#include "options.h"
#include "Cpustats.h"
#include "XCSoar.h"
#include "Utils2.h"
#include "compatibility.h"
#include "MapWindow.h"
#include "Units.h"
#include "McReady.h"
#include "externs.h"
#include "InputEvents.h"
#include <windows.h>
#include <math.h>
#include <tchar.h>
#include "InfoBoxLayout.h"
#include "Logger.h"
#include "Process.h"
#include "RasterTerrain.h" // 091109
#include "LKUtils.h"
#include "LKMapWindow.h"
#include "LKObjects.h"


#if ALPHABLENDING
#if (WINDOWSPC>0)
#include <wingdi.h>
#endif
#endif

extern void DrawGlideCircle(HDC hdc, POINT Orig, RECT rc );
extern void MapWaypointLabelAdd(TCHAR *Name, int X, int Y, TextInBoxMode_t Mode, int AltArivalAGL, bool inTask, 
	bool isLandable, bool isAirport, bool isExcluded, int index);
extern int _cdecl MapWaypointLabelListCompare(const void *elem1, const void *elem2 );

extern void DrawMapSpace(HDC hdc, RECT rc);
extern void DrawNearest(HDC hdc, RECT rc);
extern void DrawNearestTurnpoint(HDC hdc, RECT rc);
extern void DrawCommon(HDC hdc, RECT rc);
extern void DrawWelcome8000(HDC hdc, RECT rc);
#ifdef CPUSTATS
extern void DrawCpuStats(HDC hdc, RECT rc);
#endif
#ifdef DRAWDEBUG
extern void DrawDebug(HDC hdc, RECT rc);
#endif

extern void WriteInfo(HDC hdc, bool *showunit, TCHAR *BufferValue, TCHAR *BufferUnit, TCHAR *BufferTitle, 
				short *columnvalue, short *columntitle, short *row1, short *row2, short *row3);

extern int PDABatteryPercent;
extern int PDABatteryTemperature;
extern int MapWaypointLabelListCount;
extern void ConvToUpper(TCHAR *str);

extern NMEAParser nmeaParser1;
extern NMEAParser nmeaParser2;

typedef struct{
  TCHAR Name[NAME_SIZE+1];
  POINT Pos;
  TextInBoxMode_t Mode;
  int AltArivalAGL;
  bool inTask;
  bool isLandable; // VENTA5
  bool isAirport; // VENTA5
  bool isExcluded;
  int  index;
}MapWaypointLabel_t;


extern MapWaypointLabel_t MapWaypointLabelList[];


void MapWindow::DrawLook8000(HDC hdc,  RECT rc )
{
  HFONT		oldfont=0;
  SIZE TextSize, TextSize2;
  TCHAR Buffer[LKSIZEBUFFERLARGE];
  TCHAR BufferValue[LKSIZEBUFFERVALUE];
  TCHAR BufferUnit[LKSIZEBUFFERUNIT];
  TCHAR BufferTitle[LKSIZEBUFFERTITLE];
  char text[LKSIZETEXT];
  int index=-1;
  double Value;
  short rcx, rcy;
  short wlen;
  bool redwarning; // 091203
  int gatechrono=0;

  short leftmargin=0;

  static bool doinit=true;
  static bool flipflop=true;
  static short flipflopcount=0;

  #ifdef LKDRAW_OPTIMIZE
  short tlen;
  static int ySizeLK8BigFont;
  static int ySizeLK8MediumFont;
  static int ySizeLK8TargetFont;
  static short tlenFullScreen;
  static short tlenHalfScreen;
  #if NEWPNAV
  // position Y of text in navboxes
  static short yRow2Title=0;	// higher row in portrait, unused in landscape
  static short yRow2Value=0;
  static short yRow2Unit=0;
  static short yRow1Title=0;	// lower row in portrait, the only one in landscape
  static short yRow1Value=0;
  static short yRow1Unit=0;
  #endif

  #ifndef OLDSPLITTER
  static int splitoffset;

  #if NEWPNAV
  static int splitoffset2; // second raw, which really is the first from top!
  #endif

  #endif

  #else
  static short tlen; // FIX TODO 100215 no static
  #endif

  // This is going to be the START 1/3  name replacing waypoint name when gates are running
  TCHAR StartGateName[12]; // 100506
  static TCHAR StartGateNameHS[12];
  static TCHAR StartGateNameFS[12];

  if (NewMap==false) return;

  if (!IsMapFullScreen()) return; // 101203


  redwarning=false;
  oldfont = (HFONT)SelectObject(hdc, LKINFOFONT); // FIXFONT

  if ( IsMapFullScreen() && !EnablePan )
	DrawBottom=true; // TODO maybe also !TargetPan
  else
	DrawBottom=false;

  if ( ++flipflopcount >2 ) {
	flipflop = !flipflop;
	flipflopcount=0;
  }

  if (doinit) {
#if LKDRAW_OPTIMIZE
	TCHAR Tdummy[]=_T("T");
	#ifndef OLDSPLITTER
	int iconsize;
	#endif
	SelectObject(hdc, LK8BigFont); 
	GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
	ySizeLK8BigFont = TextSize.cy;

	SelectObject(hdc, LK8TargetFont); 
	GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
	ySizeLK8TargetFont = TextSize.cy;

	SelectObject(hdc, LK8MediumFont); 
	GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
	ySizeLK8MediumFont = TextSize.cy;

	// All these values are fine tuned for font/resolution/screenmode.
	// there is no speed issue inside doinit. take your time.
	#if NEWPNAV
	SelectObject(hdc, LK8TitleNavboxFont); 
	GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
	int syTitle = TextSize.cy;
	SelectObject(hdc, LK8ValueFont); 
	GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
	int syValue = TextSize.cy;
	switch (ScreenSize) {
		// Row1 is the lower, Row2 is the top, for portrait
		// WARNING, algos are wrong, need to check and recalculate for each resolution!!
		// Changing font size in Utils2 does require checking and fixing here.
		case ss480x640:
		case ss480x800:
		case ss240x320:
		case ss272x480:
			yRow2Value =  rc.bottom-(syValue*2);
			yRow2Unit  =  yRow2Value;
			yRow2Title =  yRow2Value - (syValue/2) - (syTitle/2) + NIBLSCALE(2);
			yRow1Value =  rc.bottom-(syValue/2);
			yRow1Unit  =  yRow1Value;
			yRow1Title =  yRow1Value - (syValue/2) - (syTitle/2) + NIBLSCALE(2);
			break;
		
		case ss800x480:
		case ss640x480:
		case ss400x240:
			yRow2Value =  rc.bottom-(syValue*2);
			yRow2Unit  =  rc.bottom-(syValue*2) - NIBLSCALE(2);
			yRow2Title =  rc.bottom-(syValue*2) - syTitle;
			yRow1Value =  rc.bottom-(syValue/2);
			yRow1Unit  =  yRow1Value;
			yRow1Title =  rc.bottom-(syValue/2) - syTitle;
			break;

		default:
			yRow2Value =  rc.bottom-(syValue*2);
			yRow2Unit  =  rc.bottom-(syValue*2) - NIBLSCALE(2);
			yRow2Title =  rc.bottom-(syValue*2) - syTitle;
			yRow1Value =  rc.bottom-(syValue/2);
			yRow1Unit  =  rc.bottom-(syValue/2) - NIBLSCALE(2);
			yRow1Title =  rc.bottom-(syValue/2) - syTitle;
			break;
	}
	#endif
	if ( ScreenSize < (ScreenSize_t)sslandscape ) {
		switch (ScreenSize) {			// portrait fullscreen
			case (ScreenSize_t)ss240x320:
				#if NEWPNAV
				tlenFullScreen=8;
				#else
				tlenFullScreen=6;
				#endif
				// ST 1/3
				_tcscpy(StartGateNameFS,_T("ST "));
				break;
			default:
				_tcscpy(StartGateNameFS,_T("ST "));
				#if NEWPNAV
				tlenFullScreen=8;
				#else
				tlenFullScreen=6;
				#endif
				break;
		}
		switch (ScreenSize) {			// portrait not fullscreen
			case (ScreenSize_t)ss240x320:
				_tcscpy(StartGateNameHS,_T("ST "));
				#if NEWPNAV
				tlenHalfScreen=8;
				#else
				tlenHalfScreen=6;
				#endif
				break;
			default:
				_tcscpy(StartGateNameHS,_T("ST "));
				#if NEWPNAV
				tlenHalfScreen=8;
				#else
				tlenHalfScreen=6;
				#endif
				break;
		}
	} else  {
		switch (ScreenSize) {			// landscape fullscreen
			case (ScreenSize_t)ss800x480:
			case (ScreenSize_t)ss400x240:
			case (ScreenSize_t)ss480x272:
			case (ScreenSize_t)ss720x408:
				// START 1/3
				_tcscpy(StartGateNameFS,_T("Start "));
				tlenFullScreen=9;
				break;
			case (ScreenSize_t)ss320x240:
				// STRT 1/3
				_tcscpy(StartGateNameFS,_T("Start "));
				tlenFullScreen=8; // 091114 reduced from 9
				break;
			case (ScreenSize_t)ss640x480:
				// STRT 1/3
				_tcscpy(StartGateNameFS,_T("Start "));
				tlenFullScreen=8;
				break;
			case (ScreenSize_t)ss896x672:
				_tcscpy(StartGateNameFS,_T("Start "));
				tlenFullScreen=10;
				break;
			default:
				_tcscpy(StartGateNameFS,_T("Start "));
				tlenFullScreen=9;
				break;
		}
		switch (ScreenSize) {			// landscape not fullscreen
			case (ScreenSize_t)ss480x272:
			case (ScreenSize_t)ss720x408:
				_tcscpy(StartGateNameHS,_T("ST "));
				tlenHalfScreen=7; // 091114 reduced from 9
				break;
			case (ScreenSize_t)ss320x240:
			case (ScreenSize_t)ss640x480:
				_tcscpy(StartGateNameHS,_T("ST "));
				tlenHalfScreen=6; // 091114 reduced from 7
				break;
			default:
				_tcscpy(StartGateNameHS,_T("ST "));
				tlenHalfScreen=7;
				break;
		}
	}
	
	#ifndef OLDSPLITTER
	#if NEWPNAV
	if (ScreenLandscape) {
		iconsize=NIBLSCALE(26);
		splitoffset= ((rc.right-iconsize)-rc.left)/splitter;
	} else {
		iconsize=NIBLSCALE(26);
		splitoffset= ((rc.right-iconsize)-rc.left)/splitter;
		// splitoffset2= (rc.right-rc.left)/splitter;
		splitoffset2= splitoffset;
	}
	#else
	iconsize=NIBLSCALE(26);
	splitoffset= ((rc.right-iconsize)-rc.left)/splitter;
	#endif
	#endif
#endif
	doinit=false; 
  } // end doinit

  COLORREF overcolor,distcolor;
  overcolor=OverColorRef;
  distcolor=OverColorRef;
  int yrightoffset;
  if (ScreenLandscape)
	yrightoffset=((rc.bottom + rc.top)/2)-NIBLSCALE(10);	// 101112
  else
	yrightoffset=((rc.bottom + rc.top)/3)-NIBLSCALE(10);	// 101112

#if LKPMODE
  if ( MapSpaceMode!= MSM_MAP) {
	DrawMapSpace(hdc, rc);
	goto Drawbottom;
  }
#else
  if (DrawBottom && MapSpaceMode!= MSM_MAP) {
	DrawMapSpace(hdc, rc);
	goto Drawbottom;
  }
#endif


  if ( MapWindow::IsMapFullScreen() ) {
	tlen=tlenFullScreen;
	_tcscpy(StartGateName,StartGateNameFS);
  } else {
	tlen=tlenHalfScreen;
	_tcscpy(StartGateName,StartGateNameHS);
  }


  // First we draw flight related values such as instant efficiency, altitude, new infoboxes etc.

  if (MapWindow::IsMapFullScreen() && LKVarioBar && !EnablePan) { // 091214 Vario non available in pan mode
	leftmargin=(LKVarioSize+NIBLSCALE(3)); // VARIOWIDTH + middle separator right extension
	tlen-=2; // 091115
	
  } else {
	leftmargin=0;
  }

  // no overlay - but we are still drawing MC and the wind on bottom left!
  if ( Look8000 == (Look8000_t)lxcNoOverlay ) goto drawOverlay;

  // PRINT WP TARGET NAME
  #ifdef OVERTARGET
  if ( ISPARAGLIDER && UseGates() && ActiveWayPoint==0) {
	// if running a task, use the task index normally
	if ( ValidTaskPoint(ActiveWayPoint) != false )
		index = Task[ActiveWayPoint].Index;
	else
		index=-1;
  } else {
	index = GetOvertargetIndex();
  }
  #else
  if ( ValidTaskPoint(ActiveWayPoint) != false ) {
	index = Task[ActiveWayPoint].Index;
	if ( index >=0 ) {
	// in overtarget mode, we print the name even when no target. 
  #endif
		if (DisplayMode != dmCircling) {
			rcx=rc.left+leftmargin+NIBLSCALE(1);
			rcy=rc.top+NIBLSCALE(1);
		} else {
			if (ThermalBar) 
				rcx=rc.left+leftmargin+NIBLSCALE(40);
			else
				rcx=rc.left+leftmargin+NIBLSCALE(1);
			rcy=rc.top+NIBLSCALE(1);
		}
		// Waypoint name and distance
		SelectObject(hdc, LK8TargetFont);

	#if OVERTARGET
	if ( index >=0 ) {
	#endif
		#if 0
		// Active colours
		if (WayPointList[index].Reachable) {
			TextDisplayMode.AsFlag.Color = TEXTGREEN; 
		} else {
			TextDisplayMode.AsFlag.Color = TEXTRED;
		}
		#endif
		// OVERTARGET reswp not using redwarning because Reachable is not calculated
		if (index<=RESWP_END)
			redwarning=false;
		else {
			if (WayPointCalc[index].AltArriv[AltArrivMode]>0 && !WayPointList[index].Reachable ) 
				redwarning=true;
			else	
				redwarning=false;
		}

		int gateinuse=-2;
		if (UseGates() && ActiveWayPoint==0) {
			gateinuse=ActiveGate;
			if (!HaveGates()) {
				gateinuse=-1;
			} else {
				// this is set here for the first time, when havegates
				gatechrono=GateTime(ActiveGate)-LocalTime();
			}
			if (gateinuse<0) {
				_tcscpy(Buffer,gettext(TEXT("CLOSED")));
			} else {
				_stprintf(Buffer,_T("%s%d/%d"),StartGateName,gateinuse+1,PGNumberOfGates);
			}

	 		LKWriteText(hdc,Buffer, rcx+NIBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
		} else {
			#if OVERTARGET
			TCHAR buffername[LKSIZEBUFFERLARGE];
			GetOvertargetName(buffername);
			wlen=wcslen(buffername);
 			if (wlen>tlen) {
 			 	_tcsncpy(Buffer, buffername, tlen); Buffer[tlen]='\0';
			} else {
 			 	_tcsncpy(Buffer, buffername, wlen); Buffer[wlen]='\0';
			}
			#else
			wlen=wcslen(WayPointList[index].Name);
 			if (wlen>tlen) {
 			 	_tcsncpy(Buffer, WayPointList[index].Name, tlen); Buffer[tlen]='\0';
			} else {
 			 	_tcsncpy(Buffer, WayPointList[index].Name, wlen); Buffer[wlen]='\0';
			}
			#endif

 			 ConvToUpper(Buffer);
			 LKWriteText(hdc,Buffer, rcx+NIBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
		}

		 #ifdef LKDRAW_OPTIMIZE
		 if (gateinuse>=-1) {
			// if we are still painting , it means we did not start yet..so we use colors
			if (CorrectSide() ) {
				distcolor=overcolor;
			} else {
				distcolor=RGB_RED;
			}
		 	LKFormatValue(LK_START_DIST, false, BufferValue, BufferUnit, BufferTitle);
		 } else {
			#if OVERTARGET
			switch (OvertargetMode) {
				case OVT_TASK:
		 			LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_ALT1:
		 			LKFormatDist(Alternate1, false, BufferValue, BufferUnit);
					break;
				case OVT_ALT2:
		 			LKFormatDist(Alternate2, false, BufferValue, BufferUnit);
					break;
				case OVT_BALT:
		 			LKFormatDist(BestAlternate, false, BufferValue, BufferUnit);
					break;
				case OVT_THER:
		 			LKFormatDist(RESWP_LASTTHERMAL, true, BufferValue, BufferUnit);
					break;
				case OVT_HOME:
		 			LKFormatDist(HomeWaypoint, false, BufferValue, BufferUnit);
					break;
				case OVT_MATE:
		 			LKFormatDist(RESWP_TEAMMATE, true, BufferValue, BufferUnit);
					break;
				case OVT_FLARM:
		 			LKFormatDist(RESWP_FLARMTARGET, true, BufferValue, BufferUnit);
					break;
				default:
		 			LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
					break;
			}
			#else
		 	LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
			#endif
		}

		if (!OverlayClock && ScreenLandscape && (!(ISPARAGLIDER && UseGates())) ) {
			_stprintf(BufferValue,_T("%s %s"),BufferValue,BufferUnit);
			if (MapWindow::IsMapFullScreen() ) {
				SelectObject(hdc, LK8TargetFont); 
				LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(30),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
			} else {
				SelectObject(hdc, LK8MediumFont); 
				LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(28),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
			}
		} else
			LKWriteText(hdc,BufferValue, rcx+NIBLSCALE(2), rcy+ ySizeLK8TargetFont, 0, WTMODE_OUTLINED, WTALIGN_LEFT, distcolor, true);
		 #else
		// WARNING NOT SUPPORTED ANYMORE TODO FIX
		GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
		 if (gateinuse>=-1)
		 	LKFormatValue(LK_START_DIST, false, BufferValue, BufferUnit, BufferTitle);
		 else
	 		LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);

	 	LKWriteText(hdc,BufferValue, rcx+NIBLSCALE(2), rcy+TextSize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
	 	#endif

 		GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize2);
		if (!HideUnits) {
			SelectObject(hdc, LKMAPFONT); // TODO FIX BUG here.. using different font from size
			if (!OverlayClock && ScreenLandscape && !(ISPARAGLIDER && UseGates())) {

			} else {
			 LKWriteText(hdc, BufferUnit, rcx+NIBLSCALE(4)+TextSize2.cx,rcy+ySizeLK8TargetFont+(ySizeLK8TargetFont/3)-NIBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true); 
			}
		}

		// DIFF Bearing value displayed only when not circling
	  	if (DisplayMode != dmCircling) {
			#if OVERTARGET
			switch (OvertargetMode) {
				case OVT_TASK:
		 			LKFormatValue(LK_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_ALT1:
		 			LKFormatBrgDiff(Alternate1, false, BufferValue, BufferUnit);
					break;
				case OVT_ALT2:
		 			LKFormatBrgDiff(Alternate2, false, BufferValue, BufferUnit);
					break;
				case OVT_BALT:
		 			LKFormatBrgDiff(BestAlternate, false, BufferValue, BufferUnit);
					break;
				case OVT_THER:
		 			LKFormatBrgDiff(RESWP_LASTTHERMAL, true, BufferValue, BufferUnit);
					break;
				case OVT_HOME:
		 			LKFormatBrgDiff(HomeWaypoint, false, BufferValue, BufferUnit);
					break;
				case OVT_MATE:
		 			LKFormatBrgDiff(RESWP_TEAMMATE, true, BufferValue, BufferUnit);
					break;
				case OVT_FLARM:
		 			LKFormatBrgDiff(RESWP_FLARMTARGET, true, BufferValue, BufferUnit);
					break;
				default:
		 			LKFormatValue(LK_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
					break;
			}
			#else
			LKFormatValue(LK_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
			#endif
			SelectObject(hdc, LK8BigFont);
			#if NEWPNAV
			if (ScreenLandscape)
				LKWriteText(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ NIBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, overcolor, true);
			else
				LKWriteText(hdc, BufferValue, ((rc.right+rc.left)/3)*2, rc.top+ NIBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, overcolor, true);
			#else
			LKWriteText(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ NIBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, overcolor, true);
			#endif
		}

		// Draw efficiency required and altitude arrival for destination waypoint
		// For paragliders, average efficiency and arrival destination

		SelectObject(hdc, LK8BigFont); // use this font for big values

		if ( !ISPARAGLIDER ) { // 091110
			#if OVERTARGET
			switch (OvertargetMode) {
				case OVT_TASK:
		 			LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_ALT1:
		 			LKFormatValue(LK_ALTERN1_GR, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_ALT2:
		 			LKFormatValue(LK_ALTERN2_GR, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_BALT:
		 			LKFormatValue(LK_BESTALTERN_GR, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_HOME:
		 			LKFormatGR(HomeWaypoint, false, BufferValue, BufferUnit);
					break;
				case OVT_THER:
		 			LKFormatGR(RESWP_LASTTHERMAL, true, BufferValue, BufferUnit);
					break;
				case OVT_MATE:
		 			LKFormatGR(RESWP_TEAMMATE, true, BufferValue, BufferUnit);
					break;
				case OVT_FLARM:
		 			LKFormatGR(RESWP_FLARMTARGET, true, BufferValue, BufferUnit);
					break;
				default:
		 			LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
					break;
			}
			#else
			LKFormatValue(LK_NEXT_GR, false, BufferValue, BufferUnit, BufferTitle);
			#endif

			GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
			//	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10); OLD
			rcy=yrightoffset -TextSize.cy; // 101112
			rcx=rc.right-NIBLSCALE(10);
			if (redwarning)  // 091203
				LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_RED, true);
			else
				LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, overcolor, true);

			// Altitude difference with current MC
			#if OVERTARGET
			switch (OvertargetMode) {
				case OVT_TASK:
		 			LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_ALT1:
		 			LKFormatValue(LK_ALTERN1_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_ALT2:
		 			LKFormatValue(LK_ALTERN2_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_BALT:
		 			LKFormatValue(LK_BESTALTERN_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
					break;
				case OVT_HOME:
		 			LKFormatAltDiff(HomeWaypoint, false, BufferValue, BufferUnit);
					break;
				case OVT_THER:
		 			LKFormatAltDiff(RESWP_LASTTHERMAL, true, BufferValue, BufferUnit);
					break;
				case OVT_MATE:
		 			LKFormatAltDiff(RESWP_TEAMMATE, true, BufferValue, BufferUnit);
					break;
				case OVT_FLARM:
		 			LKFormatAltDiff(RESWP_FLARMTARGET, true, BufferValue, BufferUnit);
					break;
				default:
		 			LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit,BufferTitle);
					break;
			}
			#else
			LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
			#endif
			if (redwarning) 
				LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, 
					WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_RED, true);
			else
				LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, 
					WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
		}

	} // index>0
	#if OVERTARGET
	// no valid index for current overmode, but we print something nevertheless
	else {
		TCHAR buffername[LKSIZEBUFFERLARGE];
		GetOvertargetName(buffername);
		wlen=wcslen(buffername);
	 	if (wlen>tlen) {
	 	 	_tcsncpy(Buffer, buffername, tlen); Buffer[tlen]='\0';
		} else {
	 	 	_tcsncpy(Buffer, buffername, wlen); Buffer[wlen]='\0';
		}
 		ConvToUpper(Buffer);
		LKWriteText(hdc,Buffer, rcx+NIBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
	}
	#endif
  #ifndef OVERTARGET
  } // valid taskpoint
  #endif

  // moved out from task paragliders stuff - this is painted on the right
  if ( ISPARAGLIDER ) {

	if (UseGates()&&ActiveWayPoint==0) {
		SelectObject(hdc, LK8BigFont); // use this font for big values

		if (HaveGates()) {
			Units::TimeToTextDown(BufferValue,gatechrono ); 
			rcx=rc.right-NIBLSCALE(10);
			GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
			rcy=yrightoffset -TextSize.cy; // 101112
			LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, overcolor, true);

			Value=WayPointCalc[Task[0].Index].NextETE-gatechrono;
			Units::TimeToTextDown(BufferValue, (int)Value);
			if (Value<=0) 
				LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_RED, true);
			else
				LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
		}

	} else {
		SelectObject(hdc, LK8BigFont); // use this font for big values
	  	if (DisplayMode == dmCircling)
			LKFormatValue(LK_TC_30S, false, BufferValue, BufferUnit, BufferTitle);
		else
			LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);

		GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
		rcy=yrightoffset -TextSize.cy; // 101112

		rcx=rc.right-NIBLSCALE(10);
		LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, overcolor, true);

		// Altitude difference with current MC
		#if OVERTARGET
		switch (OvertargetMode) {
			case OVT_TASK:
	 			LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
				break;
			case OVT_ALT1:
	 			LKFormatValue(LK_ALTERN1_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
				break;
			case OVT_ALT2:
	 			LKFormatValue(LK_ALTERN2_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
				break;
			case OVT_BALT:
	 			LKFormatValue(LK_BESTALTERN_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
				break;
			case OVT_HOME:
				LKFormatAltDiff(HomeWaypoint, false, BufferValue, BufferUnit);
				break;
			case OVT_THER:
				LKFormatAltDiff(RESWP_LASTTHERMAL, true, BufferValue, BufferUnit);
				break;
			case OVT_MATE:
				LKFormatAltDiff(RESWP_TEAMMATE, true, BufferValue, BufferUnit);
				break;
			case OVT_FLARM:
		 		LKFormatAltDiff(RESWP_FLARMTARGET, true, BufferValue, BufferUnit);
				break;
			default:
	 			LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
				break;
		}
		#else
		LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
		#endif
		if (redwarning)
			LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_RED, true);
		else
			LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);

	} // end no UseGates()
  } // is paraglider

drawOverlay:
  // In place of MC, print gate time
  // Even if lxcNoOverlay, we print startgates..
  if (UseGates()&&ActiveWayPoint==0) {
	SelectObject(hdc, LK8MediumFont); 

	if (HaveGates()) {
		Units::TimeToText(BufferTitle,GateTime(ActiveGate)); 
		_stprintf(BufferValue,_T("START %s"),BufferTitle);
	} else {
		_tcscpy(BufferValue,gettext(TEXT("GATES CLOSED")));
	}
	rcy=yrightoffset -ySizeLK8BigFont-(ySizeLK8MediumFont*2); // 101112
	rcx=rc.right-NIBLSCALE(10);
	LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, overcolor, true);

	// USE THIS SPACE FOR MESSAGES TO THE PILOT
	rcy+=ySizeLK8MediumFont;
	if (HaveGates()) {
		if (gatechrono>0) {
			// IsInSector works reversed!
			if (PGStartOut && CALCULATED_INFO.IsInSector) {
				_tcscpy(BufferValue,_T("WRONG inSIDE"));
			} else {
				if (!PGStartOut && !CALCULATED_INFO.IsInSector) {
					_tcscpy(BufferValue,_T("WRONG outSIDE"));
				} else {
					_tcscpy(BufferValue,_T("countdown"));
				}
			}
			if (!CALCULATED_INFO.Flying) {
				_tcscpy(BufferValue,_T("NOT FLYING")); // 101112
			}
		} else {
			// gate is open
			if ( (ActiveGate<(PGNumberOfGates-1)) && (gatechrono<-300)) {
					_tcscpy(BufferValue,_T("GATE OPEN"));
			} else {
				if ( ActiveGate>=(PGNumberOfGates-1) )  {
					Units::TimeToText(BufferTitle,GateTime(ActiveGate+1)); 
					_stprintf(BufferValue,_T("CLOSE %s"),BufferTitle);
				} else {
					if (flipflop) {
						Units::TimeToText(BufferTitle,GateTime(ActiveGate+1)); 
						_stprintf(BufferValue,_T("NEXT %s"),BufferTitle);
					} else {
						_tcscpy(BufferValue,gettext(TEXT("GATE OPEN")));
					}
				}
				_tcscpy(BufferValue,gettext(TEXT("GATE OPEN")));
			}
		}
	} else {
		_tcscpy(BufferValue,_T("NO TSK START"));
	}
	LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, distcolor, true);

  } else
  if (McOverlay && Look8000>lxcNoOverlay && (ISGLIDER || ISPARAGLIDER)) {
	SelectObject(hdc, LK8BigFont); 
	LKFormatValue(LK_MC, false, BufferValue, BufferUnit, BufferTitle);
	// rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-NIBLSCALE(10)-ySizeLK8BigFont; VERTICAL CENTERED
	rcy=yrightoffset -ySizeLK8BigFont-ySizeLK8BigFont;
	rcx=rc.right-NIBLSCALE(10);
	LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, overcolor, true);
  }
  if ( Look8000 == (Look8000_t)lxcNoOverlay ) goto Drawbottom;


  if ( (Look8000==(Look8000_t)lxcAdvanced) ) {

	SelectObject(hdc, LK8BigFont); 
	if (ISPARAGLIDER) {
		LKFormatValue(LK_HNAV, false, BufferValue, BufferUnit, BufferTitle); // 091115
	} else {
		if (DisplayMode == dmCircling)
			LKFormatValue(LK_TC_30S, false, BufferValue, BufferUnit, BufferTitle);
		else
			LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);
	}
	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	if (!EnablePan) // 091214
		rcx=rc.left+NIBLSCALE(10)+leftmargin+GlideBarOffset;   // 091115
	else
		rcx=rc.left+NIBLSCALE(10)+leftmargin;   // 091115
	if (ISPARAGLIDER||LKVarioBar)
		rcy=(rc.bottom + rc.top-BottomSize)/2 -TextSize.cy-NIBLSCALE(5);
	else
		rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10);

	if (ISPARAGLIDER) {
		LKWriteText(hdc, BufferValue, rcx, rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);
		if (!HideUnits) {
			SelectObject(hdc, LKMAPFONT);  // FIXFONT
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+NIBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);
		}

	} else {
		if (ISGLIDER) // 101204
		LKWriteText(hdc, BufferValue, rcx+NIBLSCALE(9), rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);
	}

	if (ISPARAGLIDER || LKVarioBar) { // 100213
		//LKFormatValue(LK_HGPS, false, BufferValue, BufferUnit, BufferTitle);
		LKFormatValue(LK_VARIO, false, BufferValue, BufferUnit, BufferTitle); // 091115
		SelectObject(hdc, LK8BigFont); 
		GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
		rcy+=TextSize.cy;
		LKWriteText(hdc, BufferValue, rcx,rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);
		if (!HideUnits) {
			SelectObject(hdc, LKMAPFONT); // FIXFONT
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+NIBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);
		}
	}

	LKFormatValue(LK_GNDSPEED, false, BufferValue, BufferUnit, BufferTitle);
	SelectObject(hdc, LK8BigFont); 
	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	rcy+=TextSize.cy;
	LKWriteText(hdc, BufferValue, rcx,rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);
	if (!HideUnits) {
		SelectObject(hdc, LKMAPFONT);  // FIXFONT
		LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+NIBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);
	}

	LKFormatValue(LK_TIME_LOCALSEC, false, BufferValue, BufferUnit, BufferTitle);

	if ( ScreenSize < (ScreenSize_t)sslandscape ) {
		#ifndef NEWPNAV	// 101005 Do not display CLOCK in portrait mode anymore
		if (MapWindow::IsMapFullScreen() ) {
			// SelectObject(hdc, LK8MediumFont);  091125
			SelectObject(hdc, LK8ValueFont); 
			LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(10),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
		} else {
			SelectObject(hdc, LK8MediumFont); 
			LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(27),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
		}
		#endif
	} else {
		if (OverlayClock || (ISPARAGLIDER && UseGates()) ) {
		if (MapWindow::IsMapFullScreen() ) {
			SelectObject(hdc, LK8TargetFont); 
			LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(30),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
		} else {
			SelectObject(hdc, LK8MediumFont); 
			LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(28),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
		}
		}
	}

  }

  /*
   * We want a standard interface for everybody with a minimal configuration. 
   * This navbox mode is NOT optional, and it will not be configurable.
   */

Drawbottom:
  if (DrawBottom) {

    RECT nrc;

    nrc.left=0;
    nrc.top=rc.bottom-BottomSize;
    nrc.right=rc.right;
    nrc.bottom=rc.bottom;

  // HPEN hP; REMOVE 101204
  HBRUSH hB;
  if ( INVERTCOLORS ) {
	#if LKOBJ
  	hB = LKBrush_Black;
  	// hB = LKBrush_Ndark; REMOVE 101204
	// hP = LKPen_White_N0; // FIX  with Yellow  REMOVE 101204
	#else
  	hB = (HBRUSH)CreateSolidBrush(RGB_NDARK);
	// hP = (HPEN)CreatePen(PS_SOLID,0,RGB_YELLOW);  REMOVE 101204
	#endif
  } else {
	#if LKOBJ
  	hB = LKBrush_Nlight;
	// hP = LKPen_Black_N0; REMOVE 101204
	#else
  	hB = (HBRUSH)CreateSolidBrush(RGB_NLIGHT);
	// hP = (HPEN)CreatePen(PS_SOLID,0,RGB_BLACK); REMOVE 101204
	#endif
  }

  #if ALPHABLENDING  
  #if (WINDOWSPC>0)
  HDC hdc2=CreateCompatibleDC(hdc);
  HBITMAP bitmapnew=CreateCompatibleBitmap(hdc,rc.right,rc.bottom);
  SelectObject(hdc2,bitmapnew); 
  FillRect(hdc2,&nrc, hB); 

  BLENDFUNCTION bs;
  bs.BlendOp=AC_SRC_OVER;
  bs.BlendFlags=0;
  bs.SourceConstantAlpha=195;
  bs.AlphaFormat=0;

  AlphaBlend(hdc,0,rc.bottom-BottomSize,rc.right,BottomSize,hdc2,0,rc.bottom-BottomSize,rc.right,BottomSize,bs);
  #else
  FillRect(hdc,&nrc, hB); 
  #endif
#else
  FillRect(hdc,&nrc, hB); 
  #if 0
  #if NEWPNAV
  if (!ScreenLandscape) {
	POINT pL, pR;
	pL.y=pR.y= rc.bottom - (BottomSize/2);
	pL.x=rc.left; pR.x=rc.right;
	 _DrawLine(hdc, PS_SOLID, 0, pL, pR, RGB_LIGHTGREEN, rc);
  }
  #endif
  #endif
#endif

  // NAVBOXES

  static bool wascircling=false; // init not circling of course
  static short OldBottomMode=BM_FIRST;
  bool showunit=false;

  if ( (DisplayMode == dmCircling) && !wascircling) {
	// switch to thermal mode
	OldBottomMode=BottomMode;
	BottomMode=BM_TRM;
	wascircling=true;
  }
  if ( (DisplayMode != dmCircling) && wascircling) {
	// back to cruise mode
	BottomMode=OldBottomMode;
	wascircling=false;
  }

  /*
   *   FIRST VALUE
   */

  showunit=true; // normally we do have a unit to show


  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(1,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		showunit=LKFormatValue(LK_TL_AVG, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_HGPS, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:
		showunit=LKFormatValue(LK_TC_ALL, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_FIN_DIST, true, BufferValue, BufferUnit, BufferTitle);
		break;

	case BM_SYS:
		showunit=LKFormatValue(LK_BATTERY, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;

	case BM_ALT:
		showunit=LKFormatValue(LK_BESTALTERN_GR, true, BufferValue, BufferUnit, BufferTitle); // 100221
		BufferTitle[7]='\0';
		break;

	case BM_CUS:
		index=GetInfoboxType(1);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	case BM_CUS2:
		index=GetInfoboxIndex(1,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(1,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  #if OLDSPLITTER
  rcx=rc.left+(rc.right/(splitter*2))-NIBLSCALE(5); // FIX make it static in doinit
  #else
  rcx=rc.left+(splitoffset/2);
  #endif
  #if NEWPNAV
  if (ScreenLandscape) {
	#include "LKMW3include_navbox1.cpp"
  } else {
	#include "LKMW3include_navbox2.cpp"
  }
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(7), rcy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #else
  #include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #endif

  /*
   *   SECOND VALUE
   */
  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(2,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		showunit=LKFormatValue(LK_GNDSPEED, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_HBARO, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:
		showunit=LKFormatValue(LK_ODOMETER, true, BufferValue, BufferUnit, BufferTitle); // 100221
		// showunit=false; 100221
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_FIN_ALTDIFF, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;
	case BM_SYS:
		showunit=LKFormatValue(LK_EXTBATT1VOLT, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;

	case BM_ALT:
		#if NEWPNAV
		if (ScreenLandscape) {
			showunit=LKFormatValue(LK_BESTALTERN_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
			wcscpy(BufferTitle,_T("<<<"));
		} else {
			showunit=LKFormatValue(LK_ALTERN1_GR, true, BufferValue, BufferUnit, BufferTitle);
			BufferTitle[7]='\0';
		}
		#else
		showunit=LKFormatValue(LK_BESTALTERN_ARRIV, false, BufferValue, BufferUnit, BufferTitle);
		wcscpy(BufferTitle,_T("<<<"));
		#endif
		break;
	case BM_CUS:
		index=GetInfoboxType(2);
		showunit=LKFormatValue(index, false, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(2,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(2,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, false, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  #if OLDSPLITTER
  rcx+=(rc.right/splitter); 
  #else
  rcx+=splitoffset;
  #endif
  #if NEWPNAV
  if (ScreenLandscape) {
	#include "LKMW3include_navbox1.cpp"
  } else {
	#include "LKMW3include_navbox2.cpp"
  }
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(7), rcy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #else
  #include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #endif

  /*
   *   THIRD VALUE
   */

  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(3,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		showunit=LKFormatValue(LK_HNAV, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_QFE, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:
		showunit=LKFormatValue(LK_TIMEFLIGHT, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_FIN_ETE, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_SYS:
		// TODO MAKE IT in LKPROCESS
		#if 100221
  		showunit=true;
  			wsprintf(BufferUnit, TEXT(""));
			#if NOSIM
			if (SIMMODE) {
				wsprintf(BufferTitle, TEXT("Sat"));
				wsprintf(BufferValue,TEXT("SIM"));
			} else {
				Value=GPS_INFO.SatellitesUsed;
				if (Value<1 || Value>30) {
					wsprintf(BufferValue,TEXT("---"));
				} else {
					sprintf(text,"%d",(int)Value);
					wsprintf(BufferValue, TEXT("%S"),text);

				}
				if (nmeaParser1.activeGPS == true)
					wsprintf(BufferTitle, TEXT("Sat:A"));
				else {
					if (nmeaParser2.activeGPS == true)
						wsprintf(BufferTitle, TEXT("Sat:B"));
					else
						wsprintf(BufferTitle, TEXT("Sat:?"));
				}
			}
			#else
			#ifdef _SIM_ 
  			wsprintf(BufferTitle, TEXT("Sat"));
			wsprintf(BufferValue,TEXT("SIM"));
			#else
			Value=GPS_INFO.SatellitesUsed;
			if (Value<1 || Value>30) {
				wsprintf(BufferValue,TEXT("---"));
			} else {
  				sprintf(text,"%d",(int)Value);
				wsprintf(BufferValue, TEXT("%S"),text);

			}
			if (nmeaParser1.activeGPS == true)
				wsprintf(BufferTitle, TEXT("Sat:A"));
			else {
				if (nmeaParser2.activeGPS == true)
					wsprintf(BufferTitle, TEXT("Sat:B"));
				else
					wsprintf(BufferTitle, TEXT("Sat:?"));
			}

			#endif
			#endif

		#else
		Value=GPS_INFO.SatellitesUsed;
		if (Value<1 || Value>30) {
			wsprintf(BufferValue,TEXT("---"));
 			//TextDisplayMode.AsFlag.Color = TEXTRED;
		}
		else {
		//	if (Value<3)
 		//		TextDisplayMode.AsFlag.Color = TEXTYELLOW;
  			sprintf(text,"%d",(int)Value);
			wsprintf(BufferValue, TEXT("%S"),text);
		}
  		showunit=false;
  		wsprintf(BufferTitle, TEXT("SAT"));
		#endif
		break;
	case BM_ALT:
		#if NEWPNAV
		if (ScreenLandscape)
			showunit=LKFormatValue(LK_ALTERN1_GR, true, BufferValue, BufferUnit, BufferTitle); // 100221
		else
			showunit=LKFormatValue(LK_ALTERN2_GR, true, BufferValue, BufferUnit, BufferTitle); // 100221
		BufferTitle[7]='\0';
		#else
		showunit=LKFormatValue(LK_ALTERN1_GR, true, BufferValue, BufferUnit, BufferTitle); // 100221
		BufferTitle[7]='\0';
		// showunit=false; 100221
		#endif
		break;
	case BM_CUS:
		index=GetInfoboxType(3);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(3,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(3,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  #if OLDSPLITTER
  rcx+=(rc.right/splitter); 
  #else
  rcx+=splitoffset;
  #endif
  #if NEWPNAV
  if (ScreenLandscape) {
	#include "LKMW3include_navbox1.cpp"
  } else {
	#include "LKMW3include_navbox2.cpp"
  }
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(7), rcy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #else
  #include "LKMW3include_navbox1.cpp"
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #endif

  /*
   *   FOURTH VALUE
   */

  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(4,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		showunit=LKFormatValue(LK_NEXT_DIST, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_HAGL, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:  

		showunit=LKFormatValue(LK_HOME_DIST, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_TASK_DISTCOV, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_SYS:
  		wsprintf(BufferTitle, TEXT("HBAR"));
		if (GPS_INFO.BaroAltitudeAvailable) {
			if (EnableNavBaroAltitude)
				wsprintf(BufferValue,TEXT("ON"));
			else
				wsprintf(BufferValue,TEXT("OFF"));
		} else
			wsprintf(BufferValue,TEXT("---"));
  		showunit=false;
		break;
	case BM_ALT:
		#if NEWPNAV
		if (ScreenLandscape) {
			showunit=LKFormatValue(LK_ALTERN1_ARRIV, true, BufferValue, BufferUnit, BufferTitle); // 100221
			wcscpy(BufferTitle,_T("<<<"));
		} else {
			showunit=LKFormatValue(LK_BESTALTERN_ARRIV, true, BufferValue, BufferUnit, BufferTitle); // 100221
			wcscpy(BufferTitle,_T(""));
		}
		#else
		showunit=LKFormatValue(LK_ALTERN1_ARRIV, true, BufferValue, BufferUnit, BufferTitle); // 100221
		wcscpy(BufferTitle,_T("<<<"));
		#endif
		break;
	case BM_CUS:
		index=GetInfoboxType(4);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(4,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(4,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  #if OLDSPLITTER
  rcx+=(rc.right/splitter); 
  #include "LKMW3include_navbox1.cpp"
  #else

  #if NEWPNAV
  if (ScreenLandscape) {
	rcx+=splitoffset;
  }else {
	rcx=rc.left+(splitoffset2/2);
  }
  #include "LKMW3include_navbox1.cpp"
  #else
  rcx+=splitoffset;
  #include "LKMW3include_navbox1.cpp"
  #endif
  #endif
  #if NEWPNAV
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(7), rcy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #else
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #endif

  /*
   *   FIFTH VALUE
   */
  #if NEWPNAV
  if (ScreenLandscape && (splitter<5)) goto EndOfNavboxes;
  #else
  if (splitter<5) goto EndOfNavboxes;
  #endif
  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(5,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU: 
		showunit=LKFormatValue(LK_NEXT_GR, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_FL, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_AUX:
		showunit=LKFormatValue(LK_HOMERADIAL, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;
	case BM_TSK:
// TODO MAKE IT LKPROCESS
  		Value=ALTITUDEMODIFY*CALCULATED_INFO.TaskStartAltitude;
		if (Value>0) {
			sprintf(text,"%d",(int)Value);
			wsprintf(BufferValue, TEXT("%S"),text);
  			wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
		} else {
			wsprintf(BufferValue, TEXT("---"));
			wsprintf(BufferUnit, TEXT(""));
			showunit=false;
		}
 		wsprintf(BufferTitle, TEXT("Start"),text);
		break;
	case BM_SYS:
		showunit=LKFormatValue(LK_EMPTY, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;
	case BM_ALT:
		#if NEWPNAV
		if (ScreenLandscape) {
			showunit=LKFormatValue(LK_ALTERN2_GR, true, BufferValue, BufferUnit, BufferTitle); // 100221
			BufferTitle[7]='\0';
		} else {
			showunit=LKFormatValue(LK_ALTERN1_ARRIV, false, BufferValue, BufferUnit, BufferTitle); // 100221
			wcscpy(BufferTitle,_T(""));
		}
		#else
		showunit=LKFormatValue(LK_ALTERN2_GR, true, BufferValue, BufferUnit, BufferTitle); // 100221
		BufferTitle[7]='\0';
		#endif
		break;
	case BM_CUS:
		index=GetInfoboxType(5);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(5,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(5,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  #if OLDSPLITTER
  rcx+=(rc.right/splitter)-NIBLSCALE(7);  // shorter value
  #include "LKMW3include_navbox1.cpp"
  #else

  #if NEWPNAV
  if (ScreenLandscape) {
	rcx+=splitoffset;
  }else {
	rcx+=splitoffset2;
  }
  #include "LKMW3include_navbox1.cpp"
  #else
  rcx+=splitoffset;
  #include "LKMW3include_navbox1.cpp"
  #endif

  #endif
  #if NEWPNAV
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(3), rcy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #else
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(3), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #endif

  /*
   *   SIXTH VALUE
   */
  #if NEWPNAV
  if (ScreenLandscape && (splitter<6)) goto EndOfNavboxes;
  #else
  if (splitter<6) goto EndOfNavboxes;
  #endif
  showunit=true;
  switch(BottomMode) {
	case BM_TRM:
		index=GetInfoboxIndex(6,dmCircling);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CRU:
		showunit=LKFormatValue(LK_LD_AVR, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_HGH:
		showunit=LKFormatValue(LK_AQNH, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;
	case BM_AUX:
		showunit=LKFormatValue(LK_LD_CRUISE, true, BufferValue, BufferUnit, BufferTitle); // 100221
		break;
	case BM_TSK:
		showunit=LKFormatValue(LK_SPEEDTASK_ACH, true, BufferValue, BufferUnit, BufferTitle);
		break;
	case BM_SYS:
		if (LoggerGActive()) {
  			wsprintf(BufferValue, TEXT("OK"));
		} else {
  			wsprintf(BufferValue, TEXT("NO!"));
		}
  		wsprintf(BufferTitle, TEXT("GRec"));
  		wsprintf(BufferUnit, TEXT("")); // 100221
		showunit=true;
		break;
	case BM_ALT:
		showunit=LKFormatValue(LK_ALTERN2_ARRIV, true, BufferValue, BufferUnit, BufferTitle); // 100221
		#if NEWPNAV
		if (ScreenLandscape)
			wcscpy(BufferTitle,_T("<<<"));
		else
			wcscpy(BufferTitle,_T(""));
		#else
		wcscpy(BufferTitle,_T("<<<"));
		#endif
		break;
	case BM_CUS:
		index=GetInfoboxType(6);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
	case BM_CUS2:
		index=GetInfoboxIndex(6,dmCruise);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;
		
	case BM_CUS3:
		index=GetInfoboxIndex(6,dmFinalGlide);
		showunit=LKFormatValue(index, true, BufferValue, BufferUnit, BufferTitle);
		BufferTitle[7]='\0';
		break;

	default:
		showunit=LKFormatValue(LK_ERROR, true, BufferValue, BufferUnit, BufferTitle);
		break;
  }

  #if OLDSPLITTER
  rcx+=(rc.right/splitter)-NIBLSCALE(11); 
  #include "LKMW3include_navbox1.cpp"
  #else

  #if NEWPNAV
  if (ScreenLandscape) {
	rcx+=splitoffset;
  }else {
	rcx+=splitoffset2;
  }
  #include "LKMW3include_navbox1.cpp"
  #else
  rcx+=splitoffset;
  #include "LKMW3include_navbox1.cpp"
  #endif
  #endif
  #if NEWPNAV
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(3), rcy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #else
  LKWriteText(hdc, BufferTitle, rcx+NIBLSCALE(3), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
  #endif

  /*
   *    CLEAN UP 
   */

EndOfNavboxes:
  #ifndef LKOBJ
  DeleteObject(hB);
  // DeleteObject(hP);  REMOVE 101204
  #else
  ;
  #endif
#if ALPHABLENDING
  #if (WINDOWSPC>0)
  DeleteObject(bitmapnew);
  DeleteDC(hdc2);
  #endif
#endif

} // drawbottom

  #ifdef LKPMODE
  if ( MapSpaceMode != MSM_MAP) goto TheEnd;
  #else
  if (DrawBottom && MapSpaceMode != MSM_MAP) goto TheEnd;
  #endif


  //
  // Draw wind 
  //
  SelectObject(hdc, LK8TargetFont);

  if (Look8000 == lxcNoOverlay) goto afterWind; // 100930

  LKFormatValue(LK_WIND, false, BufferValue, BufferUnit, BufferTitle);
  rcy=ySizeLK8TargetFont;
 
  if (DrawBottom)
  	LKWriteText(hdc, BufferValue, rc.left+NIBLSCALE(5)+leftmargin, rc.bottom - BottomSize- rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);
  else
  	LKWriteText(hdc, BufferValue, rc.left+NIBLSCALE(5)+leftmargin, rc.bottom - rcy-NIBLSCALE(5), 0, WTMODE_OUTLINED,WTALIGN_LEFT,overcolor, true);

afterWind:

   if ( UseMapLock && MapLock ) {
	_stprintf(Buffer,TEXT("MAPLOCK"));
  	SelectObject(hdc, LKMAPFONT); // FIXFONT
  	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	if (DrawBottom)
  		LKWriteText(hdc, Buffer, ((rc.right-rc.left-leftmargin)/2)+leftmargin, rc.bottom - BottomSize- (TextSize.cy/2)-NIBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true);
  	else
  		LKWriteText(hdc, Buffer, ((rc.right-rc.left-leftmargin)/2)+leftmargin,  rc.bottom - (TextSize.cy/2)-NIBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true);

   }
   if ( !MapWindow::IsMapFullScreen() && InfoFocus>=0 ) {

	_stprintf(Buffer,TEXT("IBOX"));
  	SelectObject(hdc, LKMAPFONT); // FIXFONT
  	GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
  	LKWriteText(hdc, Buffer, rc.right - (TextSize.cx)-NIBLSCALE(20) ,  rc.bottom - (TextSize.cy/2)-NIBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_LIGHTGREEN, true);
	if (iboxtoclick) {
		#ifndef DISABLEAUDIO
		if (EnableSoundModes) PlayResource(TEXT("IDR_WAV_CLICK")); 
		#endif
		iboxtoclick=false;
	}
   } 

TheEnd:

  // restore font and return
  SelectObject(hdc, oldfont); 


}

@


1.9
log
@*** empty log message ***
@
text
@d2 3
a4 1
  Copyright_License {
d6 1
a6 32
  LK8000 fork of XCSoar Glide Computer (http://xcsoar.sourceforge.net/
  
  Copyright (C) 2000 - 2010  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

}
a8 2
///:  $Id: LKDrawLook8000.cpp,v 1.8 2010/11/11 00:59:13 root Exp root $

a28 1
//#include "buildnumber.h"
a30 5
/* REMOVE
#define ISPARAGLIDER (AircraftCategory == (AircraftCategory_t)umParaglider)
#define CURTYPE	ModeType[ModeIndex]
#define INVERTCOLORS  (Appearance.InverseInfoBox)
*/
a57 8
/* REMOVE
#ifdef OVERTARGET
extern int GetOvertargetIndex(void);
extern void GetOvertargetName(TCHAR *overtargetname);
extern TCHAR * GetOvertargetHeader(void);
#endif
*/

a80 6
/* REMOVE
#define LKINFOFONT	LK8SmallFont		// was InfoWindowFont
///: km for distance, kmh for speed etc.  in map overlay 
#define LKMAPFONT	LK8MapFont		// was MapWindowFont
*/

a81 3
/*
 * LK8000 interface for XCS by Paolo Ventafridda
 */
a85 1
///  TextInBoxMode_t TextDisplayMode;
d112 1
a112 1
  ///: position Y of text in navboxes
d134 1
a134 1
  ///: This is going to be the START 1/3  name replacing waypoint name when gates are running
d141 2
a151 1
  ///: 100507 flipflop values
a177 1
	///: 101004
a180 1
	///:
a183 4
	///:
	///:SelectObject(hdc, LK8UnitFont); 
	///:GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
	///:int syUnit = TextSize.cy;
d185 1
a185 1
		///: Row1 is the lower, Row2 is the top, for portrait
d229 1
a229 1
				///: ST 1/3
d265 1
a265 1
				///: START 1/3
d270 1
a270 1
				///: STRT 1/3
d275 1
a275 1
				///: STRT 1/3
a306 3
	///: int AIRCRAFTMENUSIZE;
	///: #define _NOCOMPASSINCLUDE
	///: See: #include "./LKinclude_menusize.cpp";
a325 1
  ///: 100413 Set overlay's color  100923 moved here from later declaration
a347 1
  #ifdef LKDRAW_OPTIMIZE
a354 63
  #else
	///:
	///: NOT MORE USED!!!!
	///:
	if ( ScreenSize < (ScreenSize_t)sslandscape ) {
		if ( MapWindow::IsMapFullScreen() ) {
			switch (ScreenSize) {			// portrait fullscreen
				case (ScreenSize_t)ss240x320:
					tlen=6;
					break;
				default:
					tlen=6;
					break;
			}
		} else {
			switch (ScreenSize) {			// portrait not fullscreen
				case (ScreenSize_t)ss240x320:
					tlen=6;
					break;
				default:
					tlen=6;
					break;
			}
		}
	} else  {
		if ( MapWindow::IsMapFullScreen() ) {
			switch (ScreenSize) {			// landscape fullscreen
				case (ScreenSize_t)ss800x480:
				case (ScreenSize_t)ss400x240:
				case (ScreenSize_t)ss480x272:
				case (ScreenSize_t)ss720x408:
					tlen=9;
					break;
				case (ScreenSize_t)ss320x240:
					tlen=8; // 091114 reduced from 9
					break;
				case (ScreenSize_t)ss640x480:
					tlen=8;
					break;
				case (ScreenSize_t)ss896x672:
					tlen=10;
					break;
				default:
					tlen=9;
					break;
			}
		} else {
			switch (ScreenSize) {			// landscape not fullscreen
				case (ScreenSize_t)ss480x272:
				case (ScreenSize_t)ss720x408:
					tlen=7; // 091114 reduced from 9
					break;
				case (ScreenSize_t)ss320x240:
				case (ScreenSize_t)ss640x480:
					tlen=6; // 091114 reduced from 7
					break;
				default:
					tlen=7;
					break;
			}
		}
	}
  #endif // no more used
a358 1
  ///: if (MapWindow::IsMapFullScreen() && LKVarioBar) { // 091111 added Vario for PG 091115 configurable
d367 1
a367 10
  //int yrightoffset=((rc.bottom + rc.top)/2)-NIBLSCALE(10);	// 101112
  

  ///: 100413 Set overlay's color
  ///: 100923 moved earlier
  ///: COLORREF overcolor=0,distcolor=0;
  ///: overcolor=OverColorRef;
  ///: distcolor=OverColorRef;

  ///: 091122 no overlay - but we are still drawing MC and the wind on bottom left!
d370 1
a370 1
  ///: PRINT WP TARGET NAME
a371 1
  ///: if gates in use, no overtargets
d373 1
a373 1
	///: if running a task, use the task index normally
a383 1
	///: if ( index >0 ) BUGFIX 091016
d385 1
a385 1
	///: in overtarget mode, we print the name even when no target. 
d391 1
a391 2
			///: 091123 use ThermalBar flag 
			if (ThermalBar) // 091123 corrected inverted 091125
d411 1
a411 2
		///: 091203 redwarning
		///: OVERTARGET reswp not using redwarning because Reachable is not calculated
d427 1
a427 1
				///: this is set here for the first time, when havegates
d431 1
a431 1
				_tcscpy(Buffer,_T("CLOSED"));
d462 1
a462 2
			///: if we are still painting , it means we did not start yet..so we use colors
			///: if (gatechrono>0) {
a467 1
			///:}
a475 1
		 			///: LKFormatValue(LK_ALT1_DIST, false, BufferValue, BufferUnit, BufferTitle);
a478 1
		 			///: LKFormatValue(LK_ALT2_DIST, false, BufferValue, BufferUnit, BufferTitle);
a481 1
		 			///: LKFormatValue(LK_BALT_DIST, false, BufferValue, BufferUnit, BufferTitle);
a484 1
		 			///: LKFormatValue(LK_LASTTHERMAL_DIST, false, BufferValue, BufferUnit, BufferTitle);
a490 1
		 			///: LKFormatValue(LK_BALT_DIST, false, BufferValue, BufferUnit, BufferTitle);
d504 12
a515 1
		LKWriteText(hdc,BufferValue, rcx+NIBLSCALE(2), rcy+ ySizeLK8TargetFont, 0, WTMODE_OUTLINED, WTALIGN_LEFT, distcolor, true);
d517 1
a517 1
		///: WARNING NOT SUPPORTED ANYMORE TODO FIX
d530 3
a532 1
			#ifdef LKDRAW_OPTIMIZE
d534 1
a534 3
			#else
			 LKWriteText(hdc, BufferUnit, rcx+NIBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-NIBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true); 
			#endif
d537 1
a537 1
		///: DIFF Bearing value displayed only when not circling
a545 1
		 			///: LKFormatValue(LK_ALT1_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
a547 1
		 			///: LKFormatValue(LK_ALT2_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
a550 1
		 			///: LKFormatValue(LK_BALT_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
a553 1
		 			///: LKFormatValue(LK_LASTTHERMAL_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
d624 1
a624 1
			//rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10); REMOVE
a665 1
			///: 091203 warn about obstacles when positive arrivals!
d676 1
a676 1
	///: no valid index for current overmode, but we print something nevertheless
d694 1
a694 1
  ///: 091110 moved out from task paragliders stuff - this is painted on the right
a700 1
			///: gatechrono=GateTime(ActiveGate)-LocalTime(); // set at begininning now
a703 1
			// rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10); REMOVE
a708 2
			///: We don't use ETE now
			///: LKFormatValue(LK_NEXT_ETE, false, BufferValue, BufferUnit, BufferTitle);
a721 4
		///: #if LKDRAW_OPTIMIZE
		///: rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-NIBLSCALE(10);
		///: #else

a722 1
		// rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10);REMOVE
a724 2
		///: #endif

a727 4
		///: if ( ValidTaskPoint(ActiveWayPoint) != false ) 
			///: index = Task[ActiveWayPoint].Index;
			///: if ( index >=0 )

d771 2
a772 2
  ///: In place of MC, print gate time
  ///: Even if lxcNoOverlay, we print startgates..
a776 31
		#if 0 // NO USE ---------------------------
		///: if gate is currently open
		if (gatechrono<0) {
			///: if there are more gates available
			if (ActiveGate<PGNumberOfGates) {
				///: and we are not close to just open
				if (gatechrono<-120) { 
					///: then alternate current and next start
					if (flipflop) {
						Units::TimeToText(BufferTitle,GateTime(ActiveGate)); 
						_stprintf(BufferValue,_T("START %s"),BufferTitle);
					} else {
						Units::TimeToText(BufferTitle,GateTime(ActiveGate+1)); 
						_stprintf(BufferValue,_T("NEXT %s"),BufferTitle);
					}
				} else {
					///: paint only start, do not bother pilot now
					Units::TimeToText(BufferTitle,GateTime(ActiveGate)); 
					_stprintf(BufferValue,_T("START %s"),BufferTitle);
				}
			} else {
				///: there are no more gates, paint only start
				Units::TimeToText(BufferTitle,GateTime(ActiveGate)); 
				_stprintf(BufferValue,_T("START %s"),BufferTitle);
			}
		} else {
			///: gate is closed, so we just paint the start time
			Units::TimeToText(BufferTitle,GateTime(ActiveGate)); 
			_stprintf(BufferValue,_T("START %s"),BufferTitle);
		}
		#else // -------------------------------
a778 1
		#endif
d780 1
a780 1
		_tcscpy(BufferValue,_T("GATES CLOSED"));
a781 1
	// rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-NIBLSCALE(10)-(ySizeLK8MediumFont*2); REMOVE
d786 1
a786 1
	///: USE THIS SPACE FOR MESSAGES TO THE PILOT
d790 1
a790 1
			///: IsInSector works reversed!
d804 1
a804 1
			///: gate is open
d816 1
a816 1
						_tcscpy(BufferValue,_T("GATE OPEN"));
d819 1
a819 1
				_tcscpy(BufferValue,_T("GATE OPEN"));
d828 1
a828 3
  ///: 091122 MC value 
  ///: if (McOverlay) { 100930
  if (McOverlay && Look8000>lxcNoOverlay) {
d831 1
a831 2
	#if LKDRAW_OPTIMIZE
	// rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-NIBLSCALE(10)-ySizeLK8BigFont; REMOVE
a832 4
	#else
	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10)-TextSize.cy;
	#endif
a838 3


  ///: if ( (Look8000==(Look8000_t)lxcAdvanced) || ISPARAGLIDER ) { 091115 lxcStandard available for PG also
a842 2
		// LKFormatValue(LK_VARIO, false, BufferValue, BufferUnit, BufferTitle);
		///: 091203 TODO this is NOT HGPS really, since NavAltitude uses Baro is available
a849 1
//	#ifndef LKDRAW_OPTIMIZE
a850 2
//	#endif
	///: rcx=rc.left+IBLSCALE(1)+leftmargin+GlideBarOffset;   // 091110
a854 9
	///: if (ISPARAGLIDER) BUGFIX VarioBar Y position 100215
/*
	#if LKDRAW_OPTIMIZE
	if (ISPARAGLIDER||LKVarioBar)
		rcy=(rc.bottom + rc.top-BottomSize)/2 -ySizeLK8BigFont-NIBLSCALE(5);
	else
		rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-NIBLSCALE(10);
	#else
*/
a858 1
//	#endif
d868 1
a871 2
	///: rcx+=IBLSCALE(9); 091115

d909 1
d917 1
d937 1
a937 2
  HPEN hP;
  // HBRUSH hB,bB; REMOVE 090927
d941 3
a943 1
  	hB = LKBrush_Ndark;
d946 1
a947 1
	hP = (HPEN)CreatePen(PS_SOLID,0,RGB_YELLOW);
d951 1
d954 1
a955 1
	hP = (HPEN)CreatePen(PS_SOLID,0,RGB_BLACK);
d989 1
a989 5

  ///:
  ///: NAVBOXES
  ///:

a1015 1
		///: showunit=LKFormatValue(LK_TC_AVG, true, BufferValue, BufferUnit, BufferTitle);
a1039 1
		///: showunit=false; 100221
a1106 13
		///: 100221 old battery temperature, with no infobox for it
		/*
		Value=PDABatteryTemperature;
		if (Value<1||Value>100) {
  			wsprintf(BufferValue, TEXT("----"));
		}
		else {
			sprintf(text,"%.0lf",Value);
  			wsprintf(BufferValue, TEXT("%S%S"),text,_T(DEG));
		}
		showunit=false;
  		wsprintf(BufferTitle, TEXT("Btemp"),text);
		*/
a1180 1
		///: showunit=false; 100221
a1183 1
		///: showunit=false; 091222
a1315 1
		///: showunit=LKFormatValue(LK_TC_GAIN, true, BufferValue, BufferUnit, BufferTitle);
a1329 1
		///: showunit=LKFormatValue(LK_EMPTY, true, BufferValue, BufferUnit, BufferTitle); // 100221
a1383 1
	///: #include "LKMW3include_navbox1.cpp"
a1384 1
	///: New raw!
a1385 1
	///: #include "LKMW3include_navbox2.cpp" moved up to bottom (row1)
a1412 1
		///: LKFormatValue(LK_TC_30S, true, BufferValue, BufferUnit, BufferTitle);
a1415 1
		///: showunit=false; 100221
a1421 1
		///: showunit=false; 100221
a1451 1
		///: showunit=false; 100221
a1483 1
	///: #include "LKMW3include_navbox1.cpp"
a1485 1
	///: #include "LKMW3include_navbox2.cpp"
a1510 1
		///: showunit=LKFormatValue(LK_VARIO, true, BufferValue, BufferUnit, BufferTitle);
a1519 1
		///: showunit=false; 100221
a1522 1
		///: showunit=false; 100221
a1577 1
	///: #include "LKMW3include_navbox1.cpp"
a1579 1
	///: #include "LKMW3include_navbox2.cpp"
d1600 3
a1603 1
  DeleteObject(hP);
a1612 1
  ///: Do not draw wind, IBOX, LOCKED infos when in special menus
a1622 1
  ///: 100930 dont draw if no overlays please
a1627 1
  #ifdef LKDRAW_OPTIMIZE
a1628 4
  #else
  GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
  rcy=TextSize.cy;
  #endif
a1630 1
  	///: LKWriteText(hdc, BufferValue, rc.left+NIBLSCALE(5)+leftmargin, rc.bottom - BottomSize- rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);  FIXED with overcolors 100923
a1632 1
  	///: LKWriteText(hdc, BufferValue, rc.left+NIBLSCALE(5)+leftmargin, rc.bottom - rcy-NIBLSCALE(5), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true); 100923
a1641 1
  		///: LKWriteText(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2)-NIBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true); 091110
a1643 1
  		///: LKWriteText(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2)-NIBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true); 091110
@


1.8
log
@*** empty log message ***
@
text
@d38 1
a38 1
///:  $Id: LKDrawLook8000.cpp,v 1.7 2010/10/04 14:00:11 root Exp root $
d61 1
d393 5
d496 3
d766 2
a767 1
			rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10);
d848 2
a849 1
			rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10);
d874 2
a875 1
		rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10);
d972 2
a973 1
	rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-NIBLSCALE(10)-(ySizeLK8MediumFont*2);
d991 3
d1025 2
a1026 1
	rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-NIBLSCALE(10)-ySizeLK8BigFont;
d1156 3
d1160 1
d1163 3
d1167 1
d1424 23
d1469 1
d1848 1
d1850 1
@


1.7
log
@*** empty log message ***
@
text
@d38 1
a38 1
///:  $Id: LKDrawLook8000.cpp,v 1.6 2010/09/16 11:14:41 root Exp root $
d165 10
d177 3
d181 3
d230 50
d283 3
d287 1
d293 3
d297 1
d303 3
d307 1
d311 3
d315 1
d323 1
d349 1
d369 11
d383 1
d444 1
d463 1
d706 6
d713 1
d1031 4
a1034 1
		LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);
d1098 1
d1107 1
d1146 1
a1146 1
#if ALPHABLENDING
d1165 10
d1264 9
a1272 1
#include "LKMW3include_navbox1.cpp"
d1274 1
d1317 9
d1328 1
d1357 9
a1365 1
#include "LKMW3include_navbox1.cpp"
d1367 1
a1367 1

d1439 7
d1449 1
d1478 9
a1486 1
#include "LKMW3include_navbox1.cpp"
d1488 1
d1516 10
a1525 2
		showunit=LKFormatValue(LK_EMPTY, true, BufferValue, BufferUnit, BufferTitle); // 100221
		///: showunit=false; 100221
d1528 9
d1539 1
d1565 13
d1580 1
d1582 4
a1585 1
#include "LKMW3include_navbox1.cpp"
d1587 1
a1587 1

d1592 3
a1594 1

d1596 1
d1634 9
d1646 1
d1672 12
d1686 3
d1690 3
a1692 1
#include "LKMW3include_navbox1.cpp"
d1694 1
a1694 1

d1699 3
a1701 1

d1703 1
d1738 6
d1745 1
d1771 12
d1785 2
d1788 3
a1790 1
#include "LKMW3include_navbox1.cpp"
d1792 1
a1792 1

@


1.6
log
@*** empty log message ***
@
text
@d38 1
a38 1
///:  $Id: LKDrawLook8000.cpp,v 1.5 2010/05/06 13:11:18 root Exp root $
d94 8
d177 1
a177 1
	if (NewMap==false) return;
d180 2
a181 2
	redwarning=false;
	oldfont = (HFONT)SelectObject(hdc, LKINFOFONT); // FIXFONT
d183 4
a186 2
	if ( IsMapFullScreen() && !EnablePan ) DrawBottom=true; // TODO maybe also !TargetPan
		else DrawBottom=false;
d188 5
a192 5
	///: 100507 flipflop values
	if ( ++flipflopcount >2 ) {
		flipflop = !flipflop;
		flipflopcount=0;
	}
d194 1
a194 1
    	if (doinit) {
d196 11
a206 7
		TCHAR Tdummy[]=_T("T");
		#ifndef OLDSPLITTER
		int iconsize;
		#endif
		SelectObject(hdc, LK8BigFont); 
		GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
		ySizeLK8BigFont = TextSize.cy;
d208 3
a210 7
		SelectObject(hdc, LK8TargetFont); 
		GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
		ySizeLK8TargetFont = TextSize.cy;

		SelectObject(hdc, LK8MediumFont); 
		GetTextExtentPoint(hdc, Tdummy, _tcslen(Tdummy), &TextSize);
		ySizeLK8MediumFont = TextSize.cy;
d212 2
a213 1
		// All these values are fine tuned for font/resolution/screenmode.
d215 21
a235 21
			switch (ScreenSize) {			// portrait fullscreen
				case (ScreenSize_t)ss240x320:
					tlenFullScreen=6;
					///: ST 1/3
					_tcscpy(StartGateNameFS,_T("ST "));
					break;
				default:
					_tcscpy(StartGateNameFS,_T("ST "));
					tlenFullScreen=6;
					break;
			}
			switch (ScreenSize) {			// portrait not fullscreen
				case (ScreenSize_t)ss240x320:
					_tcscpy(StartGateNameHS,_T("ST "));
					tlenHalfScreen=6;
					break;
				default:
					_tcscpy(StartGateNameHS,_T("ST "));
					tlenHalfScreen=6;
					break;
			}
d237 42
a278 42
			switch (ScreenSize) {			// landscape fullscreen
				case (ScreenSize_t)ss800x480:
				case (ScreenSize_t)ss400x240:
				case (ScreenSize_t)ss480x272:
					///: START 1/3
					_tcscpy(StartGateNameFS,_T("Start "));
					tlenFullScreen=9;
					break;
				case (ScreenSize_t)ss320x240:
					///: STRT 1/3
					_tcscpy(StartGateNameFS,_T("Start "));
					tlenFullScreen=8; // 091114 reduced from 9
					break;
				case (ScreenSize_t)ss640x480:
					///: STRT 1/3
					_tcscpy(StartGateNameFS,_T("Start "));
					tlenFullScreen=8;
					break;
				case (ScreenSize_t)ss896x672:
					_tcscpy(StartGateNameFS,_T("Start "));
					tlenFullScreen=10;
					break;
				default:
					_tcscpy(StartGateNameFS,_T("Start "));
					tlenFullScreen=9;
					break;
			}
			switch (ScreenSize) {			// landscape not fullscreen
				case (ScreenSize_t)ss480x272:
					_tcscpy(StartGateNameHS,_T("ST "));
					tlenHalfScreen=7; // 091114 reduced from 9
					break;
				case (ScreenSize_t)ss320x240:
				case (ScreenSize_t)ss640x480:
					_tcscpy(StartGateNameHS,_T("ST "));
					tlenHalfScreen=6; // 091114 reduced from 7
					break;
				default:
					_tcscpy(StartGateNameHS,_T("ST "));
					tlenHalfScreen=7;
					break;
			}
d281 7
a287 7
		#ifndef OLDSPLITTER
		///: int AIRCRAFTMENUSIZE;
		///: #define _NOCOMPASSINCLUDE
		///: See: #include "./LKinclude_menusize.cpp";
		iconsize=NIBLSCALE(26);
		splitoffset= ((rc.right-iconsize)-rc.left)/splitter;
		#endif
d289 7
a295 2
		doinit=false; 
	}
d298 4
a301 4
        if ( MapSpaceMode!= MSM_MAP) {
		DrawMapSpace(hdc, rc);
		goto Drawbottom;
	}
d303 4
a306 4
        if (DrawBottom && MapSpaceMode!= MSM_MAP) {
		DrawMapSpace(hdc, rc);
		goto Drawbottom;
	}
d310 9
a318 9
	#ifdef LKDRAW_OPTIMIZE
	if ( MapWindow::IsMapFullScreen() ) {
		tlen=tlenFullScreen;
		_tcscpy(StartGateName,StartGateNameFS);
	} else {
		tlen=tlenHalfScreen;
		_tcscpy(StartGateName,StartGateNameHS);
	}
	#else
d378 1
a378 1
	#endif
d393 4
a396 3
  COLORREF overcolor,distcolor;
  overcolor=OverColorRef;
  distcolor=OverColorRef;
d398 1
a398 1
  ///: 091122 no overlay - we are still drawing MC and the wind on bottom left!
d401 13
d415 18
a432 21
     index = Task[ActiveWayPoint].Index;
     ///: if ( index >0 ) BUGFIX 091016
     if ( index >=0 )
     {
  	if (DisplayMode != dmCircling) 
	{
	  rcx=rc.left+leftmargin+NIBLSCALE(1);
	  rcy=rc.top+NIBLSCALE(1);
	} else {
/*
	///: 091110 no need to display Thermal Band profile for para!
	  if (ISPARAGLIDER)
	  	rcx=rc.left+leftmargin+NIBLSCALE(1);
	  else
	  	rcx=rc.left+leftmargin+NIBLSCALE(40);
*/
	///: 091123 use ThermalBar flag 
	if (ThermalBar) // 091123 corrected inverted 091125
	  	rcx=rc.left+leftmargin+NIBLSCALE(40);
	  else
	  	rcx=rc.left+leftmargin+NIBLSCALE(1);
d434 7
a440 24
	  rcy=rc.top+NIBLSCALE(1);
	}

	// Waypoint name and distance

	SelectObject(hdc, LK8TargetFont);

#if 0
	// Active colours
	if (WayPointList[index].Reachable) {
		TextDisplayMode.AsFlag.Color = TEXTGREEN; 
	} else {
		TextDisplayMode.AsFlag.Color = TEXTRED;
	}
#endif
	///: 091203 redwarning
	if (WayPointCalc[index].AltArriv[AltArrivMode]>0 && !WayPointList[index].Reachable ) redwarning=true;
	else redwarning=false;

	int gateinuse=-2;
	if (UseGates() && ActiveWayPoint==0) {
		gateinuse=ActiveGate;
		if (!HaveGates()) {
			gateinuse=-1;
d442 1
a442 2
			///: this is set here for the first time, when havegates
			gatechrono=GateTime(ActiveGate)-LocalTime();
d444 10
a453 4
		if (gateinuse<0) {
			_tcscpy(Buffer,_T("CLOSED"));
		} else {
			_stprintf(Buffer,_T("%s%d/%d"),StartGateName,gateinuse+1,PGNumberOfGates);
d456 16
a471 6
	 	LKWriteText(hdc,Buffer, rcx+NIBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
	} else {
		///: TODO MAKE IT AN LKPROCESS
		wlen=wcslen(WayPointList[index].Name);
 		if (wlen>tlen) {
 		 	_tcsncpy(Buffer, WayPointList[index].Name, tlen); Buffer[tlen]='\0';
d473 20
a492 1
 		 	_tcsncpy(Buffer, WayPointList[index].Name, wlen); Buffer[wlen]='\0';
d495 4
a498 8
 		 ConvToUpper(Buffer);
		 LKWriteText(hdc,Buffer, rcx+NIBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
	}

	 #ifdef LKDRAW_OPTIMIZE
	 if (gateinuse>=-1) {
		///: if we are still painting , it means we did not start yet..so we use colors
		///: if (gatechrono>0) {
d504 50
a553 13
		///:}
	 	LKFormatValue(LK_START_DIST, false, BufferValue, BufferUnit, BufferTitle);
	 } else {
	 	LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
	 }
	LKWriteText(hdc,BufferValue, rcx+NIBLSCALE(2), rcy+ ySizeLK8TargetFont, 0, WTMODE_OUTLINED, WTALIGN_LEFT, distcolor, true);
	 #else
	///: WARNING NOT SUPPORTED ANYMORE TODO FIX
 	 GetTextExtentPoint(hdc, Buffer, _tcslen(Buffer), &TextSize);
	 if (gateinuse>=-1)
	 	LKFormatValue(LK_START_DIST, false, BufferValue, BufferUnit, BufferTitle);
	 else
	 	LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
d555 2
a556 2
	 LKWriteText(hdc,BufferValue, rcx+NIBLSCALE(2), rcy+TextSize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
	 #endif
d558 9
a566 17
 	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize2);
	if (!HideUnits) {
	 SelectObject(hdc, LKMAPFONT); // TODO FIX BUG here.. using different font from size
	#ifdef LKDRAW_OPTIMIZE
	 LKWriteText(hdc, BufferUnit, rcx+NIBLSCALE(4)+TextSize2.cx,rcy+ySizeLK8TargetFont+(ySizeLK8TargetFont/3)-NIBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true); 
	#else
	 LKWriteText(hdc, BufferUnit, rcx+NIBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-NIBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true); 
	#endif
	}

	///: DIFF Bearing value displayed only when not circling
  	if (DisplayMode != dmCircling) 
	{
		LKFormatValue(LK_BRGDIFF, false, BufferValue, BufferUnit, BufferTitle);
		SelectObject(hdc, LK8BigFont);
		LKWriteText(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ NIBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, overcolor, true);
       }
d568 42
d617 31
d649 1
d660 31
d692 1
d703 18
a720 1
    } // valid taskpoint
d747 60
a806 26
	SelectObject(hdc, LK8BigFont); // use this font for big values
  	if (DisplayMode == dmCircling)
		LKFormatValue(LK_TC_30S, false, BufferValue, BufferUnit, BufferTitle);
	else
		LKFormatValue(LK_LD_AVR, false, BufferValue, BufferUnit, BufferTitle);
/*
	#if LKDRAW_OPTIMIZE
	rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-NIBLSCALE(10);
	#else
*/
	GetTextExtentPoint(hdc, BufferValue, _tcslen(BufferValue), &TextSize);
	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-NIBLSCALE(10);
//	#endif
	rcx=rc.right-NIBLSCALE(10);
	LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, overcolor, true);
/*
  if ( ValidTaskPoint(ActiveWayPoint) != false ) 
     index = Task[ActiveWayPoint].Index;
     if ( index >=0 )
*/
	// Altitude difference with current MC
	LKFormatValue(LK_NEXT_ALTDIFF, false, BufferValue, BufferUnit, BufferTitle);
	if (redwarning)
		LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_RED, true);
	else
		LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,overcolor, true);
d809 1
a809 1
  }
d813 1
d899 2
a900 1
  if (McOverlay) {
d1566 1
d1569 2
d1580 2
a1581 1
  	LKWriteText(hdc, BufferValue, rc.left+NIBLSCALE(5)+leftmargin, rc.bottom - BottomSize- rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d1583 4
a1586 1
  	LKWriteText(hdc, BufferValue, rc.left+NIBLSCALE(5)+leftmargin, rc.bottom - rcy-NIBLSCALE(5), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d1621 1
@


1.5
log
@pre gates
@
text
@d2 34
a35 1
  $Id: LKDrawLook8000.cpp,v 1.4 2010/04/13 15:28:30 root Exp root $
d38 2
d68 1
d72 1
d142 1
d147 2
d153 1
d157 3
d164 5
d178 5
d187 3
d198 3
d207 2
d211 1
d217 1
d221 1
d230 2
d235 2
d240 2
d245 1
d249 1
d255 1
d260 1
d264 1
d270 7
a276 8








d281 6
a286 1

d291 1
d295 7
a301 1
	if ( MapWindow::IsMapFullScreen() ) tlen=tlenFullScreen; else tlen=tlenHalfScreen;
d303 3
a305 2
	// TODO make a table out of these values when they are confirmed and avoid calculating them each time
	// All these values are fine tuned for font/resolution/screenmode.
d377 1
a377 1
  COLORREF overcolor;
d379 1
d426 16
a441 4
	///: TODO MAKE IT AN LKPROCESS
	wlen=wcslen(WayPointList[index].Name);
 	if (wlen>tlen) {
 	 	_tcsncpy(Buffer, WayPointList[index].Name, tlen); Buffer[tlen]='\0';
d443 10
a452 1
 	 	_tcsncpy(Buffer, WayPointList[index].Name, wlen); Buffer[wlen]='\0';
a454 2
 	 ConvToUpper(Buffer);
	 LKWriteText(hdc,Buffer, rcx+NIBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
d456 14
a469 2
	 LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
	 LKWriteText(hdc,BufferValue, rcx+NIBLSCALE(2), rcy+ ySizeLK8TargetFont, 0, WTMODE_OUTLINED, WTALIGN_LEFT, overcolor, true);
d471 1
d473 5
a477 1
	 LKFormatValue(LK_NEXT_DIST, false, BufferValue, BufferUnit, BufferTitle);
d532 23
d581 2
d586 85
d808 2
a809 1
#if (WINDOWSPC>0)
d822 3
d911 1
d913 3
d985 1
d987 3
d1090 1
d1092 3
d1153 1
a1153 1

d1155 3
d1230 1
a1230 1

d1232 3
d1302 1
a1302 1

d1304 3
d1318 2
a1319 1
#if (WINDOWSPC>0)
d1322 1
d1328 3
d1332 1
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: LKDrawLook8000.cpp,v 1.3 2010/02/22 01:21:34 root Exp root $
d288 4
d346 1
a346 1
	 LKWriteText(hdc,Buffer, rcx+NIBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d349 1
a349 1
	 LKWriteText(hdc,BufferValue, rcx+NIBLSCALE(2), rcy+ ySizeLK8TargetFont, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d353 1
a353 1
	 LKWriteText(hdc,BufferValue, rcx+NIBLSCALE(2), rcy+TextSize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d360 1
a360 1
	 LKWriteText(hdc, BufferUnit, rcx+NIBLSCALE(4)+TextSize2.cx,rcy+ySizeLK8TargetFont+(ySizeLK8TargetFont/3)-NIBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 
d362 1
a362 1
	 LKWriteText(hdc, BufferUnit, rcx+NIBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-NIBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 
d371 1
a371 1
		LKWriteText(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ NIBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, true);
d389 1
a389 1
				LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE, true);
d399 1
a399 1
					WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d421 1
a421 1
	LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE, true);
d432 1
a432 1
		LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d447 1
a447 1
	LKWriteText(hdc, BufferValue, rcx,rcy, 0, WTMODE_OUTLINED, WTALIGN_RIGHT, RGB_WHITE, true);
d489 1
a489 1
		LKWriteText(hdc, BufferValue, rcx, rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d492 1
a492 1
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+NIBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d496 1
a496 1
		LKWriteText(hdc, BufferValue, rcx+NIBLSCALE(9), rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d507 1
a507 1
		LKWriteText(hdc, BufferValue, rcx,rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d510 1
a510 1
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+NIBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d518 1
a518 1
	LKWriteText(hdc, BufferValue, rcx,rcy-NIBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d521 1
a521 1
		LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+NIBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d530 1
a530 1
			LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(10),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d533 1
a533 1
			LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(27),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d538 1
a538 1
			LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(30),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d541 1
a541 1
			LKWriteText(hdc, BufferValue, rc.right-NIBLSCALE(28),rc.top+NIBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
@


1.3
log
@prefix showunit
@
text
@d2 1
a2 1
  $Id: LKDrawLook8000.cpp,v 1.2 2010/02/19 00:08:55 root Exp root $
d281 1
a281 1
	leftmargin=(LKVarioSize+IBLSCALE(3)); // VARIOWIDTH + middle separator right extension
d298 2
a299 2
	  rcx=rc.left+leftmargin+IBLSCALE(1);
	  rcy=rc.top+IBLSCALE(1);
d304 1
a304 1
	  	rcx=rc.left+leftmargin+IBLSCALE(1);
d306 1
a306 1
	  	rcx=rc.left+leftmargin+IBLSCALE(40);
d310 1
a310 1
	  	rcx=rc.left+leftmargin+IBLSCALE(40);
d312 1
a312 1
	  	rcx=rc.left+leftmargin+IBLSCALE(1);
d314 1
a314 1
	  rcy=rc.top+IBLSCALE(1);
d342 1
a342 1
	 LKWriteText(hdc,Buffer, rcx+IBLSCALE(2), rcy,0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d345 1
a345 1
	 LKWriteText(hdc,BufferValue, rcx+IBLSCALE(2), rcy+ ySizeLK8TargetFont, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d349 1
a349 1
	 LKWriteText(hdc,BufferValue, rcx+IBLSCALE(2), rcy+TextSize.cy, 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true);
d356 1
a356 1
	 LKWriteText(hdc, BufferUnit, rcx+IBLSCALE(4)+TextSize2.cx,rcy+ySizeLK8TargetFont+(ySizeLK8TargetFont/3)-IBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 
d358 1
a358 1
	 LKWriteText(hdc, BufferUnit, rcx+IBLSCALE(4)+TextSize2.cx,rcy+TextSize.cy+(TextSize.cy/3)-IBLSCALE(1), 0, WTMODE_OUTLINED, WTALIGN_LEFT, RGB_WHITE, true); 
d367 1
a367 1
		LKWriteText(hdc, BufferValue, (rc.right+rc.left)/2, rc.top+ IBLSCALE(15), 0, WTMODE_OUTLINED, WTALIGN_CENTER, RGB_WHITE, true);
d380 2
a381 2
			rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
			rcx=rc.right-IBLSCALE(10);
d391 1
a391 1
				LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, 
d394 1
a394 1
				LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, 
d410 1
a410 1
	rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-IBLSCALE(10);
d414 1
a414 1
	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
d416 1
a416 1
	rcx=rc.right-IBLSCALE(10);
d426 1
a426 1
		LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_RED, true);
d428 1
a428 1
		LKWriteText(hdc, BufferValue, rcx,rcy+TextSize.cy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d437 1
a437 1
	rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-IBLSCALE(10)-ySizeLK8BigFont;
d440 1
a440 1
	rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10)-TextSize.cy;
d442 1
a442 1
	rcx=rc.right-IBLSCALE(10);
d466 1
a466 1
		rcx=rc.left+IBLSCALE(10)+leftmargin+GlideBarOffset;   // 091115
d468 1
a468 1
		rcx=rc.left+IBLSCALE(10)+leftmargin;   // 091115
d473 1
a473 1
		rcy=(rc.bottom + rc.top-BottomSize)/2 -ySizeLK8BigFont-IBLSCALE(5);
d475 1
a475 1
		rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-IBLSCALE(10);
d479 1
a479 1
		rcy=(rc.bottom + rc.top-BottomSize)/2 -TextSize.cy-IBLSCALE(5);
d481 1
a481 1
		rcy=(rc.bottom + rc.top)/2 -TextSize.cy-IBLSCALE(10);
d485 1
a485 1
		LKWriteText(hdc, BufferValue, rcx, rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d488 1
a488 1
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d492 1
a492 1
		LKWriteText(hdc, BufferValue, rcx+IBLSCALE(9), rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d503 1
a503 1
		LKWriteText(hdc, BufferValue, rcx,rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d506 1
a506 1
			LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d514 1
a514 1
	LKWriteText(hdc, BufferValue, rcx,rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d517 1
a517 1
		LKWriteText(hdc, BufferUnit, rcx+TextSize.cx+IBLSCALE(2),rcy+(TextSize.cy/3), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d526 1
a526 1
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(10),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d529 1
a529 1
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(27),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d534 1
a534 1
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(30),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d537 1
a537 1
			LKWriteText(hdc, BufferValue, rc.right-IBLSCALE(28),rc.top+IBLSCALE(1), 0, WTMODE_OUTLINED,WTALIGN_RIGHT,RGB_WHITE, true);
d636 1
a636 1
		LKFormatValue(LK_BATTERY, true, BufferValue, BufferUnit, BufferTitle);
d640 1
a640 1
		LKFormatValue(LK_BESTALTERN_GR, true, BufferValue, BufferUnit, BufferTitle);
d642 1
a642 1
		showunit=false;
d668 1
a668 1
  rcx=rc.left+(rc.right/(splitter*2))-IBLSCALE(5); // FIX make it static in doinit
d670 1
a670 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
d689 2
a690 2
		showunit=LKFormatValue(LK_ODOMETER, true, BufferValue, BufferUnit, BufferTitle); // 091221
		// showunit=false; 091221
d693 1
a693 1
		LKFormatValue(LK_FIN_ALTDIFF, true, BufferValue, BufferUnit, BufferTitle);
d696 1
a696 1
		LKFormatValue(LK_EXTBATT1VOLT, true, BufferValue, BufferUnit, BufferTitle);
d740 1
a740 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
d755 1
a755 1
		LKFormatValue(LK_HNAV, true, BufferValue, BufferUnit, BufferTitle);
d761 2
a762 2
		LKFormatValue(LK_TIMEFLIGHT, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
d771 2
a772 1
  		showunit=false;
d813 1
a813 1
		LKFormatValue(LK_ALTERN1_GR, true, BufferValue, BufferUnit, BufferTitle);
d815 1
a815 1
		showunit=false;
d841 1
a841 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
d869 2
a870 2
		LKFormatValue(LK_EMPTY, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
d873 1
a873 1
		LKFormatValue(LK_ALTERN1_ARRIV, true, BufferValue, BufferUnit, BufferTitle);
d901 1
a901 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(7), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
d918 2
a919 2
		LKFormatValue(LK_NEXT_GR, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
d925 2
a926 2
		LKFormatValue(LK_HOMERADIAL, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
d934 2
a935 1
		} else
d937 3
a939 2

  		wsprintf(BufferUnit, TEXT("%s"),(Units::GetAltitudeName()));
d943 1
a943 1
		LKFormatValue(LK_EMPTY, true, BufferValue, BufferUnit, BufferTitle);
d946 1
a946 1
		LKFormatValue(LK_ALTERN2_GR, true, BufferValue, BufferUnit, BufferTitle);
d948 1
a948 1
		showunit=false;
d973 1
a973 1
  rcx+=(rc.right/splitter)-IBLSCALE(7);  // shorter value
d975 1
a975 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
d995 2
a996 2
		LKFormatValue(LK_AQNH, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
d999 2
a1000 2
		LKFormatValue(LK_LD_CRUISE, true, BufferValue, BufferUnit, BufferTitle);
		showunit=false;
d1012 2
a1013 1
		showunit=false;
d1016 1
a1016 1
		LKFormatValue(LK_ALTERN2_ARRIV, true, BufferValue, BufferUnit, BufferTitle);
d1042 1
a1042 1
  rcx+=(rc.right/splitter)-IBLSCALE(11); 
d1044 1
a1044 1
  LKWriteText(hdc, BufferTitle, rcx+IBLSCALE(3), rcy-TextSize.cy, 0, WTMODE_NORMAL,WTALIGN_CENTER,RGB_WHITE, false);
d1079 1
a1079 1
  	LKWriteText(hdc, BufferValue, rc.left+IBLSCALE(5)+leftmargin, rc.bottom - BottomSize- rcy-IBLSCALE(2), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d1081 1
a1081 1
  	LKWriteText(hdc, BufferValue, rc.left+IBLSCALE(5)+leftmargin, rc.bottom - rcy-IBLSCALE(5), 0, WTMODE_OUTLINED,WTALIGN_LEFT,RGB_WHITE, true);
d1088 2
a1089 2
  		///: LKWriteText(hdc, Buffer, (rc.right-rc.left)/2, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true); 091110
  		LKWriteText(hdc, Buffer, ((rc.right-rc.left-leftmargin)/2)+leftmargin, rc.bottom - BottomSize- (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true);
d1091 2
a1092 2
  		///: LKWriteText(hdc, Buffer, (rc.right-rc.left)/2,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true); 091110
  		LKWriteText(hdc, Buffer, ((rc.right-rc.left-leftmargin)/2)+leftmargin,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_WHITE, true);
d1100 1
a1100 1
  	LKWriteText(hdc, Buffer, rc.right - (TextSize.cx)-IBLSCALE(20) ,  rc.bottom - (TextSize.cy/2)-IBLSCALE(2) , 0, WTMODE_OUTLINED,WTALIGN_CENTER,RGB_LIGHTGREEN, true);
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
  $Id: LKDrawLook8000.cpp,v 1.1 2010/02/15 14:34:01 root Exp root $
d62 3
a378 3
			#ifdef LDDRAW_OPTIMIZE
			rcy=(rc.bottom + rc.top)/2 -ySizeLK8BigFont-IBLSCALE(10);
			#else
a380 1
			#endif
d408 1
a408 1

d412 1
d415 1
a415 1
	#endif
d461 1
a461 1
	#ifndef LKDRAW_OPTIMIZE
d463 1
a463 1
	#endif
d470 1
d477 1
d482 1
a482 1
	#endif
d696 3
a698 1
		// TODO MAKE ENTRY IN LKPROCESS
d709 1
d770 26
d809 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
  $Id$
d106 10
a115 1
  static short tlen;
a122 2
	//if ( InfoBoxLayout::landscape && IsMapFullScreen() && !EnablePan ) DrawBottom=true;

d126 78
d210 3
a212 3
    	if (doinit) {
		doinit=false; // TODO OPTIMIZE ALL
	}
d271 1
d340 4
a344 1

d347 1
d351 4
a354 1
	 SelectObject(hdc, LKMAPFONT); // FIXFONT
d356 1
d376 3
d381 1
d410 3
d415 1
d436 3
d441 1
d461 1
d463 1
d469 8
a476 1
	if (ISPARAGLIDER)
d480 1
d1035 3
d1040 1
@
