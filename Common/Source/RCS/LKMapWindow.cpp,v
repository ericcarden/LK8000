head	1.6;
access;
symbols;
locks
	root:1.6; strict;
comment	@// @;


1.6
date	2010.12.11.19.20.55;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2010.11.25.00.10.10;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2010.08.20.12.51.14;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.17.20.40.26;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.11.12.07.32;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.24.19.22.32;	author root;	state Exp;
branches;
next	;


desc
@1.15a
@


1.6
log
@*** empty log message ***
@
text
@/*
   LK8000 Tactical Flight Computer -  WWW.LK8000.IT
   Released under GNU/GPL License v.2
   See CREDITS.TXT file for authors and copyrights

   $Id: LKMapWindow.cpp,v 1.5 2010/11/25 00:10:10 root Exp root $
*/


#include "StdAfx.h"
#include "compatibility.h"
#include "options.h"
#include "Defines.h"

#include "MapWindow.h"
#include "OnLineContest.h"
#include "Utils.h"
#include "XCSoar.h"
#include "LKUtils.h"
#include "Utils2.h"
#include "Units.h"
#include "Logger.h"
#include "McReady.h"
#include "Airspace.h"
#include "Waypointparser.h"
#include "Dialogs.h"
#include "externs.h"
#include "VarioSound.h"
#include "InputEvents.h"
#include <windows.h>
#include <math.h>

#include <tchar.h>

#include "Task.h"

#include "Terrain.h"
#include "RasterTerrain.h"

#include "GaugeVarioAltA.h"
#include "GaugeCDI.h"
#include "GaugeFLARM.h"
#include "InfoBoxLayout.h"
#include "LKMapWindow.h"
#if LKOBJ
#include "LKObjects.h"
#endif

#if (WINDOWSPC>0)
#include <wingdi.h>
#endif


extern HWND hWndCDIWindow;
extern HFONT MapLabelFont;
extern HFONT  MapWindowBoldFont;

#define ISPARAGLIDER (AircraftCategory == (AircraftCategory_t)umParaglider)
#define INVERTCOLORS  (Appearance.InverseInfoBox)


// This is painting traffic icons on the screen.
void MapWindow::LKDrawFLARMTraffic(HDC hDC, RECT rc, POINT Orig_Aircraft) {

  if (!EnableFLARMMap) return;

  if (!DrawInfo.FLARM_Available) return;

  // init scaled coords for traffic icon
  static bool doinit=true;
  static short scaler[5];
  static short tscaler=0;
  if (doinit) {

	switch (ScreenSize) {
		case ss480x640:
		case ss480x800:
		case ss896x672:
		case ss800x480:
		case ss640x480:
			scaler[0]=-1*(NIBLSCALE(4)-2);
			scaler[1]=NIBLSCALE(5)-2;
			scaler[2]=-1*(NIBLSCALE(6)-2);
			scaler[3]=NIBLSCALE(4)-2;
			scaler[4]=NIBLSCALE(2)-2;
			tscaler=NIBLSCALE(7)-2;
			break;
		case ss240x320:
		case ss272x480:
		case ss320x240:
		case ss480x272:
		case ss720x408:
		case ss480x234:
		case ss400x240:
			scaler[0]=-1*(NIBLSCALE(8)-2);
			scaler[1]=NIBLSCALE(10)-2;
			scaler[2]=-1*(NIBLSCALE(12)-2);
			scaler[3]=NIBLSCALE(8)-2;
			scaler[4]=NIBLSCALE(4)-2;
			tscaler=NIBLSCALE(13)-2;
			break;
		default:
			scaler[0]=-1*NIBLSCALE(4);
			scaler[1]=NIBLSCALE(5);
			scaler[2]=-1*NIBLSCALE(6);
			scaler[3]=NIBLSCALE(4);
			scaler[4]=NIBLSCALE(2);
			tscaler=NIBLSCALE(7);
			break;
	}


	doinit=false;
  }

  HPEN hpold;
  #if LKOBJ
  HPEN thinBlackPen = LKPen_Black_N1;
  #else
  HPEN thinBlackPen = CreatePen(PS_SOLID, NIBLSCALE(1), RGB(0,0,0));
  #endif
  POINT Arrow[5];

  //TCHAR buffer[50]; REMOVE
  TCHAR lbuffer[50];

  hpold = (HPEN)SelectObject(hDC, thinBlackPen);

  int i;
  int painted=0;

//  double dX, dY;

  TextInBoxMode_t displaymode;
  displaymode.AsInt = 0;
  displaymode.AsFlag.NoSetFont = 1;

  double screenrange = GetApproxScreenRange();
  double scalefact = screenrange/6000.0; // FIX 100820

  #if LKOBJ
  HBRUSH redBrush = LKBrush_Red;
  HBRUSH yellowBrush = LKBrush_Yellow;
  HBRUSH greenBrush = LKBrush_Green;
  #else
  HBRUSH redBrush = CreateSolidBrush(RGB_RED);
  HBRUSH yellowBrush = CreateSolidBrush(RGB_YELLOW);
  HBRUSH greenBrush = CreateSolidBrush(RGB_GREEN);
  #endif
  HFONT  oldfont = (HFONT)SelectObject(hDC, LK8MapFont);

  for (i=0,painted=0; i<FLARM_MAX_TRAFFIC; i++) {

	// limit to 10 icons map traffic
	if (painted>=10) {
		i=FLARM_MAX_TRAFFIC;
		continue;
	}

	if ( (DrawInfo.FLARM_Traffic[i].ID !=0) && (DrawInfo.FLARM_Traffic[i].Status != LKT_ZOMBIE) ) {

		painted++;

		double target_lon;
		double target_lat;

		target_lon = DrawInfo.FLARM_Traffic[i].Longitude;
		target_lat = DrawInfo.FLARM_Traffic[i].Latitude;

		if ((EnableFLARMMap==2)&&(scalefact>1.0)) {

			double distance;
			double bearing;

			DistanceBearing(DrawInfo.Latitude, DrawInfo.Longitude, target_lat, target_lon, &distance, &bearing);
			FindLatitudeLongitude(DrawInfo.Latitude, DrawInfo.Longitude, bearing, distance*scalefact, &target_lat, &target_lon);
		}
      
		POINT sc, sc_name, sc_av;
		LatLon2Screen(target_lon, target_lat, sc);

		sc_name = sc;

		sc_name.y -= NIBLSCALE(16);
		sc_av = sc_name;

		wsprintf(lbuffer,_T(""));
		if (DrawInfo.FLARM_Traffic[i].Cn && DrawInfo.FLARM_Traffic[i].Cn[0]!=_T('?')) { // 100322
			_tcscat(lbuffer,DrawInfo.FLARM_Traffic[i].Cn);
		}
		#ifdef FLARM_AVERAGE
		if (DrawInfo.FLARM_Traffic[i].Average30s>=0.1) {
		#else
		if (DrawInfo.FLARM_Traffic[i].ClimbRate>=0.1) {
		#endif
			if (_tcslen(lbuffer) >0)
				#ifdef FLARM_AVERAGE
				_stprintf(lbuffer,_T("%s:%.1f"),lbuffer,LIFTMODIFY*DrawInfo.FLARM_Traffic[i].Average30s);
				#else
				_stprintf(lbuffer,_T("%s:%.1f"),lbuffer,LIFTMODIFY*DrawInfo.FLARM_Traffic[i].ClimbRate);
				#endif
			else
				#ifdef FLARM_AVERAGE
				_stprintf(lbuffer,_T("%.1f"),LIFTMODIFY*DrawInfo.FLARM_Traffic[i].Average30s);
				#else
				_stprintf(lbuffer,_T("%.1f"),LIFTMODIFY*DrawInfo.FLARM_Traffic[i].ClimbRate);
				#endif
		}

		displaymode.AsFlag.Border=1;

		if (_tcslen(lbuffer)>0)
		TextInBox(hDC, lbuffer, sc.x+tscaler, sc.y+tscaler, 0, displaymode, false);

		// red circle
		if ((DrawInfo.FLARM_Traffic[i].AlarmLevel>0) && (DrawInfo.FLARM_Traffic[i].AlarmLevel<4)) {
			DrawBitmapIn(hDC, sc, hFLARMTraffic);
		}
#if 0
		Arrow[0].x = -4;
		Arrow[0].y = 5;
		Arrow[1].x = 0;
		Arrow[1].y = -6;
		Arrow[2].x = 4;
		Arrow[2].y = 5;
		Arrow[3].x = 0;
		Arrow[3].y = 2;
		Arrow[4].x = -4;
		Arrow[4].y = 5;
#endif

		Arrow[0].x = scaler[0];
		Arrow[0].y = scaler[1];
		Arrow[1].x = 0;
		Arrow[1].y = scaler[2];
		Arrow[2].x = scaler[3];
		Arrow[2].y = scaler[1];
		Arrow[3].x = 0;
		Arrow[3].y = scaler[4];
		Arrow[4].x = scaler[0];
		Arrow[4].y = scaler[1];

		switch (DrawInfo.FLARM_Traffic[i].Status) { // 100321
			case LKT_GHOST:
				SelectObject(hDC, yellowBrush);
				break;
			case LKT_ZOMBIE:
				SelectObject(hDC, redBrush);
				break;
			default:
				SelectObject(hDC, greenBrush);
				break;
		}

		PolygonRotateShift(Arrow, 5, sc.x, sc.y, DrawInfo.FLARM_Traffic[i].TrackBearing - DisplayAngle);
		Polygon(hDC,Arrow,5);

	}
  }

  SelectObject(hDC, oldfont);
  SelectObject(hDC, hpold);
  #ifndef LKOBJ
  DeleteObject((HPEN)thinBlackPen);
  DeleteObject(greenBrush);
  DeleteObject(yellowBrush);
  DeleteObject(redBrush);
  #endif

}

// MUST be an even number
#define NUMVBRICKS 32
#define BOXTHICK   2	// caution, not used as deemed
#define PIXELSEPARATE 1
#define POSCOLOR 6

// Available only in fullscreen landscape mode
void MapWindow::LKDrawVario(HDC hDC, RECT rc) {

  HPEN		oldPen;
  HBRUSH	oldBrush;

  static RECT	vrc, mrc, hrc, htrc, hbrc;
  static RECT	brc[NUMVBRICKS];
  static HPEN	blackThickPen, whiteThickPen;
  static HPEN	blackThinPen, whiteThinPen;
  static HBRUSH blackBrush, whiteBrush;
  static HBRUSH greenBrush, darkyellowBrush, orangeBrush, redBrush;
  static HBRUSH lakeBrush, blueBrush, indigoBrush;
  static HBRUSH *positiveBrush[NUMVBRICKS/2];
  static HBRUSH *negativeBrush[NUMVBRICKS/2];
  static bool	doinit=true;

  static short startInitCounter=0;
  static bool dogaugeinit=true;

  if (doinit) {

  int boxthick;
  int hpixelseparate;
  int vpixelseparate;

  // A dirty hack for an impossible division solution
  // lowres devices should have 8 bricks, and not 16 as asked by users!
  switch (ScreenSize) {
	case ss320x240:
	case ss400x240:
		hpixelseparate=0;
		vpixelseparate=-1;
		boxthick=0;
		break;
	case ss480x272:
	case ss480x234:
		hpixelseparate=0;
		vpixelseparate=-2;
		boxthick=0;
		break;
	default:
		hpixelseparate=PIXELSEPARATE;
		vpixelseparate=PIXELSEPARATE;
		boxthick=IBLSCALE(BOXTHICK);
		break;
  }

  int variowidth=LKVarioSize;


  #if LKOBJ
  whiteThickPen =  LKPen_White_N2;	// BOXTHICK
  blackThickPen =  LKPen_Black_N2;	// BOXTHICK
  whiteThinPen =   LKPen_White_N0;
  blackThinPen =   LKPen_Black_N0;
  blackBrush = LKBrush_Black;
  whiteBrush = LKBrush_White;
  greenBrush = LKBrush_Green;
  darkyellowBrush = LKBrush_DarkYellow2;
  orangeBrush = LKBrush_Orange;
  redBrush = LKBrush_Red;
  lakeBrush = LKBrush_Lake;
  blueBrush = LKBrush_Blue;
  indigoBrush = LKBrush_Indigo;
  #else
  whiteThickPen =   (HPEN)CreatePen(PS_SOLID,IBLSCALE(BOXTHICK),RGB_WHITE);
  blackThickPen =   (HPEN)CreatePen(PS_SOLID,IBLSCALE(BOXTHICK),RGB_BLACK);
  whiteThinPen =   (HPEN)CreatePen(PS_SOLID,0,RGB_WHITE);
  blackThinPen =   (HPEN)CreatePen(PS_SOLID,0,RGB_BLACK);
  blackBrush = (HBRUSH)CreateSolidBrush(RGB_BLACK);
  whiteBrush = (HBRUSH)CreateSolidBrush(RGB_WHITE);
  greenBrush = (HBRUSH)CreateSolidBrush(RGB_GREEN);
  darkyellowBrush = (HBRUSH)CreateSolidBrush(RGB_DARKYELLOW2);
  orangeBrush = (HBRUSH)CreateSolidBrush(RGB_ORANGE);
  redBrush = (HBRUSH)CreateSolidBrush(RGB_RED);
  lakeBrush = (HBRUSH)CreateSolidBrush(RGB_LAKE);
  blueBrush = (HBRUSH)CreateSolidBrush(RGB_BLUE);
  indigoBrush = (HBRUSH)CreateSolidBrush(RGB_INDIGO);
  #endif

  // set default background in case of missing values
  for (int i=0; i<(NUMVBRICKS/2); i++ )
	positiveBrush[i]= &blackBrush;
  for (int i=0; i<(NUMVBRICKS/2); i++ )
	negativeBrush[i]= &blackBrush;

  positiveBrush[15]=&greenBrush;
  positiveBrush[14]=&greenBrush;
  positiveBrush[13]=&greenBrush;
  positiveBrush[12]=&greenBrush;
  positiveBrush[11]=&darkyellowBrush;
  positiveBrush[10]=&darkyellowBrush;
  positiveBrush[9]=&darkyellowBrush;
  positiveBrush[8]=&darkyellowBrush;
  positiveBrush[7]=&orangeBrush;
  positiveBrush[6]=&orangeBrush;
  positiveBrush[5]=&orangeBrush;
  positiveBrush[4]=&orangeBrush;
  positiveBrush[3]=&redBrush;
  positiveBrush[2]=&redBrush;
  positiveBrush[1]=&redBrush;
  positiveBrush[0]=&redBrush;

  negativeBrush[0]=&lakeBrush;
  negativeBrush[1]=&lakeBrush;
  negativeBrush[2]=&lakeBrush;
  negativeBrush[3]=&lakeBrush;
  negativeBrush[4]=&blueBrush;
  negativeBrush[5]=&blueBrush;
  negativeBrush[6]=&blueBrush;
  negativeBrush[7]=&blueBrush;
  negativeBrush[8]=&indigoBrush;
  negativeBrush[9]=&indigoBrush;
  negativeBrush[10]=&indigoBrush;
  negativeBrush[11]=&indigoBrush;
  negativeBrush[12]=&blackBrush;
  negativeBrush[13]=&blackBrush;
  negativeBrush[14]=&blackBrush;
  negativeBrush[15]=&blackBrush;


  // vario paint area
  vrc.left=rc.left+NIBLSCALE(1);
  vrc.top=rc.top+NIBLSCALE(1);
  vrc.right=vrc.left+variowidth;
  vrc.bottom=rc.bottom - BottomSize - NIBLSCALE(1);;

  // meter area
  mrc.left=vrc.left+boxthick-hpixelseparate;
  mrc.top=vrc.top+boxthick-vpixelseparate;;
  mrc.right=vrc.right-boxthick;
  mrc.bottom=vrc.bottom-boxthick;

  int vmiddle=((mrc.bottom-mrc.top)/2)+mrc.top;

  // half vario separator for positive and negative values
  hrc.top = vrc.top+ vmiddle-NIBLSCALE(1);
  hrc.bottom = vrc.top+ vmiddle+NIBLSCALE(1);
  hrc.left= vrc.left;
  // MUST MATCH MapWindow DrawLook8000 leftmargin!!
  hrc.right=vrc.right+NIBLSCALE(2);

  // half top meter area
  htrc.left=mrc.left;
  htrc.right=mrc.right;
  htrc.top=mrc.top;

  switch (ScreenSize) {
	case ss320x240:
	case ss480x234:
	case ss480x272:
		htrc.bottom=hrc.top -vpixelseparate;
		hbrc.top=hrc.bottom+vpixelseparate;
		break;
	default:
		htrc.bottom=hrc.top -vpixelseparate-1;
		hbrc.top=hrc.bottom+vpixelseparate+1;
		break;
  }

  // half bottom meter area
  hbrc.left=mrc.left;
  hbrc.right=mrc.right;
  hbrc.bottom=mrc.bottom;

  // pixel height of each brick
  int bricksize=(htrc.bottom - htrc.top - ((vpixelseparate) * ((NUMVBRICKS/2)-1)  )) / (NUMVBRICKS/2);
#if (WINDOWSPC>0)
  if (ScreenSize==ss720x408) bricksize=13;
#endif
  if (ScreenSize==ss480x272) bricksize=9;
  if (ScreenSize==ss480x234) bricksize=8;
 
  // Pre-calculate brick positions for half top
  for (int i=0; i<(NUMVBRICKS/2); i++) {
	brc[i].top= htrc.top + (bricksize*i)+(i*(vpixelseparate));
	// make the last one rounded since bricksize could be slighlty smaller due to division round
	if (i==((NUMVBRICKS/2)-1))
		brc[i].bottom= htrc.bottom;
	else
		brc[i].bottom= brc[i].top+bricksize;
	brc[i].left= htrc.left;
	brc[i].right= htrc.right;
  }
  // Pre-calculate brick positions for half bottom
  for (int i=((NUMVBRICKS/2)-1); i>=0; i--) {
	brc[ (NUMVBRICKS/2)+ i].bottom= hbrc.bottom - (bricksize*(  ((NUMVBRICKS/2)-1)-i)  ) - 
		(  (((NUMVBRICKS/2)-1)-i) * vpixelseparate   );
	if ( i == 0 )
		brc[ (NUMVBRICKS/2)+ i].top = hbrc.top;
	else
		brc[ (NUMVBRICKS/2)+ i].top = brc[ (NUMVBRICKS/2)+i].bottom - bricksize;
	brc[ (NUMVBRICKS/2)+ i].left = hbrc.left;
	brc[ (NUMVBRICKS/2)+ i].right = hbrc.right;
  }


	doinit=false;
  } // END of INIT




  // draw external box
  if (BgMapColor>POSCOLOR) 
	oldPen=(HPEN)SelectObject(hDC,whiteThinPen);
  else
	oldPen=(HPEN)SelectObject(hDC,blackThickPen);
  oldBrush=(HBRUSH)SelectObject(hDC,hInvBackgroundBrush[BgMapColor]);
  Rectangle(hDC,vrc.left, vrc.top, vrc.right, vrc.bottom);

  // draw middle separator for 0 scale indicator
  if (BgMapColor>POSCOLOR) 
  	FillRect(hDC,&hrc, whiteBrush);
  else
  	FillRect(hDC,&hrc, blackBrush);

  if (BgMapColor>POSCOLOR)
	  SelectObject(hDC,whiteThinPen);
  else
	  SelectObject(hDC,blackThinPen);

  double value;
  if (GPS_INFO.VarioAvailable) {
	//value = LIFTMODIFY*GPS_INFO.Vario;
	value = GPS_INFO.Vario;
  } else {
	value = CALCULATED_INFO.Vario;
  }

  if (dogaugeinit) {

	// this is causing problems on emulators and condor and most of the times when the gps has no valid date
	// so we don't use seconds, but loop counter
	if ( startInitCounter++ >2) {
		dogaugeinit=false;
	} else {
		short j=NUMVBRICKS/2;
		// Demo show all bricks
		for (int i=0; i<j; i++)  {
			SelectObject(hDC,*positiveBrush[i]);
			Rectangle(hDC,brc[i].left, brc[i].top, brc[i].right, brc[i].bottom);
		}
		for (int i=0; i<j; i++)  {
			SelectObject(hDC,*negativeBrush[i]);
			Rectangle(hDC,brc[i+(NUMVBRICKS/2)].left, brc[i+(NUMVBRICKS/2)].top, brc[i+(NUMVBRICKS/2)].right, brc[i+(NUMVBRICKS/2)].bottom);
		}
		
		SelectObject(hDC,oldPen);
		SelectObject(hDC,oldBrush);
		return;

	}
  }

  short meter=-1;
  if (value>0) {

	if (value>=0.05) meter=15;
	if (value>=0.25) meter=14;
	if (value>=0.50) meter=13;
	if (value>=0.75) meter=12;
	if (value>=1.00) meter=11;
	if (value>=1.25) meter=10;
	if (value>=1.50) meter=9;
	if (value>=1.75) meter=8;
	if (value>=2.00) meter=7;
	if (value>=2.50) meter=6;
	if (value>=3.00) meter=5;
	if (value>=3.50) meter=4;
	if (value>=4.00) meter=3;
	if (value>=4.50) meter=2;
	if (value>=5.00) meter=1;
	if (value>=6.00) meter=0;

	if (meter>=0) {
		for (short i=15; i>=meter; i--) {
			switch (LKVarioBar) {
				case vBarVarioColor:
					SelectObject(hDC,*positiveBrush[i]);
					break;
				case vBarVarioMono:
					if (BgMapColor>POSCOLOR)
						SelectObject(hDC,whiteBrush);
					else
						SelectObject(hDC,blackBrush);
					break;
				case vBarVarioRB:
					SelectObject(hDC,redBrush);
					break;
				case vBarVarioGR:
				default:
					SelectObject(hDC,greenBrush);
					break;
			}
/*
			if (LKVarioBar == vBarVarioColor) 
				SelectObject(hDC,*positiveBrush[i]);
			else {
				if (BgMapColor>POSCOLOR)
					SelectObject(hDC,whiteBrush);
				else
					SelectObject(hDC,blackBrush);
			}
*/
			Rectangle(hDC,brc[i].left, brc[i].top, brc[i].right, brc[i].bottom);
		}
	}
  } else if (value <0) {
	value*=-1;
	if (value>=0.05) meter=0;
	if (value>=0.25) meter=1;
	if (value>=0.50) meter=2;
	if (value>=0.75) meter=3;
	if (value>=1.00) meter=4;
	if (value>=1.25) meter=5;
	if (value>=1.50) meter=6;
	if (value>=1.75) meter=7;
	if (value>=2.00) meter=8;
	if (value>=2.50) meter=9;
	if (value>=3.00) meter=10;
	if (value>=3.50) meter=11;
	if (value>=4.00) meter=12;
	if (value>=4.50) meter=13;
	if (value>=5.00) meter=14;
	if (value>=6.00) meter=15;

	if (meter>=0) {
		for (short i=0; i<=meter; i++) {
			switch (LKVarioBar) {
				case vBarVarioColor:
					SelectObject(hDC,*negativeBrush[i]);
					break;
				case vBarVarioMono:
					if (BgMapColor>POSCOLOR)
						SelectObject(hDC,whiteBrush);
					else
						SelectObject(hDC,blackBrush);
					break;
				case vBarVarioRB:
					SelectObject(hDC,blueBrush);
					break;
				case vBarVarioGR:
				default:
					SelectObject(hDC,redBrush);
					break;
			}
/*
			if (LKVarioBar == vBarVarioColor) 
				SelectObject(hDC,*negativeBrush[i]);
			else {
				if (BgMapColor>POSCOLOR)
					SelectObject(hDC,whiteBrush);
				else
					SelectObject(hDC,blackBrush);
			}
*/
			Rectangle(hDC,brc[i+(NUMVBRICKS/2)].left, brc[i+(NUMVBRICKS/2)].top, brc[i+(NUMVBRICKS/2)].right, brc[i+(NUMVBRICKS/2)].bottom);
		}
	}

  }
	
  // cleanup and return 
  SelectObject(hDC,oldPen);
  SelectObject(hDC,oldBrush);
  return;

}

#ifdef NEWTRAIL

// try not to use colors when over a useless mapscale
double MapWindow::LKDrawTrail( HDC hdc, const POINT Orig, const RECT rc)
{
  int i, snail_index;
  SNAIL_POINT P1;
  #if 100303
  int  nearby;
  bool usecolors=false;
  #endif

  double TrailFirstTime = -1;

  if(!TrailActive)
    return -1;

  #if 0	// 100303
  if ((DisplayMode == dmCircling) != last_circling) {
    need_colour = true;
  }
  last_circling = (DisplayMode == dmCircling);
  #endif

  #if 100303
  if (MapWindow::MapScale <2.34) { // <3km map zoom
	usecolors=true;
  }
  #endif

  // Trail drift calculations

  double traildrift_lat = 0.0;
  double traildrift_lon = 0.0;
  
  if (EnableTrailDrift && (DisplayMode == dmCircling)) {
    double tlat1, tlon1;
    
    FindLatitudeLongitude(DrawInfo.Latitude, 
                          DrawInfo.Longitude, 
                          DerivedDrawInfo.WindBearing, 
                          DerivedDrawInfo.WindSpeed,
                          &tlat1, &tlon1);
    traildrift_lat = (DrawInfo.Latitude-tlat1);
    traildrift_lon = (DrawInfo.Longitude-tlon1);
  } else {
    traildrift_lat = 0.0;
    traildrift_lon = 0.0;
  }
  
  // JMW don't draw first bit from home airport

  //  Trail size

  int num_trail_max;
  if (TrailActive!=2) {
	// scan entire trail for sink magnitude
	num_trail_max = TRAILSIZE;
  } else {
	// scan only recently for lift magnitude
	num_trail_max = TRAILSIZE/TRAILSHRINK;
  }
  if ((DisplayMode == dmCircling)) {
	num_trail_max /= TRAILSHRINK;
  }

  // Snail skipping 

  const int skip_divisor = num_trail_max/5;
  int skip_border = skip_divisor;
  int skip_level= 3; // TODO code: try lower level?

  int snail_offset = TRAILSIZE+iSnailNext-num_trail_max;
  while (snail_offset>= TRAILSIZE) {
    snail_offset -= TRAILSIZE;
  }
  while (snail_offset< 0) {
    snail_offset += TRAILSIZE;
  }
  const int zero_offset = (TRAILSIZE-snail_offset);
  skip_border += zero_offset % skip_level;

  int index_skip = ((int)DrawInfo.Time)%skip_level;

  // TODO code: Divide by time step cruise/circling for zero_offset

  // Keep track of what's drawn

  bool this_visible = true;
  bool last_visible = false;
  POINT point_lastdrawn;
  point_lastdrawn.x = 0;
  point_lastdrawn.y = 0;

  // Average colour display for skipped points
  float vario_av = 0;
  int vario_av_num = 0;

  // Constants for speedups

  const bool display_circling = DisplayMode == dmCircling;
  const double display_time = DrawInfo.Time;

  // expand bounds so in strong winds the appropriate snail points are
  // still visible (since they are being tested before drift is applied)
  // this expands them by one minute

  // NOT a good idea, other functions will assume to be within screen boundaries..
  rectObj bounds_thermal = screenbounds_latlon;
  screenbounds_latlon.minx -= fabs(60.0*traildrift_lon);
  screenbounds_latlon.maxx += fabs(60.0*traildrift_lon);
  screenbounds_latlon.miny -= fabs(60.0*traildrift_lat);
  screenbounds_latlon.maxy += fabs(60.0*traildrift_lat);

  const rectObj bounds = bounds_thermal;

  const int deg = DEG_TO_INT(AngleLimit360(DisplayAngle));
  const int cost = ICOSTABLE[deg];
  const int sint = ISINETABLE[deg];
  const int xxs = Orig_Screen.x*1024-512;
  const int yys = Orig_Screen.y*1024+512;
  const double mDrawScale = DrawScale;
  const double mPanLongitude = PanLongitude;
  const double mPanLatitude = PanLatitude;

  // Main loop

#if 100303
  if (display_circling) {
	nearby=NIBLSCALE(1);
  } else {
  	if (MapWindow::MapScale <=1)
		nearby=NIBLSCALE(1); 
	else
		nearby=NIBLSCALE(2);
  }
#endif
 
  for(i=1;i< num_trail_max; ++i) 
  {
    ///// Handle skipping

    if (i>=skip_border) {
      skip_level= max(1,skip_level-1);
      skip_border= i+2*(zero_offset % skip_level)+skip_divisor;
      index_skip = skip_level;
    }

    index_skip++;
    if ((i<num_trail_max-10) && (index_skip < skip_level)) {
      continue;
    } else {
      index_skip=0;
    }

    ////// Find the snail point

    snail_index = snail_offset+i;
    while (snail_index>=TRAILSIZE) {
      snail_index-= TRAILSIZE;
    }

    P1 = SnailTrail[snail_index];

    /////// Mark first time of display point

    if (((TrailFirstTime<0) || (P1.Time<TrailFirstTime)) && (P1.Time>=0)) {
      TrailFirstTime = P1.Time;
    }

    //////// Ignoring display elements for modes

    if (display_circling) {
      if ((!P1.Circling)&&( i<num_trail_max-60 )) {
        // ignore cruise mode lines unless very recent
	last_visible = false;
        continue;
      }
    } else {
      //  if ((P1.Circling)&&( snail_index % 5 != 0 )) {
        // JMW TODO code: This won't work properly!
        // draw only every 5 points from circling when in cruise mode
	//        continue;
      //      }
    }

    ///////// Filter if far visible

    if (!P1.FarVisible) {
      last_visible = false;
      continue;
    }

    ///////// Determine if this is visible

    this_visible =   ((P1.Longitude> bounds.minx) &&
		     (P1.Longitude< bounds.maxx) &&
		     (P1.Latitude> bounds.miny) &&
		     (P1.Latitude< bounds.maxy)) ;

    if (!this_visible && !last_visible) {
      last_visible = false;
      continue;
    }

    ////////// Find coordinates on screen after applying trail drift

    // now we know either point is visible, better get screen coords
    // if we don't already.

    double dt = max(0,(display_time-P1.Time)*P1.DriftFactor);
    double this_lon = P1.Longitude+traildrift_lon*dt;
    double this_lat = P1.Latitude+traildrift_lat*dt;

#if 1
    // this is faster since many parameters are const
    int Y = Real2Int((mPanLatitude-this_lat)*mDrawScale);
    int X = Real2Int((mPanLongitude-this_lon)*fastcosine(this_lat)*mDrawScale);
    P1.Screen.x = (xxs-X*cost + Y*sint)/1024;
    P1.Screen.y = (Y*cost + X*sint + yys)/1024;
#else
    LatLon2Screen(this_lon, 
		  this_lat, 
		  P1.Screen);
#endif

    ////////// Determine if we should skip if close to previous point

    if (last_visible && this_visible) {
	// only average what's visible
	if ( (abs(P1.Screen.y-point_lastdrawn.y) + abs(P1.Screen.x-point_lastdrawn.x)) <nearby) { // 100303 
		if (usecolors) {
			vario_av += P1.Vario;
			vario_av_num ++;
		}
		continue;
		// don't draw if very short line
	}
    }

    if (usecolors) {
	float useval;
	float offval=1.0;
	int usecol;

	if ( vario_av_num ) useval=vario_av/(vario_av_num+1); else useval=P1.Vario; // 091202 avnum

	if (useval<0) offval=-1;
	useval=fabs(useval);
	
	if ( useval <0.1 ) {
		P1.Colour=7;
		goto go_selcolor;
	}
	if (useval <=0.5 ) {; usecol=1; goto go_setcolor; }
	if (useval <=1.0 ) {; usecol=2; goto go_setcolor; }
	if (useval <=1.5 ) {; usecol=3; goto go_setcolor; }
	if (useval <=2.0 ) {; usecol=4; goto go_setcolor; }
	if (useval <=3.0 ) {; usecol=5; goto go_setcolor; }
	if (useval <=4.0 ) {; usecol=6; goto go_setcolor; }
	usecol=7; // 7th : 4ms and up

go_setcolor:
	P1.Colour = 7+(short int)(usecol*offval);
    } else {
	P1.Colour = 3; // blue
    }

go_selcolor:
    SelectObject(hdc, hSnailPens[P1.Colour]);

    if (!last_visible) { // draw set cursor at P1
#ifndef NOLINETO
      MoveToEx(hdc, P1.Screen.x, P1.Screen.y, NULL);
#endif
    } else {
#ifndef NOLINETO
      LineTo(hdc, P1.Screen.x, P1.Screen.y);
#else
      DrawSolidLine(hdc, P1.Screen, point_lastdrawn, rc);
#endif
    }
    point_lastdrawn = P1.Screen;
    last_visible = this_visible;
  }

  // draw final point to glider
  if (last_visible) {
#ifndef NOLINETO 
    LineTo(hdc, Orig.x, Orig.y);
#else
    DrawSolidLine(hdc, Orig, point_lastdrawn, rc);
#endif
  }

  return TrailFirstTime;
}

#endif

#if AUTORIENT
// change dynamically the map orientation mode
// set true flag for resetting DisplayOrientation mode and return
void MapWindow::SetAutoOrientation(bool doreset) {

  static bool doinit=true;

  if (doinit) {
	OldDisplayOrientation=DisplayOrientation;
	doinit=false;
  }

  if (doreset) {
	OldDisplayOrientation=DisplayOrientation;
	return;
  }

  // 1.4 because of correction if mapscale reported on screen in MapWindow2
  if ((MapScale*1.4) >= AutoOrientScale) {
	// DisplayOrientation=NORTHSMART; // better to keep the glider centered on low zoom levels
	DisplayOrientation=NORTHUP;
  } else {
	DisplayOrientation=OldDisplayOrientation;
  }
}
#endif


@


1.5
log
@*** empty log message ***
@
text
@d2 3
a4 1
  Copyright_License {
d6 1
a6 32
  LK8000 fork of XCSoar Glide Computer (http://xcsoar.sourceforge.net/
  
  Copyright (C) 2000 - 2010  

  	M Roberts (original release)
	Robin Birch <robinb@@ruffnready.co.uk>
	Samuel Gisiger <samuel.gisiger@@triadis.ch>
	Jeff Goodenough <jeff@@enborne.f2s.com>
	Alastair Harrison <aharrison@@magic.force9.co.uk>
	Scott Penrose <scottp@@dd.com.au>
	John Wharington <jwharington@@gmail.com>
	Lars H <lars_hn@@hotmail.com>
	Rob Dunning <rob@@raspberryridgesheepfarm.com>
	Russell King <rmk@@arm.linux.org.uk>
	Paolo Ventafridda <coolwind@@email.it>
	Tobias Lohner <tobias@@lohner-net.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

}
a8 2
///:  $Id: LKMapWindow.cpp,v 1.4 2010/08/20 12:51:14 root Exp root $

a29 1
// #include <assert.h>
d45 3
d62 1
a62 1
///: This is painting traffic icons on the screen.
d69 1
a69 1
  ///: 100820 init scaled coords for traffic icon
d117 3
d121 1
a138 2
  ///: double scalefact = screenrange/6000.0;  testfix 091020
  ///: double scalefact = screenrange/12000.0; // 122a
d141 5
d149 1
a149 1
  ///: HFONT  oldfont = (HFONT)SelectObject(hDC, LK8InfoSmallFont); 122a
d154 1
a154 1
	///: 100404 limit to 10 icons map traffic
a159 1
	///: if ( DrawInfo.FLARM_Traffic[i].ID!=0) { 100325
a211 1
		///: TextInBox(hDC, lbuffer, sc.x+NIBLSCALE(3), sc.y, 0, displaymode, false);  1.22a
d215 1
a215 23
/*
      TCHAR label_name[100];
      TCHAR label_avg[100];

      sc_av.x += NIBLSCALE(3);

      if (DrawInfo.FLARM_Traffic[i].Average30s>=0.1) {
	_stprintf(label_avg, TEXT("%.1f"), 
		  LIFTMODIFY*DrawInfo.FLARM_Traffic[i].Average30s);
      } else {
	label_avg[0]= _T('\0');
      }

      
      int dx = (sc_av.x-Orig_Aircraft.x);
      int dy = (sc_av.y-Orig_Aircraft.y);

      ///: if (dx*dx+dy*dy > IBLSCALE(30)*IBLSCALE(30)) { TESTFIX 091020
	// only draw labels if not close to aircraft


*/
		///: red circle
d263 1
d268 1
d272 1
a272 1
///: MUST be an even number
d274 1
a274 1
#define BOXTHICK   2
d278 1
a278 2
///: 091111
///: Available only in fullscreen landscape mode
a294 1
  ///: static double startInitTime=0;
d304 2
a305 2
  ///: A dirty hack for an impossible division solution
  ///: lowres devices should have 8 bricks, and not 16 as asked by users!
d328 16
a347 1

d357 1
d359 1
a359 1
  ///: set default background in case of missing values
a364 20
  ///: set custom values here: 0-n where 0 is the top (higher vario value always)
/*
  positiveBrush[7]=&greenBrush;
  positiveBrush[6]=&greenBrush;
  positiveBrush[5]=&greenBrush;
  positiveBrush[4]=&darkyellowBrush;
  positiveBrush[3]=&darkyellowBrush;
  positiveBrush[2]=&orangeBrush;
  positiveBrush[1]=&orangeBrush;
  positiveBrush[0]=&redBrush;

  negativeBrush[0]=&lakeBrush;
  negativeBrush[1]=&lakeBrush;
  negativeBrush[2]=&lakeBrush;
  negativeBrush[3]=&blueBrush;
  negativeBrush[4]=&blueBrush;
  negativeBrush[5]=&indigoBrush;
  negativeBrush[6]=&indigoBrush;
  negativeBrush[7]=&blackBrush;
*/
d400 1
a400 1
  ///: vario paint area
d406 1
a406 1
  ///: meter area
d414 1
a414 1
  ///: half vario separator for positive and negative values
d421 1
a421 1
  ///: half top meter area
a425 1
  ///: 091116 terrible solution
d439 1
a439 1
  ///: half bottom meter area
d444 1
a444 1
  ///: pixel height of each brick
a445 1
  ///: 091116 this is ugly, but could not find a better solution
d452 1
a452 1
  ///: Pre-calculate brick positions for half top
d455 1
a455 1
	///: make the last one rounded since bricksize could be slighlty smaller due to division round
d463 1
a463 1
  ///: Pre-calculate brick positions for half bottom
d482 1
a482 1
  ///: draw external box
d490 1
a490 1
  ///: draw middle separator for 0 scale indicator
a499 6
/*
  ///: Demo show half and top areas
  SelectObject(hDC,greenBrush);
  Rectangle(hDC,htrc.left, htrc.top, htrc.right, htrc.bottom);
  Rectangle(hDC,hbrc.left, hbrc.top, hbrc.right, hbrc.bottom);
*/
d511 2
a512 4
	///: 091129 this is causing problems on emulators and condor and most of the times when the gps has no valid date
	///: so we don't use seconds, but loop counter
	///: if (startInitTime == 0 ) startInitTime=GPS_INFO.Time;
	///: if ( GPS_INFO.Time > (startInitTime+5.0) ) {
a515 15
#if (0)
		///: startInitTime=18.0  is too long, this demo mode too long
		static short j=(NUMVBRICKS/2)+1;
		if (--j <0 || (GPS_INFO.Time>startInitTime+16)) j=NUMVBRICKS/2;

		///: Demo show all bricks
		for (int i=0; i<j; i++)  {
			SelectObject(hDC,*positiveBrush[i]);
			Rectangle(hDC,brc[i].left, brc[i].top, brc[i].right, brc[i].bottom);
		}
		for (int i=0; i<j; i++)  {
			SelectObject(hDC,*negativeBrush[i]);
			Rectangle(hDC,brc[i+(NUMVBRICKS/2)].left, brc[i+(NUMVBRICKS/2)].top, brc[i+(NUMVBRICKS/2)].right, brc[i+(NUMVBRICKS/2)].bottom);
		}
#else
d517 1
a517 1
		///: Demo show all bricks
a525 1
#endif
d642 1
a642 1
  ///: cleanup and return 
d651 1
a651 1
///: 100303 try not to use colors when over a useless mapscale
a655 4
  ///: static BOOL last_circling = FALSE; 100303
  ///: static float vario_max= 5.0;
  ///: static float vario_min= -5.0;
  ///: static bool need_colour = true;  100303
a673 1
  ///: StartupStore(_T(".... MapScale=%f \n"),MapWindow::MapScale); 
d679 1
a679 1
  //////////// Trail drift calculations
d701 1
a701 1
  /////////////  Trail size
d705 1
a705 1
	///: scan entire trail for sink magnitude
d708 1
a708 1
	///: scan only recently for lift magnitude
d715 1
a715 4
  ///: vario_max = 3.0;
  ///: vario_min = -3.0;

  ///////////// Snail skipping 
d735 1
a735 1
  ///////////// Keep track of what's drawn
d743 1
a743 1
  ///////////// Average colour display for skipped points
d747 1
a747 1
  ///////////// Constants for speedups
d756 1
a756 2
  ///: 100709 NOT a good idea, other functions will assume to be within screen boundaries..

d774 1
a774 1
  ////////////// Main loop
a878 1
	///: if (abs(P1.Screen.y-point_lastdrawn.y) +abs(P1.Screen.x-point_lastdrawn.x)<NIBLSCALE(2)) { // 091202 4 100303 obs
d950 2
a951 2
///: 100909 change dynamically the map orientation mode
///: 101008 set true flag for resetting DisplayOrientation mode and return
d966 1
a966 5
  ///: StartupStore(_T("... MapScale=%.3f RequestMapScale=%.3f MapScaleOverDistanceModify=%.3f\n"),
  ///: MapWindow::MapScale, RequestMapScale, MapScaleOverDistanceModify);
  ///: StartupStore(_T("... DisplayOrientation=%d oldDisplayOrientation=%d\n"), DisplayOrientation, OldDisplayOrientation);

  ///: 1.4 because of correction if mapscale reported on screen in MapWindow2
@


1.4
log
@122a
@
text
@d2 1
d4 30
a33 1
  $Id: LKMapWindow.cpp,v 1.3 2009/12/17 20:40:26 root Exp root $
d35 1
d38 3
d98 47
d164 3
a166 2
  ///: double scalefact = screenrange/6000.0; TESTFIX 091020
  double scalefact = screenrange/12000.0;
d171 2
a172 1
  HFONT  oldfont = (HFONT)SelectObject(hDC, LK8InfoSmallFont);
d235 3
a237 1
		TextInBox(hDC, lbuffer, sc.x+NIBLSCALE(3), sc.y, 0, displaymode, false);
d265 1
a265 1

d276 1
d278 10
d382 1
a382 1
  darkyellowBrush = (HBRUSH)CreateSolidBrush(RGB(0xff, 0xd7, 0x00));
d498 3
d1034 33
@


1.3
log
@1.17f
@
text
@d3 1
a3 1
  $Id: LKMapWindow.cpp,v 1.2 2009/11/11 12:07:32 root Exp root $
d57 1
a57 1

d65 1
a65 1
  HPEN thinBlackPen = CreatePen(PS_SOLID, IBLSCALE(1), RGB(0,0,0));
d74 1
d91 10
a100 1
  for (i=0; i<FLARM_MAX_TRAFFIC; i++) {
d102 1
a102 1
	if (DrawInfo.FLARM_Traffic[i].ID!=0) {
d124 1
a124 1
		sc_name.y -= IBLSCALE(16);
d128 2
a129 2
		if (DrawInfo.FLARM_Traffic[i].Name) {
			_tcscat(lbuffer,DrawInfo.FLARM_Traffic[i].Name);
d131 1
d133 3
d137 1
d139 3
d143 1
d145 3
d152 1
a152 1
		TextInBox(hDC, lbuffer, sc.x+IBLSCALE(3), sc.y, 0, displaymode, false);
d158 1
a158 1
      sc_av.x += IBLSCALE(3);
d176 1
d193 2
a194 2
		switch (DrawInfo.FLARM_Traffic[i].AlarmLevel) {
			case 1:
d197 1
a197 2
			case 2:
			case 3:
d200 1
a200 2
			case 0:
			case 4:
d355 2
a356 2
  vrc.left=rc.left+IBLSCALE(1);
  vrc.top=rc.top+IBLSCALE(1);
d358 1
a358 1
  vrc.bottom=rc.bottom - BottomSize - IBLSCALE(1);;
d369 2
a370 2
  hrc.top = vrc.top+ vmiddle-IBLSCALE(1);
  hrc.bottom = vrc.top+ vmiddle+IBLSCALE(1);
d373 1
a373 1
  hrc.right=vrc.right+IBLSCALE(2);
a626 1
//int MapWindow::iSnailNext=0;
d628 1
a628 1
// This function is slow...
d633 8
a640 4
  static BOOL last_circling = FALSE;
  static float vario_max= 5.0;
  static float vario_min= -5.0;
  static bool need_colour = true;
d647 1
d652 8
d687 2
a688 1
    num_trail_max = TRAILSIZE;
d690 2
a691 1
    num_trail_max = TRAILSIZE/TRAILSHRINK;
d694 1
a694 1
    num_trail_max /= TRAILSHRINK;
d697 2
a698 8
  ///////////// Vario colour scaling

  //float this_vario_max = (float)(1.5*min(5.0, max(MACCREADY,0.5)));
  //float this_vario_min = (float)(-1.5*min(5.0, max(MACCREADY,2.0)));
  //vario_max = this_vario_max;
  //vario_min = this_vario_min;
  vario_max = 3.0;
  vario_min = -3.0;
d741 2
d762 11
d864 10
a873 9
      // only average what's visible

      if (abs(P1.Screen.y-point_lastdrawn.y)
	  +abs(P1.Screen.x-point_lastdrawn.x)<IBLSCALE(2)) { // 091202 4
	vario_av += P1.Vario;
	vario_av_num ++;
	continue;
	// don't draw if very short line
      }
d876 1
a876 20
    ////////// Lookup the colour if it's not already set

   // if ((P1.Colour<0)||(P1.Colour>=NUMSNAILCOLORS)) {
/*
      float colour_vario = P1.Vario;
      if (vario_av_num) {
	// set color to average if skipped
	colour_vario = (colour_vario+vario_av)/(vario_av_num+1);
	///: -7 +7
	vario_av_num= 0;
	vario_av= 0;
      }
      if (colour_vario<0) {
	colour_vario /= (-vario_min); // JMW fixed bug here
      } else {
	colour_vario /= vario_max;
      }
      P1.Colour = fSnailColour(colour_vario);
*/

a898 1
//	usecol=7+(usecol*offval);
d900 3
a903 1
    //}
@


1.2
log
@*** empty log message ***
@
text
@d3 1
a3 1
  $Id: LKMapWindow.cpp,v 1.1 2009/10/24 19:22:32 root Exp root $
d54 2
d199 711
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
  $Id$
d66 1
a66 1
  TCHAR buffer[50];
d120 1
a120 1
			if (lbuffer) 
@
